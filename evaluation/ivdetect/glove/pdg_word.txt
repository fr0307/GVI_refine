AS N1 BITSTRING c2i AS N1 BITSTRINGAS N1 BITSTRING a const unsigned char pp long len AS N1 BITSTRING ret NULL const unsigned char p unsigned char s int i if len 1 i AS N1 RSTRINGTOOSHORT goto err if a NULL a NULL if ret MAS N1 BITSTRING new NULL return NULL else ret a p pp i p ret flags AS N1 STRINGFLAGBITSLEFT 0x07 ret flags AS N1 STRINGFLAGBITSLEFT i 0x07 if len 1 s unsigned char OPENSSL malloc int len if s NULL i ERRRMALLOCFAILURE goto err memcpy s p int len s len 1 0xff i p len else s NULL ret length int len if ret data NULLOPENSSL free ret data ret data s ret type VAS N1 BITSTRING if a NULL a ret pp p return ret err AS N1err AS N1 F C2 IAS N1 BITSTRING i if ret NULL a NULL a ret MAS N1 BITSTRING free ret return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Fraps Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data AV Frame const f s frame uint32 t header unsigned int version header size unsigned int x y const uint32 t buf32 uint32 t luma1 luma2 cb cr uint32 t offs 4 int i j ret is chroma planes enum AV Pixel Format pix fmt header AVR L32 buf version header 0xff header size header 1 30 8 4 if version 5 av log avctx AVLOGERROR This file is encoded with Fraps version d This codec can only decode versions 5 n version return AVERRORPATCHWELCOME buf 4 if header size 8 buf 4 pix fmt version 1 AVPIXFMTBG R24 AVPIXFMTYUV J420 P if avctx pix fmt pix fmt f data 0 avctx release buffer avctx f avctx pix fmt pix fmt switch version case 0 default if buf size avctx width avctx height 3 2 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 2 header size return AVERRORINVALIDDATA if avctx width 8 0 avctx height 2 0 av log avctx AVLOGERROR Invalid frame size dx d n avctx width avctx height return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI buf32 const uint32 t buf for y 0 y avctx height 2 y luma1 uint32 t f data 0 y 2 f linesize 0 luma2 uint32 t f data 0 y 2 1 f linesize 0 cr uint32 t f data 1 y f linesize 1 cb uint32 t f data 2 y f linesize 2 for x 0 x avctx width x 8 luma1 buf32 luma1 buf32 luma2 buf32 luma2 buf32 cr buf32 cb buf32 break case 1 if buf size avctx width avctx height 3 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 header size return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI for y 0 y avctx height y memcpy f data 0 avctx height y 1 f linesize 0 buf y avctx width 3 3 avctx width break case 2 case 4 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i is chroma i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data i f linesize i avctx width is chroma avctx height is chroma buf offs i offs i 1 offs i is chroma 1 0 av log avctx AVLOGERROR Error decoding plane i n i return ret break case 3 case 5 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data 0 i f linesize 0 avctx height 1 f linesize 0 avctx width avctx height buf offs i offs i 1 offs i 0 3 0 av log avctx AVLOGERROR Error decoding plane i n i return ret for j 0 j avctx height j for i 0 i avctx width i f data 0 0 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 f data 0 2 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 break frame f got frame 1 return buf size int ff intrax8 decode picture Intra X8 Context const w int dquant int quant offset Mpeg Enc Context const s w s int mb xy assert s w use quant matrix get bits1 s gb w dquant dquant w quant dquant 1 w qsum quant offset w divide quant dc luma 1 16 w quant 1 w quant if w quant 5 w quant dc chroma w quant w divide quant dc chroma w divide quant dc luma else w quant dc chroma w quant w quant 3 3 w divide quant dc chroma 1 16 w quant dc chroma 1 w quant dc chroma x8 reset vlc tables w s resync mb x 0 s resync mb y 0 for s mb y 0 s mb y s mb height 2 s mb y x8 init block index s mb xy s mb y 1 s mb stride for s mb x 0 s mb x s mb width 2 s mb x x8 get prediction w if x8 setup spatial predictor w 0 goto error if x8 decode intra mb w 0 goto error if s mb x s mb y 1 x8 get prediction chroma w x8 setup spatial predictor w 1 if x8 decode intra mb w 1 goto error x8 setup spatial predictor w 2 if x8 decode intra mb w 2 goto error s dest 1 8 s dest 2 8 s mbskip table mb xy 0 s mbintra table mb xy 1 s current picture f qscale table mb xy w quant mb xy s dest 0 8 if s mb y 1 ff mpeg draw horiz band s s mb y 1 8 16 error ff er add slice s er s resync mb x s resync mb y s mb x 1 1 s mb y 1 1 ERMBEND return 0 void vp9 xform quant MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size tran low t const coeff BLOCKOFFSET p coeff block tran low t const qcoeff BLOCKOFFSET p qcoeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break static int find unused picture Mpeg Enc Context s int shared int i if shared for i 0 i MAXPICTURECOUNT i if s picture i f data 0 NULL return i else for i 0 i MAXPICTURECOUNT i if pic is unused s s picture i return i return int evbuffer add vprintf struct evbuffer buf const char fmt va list ap char buffer size t space size t oldoff buf off int sz va list aq evbuffer expand buf 64 for size t used buf misalign buf off buffer char buf buffer buf off assert buf totallen used space buf totallen used sz evutil vsnprintf buffer space fmt aq va end aq if sz 0 return 1 if size t sz space buf off sz if buf cb NULL buf cb buf oldoff buf off buf cbarg return sz if evbuffer expand buf sz 1 1 return 1 static void evhttp handle request struct evhttp request req void arg struct evhttp http arg struct evhttp cb cb NULL event debug s req uri s func req uri if req uri NULL event debug s bad request func if req evcon state EVCONDISCONNECTED evhttp connection fail req evcon EVCONHTTPEOF else event debug s sending error func evhttp send error req HTTPBADREQUEST Bad Request return if cb evhttp dispatch callback http callbacks req NULL cb cb req cb cbarg return if http gencb http gencb req http gencbarg return else struct evbuffer buf evbuffer new evhttp response code req HTTPNOTFOUND Not Found evbuffer add printf buf ERRFORMAT escaped html free escaped html evhttp send page req buf evbuffer free buf static void decrypt MPI output MPI a MPI b ELG secret key skey MPI t1 t2 r unsigned int nbits mpi get nbits skey p mpi normalize a mpi normalize b t1 mpi alloc secure mpi nlimb hint from nbits nbits r mpi alloc mpi nlimb hint from nbits nbits randomize mpi r nbits 0 mpi powm t1 r skey x skey p mpi mulm t2 a r skey p mpi powm t2 t2 skey x skey p mpi invm t2 t2 skey p mpi mulm t1 t1 t2 skey p mpi free r mpi free t2 mpi invm t1 t1 skey p log mpidump elg decrypted x skey x log mpidump elg decrypted p skey p log mpidump elg decrypted a a log mpidump elg decrypted b b log mpidump elg decrypted M output static inline int vc1 pred dc Mpeg Enc Context s int overlap int pq int n int a avail int c avail int16 t dc val ptr int dir ptr int a b c wrap pred int16 t dc val int mb pos s mb x s mb y s mb stride int q1 q2 0 int dqscale index wrap s block wrap n dc val s dc val 0 s block index n c dc val 1 b dc val 1 wrap a dc val wrap q1 s current picture qscale table mb pos dqscale index s y dc scale table q1 1 if dqscale index 0 return 0 if c avail n 1 n 3 q2 s current picture qscale table mb pos 1 if q2 q2 q1 c c s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail n 2 n 3 q2 s current picture qscale table mb pos s mb stride if q2 q2 q1 a a s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail n 3 int off mb pos if n 1 off if n 2 off s mb stride q2 s current picture qscale table off if q2 q2 q1 b b s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail if abs a b abs b c pred c dir ptr 1 else pred a dir ptr 0 else if a avail pred a dir ptr 0 else if c avail pred c dir ptr 1 else pred 0 dir ptr 1 dc val ptr dc val 0 return pred static uint get table structure char table char db char table type char ignore flag my bool init 0 delayed write data complete insert my ulonglong num fields char result table opt quoted table const char insert option char name buff NAMELEN 3 table buff NAMELEN 2 3 char table buff2 NAMELEN 2 3 query buff QUERYLENGTH const char show fields stmt SELECTCOLUMNNAMEAS Field COLUMNTYPEAS Type ISNULLABLEAS Null COLUMNKEYAS Key COLUMNDEFAULTAS Default EXTRAAS Extra COLUMNCOMMENTAS Comment FROMINFORMATIONSCHEMACOLUMNSWHERETABLESCHEMA s ANDTABLENAME s FILE sql file md result file int len my bool is log table MYSQLRES result MYSQLROW row DBUGENTER get table structure DBUGPRINT enter db s table s db table ignore flag check if ignore table table table type delayed opt delayed if delayed ignore flag IGNOREINSERTDELAYED delayed 0 verbose msg Warning Unable to use delayed inserts for table s because it s of type s n table table type complete insert 0 if write data ignore flag IGNOREDATA complete insert opt complete insert if insert pat inited insert pat inited 1 init dynamic string checked insert pat 1024 1024 else dynstr set checked insert pat insert option delayed opt ignore DELAYEDIGNORE delayed DELAYED opt ignore IGNORE verbose msg Retrieving table structure for table s n table len my snprintf query buff sizeof query buff SETSQLQUOTESHOWCREATE d opt quoted opt keywords if create options strmov query buff len result table quote name table table buff 1 opt quoted table quote name table table buff2 0 if opt order by primary order by primary key fields result table if opt xml mysql query with error report mysql 0 query buff if opt no create info char buff 20 FNREFLENMYSQLFIELD field my snprintf buff sizeof buff show create table s result table if switch character set results mysql binary mysql query with error report mysql result buff switch character set results mysql default charset DBUGRETURN 0 if path if sql file open sql file for table table OWRONLYDBUGRETURN 0 write header sql file db if strcmp table type VIEW 0 print comment sql file 0 n n Temporary table structure for view s n n n fix for comment result table else print comment sql file 0 n n Table structure for table s n n n fix for comment result table if opt drop if general log or slow log tables db table fprintf sql file DROPTABLEIFEXISTS s n opt quoted table check io sql file field mysql fetch field direct result 0 if strcmp field name View 0 char scv buff NULL my ulonglong n cols verbose msg It s a view create dummy table for view n if row mysql fetch row result scv buff row 1 scv buff my strdup scv buff MYF 0 mysql free result result my snprintf query buff sizeof query buff SHOWFIELDSFROM s result table if switch character set results mysql binary mysql query with error report mysql result query buff switch character set results mysql default charset if mysql errno mysql ERVIEWINVALID fprintf sql file n failed on view s s n n result table scv buff scv buff my free scv buff DBUGRETURN 0 else my free scv buff n cols mysql num rows result if 0 n cols if n cols 1000 fprintf stderr Warning Creating a stand in table for view s may fail when replaying the dump file produced because of the number of columns exceeding 1000 Exercise caution when replaying the produced dump file n table if opt drop fprintf sql file n opt quoted table check io sql file fprintf sql file SET saved cs client character set client n SET character set client utf8 n n SET character set client saved cs client n check io sql file mysql free result result if path my fclose sql file MYFMYWME seen views 1 DBUGRETURN 0 row mysql fetch row result is log table general log or slow log tables db table if is log table row 1 13 if opt compatible mode 3 fprintf sql file is log table CREATETABLEIFNOTEXISTS s n s n row 1 else fprintf sql file n n s s n n is log table CREATETABLEIFNOTEXISTS row 1 check io sql file mysql free result result my snprintf query buff sizeof query buff show fields from s result table if mysql query with error report mysql result query buff if path my fclose sql file MYFMYWMEDBUGRETURN 0 if write data if opt replace into dynstr append checked insert pat REPLACE else dynstr append checked insert pat INSERT dynstr append checked insert pat insert option dynstr append checked insert pat INTO dynstr append checked insert pat opt quoted table if complete insert dynstr append checked insert pat else dynstr append checked insert pat VALUES if extended insert dynstr append checked insert pat while row mysql fetch row result if complete insert if init dynstr append checked insert pat init 1 dynstr append checked insert pat quote name row SHOWFIELDNAME name buff 0 num fields mysql num rows result mysql free result result else verbose msg s Warning Can t set SQLQUOTESHOWCREATE option s n my progname short mysql error mysql my snprintf query buff sizeof query buff show fields stmt db table if mysql query with error report mysql result query buff DBUGRETURN 0 if opt no create info if path if sql file open sql file for table table OWRONLYDBUGRETURN 0 write header sql file db print comment sql file 0 n n Table structure for table s n n n fix for comment result table if opt drop fprintf sql file DROPTABLEIFEXISTS s n result table if opt xml fprintf sql file CREATETABLE s n result table else print xml tag sql file t n table structure name table Null S check io sql file if write data if opt replace into dynstr append checked insert pat REPLACE else dynstr append checked insert pat INSERT dynstr append checked insert pat insert option dynstr append checked insert pat INTO dynstr append checked insert pat result table if complete insert dynstr append checked insert pat else dynstr append checked insert pat VALUES if extended insert dynstr append checked insert pat while row mysql fetch row result ulong lengths mysql fetch lengths result if init if opt xml opt no create info fputs n sql file check io sql file if complete insert dynstr append checked insert pat init 1 if complete insert dynstr append checked insert pat quote name row SHOWFIELDNAME name buff 0 if opt no create info if opt xml print xml row sql file field result row Null S continue if opt keywords fprintf sql file s s s result table quote name row SHOWFIELDNAME name buff 0 row SHOWTYPE else fprintf sql file s s quote name row SHOWFIELDNAME name buff 0 row SHOWTYPE if row SHOWDEFAULT fputs DEFAULT sql file unescape sql file row SHOWDEFAULT lengths SHOWDEFAULT if row SHOWNULL 0 fputs NOTNULL sql file if row SHOWEXTRA 0 fprintf sql file s row SHOWEXTRA check io sql file num fields mysql num rows result mysql free result result if opt no create info char buff 20 FNREFLEN uint keynr primary key my snprintf buff sizeof buff show keys from s result table if mysql query with error report mysql result buff if mysql errno mysql ERWRONGOBJECT fputs t t options Comment view n sql file goto continue xml fprintf stderr s Can t get keys for table s s n my progname short result table mysql error mysql if path my fclose sql file MYFMYWMEDBUGRETURN 0 keynr 0 primary key INTMAX while row mysql fetch row result if atoi row 3 1 keynr primary key keynr break mysql data seek result 0 keynr 0 while row mysql fetch row result if opt xml print xml row sql file key result row Null S continue if atoi row 3 1 if keynr putc sql file if atoi row 1 fprintf sql file n KEY s quote name row 2 name buff 0 else if keynr primary key fputs n PRIMARYKEY sql file else fprintf sql file n UNIQUE s quote name row 2 name buff 0 else putc sql file fputs quote name row 4 name buff 0 sql file if row 7 fprintf sql file s row 7 check io sql file mysql free result result if opt xml if keynr putc sql file fputs n sql file check io sql file if create options char show name buff NAMELEN 2 2 24 my snprintf buff sizeof buff show table status like s quote for like table show name buff if mysql query with error report mysql result buff if mysql errno mysql ERPARSEERROR verbose msg Warning Couldn t get status information for table s s n result table mysql error mysql else if row mysql fetch row result fprintf stderr Error Couldn t read status information for table s s n result table mysql error mysql else if opt xml print xml row sql file options result row Null S else fputs sql file check io sql file mysql free result result continue xml if opt xml fputs n sql file else fputs t table structure n sql file check io sql file static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Kmvc Context const ctx avctx priv data uint8 t out src int i ret int header int blocksize const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL bytestream2 init ctx g avpkt data avpkt size if ctx pic data 0 avctx release buffer avctx ctx pic ctx pic reference 1 ctx pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx ctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret header bytestream2 get byte ctx g if bytestream2 peek byte ctx g 127 bytestream2 skip ctx g 3 for i 0 i 127 i ctx pal i header 0x81 bytestream2 get be24 ctx g bytestream2 skip ctx g 1 bytestream2 seek ctx g 127 4 3 SEEKCUR if header KMVCKEYFRAME ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP if header KMVCPALETTE ctx pic palette has changed 1 for i 1 i ctx palsize i ctx pal i bytestream2 get be24 ctx g if pal ctx pic palette has changed 1 memcpy ctx pal pal AVPALETTESIZE if ctx setpal ctx setpal 0 ctx pic palette has changed 1 memcpy ctx pic data 1 ctx pal 1024 blocksize bytestream2 get byte ctx g if blocksize 8 blocksize 127 av log avctx AVLOGERROR Block size i n blocksize return AVERRORINVALIDDATA memset ctx cur 0 320 200 switch header KMVCMETHOD case 0 case 1 memcpy ctx cur ctx prev 320 200 break case 3 kmvc decode intra 8x8 ctx avctx width avctx height break case 4 kmvc decode inter 8x8 ctx avctx width avctx height break default av log avctx AVLOGERROR Unknown compression method i n header KMVCMETHOD return AVERRORINVALIDDATA out ctx pic data 0 src ctx cur for i 0 i avctx height i memcpy out src avctx width src 320 out ctx pic linesize 0 if ctx cur ctx frm0 ctx cur ctx frm1 ctx prev ctx frm0 else ctx cur ctx frm0 ctx prev ctx frm1 got frame 1 AV Frame data ctx pic return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AS V1 Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p a picture int mb x mb y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 av fast padded malloc a bitstream buffer a bitstream buffer size buf size if a bitstream buffer return AVERRORENOMEM if avctx codec id AVCODECIDAS V1 a dsp bswap buf uint32 t a bitstream buffer const uint32 t buf buf size 4 else int i for i 0 i buf size i a bitstream buffer i ff reverse buf i init get bits a gb a bitstream buffer buf size 8 for mb y 0 mb y a mb height2 mb y for mb x 0 mb x a mb width2 mb x if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb width2 a mb width mb x a mb width2 for mb y 0 mb y a mb height2 mb y if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb height2 a mb height mb y a mb height2 for mb x 0 mb x a mb width mb x if ret decode mb a a block 0 return ret idct put a mb x mb y picture a picture got frame 1 emms c return get bits count a gb 31 32 4 void examine variable Planner Info root Node node int var Relid Variable Stat Data vardata Node basenode Relids varnos Rel Opt Info onerel Mem Set vardata 0 sizeof Variable Stat Data vardata vartype expr Type node if Is A node Relabel Type basenode Node Relabel Type node arg else basenode node if Is A basenode Var var Relid 0 var Relid Var basenode varno Var var Var basenode vardata var basenode vardata rel find base rel root var varno vardata atttype var vartype vardata atttypmod var vartypmod vardata isunique has unique index vardata rel var varattno examine simple variable root var vardata return varnos pull varnos basenode onerel NULL switch bms membership varnos case BMSEMPTYSET break case BMSSINGLETON if var Relid 0 bms is member var Relid varnos onerel find base rel root var Relid var Relid bms singleton member varnos vardata rel onerel node basenode break case BMSMULTIPLE if var Relid 0 vardata rel find join rel root varnos node basenode else if bms is member var Relid varnos vardata rel find base rel root var Relid node basenode break bms free varnos vardata var node vardata atttype expr Type node vardata atttypmod expr Typmod node if onerel List Cell ilist foreach ilist onerel indexlist Index Opt Info index Index Opt Info lfirst ilist List Cell indexpr item int pos indexpr item list head index indexprs if indexpr item NULL continue for pos 0 pos index ncolumns pos if index indexkeys pos 0 Node indexkey if indexpr item NULL elog ERROR too few entries in indexprs list indexkey Node lfirst indexpr item if indexkey Is A indexkey Relabel Type indexkey Node Relabel Type indexkey arg if equal node indexkey if index unique index ncolumns 1 index indpred NIL index pred OK vardata isunique true if get index stats hook get index stats hook root index indexoid pos 1 vardata if Heap Tuple Is Valid vardata stats Tuple vardata freefunc elog ERROR no function provided to release variable stats with else if index indpred NIL vardata stats Tuple Search Sys Cache3 STATRELATTINH Object Id Get Datum index indexoid Int16 Get Datum pos 1 Bool Get Datum false vardata freefunc Release Sys Cache if Heap Tuple Is Valid vardata stats Tuple Range Tbl Entry rte rte planner rt fetch index rel relid root Assert rte rtekind RTERELATION vardata acl ok pg class aclcheck rte relid Get User Id ACLSELECTACLCHECKOK else vardata acl ok true if vardata stats Tuple break indexpr item lnext indexpr item if vardata stats Tuple break static int atrac1 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size A T1 Ctx q avctx priv data int ch ret Get Bit Context gb if buf size 212 avctx channels av log avctx AVLOGERROR Not enough data to decode n return AVERRORINVALIDDATA frame nb samples A T1 SUSAMPLES if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for ch 0 ch avctx channels ch A T1 SU Ctx su q S Us ch init get bits gb buf 212 ch 212 8 ret at1 parse bsm gb su log2 block count if ret 0 return ret ret at1 unpack dequant gb su q spec if ret 0 return ret ret at1 imdct block su q if ret 0 return ret at1 subband synthesis q su float frame extended data ch got frame ptr 1 return avctx block align static bool vmxnet tx pkt parse headers struct Vmxnet Tx Pkt pkt struct iovec l2 hdr l3 hdr size t bytes read size t full ip6hdr len uint16 t l3 proto assert pkt l2 hdr pkt vec VMXNETTXPKT L2 HDRFRAG l3 hdr pkt vec VMXNETTXPKT L3 HDRFRAG bytes read iov to buf pkt raw pkt raw frags 0 l2 hdr iov base ETHMAX L2 HDRLEN if bytes read sizeof struct eth header l2 hdr iov len 0 return false l2 hdr iov len sizeof struct eth header switch be16 to cpu PKTGETETHHDR l2 hdr iov base h proto case ETHPVLAN l2 hdr iov len sizeof struct vlan header break case ETHPDVLAN l2 hdr iov len 2 sizeof struct vlan header break if bytes read l2 hdr iov len l2 hdr iov len 0 return false l3 proto eth get l3 proto l2 hdr iov base l2 hdr iov len switch l3 proto case ETHPIP l3 hdr iov base g malloc ETHMAXI P4 HDRLEN bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base sizeof struct ip header if bytes read sizeof struct ip header l3 hdr iov len 0 return false l3 hdr iov len IPHDRGETLEN l3 hdr iov base pkt l4proto struct ip header l3 hdr iov base ip p bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len sizeof struct ip header l3 hdr iov base sizeof struct ip header l3 hdr iov len sizeof struct ip header if bytes read l3 hdr iov len sizeof struct ip header l3 hdr iov len 0 return false break case ETHPIP V6 if eth parse ipv6 hdr pkt raw pkt raw frags l2 hdr iov len pkt l4proto full ip6hdr len l3 hdr iov len 0 return false l3 hdr iov base g malloc full ip6hdr len bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base full ip6hdr len if bytes read full ip6hdr len l3 hdr iov len 0 return false else l3 hdr iov len full ip6hdr len break default l3 hdr iov len 0 break vmxnet tx pkt calculate hdr len pkt pkt packet type get eth packet type l2 hdr iov base return true static void tcmpt destroy jpc enc tcmpt t tcmpt jpc enc rlvl t rlvl uint fast16 t rlvlno if tcmpt rlvls for rlvlno 0 rlvl tcmpt rlvls rlvlno tcmpt numrlvls rlvlno rlvl rlvl destroy rlvl jas free tcmpt rlvls tcmpt rlvls NULL if tcmpt data jas seq2d destroy tcmpt data tcmpt data NULL if tcmpt tsfb jpc tsfb destroy tcmpt tsfb tcmpt tsfb static guint32 dissect minipacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet proto item item ts tvb get ntohs tvb offset iax packet iax2 get packet data for minipacket pinfo scallno FALSE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add uint iax2 tree hf iax2 minits tvb offset 2 ts iax2 add ts fields pinfo iax2 tree iax packet guint16 ts else iax2 add ts fields pinfo iax2 tree iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini packet source call d timestamp ums scallno ts dissect payload tvb offset pinfo iax2 tree main tree ts FALSE iax packet iax packet first time FALSE return offset static int dissect CPM Create Query tvbuff t tvb packet info pinfo proto tree parent tree gboolean in void data U gint offset 16 proto item item proto tree tree item proto tree add item parent tree hf mswsp msg tvb offset 1 ENCNA tree proto item add subtree item ett mswsp msg proto item set text item CPM Create Query s in In Out col append str pinfo cinfo COLINFO Create Query if in proto item ti proto tree pad tree proto tree add subtree tree tvb offset 0 ett mswsp pad ti Padding guint8 C Column Set Present C Restriction Present C Sort Set Present C Categorization Set Present guint32 size tvb get letohl tvb offset proto tree add uint tree hf mswsp msg cpmcreatequery size tvb offset 4 size offset 4 C Column Set Present tvb get guint8 tvb offset proto tree add item tree hf mswsp msg cpmcreatequery ccolumnsetpresent tvb offset 1 ENCLITTLEENDIAN offset 1 if C Column Set Present offset parse padding tvb offset 4 pad tree padding C Column Set Present offset parse padding tvb offset 4 pad tree padding C Column Set Present offset parse C Column Set tvb offset tree C Column Set C Restriction Present tvb get guint8 tvb offset proto tree add item tree hf mswsp msg cpmcreatequery crestrictionpresent tvb offset 1 ENCLITTLEENDIAN offset 1 if C Restriction Present offset parse C Restriction Array tvb pinfo offset tree pad tree Restriction Array C Sort Set Present tvb get guint8 tvb offset proto tree add item tree hf mswsp msg cpmcreatequery csortpresent tvb offset 1 ENCLITTLEENDIAN offset 1 if C Sort Set Present offset parse padding tvb offset 4 tree padding C Sort Set Present offset parse C In Group Sort Aggreg Sets tvb pinfo offset tree pad tree Group Sort Aggreg Sets C Categorization Set Present tvb get guint8 tvb offset proto tree add item tree hf mswsp msg cpmcreatequery ccategpresent tvb offset 1 ENCLITTLEENDIAN offset 1 if C Categorization Set Present guint32 count i offset parse padding tvb offset 4 pad tree padding C Categorization Set Present count tvb get letohl tvb offset proto tree add uint tree hf mswsp msg cpmcreatequery ccateg count tvb offset 4 count offset 4 for i 0 i count i offset parse C Categorization Spec tvb pinfo offset tree pad tree categories u i offset parse padding tvb offset 4 tree XXXX offset parse C Rowset Properties tvb offset tree pad tree Row Set Properties offset parse C Pid Mapper tvb offset tree pad tree Pid Mapper parse C Column Group Array tvb offset tree pad tree Group Array else proto tree add item tree hf mswsp msg cpmcreatequery trueseq tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmcreatequery workid tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmcreatequery cursors tvb offset 1 ENCNA return tvb reported length tvb static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Zmbv Context const c avctx priv data int zret ZOK int len buf size int hi ver lo ver ret uint8 t tmp if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret c flags buf 0 buf len if c flags ZMBVKEYFRAME hi ver buf 0 lo ver buf 1 c comp buf 2 c fmt buf 3 c bw buf 4 c bh buf 5 c decode intra NULL c decode xor NULL buf 6 len 6 av log avctx AVLOGDEBUG Flags X ver i i comp i fmt i blk ix i n c flags hi ver lo ver c comp c fmt c bw c bh if hi ver 0 lo ver 1 av log ask for sample avctx Unsupported version i i n hi ver lo ver return AVERRORPATCHWELCOME if c bw 0 c bh 0 av log ask for sample avctx Unsupported block size ix i n c bw c bh return AVERRORPATCHWELCOME if c comp 0 c comp 1 av log ask for sample avctx Unsupported compression type i n c comp return AVERRORPATCHWELCOME switch c fmt case ZMBVFMT 8 BPP c bpp 8 c decode intra zmbv decode intra c decode xor zmbv decode xor 8 break case ZMBVFMT 15 BPP case ZMBVFMT 16 BPP c bpp 16 c decode intra zmbv decode intra c decode xor zmbv decode xor 16 break c decode intra zmbv decode intra c decode xor zmbv decode xor 24 break c decode intra zmbv decode intra c decode xor zmbv decode xor 32 break default c decode intra NULL c decode xor NULL av log ask for sample avctx Unsupported for now format i n c fmt return AVERRORPATCHWELCOME zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN tmp av realloc c cur avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c cur tmp tmp av realloc c prev avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c prev tmp c bx c width c bw 1 c bw c by c height c bh 1 c bh if c decode intra NULL av log avctx AVLOGERROR Error Got no format or no keyframe n return AVERRORINVALIDDATA if c comp 0 memcpy c decomp buf buf len c decomp size 1 else c zstream total in c zstream total out 0 c zstream next in buf c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZSYNCFLUSH if zret ZOK zret ZSTREAMEND av log avctx AVLOGERROR inflate error d n zret return AVERRORINVALIDDATA c decomp len c zstream total out if c flags ZMBVKEYFRAME c pic key frame 1 c pic pict type AVPICTURETYPEI c decode intra c else c pic key frame 0 c pic pict type AVPICTURETYPEP if c decomp len c decode xor c uint8 t out src int i j out c pic data 0 src c cur switch c fmt case ZMBVFMT 8 BPP for j 0 j c height j for i 0 i c width i out i 3 0 c pal src 3 0 out i 3 1 c pal src 3 1 out i 3 2 c pal src 3 2 src out c pic linesize 0 break case ZMBVFMT 15 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x7 C00 7 out i 3 1 tmp 0x03 E0 2 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break case ZMBVFMT 16 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x F800 8 out i 3 1 tmp 0x07 E0 3 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break j c height j memcpy out src c width 3 src c width 3 out c pic linesize 0 break j c height j for i 0 i c width i uint32 t tmp AVR L32 src src 4 AVW B24 out i 3 tmp out c pic linesize 0 break default av log avctx AVLOGERROR Cannot handle format i n c fmt FFSWAP uint8 t c cur c prev got frame 1 AV Frame data c pic return buf size static int bethsoftvid decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Bethsoftvid Context vid avctx priv data char block type uint8 t dst uint8 t frame end int remaining avctx width int wrap to next line int code ret int yoffset if ret ff reget buffer avctx vid frame 0 av log avctx AVLOGERROR reget buffer failed n return ret wrap to next line vid frame linesize 0 avctx width if avpkt side data elems 0 avpkt side data 0 type AVPKTDATAPALETTE bytestream2 init vid g avpkt side data 0 data avpkt side data 0 size if ret set palette vid 0 return ret bytestream2 init vid g avpkt data avpkt size dst vid frame data 0 frame end vid frame data 0 vid frame linesize 0 avctx height switch block type bytestream2 get byte vid g case PALETTEBLOCK got frame 0 if ret set palette vid 0 av log avctx AVLOGERROR error reading palette n return ret return bytestream2 tell vid g case VIDEOYOFFPFRAME yoffset bytestream2 get le16 vid g if yoffset avctx height return AVERRORINVALIDDATA dst vid frame linesize 0 yoffset while code bytestream2 get byte vid g int length code 0x7f while length remaining if code 0x80 bytestream2 get buffer vid g dst remaining else if block type VIDEOIFRAME memset dst bytestream2 peek byte vid g remaining length remaining dst remaining wrap to next line remaining avctx width if dst frame end goto end if code 0x80 bytestream2 get buffer vid g dst length else if block type VIDEOIFRAME memset dst bytestream2 get byte vid g length remaining length dst length end if ret av frame ref data vid frame 0 return ret got frame 1 return avpkt size static int dca decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int lfe samples int num core channels 0 int i ret float samples flt DCA Context s avctx priv data int channels full channels int core ss end s xch present 0 s dca buffer size ff dca convert bitstream buf buf size s dca buffer DCAMAXFRAMESIZEDCAMAXEXSSHEADERSIZE if s dca buffer size AVERRORINVALIDDATA av log avctx AVLOGERROR Not a valid DCA frame n return AVERRORINVALIDDATA init get bits s gb s dca buffer s dca buffer size 8 if ret dca parse frame header s 0 return ret avctx sample rate s sample rate avctx bit rate s bit rate s profile FFPROFILEDTS for i 0 i s sample blocks 8 i if ret dca decode block s 0 i av log avctx AVLOGERROR error decoding block n return ret num core channels s prim channels if s ext coding s core ext mask dca ext audio descr mask s ext descr else s core ext mask 0 core ss end FFMIN s frame size s dca buffer size 8 if s core ext mask 0 s core ext mask DCAEXTXCH s core ext mask FFMAX s core ext mask 0 skip bits long s gb get bits count s gb 31 while core ss end get bits count s gb 32 uint32 t bits get bits long s gb 32 switch bits case 0x5a5a5a5a int ext amode xch fsize s xch base channel s prim channels xch fsize show bits s gb 10 if s frame size get bits count s gb 3 4 xch fsize s frame size get bits count s gb 3 4 xch fsize 1 continue skip bits s gb 10 s core ext mask DCAEXTXCH if ext amode get bits s gb 4 1 av log avctx AVLOGERRORX Ch extension amode d not supported n ext amode continue dca parse audio coding header s s xch base channel for i 0 i s sample blocks 8 i if ret dca decode block s s xch base channel i av log avctx AVLOGERROR error decoding X Ch extension n continue s xch present 1 break case 0x47004a03 s core ext mask DCAEXTXXCH break case 0x1d95f262 int fsize96 show bits s gb 12 1 if s frame size get bits count s gb 3 4 fsize96 continue av log avctx AVLOGDEBUG X96 extension found at d bits n get bits count s gb skip bits s gb 12 av log avctx AVLOGDEBUGFSIZ E96 d bytes n fsize96 av log avctx AVLOGDEBUGREVNO d n get bits s gb 4 s core ext mask DCAEXT X96 break skip bits long s gb get bits count s gb 31 else skip bits long s gb core ss end get bits count s gb if s core ext mask DCAEXT X96 s profile FFPROFILEDTS 96 24 else if s core ext mask DCAEXTXCHDCAEXTXXCH s profile FFPROFILEDTSES if s dca buffer size s frame size 32 get bits long s gb 32 DCAHDMARKER dca exss parse header s avctx profile s profile full channels channels s prim channels s lfe if s amode 16 avctx channel layout dca core channel layout s amode if s xch present avctx request channels avctx request channels num core channels s lfe avctx channel layout AVCHBACKCENTER if s lfe avctx channel layout AVCHLOWFREQUENCY s channel order tab dca channel reorder lfe xch s amode else s channel order tab dca channel reorder nolfe xch s amode else channels num core channels s lfe s xch present 0 if s lfe avctx channel layout AVCHLOWFREQUENCY s channel order tab dca channel reorder lfe s amode else s channel order tab dca channel reorder nolfe s amode if channels s lfe s channel order tab channels 1 s lfe 0 return AVERRORINVALIDDATA if avctx request channels 2 s prim channels 2 channels 2 s output DCASTEREO avctx channel layout AVCHLAYOUTSTEREO else av log avctx AVLOGERROR Non standard configuration d n s amode return AVERRORINVALIDDATA avctx channels channels frame nb samples 256 s sample blocks 8 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples flt float frame extended data if avctx channels full channels ret av samples get buffer size NULL full channels channels frame nb samples avctx sample fmt 0 if ret 0 return ret av fast malloc s extra channels buffer s extra channels buffer size ret if s extra channels buffer return AVERRORENOMEM ret av samples fill arrays uint8 t s extra channels NULL s extra channels buffer full channels channels frame nb samples avctx sample fmt 0 if ret 0 return ret for i 0 i s sample blocks 8 i int ch for ch 0 ch channels ch s samples chanptr ch samples flt ch i 256 for ch full channels ch s samples chanptr ch s extra channels ch channels i 256 dca filter channels s i if s source pcm res 1 s xch present float back chan s samples chanptr s channel order tab s xch base channel float lt chan s samples chanptr s channel order tab s xch base channel 2 float rt chan s samples chanptr s channel order tab s xch base channel 1 s fdsp vector fmac scalar lt chan back chan MSQR T1 2 256 s fdsp vector fmac scalar rt chan back chan MSQR T1 2 256 lfe samples 2 s lfe s sample blocks 8 for i 0 i 2 s lfe 4 i s lfe data i s lfe data i lfe samples got frame ptr 1 return buf size static void block rd txfm int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct rdcost block args args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi int64 t rd1 rd2 rd if args skip return if is inter block mbmi vp9 encode block intra x plane block plane bsize tx size mbmi skip dist block plane block tx size args else if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args else if x skip txfm plane 2 block tx size 1 2 tran low t const coeff BLOCKOFFSET x plane plane coeff block tran low t const dqcoeff BLOCKOFFSET xd plane plane dqcoeff block vp9 xform quant dc x plane block plane bsize tx size args sse x bsse plane 2 block tx size 1 4 args dist args sse if x plane plane eobs block args dist args sse coeff 0 coeff 0 coeff 0 dqcoeff 0 coeff 0 dqcoeff 0 2 else x plane plane eobs block 0 args sse x bsse plane 2 block tx size 1 4 args dist args sse else vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args rate block plane block plane bsize tx size args rd1 RDCOST x rdmult x rddiv args rate args dist rd2 RDCOST x rdmult x rddiv 0 args sse rd MIN rd1 rd2 if plane 0 x zcoeff blk tx size block x plane plane eobs block rd1 rd2 xd lossless args this rate args rate args this dist args dist args this sse args sse args this rd rd if args this rd args best rd args skip 1 return static int gdev pdf put params impl gx device dev const gx device pdf save dev gs param list plist int ecode code gx device pdf pdev gx device pdf dev float cl float pdev Compatibility Level bool locked pdev params Lock Distiller Params For OPDF Read gs param name param name pdev pdf memory gs memory stable pdev memory gs param string array ppa gs param string pps code param read string array plist param name pdfmark ppa switch code case 0 code pdfwrite pdf open document pdev if code 0 return code code pdfmark process pdev ppa if code 0 return code default param signal error plist param name code return code case 1 break code param read string array plist param name DSC ppa switch code case 0 code pdfwrite pdf open document pdev if code 0 return code code pdf dsc process pdev ppa if code 0 return code default param signal error plist param name code return code case 1 break code param read string plist param name pdfpagelabels pps switch code case 0 if pdev For OPDF Read cos dict t const pcd pdev Catalog code pdfwrite pdf open document pdev if code 0 return code code cos dict put string pcd const byte Page Labels 11 pps data pps size if code 0 return code else return 0 default param signal error plist param name code return code case 1 break ecode param read bool plist Lock Distiller Params locked if ecode 0 param signal error plist param name ecode int efo 1 ecode param put int plist param name Embed Font Objects efo ecode if ecode 0 param signal error plist param name ecode if efo 1 param signal error plist param name ecode gs error rangecheck int cdv Core Dist Version ecode param put int plist param name Core Dist Version cdv ecode if ecode 0 return gs note error ecode if cdv Core Dist Version param signal error plist param name ecode gs error rangecheck switch code param read float plist param name Compatibility Level cl default ecode code param signal error plist param name ecode break case 0 if locked pdev params Lock Distiller Params if cl float 1 15 cl float 1 1 else if cl float 1 25 cl float 1 2 else if cl float 1 35 cl float 1 3 else if cl float 1 45 cl float 1 4 else if cl float 1 55 cl float 1 5 else if cl float 1 65 cl float 1 6 else if cl float 1 75 cl float 1 7 else cl float 2 0 if pdev params Transfer Function Info tfi Preserve pdev params Transfer Function Info tfi Apply case 1 break gs memory t mem plist memory plist memory pdev pdf memory code gs param read items plist pdev pdf param items if code 0 code param read bool plist For OPDF Read For OPDF Read 0 if code 0 pdev is ps2write locked pdev params Lock Distiller Params pdev For OPDF Read For OPDF Read plist memory mem if code 0 ecode code long fon pdev First Object Number if fon save dev First Object Number if fon 0 fon 0x7fff0000 pdev next id 0 pdev next id save dev First Object Number pdf num initial ids ecode gs error rangecheck param signal error plist First Object Number ecode static const char const pcm names Device Gray Device RGB Device CMYK Device N 0 int pcm 1 ecode param put enum plist Process Color Model pcm pcm names ecode if pcm 0 pdf set process color model pdev pcm rc decrement pdev icc struct gdev pdf put params impl Process Color Model changed pdev icc struct 0 if ecode 0 goto fail if pdev is ps2write code param read bool plist Produce DSC pdev Produce DSC 0 param signal error plist param name code if pdev PDFA 0 pdev PDFA 3 ecode gs note error gs error rangecheck param signal error plist PDFA ecode goto fail if pdev PDFA 0 pdev Abort PDFAX pdev PDFA 0 if pdev PDFX pdev Abort PDFAX pdev PDFX 0 if pdev PDFX pdev PDFA 0 ecode gs note error gs error rangecheck param signal error plist PDFA ecode goto fail if pdev PDFX pdev For OPDF Read ecode gs note error gs error rangecheck param signal error plist PDFX ecode goto fail if pdev PDFA 0 pdev For OPDF Read ecode gs note error gs error rangecheck param signal error plist PDFA ecode goto fail if pdev PDFA 1 pdev PDFX pdev Compatibility Level 1 4 pdev Have Transparency false pdev Preserve S Mask false if pdev PDFX cl float 1 3 if pdev PDFA 0 cl 1 4 cl float 1 4 pdev version cl 1 2 psdf version level2 psdf version ll3 if pdev For OPDF Read pdev Resources Before Usage true pdev Have CFF false pdev Have PDF Widths false pdev Have Stroke Color false cl float 1 2 pdev Max Inline Image Size max long pdev version psdf version level2 else pdev Resources Before Usage false pdev Have CFF true pdev Have PDF Widths true pdev Have Stroke Color true pdev Param Compatibility Level cl if cl 1 2 pdev Have CFF false ecode gdev psdf put params dev plist if ecode 0 goto fail if pdev Compatibility Level 1 7 pdev params Transfer Function Info tfi Preserve pdev params Transfer Function Info tfi Apply emprintf pdev memory n It is not possible to preserve transfer functions in PDF 2 0 ntransfer functions will be applied instead n if pdev params Convert CMYK Images To RGB if pdev params Color Conversion Strategy ccs CMYK emprintf pdev memory Convert CMYK Images To RGB is not compatible with Color Conversion Strategy of CMYK n else if pdev params Color Conversion Strategy ccs Gray emprintf pdev memory Convert CMYK Images To RGB is not compatible with Color Conversion Strategy of Gray n else if pdev icc struct rc decrement pdev icc struct reset default profile n pdf set process color model pdev 1 ecode gsicc init device profile struct gx device pdev NULL 0 if ecode 0 goto fail switch pdev params Color Conversion Strategy case ccs By Object Type case ccs Leave Color Unchanged break case ccs Use Device Dependent Color case ccs Use Device Independent Color case ccs Use Device Independent Color For Images pdev params Transfer Function Info tfi Apply break case ccs CMYK pdev params Transfer Function Info tfi Apply if pdev icc struct rc decrement pdev icc struct reset default profile n pdf set process color model pdev 2 ecode gsicc init device profile struct gx device pdev NULL 0 if ecode 0 goto fail break case ccs Gray pdev params Transfer Function Info tfi Apply if pdev icc struct rc decrement pdev icc struct reset default profile n pdf set process color model pdev 0 ecode gsicc init device profile struct gx device pdev NULL 0 if ecode 0 goto fail break case ccs s RGB case ccs RGB pdev params Transfer Function Info tfi Apply if pdev params Convert CMYK Images To RGB if pdev icc struct rc decrement pdev icc struct reset default profile n pdf set process color model pdev 1 ecode gsicc init device profile struct gx device pdev NULL 0 if ecode 0 goto fail break default break if cl 1 5f pdev params Color Image Filter NULL strcmp pdev params Color Image Filter JPX Encode emprintf pdev memory JPX Encode requires Compatibility Level 1 5 n ecode gs note error gs error rangecheck if cl 1 5f pdev params Gray Image Filter NULL strcmp pdev params Gray Image Filter JPX Encode emprintf pdev memory JPX Encode requires Compatibility Level 1 5 n ecode gs note error gs error rangecheck if cl 1 4f pdev params Mono Image Filter NULL strcmp pdev params Mono Image Filter JBI G2 Encode emprintf pdev memory JBI G2 Encode requires Compatibility Level 1 4 n ecode gs note error gs error rangecheck if pdev Have True Types pdev version psdf version level2 pdev version psdf version level2 with TT if ecode 0 goto fail if pdev First Object Number save dev First Object Number if pdev xref file 0 if gp fseek 64 pdev xref file 0 LSEEKSET 0 ecode gs error ioerror goto fail pdf initialize ids pdev pdev Compatibility Level int cl 10 0 5 10 0 if pdev Owner Password size save dev Owner Password size pdev Owner Password size 0 memcmp pdev Owner Password data save dev Owner Password data pdev Owner Password size 0 if pdev is open if pdev Page Count 0 gs closedevice gx device save dev return 0 else emprintf pdev memory Owner Password changed mid job ignoring n if pdev Linearise pdev is ps2write emprintf pdev memory Can t linearise Post Script output ignoring n pdev Linearise false if pdev Linearise pdev Owner Password size 0 emprintf pdev memory Can t linearise encrypted PDF ignoring n pdev Linearise false if pdev Flatten Fonts pdev Preserve Tr Mode false return 0 fail pdev version save dev version pdf set process color model pdev save dev pcm color info index pdev saved fill color save dev saved fill color pdev saved stroke color save dev saved fill color const gs param item t ppi pdf param items for ppi key ppi memcpy char pdev ppi offset char save dev ppi offset gs param type sizes ppi type pdev For OPDF Read save dev For OPDF Read return ecode void vp9 init layer context V P9 COMP const cpi SVC const svc cpi svc const V P9 Encoder Config const oxcf cpi oxcf int layer int layer end int alt ref idx svc number spatial layers svc number temporal layers svc spatial layer id 0 svc temporal layer id 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR layer end svc number temporal layers else layer end svc number spatial layers for layer 0 layer layer end layer LAYERCONTEXT const lc svc layer context layer RATECONTROL const lrc lc rc int i lc current video frame in layer 0 lc layer size 0 lc frames from key frame 0 lc last frame type FRAMETYPES lrc ni av qi oxcf worst allowed q lrc total actual bits 0 lrc total target vs actual 0 lrc ni tot qi 0 lrc tot q 0 0 lrc avg q 0 0 lrc ni frames 0 lrc decimation count 0 lrc decimation factor 0 for i 0 i RATEFACTORLEVELS i lrc rate correction factors i 1 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR lc target bandwidth oxcf ts target bitrate layer lrc last q INTERFRAME oxcf worst allowed q lrc avg frame qindex INTERFRAME oxcf worst allowed q else lc target bandwidth oxcf ss target bitrate layer lrc last q KEYFRAME oxcf best allowed q lrc last q INTERFRAME oxcf best allowed q lrc avg frame qindex KEYFRAME oxcf worst allowed q oxcf best allowed q 2 lrc avg frame qindex INTERFRAME oxcf worst allowed q oxcf best allowed q 2 if oxcf ss play alternate layer lc alt ref idx alt ref idx else lc alt ref idx 1 lc gold ref idx 1 lrc buffer level oxcf starting buffer level ms lc target bandwidth 1000 lrc bits off target lrc buffer level if svc number temporal layers 1 cpi oxcf rc mode VPXCBR alt ref idx REFFRAMES svc layer context 0 gold ref idx alt ref idx static void choose intra uv mode V P9 COMP cpi PICKMODECONTEXT ctx BLOCKSIZE bsize TXSIZE max tx size int rate uv int rate uv tokenonly int64 t dist uv int skip uv PREDICTIONMODE mode uv MACROBLOCK const x cpi mb if cpi sf use uv intra rd estimate rd sbuv dcpred cpi x rate uv rate uv tokenonly dist uv skip uv bsize BLOCK 8 X8 BLOCK 8 X8 bsize else rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv skip uv bsize BLOCK 8 X8 BLOCK 8 X8 bsize max tx size mode uv x e mbd mi 0 src mi mbmi uv mode void ff h264 filter mb H264 Context h int mb x int mb y uint8 t img y uint8 t img cb uint8 t img cr unsigned int linesize unsigned int uvlinesize const int mb xy mb x mb y h mb stride const int mb type h cur pic f mb type mb xy const int mvy limit ISINTERLACED mb type 2 4 int first vertical edge done 0 av unused int dir int chroma CONFIGGRAY h flags CODECFLAGGRAY int qp bd offset 6 h sps bit depth luma 8 int a h slice alpha c0 offset qp bd offset int b h slice beta offset qp bd offset if FRAMEMBAFFISINTERLACED mb type h left type LTOP h left type LTOPDECLAREALIGNED 8 int16 t b S 8 int qp 2 int bqp 2 int rqp 2 int mb qp mbn0 qp mbn1 qp int i first vertical edge done 1 if ISINTRA mb type AVW N64 A b S 0 0x0004000400040004 ULLAVW N64 A b S 4 0x0004000400040004 ULL else static const uint8 t offset 2 2 8 3 4 0 3 4 0 3 4 0 3 4 0 3 4 1 3 4 1 3 4 1 3 4 1 3 4 2 3 4 2 3 4 2 3 4 2 3 4 3 3 4 3 3 4 3 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 const uint8 t off offset MBFIELD mb y 1 for i 0 i 8 i int j MBFIELD i 2 i 1 int mbn xy h left mb xy LEFT j int mbn type h left type LEFT j if ISINTRA mbn type b S i 4 else b S i 1 h non zero count cache 12 8 i 1 h pps cabac IS 8x8 DCT mbn type h cbp table mbn xy MBFIELD i 2 mb y 1 8 2 12 h non zero count mbn xy off i mb qp h cur pic f qscale table mb xy mbn0 qp h cur pic f qscale table h left mb xy 0 mbn1 qp h cur pic f qscale table h left mb xy 1 qp 0 mb qp mbn0 qp 1 1 bqp 0 get chroma qp h 0 mb qp get chroma qp h 0 mbn0 qp 1 1 rqp 0 get chroma qp h 1 mb qp get chroma qp h 1 mbn0 qp 1 1 qp 1 mb qp mbn1 qp 1 1 bqp 1 get chroma qp h 0 mb qp get chroma qp h 0 mbn1 qp 1 1 rqp 1 get chroma qp h 1 mb qp get chroma qp h 1 mbn1 qp 1 1 tprintf h avctx filter mb d d MBAFFQ Py d d Q Pb d d Q Pr d d ls d uvls d mb x mb y qp 0 qp 1 bqp 0 bqp 1 rqp 0 rqp 1 linesize uvlinesize int i for i 0 i 8 i tprintf h avctx b S d d i b S i tprintf h avctx n if MBFIELD filter mb mbaff edgev h img y linesize b S 1 qp 0 a b 1 filter mb mbaff edgev h img y 8 linesize linesize b S 4 1 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgev h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgev h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgev h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else if CHROM A422 filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 4 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 4 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgev h img y 2 linesize b S 2 qp 0 a b 1 filter mb mbaff edgev h img y linesize 2 linesize b S 1 2 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgev h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgev h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgev h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 else filter mb mbaff edgecv h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgecv h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgecv h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgecv h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 dir 2 dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit dir 0 first vertical edge done a b chroma dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit 0 a b chroma 1 AS N1 BITSTRING c2i AS N1 BITSTRINGAS N1 BITSTRING a const unsigned char pp long len AS N1 BITSTRING ret NULL const unsigned char p unsigned char s int i if len 1 i AS N1 RSTRINGTOOSHORT goto err if a NULL a NULL if ret MAS N1 BITSTRING new NULL return NULL else ret a p pp i p ret flags AS N1 STRINGFLAGBITSLEFT 0x07 ret flags AS N1 STRINGFLAGBITSLEFT i 0x07 if len 1 s unsigned char OPENSSL malloc int len if s NULL i ERRRMALLOCFAILURE goto err memcpy s p int len s len 1 0xff i p len else s NULL ret length int len if ret data NULLOPENSSL free ret data ret data s ret type VAS N1 BITSTRING if a NULL a ret pp p return ret err AS N1err AS N1 F C2 IAS N1 BITSTRING i if ret NULL a NULL a ret MAS N1 BITSTRING free ret return static gcry err code t sexp data to mpi gcry sexp t input gcry mpi t ret mpi struct pk encoding ctx ctx gcry err code t rc 0 gcry sexp t ldata lhash lvalue int i size t n const char s int unknown flag 0 int parsed flags 0 int explicit raw 0 ret mpi NULL ldata gcry sexp find token input data 0 if ldata ret mpi gcry sexp nth mpi input 0 0 return ret mpi GPGERRNOERRORGPGERRINVOBJ gcry sexp t lflags gcry sexp find token ldata flags 0 if lflags for i gcry sexp length lflags 1 i 0 i s gcry sexp nth data lflags i n if s else if n 7 memcmp s rfc6979 7 parsed flags PUBKEYFLAGRF C6979 else if n 5 memcmp s eddsa 5 ctx encoding PUBKEYENCRAW parsed flags PUBKEYFLAGEDDSA else if n 3 memcmp s raw 3 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCRAW explicit raw 1 else if n 5 memcmp s pkcs1 5 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCPKC S1 else if n 4 memcmp s oaep 4 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCOAEP else if n 3 memcmp s pss 3 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCPSS else if n 11 memcmp s no blinding 11 parsed flags PUBKEYFLAGNOBLINDING else unknown flag 1 gcry sexp release lflags if ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCRAW lhash gcry sexp find token ldata hash 0 lvalue lhash NULL gcry sexp find token ldata value 0 if lhash lvalue rc GPGERRINVOBJ else if unknown flag rc GPGERRINVFLAG else if ctx encoding PUBKEYENCRAW parsed flags PUBKEYFLAGEDDSA gcry sexp t list void value size t valuelen if lvalue rc GPGERRINVOBJ goto leave list gcry sexp find token ldata hash algo 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO gcry sexp release list else rc GPGERRINVOBJ if rc goto leave value gcry sexp nth buffer lvalue 1 valuelen if value valuelen 0 value gcry malloc 1 if value rc gpg err code from syserror else if valuelen 8 valuelen gcry free value rc GPGERRTOOLARGE if rc goto leave ret mpi gcry mpi set opaque NULL value valuelen 8 else if ctx encoding PUBKEYENCRAW lhash explicit raw parsed flags PUBKEYFLAGRF C6979 if gcry sexp length lhash 3 rc GPGERRINVOBJ else if s gcry sexp nth data lhash 1 n n rc GPGERRINVOBJ else void value size t valuelen ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO else if value gcry sexp nth buffer lhash 2 valuelen rc GPGERRINVOBJ else if valuelen 8 valuelen gcry free value rc GPGERRTOOLARGE else ret mpi gcry mpi set opaque NULL value valuelen 8 else if ctx encoding PUBKEYENCRAW lvalue if parsed flags PUBKEYFLAGRF C6979 rc GPGERRCONFLICT goto leave ret mpi gcry sexp nth mpi lvalue 1 GCRYMPIFMTUSG if ret mpi rc GPGERRINVOBJ else if ctx encoding PUBKEYENCPKC S1 lvalue ctx op PUBKEYOPENCRYPT const void value size t valuelen gcry sexp t list void random override NULL size t random override len 0 if value gcry sexp nth data lvalue 1 valuelen valuelen rc GPGERRINVOBJ else list gcry sexp find token ldata random override 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else if n 0 random override gcry malloc n if random override rc gpg err code from syserror else memcpy random override s n random override len n gcry sexp release list if rc goto leave rc pkcs1 encode for encryption ret mpi ctx nbits value valuelen random override random override len gcry free random override else if ctx encoding PUBKEYENCPKC S1 lhash ctx op PUBKEYOPSIGN ctx op PUBKEYOPVERIFY if gcry sexp length lhash 3 rc GPGERRINVOBJ else if s gcry sexp nth data lhash 1 n n rc GPGERRINVOBJ else const void value size t valuelen ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO else if value gcry sexp nth data lhash 2 valuelen valuelen rc GPGERRINVOBJ else rc pkcs1 encode for signature ret mpi ctx nbits value valuelen ctx hash algo else if ctx encoding PUBKEYENCOAEP lvalue ctx op PUBKEYOPENCRYPT const void value size t valuelen if value gcry sexp nth data lvalue 1 valuelen valuelen rc GPGERRINVOBJ else gcry sexp t list void random override NULL size t random override len 0 list gcry sexp find token ldata hash algo 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO gcry sexp release list if rc goto leave list gcry sexp find token ldata label 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else if n 0 ctx label gcry malloc n if ctx label rc gpg err code from syserror else memcpy ctx label s n ctx labellen n gcry sexp release list if rc goto leave list gcry sexp find token ldata random override 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else if n 0 random override gcry malloc n if random override rc gpg err code from syserror else memcpy random override s n random override len n gcry sexp release list if rc goto leave rc oaep encode ret mpi ctx nbits ctx hash algo value valuelen ctx label ctx labellen random override random override len gcry free random override else if ctx encoding PUBKEYENCPSS lhash ctx op PUBKEYOPSIGN if gcry sexp length lhash 3 rc GPGERRINVOBJ else if s gcry sexp nth data lhash 1 n n rc GPGERRINVOBJ else const void value size t valuelen void random override NULL size t random override len 0 ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO else if value gcry sexp nth data lhash 2 valuelen valuelen rc GPGERRINVOBJ else gcry sexp t list list gcry sexp find token ldata salt length 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ goto leave ctx saltlen unsigned int strtoul s NULL 10 gcry sexp release list list gcry sexp find token ldata random override 0 if list s gcry sexp nth data list 1 n if s rc GPGERRNOOBJ else if n 0 random override gcry malloc n if random override rc gpg err code from syserror else memcpy random override s n random override len n gcry sexp release list if rc goto leave rc pss encode ret mpi ctx nbits 1 ctx hash algo value valuelen ctx saltlen random override random override len gcry free random override else if ctx encoding PUBKEYENCPSS lhash ctx op PUBKEYOPVERIFY if gcry sexp length lhash 3 rc GPGERRINVOBJ else if s gcry sexp nth data lhash 1 n n rc GPGERRINVOBJ else ctx hash algo get hash algo s n if ctx hash algo rc GPGERRDIGESTALGO else ret mpi gcry sexp nth mpi lhash 2 GCRYMPIFMTUSG if ret mpi rc GPGERRINVOBJ ctx verify cmp pss verify cmp ctx verify arg ret mpi else rc GPGERRCONFLICT leave gcry sexp release ldata gcry sexp release lhash gcry sexp release lvalue if rc ctx flags parsed flags else gcry free ctx label ctx label NULL return rc static double ineq histogram selectivity Planner Info root Variable Stat Data vardata Fmgr Info opproc bool isgt Datum constval Oid consttype double hist selec Oid hist op Datum values int nvalues hist selec 1 0 if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opproc fn oid get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid hist op values nvalues NULLNULL if nvalues 1 double histfrac int lobound 0 int hibound nvalues bool have end false if nvalues 2 have end get actual variable range root vardata hist op values 0 values 1 while lobound hibound int probe lobound hibound 2 bool ltcmp if probe 0 nvalues 2 have end get actual variable range root vardata hist op values 0 NULL else if probe nvalues 1 nvalues 2 have end get actual variable range root vardata hist op NULL values probe ltcmp Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values probe constval if isgt ltcmp ltcmp if ltcmp lobound probe 1 else hibound probe if lobound 0 histfrac 0 0 else if lobound nvalues histfrac 1 0 else int i lobound double val high low double binfrac if convert to scalar constval consttype val values i 1 values i vardata vartype low high if high low binfrac 0 5 else if val low binfrac 0 0 else if val high binfrac 1 0 else binfrac val low high low if isnan binfrac binfrac 0 0 binfrac 1 0 binfrac 0 5 else binfrac 0 5 histfrac double i 1 binfrac histfrac double nvalues 1 hist selec isgt 1 0 histfrac histfrac if have end CLAMPPROBABILITY hist selec else if hist selec 0 0001 hist selec 0 0001 else if hist selec 0 9999 hist selec 0 9999 free attstatsslot vardata atttype values nvalues NULL 0 return hist selec static void tokenize b int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct tokenize b args const args arg V P9 COMP cpi args cpi MACROBLOCKD xd args xd TOKENEXTRA tp args tp uint8 t token cache 32 32 struct macroblock plane p cpi mb plane plane struct macroblockd plane pd xd plane plane MBMODEINFO mbmi xd mi 0 mbmi int pt int c TOKENEXTRA t tp int eob p eobs block const PLANETYPE type pd plane type const int16 t qcoeff BLOCKOFFSET p qcoeff block const int segment id mbmi segment id const int16 t scan nb const scan order so const int ref is inter block mbmi unsigned int const counts COEFFCONTEXTSENTROPYTOKENS cpi coef counts tx size type ref vp9 prob const coef probs COEFFCONTEXTSUNCONSTRAINEDNODES cpi common fc coef probs tx size type ref unsigned int const eob branch COEFFCONTEXTS cpi common counts eob branch tx size type ref const uint8 t const band get band translate tx size const int seg eob get tx eob cpi common seg segment id tx size int aoff loff txfrm block to raster xy plane bsize tx size block aoff loff pt get entropy context tx size pd above context aoff pd left context loff so get scan xd tx size type block scan so scan nb so neighbors c 0 while c eob int v 0 int skip eob 0 v qcoeff scan c while v add token no extra t coef probs band c pt ZEROTOKEN skip eob counts band c pt eob branch band c pt skip eob skip eob 1 token cache scan c 0 c pt get coef context nb token cache c v qcoeff scan c add token t coef probs band c pt vp9 dct value tokens ptr v extra uint8 t vp9 dct value tokens ptr v token uint8 t skip eob counts band c pt eob branch band c pt skip eob token cache scan c vp9 pt energy class vp9 dct value tokens ptr v token c pt get coef context nb token cache c if c seg eob add token no extra t coef probs band c pt EOBTOKEN 0 counts band c pt eob branch band c pt tp t vp9 set contexts xd pd plane bsize tx size c 0 aoff loff static int rv34 decode mv R V34 Dec Context r int block type Mpeg Enc Context s r s Get Bit Context gb s gb int i j k l int mv pos s mb x 2 s mb y 2 s b8 stride int next bt memset r dmv 0 sizeof r dmv for i 0 i num mvs block type i r dmv i 0 svq3 get se golomb gb r dmv i 1 svq3 get se golomb gb switch block type case R V34 MBTYPEINTRA case R V34 MBTYPEINTR A16x16 ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride return 0 case R V34 MBSKIP if s pict type AVPICTURETYPEPZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBDIRECT if HAVETHREADS s avctx active thread type FFTHREADFRAME ff thread await progress s next picture ptr f FFMAX 0 s mb y 1 0 next bt s next picture ptr f mb type s mb x s mb y s mb stride if ISINTRA next bt ISSKIP next bt ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride ZER O8x2 s current picture ptr f motion val 1 s mb x 2 s mb y 2 s b8 stride s b8 stride else for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k for l 0 l 2 l s current picture ptr f motion val l mv pos i j s b8 stride k calc add mv r l s next picture ptr f motion val 0 mv pos i j s b8 stride k if IS 16 X8 next bt IS 8 X16 next bt IS 8 X8 next bt rv34 mc 2mv r block type else rv34 mc 2mv skip r ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride break case R V34 MBP 16x16 case R V34 MBPMI X16x16 rv34 pred mv r block type 0 0 rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBFORWARD case R V34 MBBBACKWARD r dmv 1 0 r dmv 0 0 r dmv 1 1 r dmv 0 1 if r rv30 rv34 pred mv rv3 r block type block type R V34 MBBBACKWARD else rv34 pred mv b r block type block type R V34 MBBBACKWARD rv34 mc 1mv r block type 0 0 0 2 2 block type R V34 MBBBACKWARD break case R V34 MBP 16x8 case R V34 MBP 8x16 rv34 pred mv r block type 0 0 rv34 pred mv r block type 1 block type R V34 MBP 16x8 1 if block type R V34 MBP 16x8 rv34 mc 1mv r block type 0 0 0 2 1 0 rv34 mc 1mv r block type 0 8 s b8 stride 2 1 0 if block type R V34 MBP 8x16 rv34 mc 1mv r block type 0 0 0 1 2 0 rv34 mc 1mv r block type 8 0 1 1 2 0 break case R V34 MBBBIDIR rv34 pred mv b r block type 0 rv34 pred mv b r block type 1 rv34 mc 2mv r block type break case R V34 MBP 8x8 for i 0 i 4 i rv34 pred mv r block type i i rv34 mc 1mv r block type i 1 3 i 2 2 i 1 i 1 s b8 stride 1 1 0 break return 0 static void encode block int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd struct optimize ctx const ctx args ctx struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block int i j uint8 t dst ENTROPYCONTEXT a l txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j pd dst stride 4 i a ctx ta plane i l ctx tl plane j if x zcoeff blk tx size block plane 0 p eobs block 0 a l 0 return if x skip recode if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 if x quant fp vp9 xform quant fp x plane block plane bsize tx size else vp9 xform quant x plane block plane bsize tx size else if x skip txfm plane 2 block tx size 1 2 vp9 xform quant dc x plane block plane bsize tx size else p eobs block 0 a l 0 return else vp9 xform quant x plane block plane bsize tx size if x optimize x skip recode x skip optimize const int ctx combine entropy contexts a l a l optimize b x plane block tx size ctx 0 else a l p eobs block 0 if p eobs block args skip 0 if x skip encode p eobs block 0 return switch tx size case TX 32 X32 vp9 idct32x32 add dqcoeff dst pd dst stride p eobs block break case TX 16 X16 vp9 idct16x16 add dqcoeff dst pd dst stride p eobs block break case TX 8 X8 vp9 idct8x8 add dqcoeff dst pd dst stride p eobs block break case TX 4 X4 x itxm add dqcoeff dst pd dst stride p eobs block break default assert 0 Invalid transform size break static void encode nonrd sb row V P9 COMP cpi const Tile Info const tile int mi row TOKENEXTRA tp SPEEDFEATURES const sf cpi sf V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd int mi col vpx memset xd left context 0 sizeof xd left context vpx memset xd left seg context 0 sizeof xd left seg context for mi col tile mi col start mi col tile mi col end mi col MIBLOCKSIZE int dummy rate 0 int64 t dummy dist 0 const int idx str cm mi stride mi row mi col MODEINFO mi cm mi idx str MODEINFO prev mi cm prev mip cm mi stride 1 idx str src mi BLOCKSIZE bsize x in static area 0 x source variance UINTMAX vp9 zero x pred mv switch sf partition search type case VARBASEDPARTITION choose partitioning cpi tile mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case SOURCEVARBASEDPARTITION set source var based partition cpi tile mi mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case VARBASEDFIXEDPARTITION case FIXEDPARTITION bsize sf partition search type FIXEDPARTITION sf always this block size get nonrd var based fixed partition cpi mi row mi col set fixed partitioning cpi tile mi mi row mi col bsize nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case REFERENCEPARTITION if sf partition check x in static area is background cpi tile mi row mi col set modeinfo offsets cm xd mi row mi col auto partition range cpi tile mi row mi col sf min partition size sf max partition size nonrd pick partition cpi tile tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 IN T64 MAX cpi pc root else copy partitioning cm mi prev mi nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break default assert 0 break static int msmpeg4v34 decode mb Mpeg Enc Context s int16 t block 6 64 int cbp code i uint8 t coded val uint32 t const mb type ptr s current picture mb type s mb x s mb y s mb stride if s pict type AVPICTURETYPEP if s use skip mb code if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 mb type ptr MBTYPESKIPMBTYPE L0 MBTYPE 16x16 return 0 code get vlc2 s gb ff mb non intra vlc DEFAULTINTERINDEX table MBNONINTRAVLCBITS 3 if code 0 return 1 s mb intra code 0x40 6 cbp code 0x3f else s mb intra 1 code get vlc2 s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if code 0 return 1 cbp 0 for i 0 i 6 i int val code 5 i 1 if i 4 int pred ff msmpeg4 coded block pred s i coded val val val pred coded val val cbp val 5 i if s mb intra int mx my if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index ff h263 pred motion s 0 0 mx my if ff msmpeg4 decode motion s mx my 0 return 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 mx s mv 0 0 1 my mb type ptr MBTYPE L0 MBTYPE 16x16 else av dlog s I at d d d 06 X n s mb x s mb y cbp 3 1 0 cbp 0x3 C 2 0 show bits s gb 24 s ac pred get bits1 s gb mb type ptr MBTYPEINTRA if s inter intra pred s h263 aic dir get vlc2 s gb ff inter intra vlc table INTERINTRAVLCBITS 1 av dlog s d d d d s ac pred s h263 aic dir s mb x s mb y if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index s dsp clear blocks s block 0 for i 0 i 6 i if ff msmpeg4 decode block s block i i cbp 5 i 1 NULL 0 av log s avctx AVLOGERROR nerror while decoding block d x d d n s mb x s mb y i return 1 return 0 static void sig message join SERVERREC server const char channel const char nick const char address CHANNELREC chanrec g return if fail nick NULL chanrec channel find server channel if chanrec NULLCHANNELLASTMSGADD chanrec nick char irc ctcp dcc filename without quotes const char filename int length length strlen filename if length 1 if filename 0 filename length 1 return weechat strndup filename 1 length 2 return strdup filename static void encode sb rt V P9 COMP cpi const Tile Info const tile TOKENEXTRA tp int mi row int mi col int output enabled BLOCKSIZE bsize PCTREE pc tree V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const int bsl b width log2 bsize hbs 1 bsl 4 int ctx PARTITIONTYPE partition BLOCKSIZE subsize if mi row cm mi rows mi col cm mi cols return if bsize BLOCK 8 X8 const int idx str xd mi stride mi row mi col MODEINFO mi 8x8 cm mi idx str src mi ctx partition plane context xd mi row mi col bsize subsize mi 8x8 0 src mi mbmi sb type else ctx 0 subsize BLOCK 4 X4 partition partition lookup bsl subsize if output enabled bsize BLOCK 4 X4 cm counts partition ctx partition switch partition case PARTITIONNONE encode b rt cpi tile tp mi row mi col output enabled subsize pc tree none break case PARTITIONVERT encode b rt cpi tile tp mi row mi col output enabled subsize pc tree vertical 0 if mi col hbs cm mi cols bsize BLOCK 8 X8 encode b rt cpi tile tp mi row mi col hbs output enabled subsize pc tree vertical 1 break case PARTITIONHORZ encode b rt cpi tile tp mi row mi col output enabled subsize pc tree horizontal 0 if mi row hbs cm mi rows bsize BLOCK 8 X8 encode b rt cpi tile tp mi row hbs mi col output enabled subsize pc tree horizontal 1 break case PARTITIONSPLIT subsize get subsize bsize PARTITIONSPLIT encode sb rt cpi tile tp mi row mi col output enabled subsize pc tree split 0 encode sb rt cpi tile tp mi row mi col hbs output enabled subsize pc tree split 1 encode sb rt cpi tile tp mi row hbs mi col output enabled subsize pc tree split 2 encode sb rt cpi tile tp mi row hbs mi col hbs output enabled subsize pc tree split 3 break default assert Invalid partition type break if partition PARTITIONSPLIT bsize BLOCK 8 X8 update partition context xd mi row mi col subsize bsize static void apply loop filter Vp3 Decode Context s int plane int ystart int yend int x y int bounding values s bounding values array 127 int width s fragment width plane int height s fragment height plane int fragment s fragment start plane ystart width int stride s current frame linesize plane uint8 t plane data s current frame data plane if s flipped image stride stride plane data s data offset plane 8 ystart stride for y ystart y yend y for x 0 x width x if s all fragments fragment coding method MODECOPY if x 0 s vp3dsp h loop filter plane data 8 x stride bounding values if y 0 s vp3dsp v loop filter plane data 8 x stride bounding values if x width 1 s all fragments fragment 1 coding method MODECOPY s vp3dsp h loop filter plane data 8 x 8 stride bounding values if y height 1 s all fragments fragment width coding method MODECOPY s vp3dsp v loop filter plane data 8 x 8 stride stride bounding values fragment plane data 8 stride static void fill vaapi pic VA Picture H264 va pic Picture pic int pic structure if pic structure 0 pic structure pic reference pic structure PICTFRAME va pic picture id ff vaapi get surface id pic va pic frame idx pic long ref pic pic id pic frame num va pic flags 0 if pic structure PICTFRAME va pic flags pic structure PICTTOPFIELDVAPICTURE H264 TOPFIELDVAPICTURE H264 BOTTOMFIELD if pic reference va pic flags pic long ref VAPICTURE H264 LONGTERMREFERENCEVAPICTURE H264 SHORTTERMREFERENCE va pic Top Field Order Cnt 0 if pic field poc 0 INTMAX va pic Top Field Order Cnt pic field poc 0 va pic Bottom Field Order Cnt 0 if pic field poc 1 INTMAX va pic Bottom Field Order Cnt pic field poc 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AS V1 Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p a picture int mb x mb y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 av fast padded malloc a bitstream buffer a bitstream buffer size buf size if a bitstream buffer return AVERRORENOMEM if avctx codec id AVCODECIDAS V1 a dsp bswap buf uint32 t a bitstream buffer const uint32 t buf buf size 4 else int i for i 0 i buf size i a bitstream buffer i ff reverse buf i init get bits a gb a bitstream buffer buf size 8 for mb y 0 mb y a mb height2 mb y for mb x 0 mb x a mb width2 mb x if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb width2 a mb width mb x a mb width2 for mb y 0 mb y a mb height2 mb y if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb height2 a mb height mb y a mb height2 for mb x 0 mb x a mb width mb x if ret decode mb a a block 0 return ret idct put a mb x mb y picture a picture got frame 1 emms c return get bits count a gb 31 32 4 int getulong const char numstr unsigned long int result long long int val char endptr errno 0 val strtoll numstr endptr 0 if 0 numstr 0 endptr ERANGE errno val unsigned long int val return 0 result unsigned long int val return 1 static int load input picture Mpeg Enc Context s const AV Frame pic arg AV Frame pic NULL int64 t pts int i display picture number 0 const int encoding delay s max b frames s max b frames s low delay 0 1 int direct 1 if pic arg pts pic arg pts display picture number s input picture number if pts AVNOPTSVALUE if s user specified pts AVNOPTSVALUE int64 t time pts int64 t last s user specified pts if time last av log s avctx AVLOGERROR Error Invalid timestamp PR Id64 last PR Id64 n pts s user specified pts return 1 if s low delay display picture number 1 s dts delta time last s user specified pts pts else if s user specified pts AVNOPTSVALUE s user specified pts pts s user specified pts 1 av log s avctx AVLOGINFO Warning AV Frame pts trying to guess PR Id64 n pts else pts display picture number if pic arg if encoding delay s flags CODECFLAGINPUTPRESERVED direct 0 if pic arg linesize 0 s linesize direct 0 if pic arg linesize 1 s uvlinesize direct 0 if pic arg linesize 2 s uvlinesize direct 0 av dlog s avctx d d d d n pic arg linesize 0 pic arg linesize 1 s linesize s uvlinesize if direct i ff find unused picture s 1 if i 0 return i pic s picture i f pic reference 3 for i 0 i 4 i pic data i pic arg data i pic linesize i pic arg linesize i if ff alloc picture s Picture pic 1 0 return 1 else i ff find unused picture s 0 if i 0 return i pic s picture i f pic reference 3 if ff alloc picture s Picture pic 0 0 return 1 if pic data 0 INPLACEOFFSET pic arg data 0 pic data 1 INPLACEOFFSET pic arg data 1 pic data 2 INPLACEOFFSET pic arg data 2 else int h chroma shift v chroma shift av pix fmt get chroma sub sample s avctx pix fmt h chroma shift v chroma shift for i 0 i 3 i int src stride pic arg linesize i int dst stride i s uvlinesize s linesize int h shift i h chroma shift 0 int v shift i v chroma shift 0 int w s width h shift int h s height v shift uint8 t src pic arg data i uint8 t dst pic data i if s avctx rc buffer size dst INPLACEOFFSET if src stride dst stride memcpy dst src src stride h else while h memcpy dst src w dst dst stride src src stride copy picture attributes s pic pic arg pic display picture number display picture number pic pts pts for i 1 i MAXPICTURECOUNT i s input picture i 1 s input picture i s input picture encoding delay Picture pic return 0 void vp9 init layer context V P9 COMP const cpi SVC const svc cpi svc const V P9 Encoder Config const oxcf cpi oxcf int layer int layer end int alt ref idx svc number spatial layers svc number temporal layers svc spatial layer id 0 svc temporal layer id 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR layer end svc number temporal layers else layer end svc number spatial layers for layer 0 layer layer end layer LAYERCONTEXT const lc svc layer context layer RATECONTROL const lrc lc rc int i lc current video frame in layer 0 lc layer size 0 lc frames from key frame 0 lc last frame type FRAMETYPES lrc ni av qi oxcf worst allowed q lrc total actual bits 0 lrc total target vs actual 0 lrc ni tot qi 0 lrc tot q 0 0 lrc avg q 0 0 lrc ni frames 0 lrc decimation count 0 lrc decimation factor 0 for i 0 i RATEFACTORLEVELS i lrc rate correction factors i 1 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR lc target bandwidth oxcf ts target bitrate layer lrc last q INTERFRAME oxcf worst allowed q lrc avg frame qindex INTERFRAME oxcf worst allowed q else lc target bandwidth oxcf ss target bitrate layer lrc last q KEYFRAME oxcf best allowed q lrc last q INTERFRAME oxcf best allowed q lrc avg frame qindex KEYFRAME oxcf worst allowed q oxcf best allowed q 2 lrc avg frame qindex INTERFRAME oxcf worst allowed q oxcf best allowed q 2 if oxcf ss play alternate layer lc alt ref idx alt ref idx else lc alt ref idx 1 lc gold ref idx 1 lrc buffer level oxcf starting buffer level ms lc target bandwidth 1000 lrc bits off target lrc buffer level if svc number temporal layers 1 cpi oxcf rc mode VPXCBR alt ref idx REFFRAMES svc layer context 0 gold ref idx alt ref idx static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Video XL Context const a avctx priv data AV Frame const p a pic uint8 t YUV int i j ret int stride uint32 t val int y0 y1 y2 y3 0 c0 0 c1 0 if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 Y a pic data 0 U a pic data 1 V a pic data 2 stride avctx width 4 if buf size avctx width avctx height av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA for i 0 i avctx height i buf stride for j 0 j avctx width j 4 val AVR L32 buf buf 4 val val 16 0x FFFF val 0x FFFF 16 if j y0 val 0x1 F 2 else y0 y3 xl table val 0x1 F val 5 y1 y0 xl table val 0x1 F val 5 y2 y1 xl table val 0x1 F val 6 y3 y2 xl table val 0x1 F val 5 if j c0 val 0x1 F 2 else c0 xl table val 0x1 F val 5 if j c1 val 0x1 F 2 else c1 xl table val 0x1 FY j 0 y0 1 Y j 1 y1 1 Y j 2 y2 1 Y j 3 y3 1 U j 2 c0 1 V j 2 c1 1 buf avctx width 4 Y a pic linesize 0 U a pic linesize 1 V a pic linesize 2 got frame 1 AV Frame data a pic return buf size static int32 t append Keywords To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status char buf ULOCKEYWORDANDVALUESCAPACITY char attr Buf ULOCKEYWORDANDVALUESCAPACITY 0 int32 t attr Buf Length 0 U Enumeration keyword Enum NULL int32 t reslen 0 keyword Enum uloc open Keywords locale ID status if UFAILURE status had Posix uenum close keyword Enum return 0 if keyword Enum NULL had Posix int32 t len const char key Extension List Entry first Ext NULL Extension List Entry ext Attribute List Entry first Attr NULL Attribute List Entry attr char attr Value char ext Buf ULOCKEYWORDANDVALUESCAPACITY char p Ext Buf ext Buf int32 t ext Buf Capacity sizeof ext Buf const char bcp Key nullptr bcp Value nullptr U Error Code tmp Status UZEROERROR int32 t keylen U Bool is Bcp U Ext while TRUE key uenum next keyword Enum NULL status if key NULL break len uloc get Keyword Value locale ID key buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR break tmp Status UZEROERROR continue keylen int32 t uprv strlen key is Bcp U Ext keylen 1 if uprv strcmp key LOCALEATTRIBUTEKEY 0 if len 0 int32 t i 0 while TRUE attr Buf Length 0 for i len i if buf i attr Buf attr Buf Length buf i else i break if attr Buf Length 0 attr Buf attr Buf Length 0 else if i len break attr Attribute List Entry uprv malloc sizeof Attribute List Entry if attr NULL status UMEMORYALLOCATIONERROR break attr Value char uprv malloc attr Buf Length 1 if attr Value NULL status UMEMORYALLOCATIONERROR break uprv strcpy attr Value attr Buf attr attribute attr Value if add Attribute To List first Attr attr uprv free attr uprv free attr Value if strict status UILLEGALARGUMENTERROR break bcp Key LOCALEATTRIBUTEKEY bcp Value NULL else if is Bcp U Ext bcp Key uloc to Unicode Locale Key key if bcp Key NULL if strict status UILLEGALARGUMENTERROR break continue bcp Value uloc to Unicode Locale Type key buf if bcp Value NULL if strict status UILLEGALARGUMENTERROR break continue if bcp Value buf int32 t bcp Value Len uprv strlen bcp Value if bcp Value Len ext Buf Capacity uprv strcpy p Ext Buf bcp Value TC String to Lower Case p Ext Buf bcp Value p Ext Buf p Ext Buf bcp Value Len 1 ext Buf Capacity bcp Value Len 1 else if strict status UILLEGALARGUMENTERROR break continue else if key PRIVATEUSE if is Privateuse Value Subtags buf len if strict status UILLEGALARGUMENTERROR break continue else if is Extension Singleton key keylen is Extension Subtags buf len if strict status UILLEGALARGUMENTERROR break continue bcp Key key if len 1 ext Buf Capacity uprv memcpy p Ext Buf buf len bcp Value p Ext Buf p Ext Buf len p Ext Buf 0 p Ext Buf ext Buf Capacity len 1 else status UILLEGALARGUMENTERROR break ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR break ext key bcp Key ext value bcp Value if add Extension To List first Ext ext TRUE uprv free ext if strict status UILLEGALARGUMENTERROR break if had Posix ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR goto cleanup ext key POSIXKEY ext value POSIXVALUE if add Extension To List first Ext ext TRUE uprv free ext if USUCCESS status first Ext NULL first Attr NULLU Bool start LDML Extension FALSE for ext first Ext ext ext ext next if start LDML Extension uprv strlen ext key 1 if reslen capacity append At reslen SEP reslen if reslen capacity append At reslen LDMLEXT reslen start LDML Extension TRUE if uprv strcmp ext key LOCALEATTRIBUTEKEY 0 for attr first Attr attr attr attr next if reslen capacity append At reslen SEP reslen len int32 t uprv strlen attr attribute if reslen capacity uprv memcpy append At reslen attr attribute uprv min len capacity reslen reslen len else if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext key if reslen capacity uprv memcpy append At reslen ext key uprv min len capacity reslen reslen len if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext value if reslen capacity uprv memcpy append At reslen ext value uprv min len capacity reslen reslen len cleanup ext first Ext while ext NULL Extension List Entry tmp Ext ext next uprv free ext ext tmp Ext attr first Attr while attr NULL Attribute List Entry tmp Attr attr next char p Value char attr attribute uprv free p Value uprv free attr attr tmp Attr uenum close keyword Enum if UFAILURE status return 0 return u terminate Chars append At capacity reslen status void jpc qmfb split colgrp jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr JPCQMFBCOLGRPSIZE srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr JPCQMFBCOLGRPSIZE if buf splitbuf jas free buf int tmx check pretran sip msg t msg unsigned int chid unsigned int slotid int dsize struct via param vbr str scallid str scseqmet str scseqnum str sftag str svbranch NULL 0 pretran t it if tmx ptran table NULLLMERR pretran hash table not initialized yet n return 1 if get route type REQUESTROUTELMERR invalid usage not in request route n return 1 if msg first line type SIPREQUESTLMERR invalid usage not a sip request n return 1 if parse headers msg HDRFROMFHDRVI A1 FHDRCALLIDFHDRCSEQF 0 0 LMERR failed to parse required headers n return 1 if msg cseq NULL msg cseq parsed NULLLMERR failed to parse cseq headers n return 1 if get cseq msg method id METHODACK get cseq msg method id METHODCANCELLMDBG no pre transaction management for ACK or CANCEL n return 1 if msg via1 0 LMERR failed to get Via header n return 1 if parse from header msg 0 get from msg tag value len 0 LMERR failed to get From header n return 1 if msg callid NULL msg callid body s NULLLMERR failed to parse callid headers n return 1 vbr msg via1 branch scallid msg callid body trim scallid scseqmet get cseq msg method trim scseqmet scseqnum get cseq msg number trim scseqnum sftag get from msg tag value trim sftag chid get hash1 raw msg callid body s msg callid body len slotid chid tmx ptran size 1 if unlikely tmx proc ptran NULL tmx proc ptran pretran t shm malloc sizeof pretran t if tmx proc ptran NULLLMERR not enough memory for pretran structure n return 1 memset tmx proc ptran 0 sizeof pretran t tmx proc ptran pid my pid dsize scallid len scseqnum len scseqmet len sftag len 4 if likely vbr NULL svbranch vbr value trim svbranch dsize svbranch len 1 if dsize 256 dsize 256 tmx pretran unlink if dsize tmx proc ptran dbuf len if tmx proc ptran dbuf s shm free tmx proc ptran dbuf s tmx proc ptran dbuf s char shm malloc dsize if tmx proc ptran dbuf s NULLLMERR not enough memory for pretran data n return 1 tmx proc ptran dbuf len dsize tmx proc ptran hid chid tmx proc ptran cseqmetid get cseq msg method id tmx proc ptran callid s tmx proc ptran dbuf s memcpy tmx proc ptran callid s scallid s scallid len tmx proc ptran callid len scallid len tmx proc ptran callid s tmx proc ptran callid len 0 tmx proc ptran ftag s tmx proc ptran callid s tmx proc ptran callid len 1 memcpy tmx proc ptran ftag s sftag s sftag len tmx proc ptran ftag len sftag len tmx proc ptran ftag s tmx proc ptran ftag len 0 tmx proc ptran cseqnum s tmx proc ptran ftag s tmx proc ptran ftag len 1 memcpy tmx proc ptran cseqnum s scseqnum s scseqnum len tmx proc ptran cseqnum len scseqnum len tmx proc ptran cseqnum s tmx proc ptran cseqnum len 0 tmx proc ptran cseqmet s tmx proc ptran cseqnum s tmx proc ptran cseqnum len 1 memcpy tmx proc ptran cseqmet s scseqmet s scseqmet len tmx proc ptran cseqmet len scseqmet len tmx proc ptran cseqmet s tmx proc ptran cseqmet len 0 if likely vbr NULL tmx proc ptran vbranch s tmx proc ptran cseqmet s tmx proc ptran cseqmet len 1 memcpy tmx proc ptran vbranch s svbranch s svbranch len tmx proc ptran vbranch len svbranch len tmx proc ptran vbranch s tmx proc ptran vbranch len 0 else tmx proc ptran vbranch s NULL tmx proc ptran vbranch len 0 lock get tmx ptran table slotid lock it tmx ptran table slotid plist tmx pretran link safe slotid for it NULL it it next if tmx proc ptran hid it hid tmx proc ptran cseqmetid it cseqmetid tmx proc ptran callid len it callid len tmx proc ptran ftag len it ftag len tmx proc ptran cseqmet len it cseqmet len tmx proc ptran cseqnum len it cseqnum len continue if tmx proc ptran vbranch s NULL it vbranch s NULL if tmx proc ptran vbranch len it vbranch len continue if tmx proc ptran vbranch s it vbranch len 1 it vbranch s it vbranch len 1 continue if memcmp tmx proc ptran vbranch s it vbranch s it vbranch len 0 continue if memcmp tmx proc ptran callid s it callid s it callid len 0 memcmp tmx proc ptran ftag s it ftag s it ftag len 0 memcmp tmx proc ptran cseqnum s it cseqnum s it cseqnum len 0 continue if it cseqmetid METHODOTHER it cseqmetid METHODUNDEF memcmp tmx proc ptran cseqmet s it cseqmet s it cseqmet len 0 continue LMDBG matched another pre transaction by pid d for s n it pid it callid len it callid s lock release tmx ptran table slotid lock return 1 lock release tmx ptran table slotid lock return 0 static int mv refs rt const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 int const motion 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col 1 const motion 1 for i MVREFNEIGHBOURS refmv count i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 if different ref found refmv count for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd return const motion static gboolean logcat read packet struct logcat phdr logcat FILET fh struct wtap pkthdr phdr Buffer buf int err gchar err info gint bytes read gint packet size guint16 payload length guint tmp 2 guint8 pd bytes read file read tmp 2 fh if bytes read 2 err file error fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return FALSE payload length pletoh16 tmp if logcat version 1 packet size 5 4 payload length else if logcat version 2 packet size 6 4 payload length else return FALSE buffer assure space buf packet size pd buffer start ptr buf memcpy pd tmp 2 bytes read file read pd 2 packet size 2 fh if bytes read packet size 2 err file error fh err info if err 0 err WTAPERRSHORTREAD return FALSE phdr rec type RECTYPEPACKET phdr presence flags WTAPHASTS phdr ts secs time t pletoh32 pd 12 phdr ts nsecs int pletoh32 pd 16 phdr caplen packet size phdr len packet size phdr pseudo header logcat version logcat version return static int ac3 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size A C3 Decode Context s avctx priv data int blk ch err ret const uint8 t channel map const float output A C3 MAXCHANNELS if buf size 2 AVR B16 buf 0x770 B int cnt FFMIN buf size A C3 FRAMEBUFFERSIZE 1 s dsp bswap16 buf uint16 t s input buffer const uint16 t buf cnt else memcpy s input buffer buf FFMIN buf size A C3 FRAMEBUFFERSIZE buf s input buffer init get bits s gbc buf buf size 8 err parse frame header s if err switch err case AACA C3 PARSEERRORSYNC av log avctx AVLOGERROR frame sync error n return 1 case AACA C3 PARSEERRORBSID av log avctx AVLOGERROR invalid bitstream id n break case AACA C3 PARSEERRORSAMPLERATE av log avctx AVLOGERROR invalid sample rate n break case AACA C3 PARSEERRORFRAMESIZE av log avctx AVLOGERROR invalid frame size n break case AACA C3 PARSEERRORFRAMETYPE if s frame type EA C3 FRAMETYPEDEPENDENT s substreamid av log avctx AVLOGERROR unsupported frame type skipping frame n got frame ptr 0 return s frame size else av log avctx AVLOGERROR invalid frame type n break default av log avctx AVLOGERROR invalid header n break else if s frame size buf size av log avctx AVLOGERROR incomplete frame n err AACA C3 PARSEERRORFRAMESIZE else if avctx err recognition AVEFCRCCHECK if av crc av crc get table AVCRC 16 ANSI 0 buf 2 s frame size 2 av log avctx AVLOGERROR frame CRC mismatch n err AACA C3 PARSEERRORCRC if err avctx sample rate s sample rate avctx bit rate s bit rate if err s channels s out channels s channels s out channels s channels s output mode s channel mode if s lfe on s output mode A C3 OUTPUTLFEON if avctx request channels 0 avctx request channels 2 avctx request channels s channels s out channels avctx request channels s output mode avctx request channels 1 A C3 CHMODEMONOA C3 CHMODESTEREO s channel layout avpriv ac3 channel layout tab s output mode avctx channels s out channels avctx channel layout s channel layout if s channels s out channels s output mode A C3 OUTPUTLFEON s fbw channels s out channels set downmix coeffs s else if s channels av log avctx AVLOGERROR unable to determine channel mode n return AVERRORINVALIDDATA avctx channels s out channels avctx audio service type s bitstream mode if s bitstream mode 0x7 s channels 1 avctx audio service type AVAUDIOSERVICETYPEKARAOKE frame nb samples s num blocks 256 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret channel map ff ac3 dec channel map s output mode A C3 OUTPUTLFEON s lfe on for ch 0 ch s channels ch if ch s out channels s outptr channel map ch float frame data ch else s outptr ch s output ch output ch s output ch for blk 0 blk s num blocks blk if err decode audio block s blk av log avctx AVLOGERROR error decoding the audio block n err 1 if err for ch 0 ch s out channels ch memcpy s outptr channel map ch output ch 1024 for ch 0 ch s out channels ch output ch s outptr channel map ch s outptr channel map ch A C3 BLOCKSIZE for ch 0 ch s out channels ch memcpy s output ch output ch 1024 got frame ptr 1 return FFMIN buf size s frame size static int archive read format cpio read header struct archive read a struct archive entry entry struct cpio cpio const void h struct archive string conv sconv size t namelength size t name pad int r cpio struct cpio a format data sconv cpio opt sconv if sconv NULL if cpio init default conversion cpio sconv default archive string default conversion for read a archive cpio init default conversion 1 sconv cpio sconv default r cpio read header a cpio entry namelength name pad if r ARCHIVEWARN return r h archive read ahead a namelength name pad NULL if h NULL return ARCHIVEFATAL if archive entry copy pathname l entry const char h namelength sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Pathname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Pathname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN cpio entry offset 0 archive read consume a namelength name pad if archive entry filetype entry AEIFLNK if cpio entry bytes remaining 1024 1024 archive set error a archive ENOMEM Rejecting malformed cpio archive symlink contents exceed 1 megabyte return ARCHIVEFATAL h archive read ahead a size t cpio entry bytes remaining NULL if h NULL return ARCHIVEFATAL if archive entry copy symlink l entry const char h size t cpio entry bytes remaining sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Linkname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Linkname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN archive read consume a cpio entry bytes remaining cpio entry bytes remaining 0 if namelength 11 strcmp const char h TRAILER 0 archive clear error a archive return ARCHIVEEOF if record hardlink a cpio entry ARCHIVEOK return ARCHIVEFATAL return r static void render slice Vp3 Decode Context s int slice int x y i j fragment int16 t block s block int motion x 0xdeadbeef motion y 0xdeadbeef int motion halfpel index uint8 t motion source int plane first pixel if slice s c superblock height return for plane 0 plane 3 plane uint8 t output plane s current frame data plane s data offset plane uint8 t last plane s last frame data plane s data offset plane uint8 t golden plane s golden frame data plane s data offset plane int stride s current frame linesize plane int plane width s width plane s chroma x shift int plane height s height plane s chroma y shift int8 t motion val 2 s motion val plane int sb x sb y slice plane s chroma y shift int slice height sb y 1 plane s chroma y shift int slice width plane s c superblock width s y superblock width int fragment width s fragment width plane int fragment height s fragment height plane int fragment start s fragment start plane int do await plane HAVETHREADS s avctx active thread type FFTHREADFRAME if s flipped image stride stride if CONFIGGRAY plane s avctx flags CODECFLAGGRAY continue for sb y slice height sb y for sb x 0 sb x slice width sb x for j 0 j 16 j x 4 sb x hilbert offset j 0 y 4 sb y hilbert offset j 1 fragment y fragment width x i fragment start fragment if x fragment width y fragment height continue first pixel 8 y stride 8 x if do await s all fragments i coding method MODEINTRA await reference row s s all fragments i motion val fragment 1 16 y s chroma y shift if s all fragments i coding method MODECOPY if s all fragments i coding method MODEUSINGGOLDEN s all fragments i coding method MODEGOLDENMV motion source golden plane else motion source last plane motion source first pixel motion halfpel index 0 if s all fragments i coding method MODEINTRA s all fragments i coding method MODEUSINGGOLDEN int src x src y motion x motion val fragment 0 motion y motion val fragment 1 src x motion x 1 8 x src y motion y 1 8 y motion halfpel index motion x 0x01 motion source motion x 1 motion halfpel index motion y 0x01 1 motion source motion y 1 stride if src x 0 src y 0 src x 9 plane width src y 9 plane height uint8 t temp s edge emu buffer if stride 0 temp 8 stride s vdsp emulated edge mc temp motion source stride 9 9 src x src y plane width plane height motion source temp if s all fragments i coding method MODEINTRA if motion halfpel index 3 s dsp put no rnd pixels tab 1 motion halfpel index output plane first pixel motion source stride 8 else int d motion x motion y 31 s vp3dsp put no rnd pixels l2 output plane first pixel motion source d motion source stride 1 d stride 8 if s all fragments i coding method MODEINTRA int index index vp3 dequant s s all fragments i plane 0 block if index 63 continue s vp3dsp idct put output plane first pixel stride block else int index vp3 dequant s s all fragments i plane 1 block if index 63 continue if index 0 s vp3dsp idct add output plane first pixel stride block else s vp3dsp idct dc add output plane first pixel stride block else s dsp put pixels tab 1 0 output plane first pixel last plane first pixel stride 8 if s skip loop filter apply loop filter s plane 4 sb y sb y FFMIN 4 sb y 3 fragment height 1 vp3 draw horiz band s FFMIN 32 s chroma y shift slice 1 16 s height 16 int get vp9 frame buffer void cb priv size t min size vpx codec frame buffer t fb int i struct External Frame Buffer List const ext fb list struct External Frame Buffer List cb priv if ext fb list NULL return 1 for i 0 i ext fb list num external frame buffers i if ext fb list ext fb i in use break if i ext fb list num external frame buffers return 1 if ext fb list ext fb i size min size free ext fb list ext fb i data ext fb list ext fb i data uint8 t malloc min size if ext fb list ext fb i data return 1 ext fb list ext fb i size min size fb data ext fb list ext fb i data fb size ext fb list ext fb i size ext fb list ext fb i in use 1 fb priv ext fb list ext fb i return 0 void ff vdpau h264 picture complete H264 Context h struct vdpau render state render render struct vdpau render state h cur pic ptr f data 0 assert render render info h264 slice count h slice num if render info h264 slice count 1 return render info h264 is reference h cur pic ptr reference 3 VDPTRUEVDPFALSE render info h264 field pic flag h picture structure PICTFRAME render info h264 bottom field flag h picture structure PICTBOTTOMFIELD render info h264 num ref frames h sps ref frame count render info h264 mb adaptive frame field flag h sps mb aff render info h264 field pic flag render info h264 constrained intra pred flag h pps constrained intra pred render info h264 weighted pred flag h pps weighted pred render info h264 weighted bipred idc h pps weighted bipred idc render info h264 frame mbs only flag h sps frame mbs only flag render info h264 transform 8x8 mode flag h pps transform 8x8 mode render info h264 chroma qp index offset h pps chroma qp index offset 0 render info h264 second chroma qp index offset h pps chroma qp index offset 1 render info h264 pic init qp minus26 h pps init qp 26 render info h264 num ref idx l0 active minus1 h pps ref count 0 1 render info h264 num ref idx l1 active minus1 h pps ref count 1 1 render info h264 log2 max frame num minus4 h sps log2 max frame num 4 render info h264 pic order cnt type h sps poc type render info h264 log2 max pic order cnt lsb minus4 h sps poc type 0 h sps log2 max poc lsb 4 render info h264 delta pic order always zero flag h sps delta pic order always zero flag render info h264 direct 8x8 inference flag h sps direct 8x8 inference flag render info h264 entropy coding mode flag h pps cabac render info h264 pic order present flag h pps pic order present render info h264 deblocking filter control present flag h pps deblocking filter parameters present render info h264 redundant pic cnt present flag h pps redundant pic cnt present memcpy render info h264 scaling lists 4x4 h pps scaling matrix4 sizeof render info h264 scaling lists 4x4 memcpy render info h264 scaling lists 8x8 0 h pps scaling matrix8 0 sizeof render info h264 scaling lists 8x8 0 memcpy render info h264 scaling lists 8x8 1 h pps scaling matrix8 3 sizeof render info h264 scaling lists 8x8 0 ff h264 draw horiz band h 0 h avctx height render bitstream buffers used 0 static MBMODEINFO set offsets V P9 COMMON const cm MACROBLOCKD const xd const Tile Info const tile BLOCKSIZE bsize int mi row int mi col const int bw num 8x8 blocks wide lookup bsize const int bh num 8x8 blocks high lookup bsize const int x mis MIN bw cm mi cols mi col const int y mis MIN bh cm mi rows mi row const int offset mi row cm mi stride mi col int x y xd mi cm mi offset xd mi 0 src mi xd mi 0 xd mi 0 mbmi sb type bsize for y 0 y y mis y for x y x x mis x xd mi y cm mi stride x src mi xd mi 0 set skip context xd mi row mi col set mi row col xd tile mi row bh mi col bw cm mi rows cm mi cols vp9 setup dst planes xd plane get frame new buffer cm mi row mi col return xd mi 0 mbmi static void write ref frames const V P9 COMMON cm const MACROBLOCKD xd vp9 writer w const MBMODEINFO const mbmi xd mi 0 src mi mbmi const int is compound has second ref mbmi const int segment id mbmi segment id if vp9 segfeature active cm seg segment id SEGLVLREFFRAME assert is compound assert mbmi ref frame 0 vp9 get segdata cm seg segment id SEGLVLREFFRAME else if cm reference mode REFERENCEMODESELECT vp9 write w is compound vp9 get reference mode prob cm xd else assert is compound cm reference mode SINGLEREFERENCE if is compound vp9 write w mbmi ref frame 0 GOLDENFRAME vp9 get pred prob comp ref p cm xd else const int bit0 mbmi ref frame 0 LASTFRAME vp9 write w bit0 vp9 get pred prob single ref p1 cm xd if bit0 const int bit1 mbmi ref frame 0 GOLDENFRAME vp9 write w bit1 vp9 get pred prob single ref p2 cm xd static int aura decode frame AV Codec Context avctx void data int got frame AV Packet pkt Aura Decode Context s avctx priv data uint8 t YUV uint8 t val int x y ret const uint8 t buf pkt data const int8 t delta table const int8 t buf 16 if pkt size 48 avctx height avctx width av log avctx AVLOGERROR got a buffer with d bytes when d were expected n pkt size 48 avctx height avctx width return AVERRORINVALIDDATA buf 48 if s frame data 0 avctx release buffer avctx s frame s frame buffer hints FFBUFFERHINTSVALID s frame reference 0 if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret Y s frame data 0 U s frame data 1 V s frame data 2 for y 0 y avctx height y val buf U 0 val 0x F0 Y 0 val 4 val buf V 0 val 0x F0 Y 1 Y 0 delta table val 0x FY 2 UV for x 1 x avctx width 1 x val buf U 0 U 1 delta table val 4 Y 0 Y 1 delta table val 0x F val buf V 0 V 1 delta table val 4 Y 1 Y 0 delta table val 0x FY 2 UVY s frame linesize 0 avctx width U s frame linesize 1 avctx width 1 V s frame linesize 2 avctx width 1 got frame 1 AV Frame data s frame return pkt size static void choose partitioning V P9 COMP cpi const Tile Info const tile int mi row int mi col V P9 COMMON const cm cpi common MACROBLOCK x cpi mb MACROBLOCKD xd cpi mb e mbd int i j k v64x64 vt uint8 t s const uint8 t d int sp int dp int pixels wide 64 pixels high 64 int mv nearest mv near mv const Y V12 BUFFERCONFIG yv12 get ref frame buffer cpi LASTFRAME const struct scale factors const sf cm frame refs LASTFRAME 1 sf vp9 zero vt set offsets cpi tile mi row mi col BLOCK 64 X64 if xd mb to right edge 0 pixels wide xd mb to right edge 3 if xd mb to bottom edge 0 pixels high xd mb to bottom edge 3 s x plane 0 src buf sp x plane 0 src stride if cm frame type KEYFRAME vp9 setup pre planes xd 0 yv12 mi row mi col sf xd mi 0 mbmi ref frame 0 LASTFRAME xd mi 0 mbmi sb type BLOCK 64 X64 vp9 find best ref mvs xd cm allow high precision mv xd mi 0 mbmi ref mvs LASTFRAME nearest mv near mv xd mi 0 mbmi mv 0 nearest mv vp9 build inter predictors sby xd mi row mi col BLOCK 64 X64 d xd plane 0 dst buf dp xd plane 0 dst stride else d V P9 VAROFFS dp 0 for i 0 i 4 i const int x32 idx i 1 5 const int y32 idx i 1 5 for j 0 j 4 j const int x16 idx x32 idx j 1 4 const int y16 idx y32 idx j 1 4 v16x16 vst vt split i split j for k 0 k 4 k int x idx x16 idx k 1 3 int y idx y16 idx k 1 3 unsigned int sse 0 int sum 0 if x idx pixels wide y idx pixels high vp9 get8x8var s y idx sp x idx sp d y idx dp x idx dp sse sum fill variance sse sum 64 vst split k part variances none for i 0 i 4 i for j 0 j 4 j fill variance tree vt split i split j BLOCK 16 X16 fill variance tree vt split i BLOCK 32 X32 fill variance tree vt BLOCK 64 X64 if set vt partitioning cpi vt BLOCK 64 X64 mi row mi col for i 0 i 4 i const int x32 idx i 1 2 const int y32 idx i 1 2 if set vt partitioning cpi vt split i BLOCK 32 X32 mi row y32 idx mi col x32 idx for j 0 j 4 j const int x16 idx j 1 1 const int y16 idx j 1 1 set block size cpi mi row y32 idx y16 idx mi col x32 idx x16 idx BLOCK 16 X16 else for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 static inline picture t ffmpeg New Pict Buf decoder t p dec AV Codec Context p context decoder sys t p sys p dec p sys int width p context coded width int height p context coded height if p sys p va NULL int aligns AVNUMDATAPOINTERS avcodec align dimensions2 p context width height aligns if width 0 height 0 width 8192 height 8192 msg Err p dec Invalid frame size dx d width height return NULL p dec fmt out video i width width p dec fmt out video i height height if width p context width height p context height p dec fmt out video i visible width p context width p dec fmt out video i visible height p context height else p dec fmt out video i visible width width p dec fmt out video i visible height height if p sys p va Get Vlc Chroma p dec fmt out video p context pix fmt p dec fmt out video i chroma VLCCODEC I420 p dec fmt out i codec p dec fmt out video i chroma if p dec fmt in video i sar num 0 p dec fmt in video i sar den 0 p dec fmt out video i sar num p dec fmt in video i sar num p dec fmt out video i sar den p dec fmt in video i sar den else p dec fmt out video i sar num p context sample aspect ratio num p dec fmt out video i sar den p context sample aspect ratio den if p dec fmt out video i sar num p dec fmt out video i sar den p dec fmt out video i sar num 1 p dec fmt out video i sar den 1 if p dec fmt in video i frame rate 0 p dec fmt in video i frame rate base 0 p dec fmt out video i frame rate p dec fmt in video i frame rate p dec fmt out video i frame rate base p dec fmt in video i frame rate base p dec fmt out video i frame rate p context framerate num p dec fmt out video i frame rate base p context framerate den p dec fmt out video i frame rate p context time base den p dec fmt out video i frame rate base p context time base num MAX p context ticks per frame 1 static int ra288 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float out int i ret R A288 Context ractx avctx priv data Get Bit Context gb if buf size avctx block align av log avctx AVLOGERROR Error Input buffer is too small d d n buf size avctx block align return AVERRORINVALIDDATA frame nb samples R A288 BLOCKSIZER A288 BLOCKSPERFRAME if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out float frame data 0 init get bits gb buf avctx block align 8 for i 0 i R A288 BLOCKSPERFRAME i float gain amptable get bits gb 3 int cb coef get bits gb 6 i 1 decode ractx gain cb coef memcpy out ractx sp hist 70 36 R A288 BLOCKSIZE sizeof out out R A288 BLOCKSIZE if i 7 3 backward filter ractx ractx sp hist ractx sp rec syn window ractx sp lpc syn bw tab 36 40 35 70 backward filter ractx ractx gain hist ractx gain rec gain window ractx gain lpc gain bw tab 10 8 20 28 got frame ptr 1 return avctx block align static int do uncompress compress filter context t zfx z stream zs IOBUF a size t ret len int zrc int rc 0 int leave 0 size t n int nread count int refill zs avail in if DBGFILTER log debug begin inflate avail in u avail out u inbuf u n unsigned zs avail in unsigned zs avail out unsigned zfx inbufsize do if zs avail in zfx inbufsize refill n zs avail in if n ifndef riscos zs next in zfx inbuf nread iobuf read a zfx inbuf n count if nread 1 nread 0 n nread if nread count zfx algo 1 zfx algo1hack 4 zfx inbuf n 0x FF zfx algo1hack n leave 1 zs avail in n refill 1 if DBGFILTER log debug enter inflate avail in u avail out u n unsigned zs avail in unsigned zs avail out if zrc ZSTREAMEND rc 1 else if zrc ZOK zrc ZBUFERROR if zs msg log fatal zlib inflate problem s n zs msg else log fatal zlib inflate problem rc d n zrc while zs avail out zrc ZSTREAMEND zrc ZBUFERROR leave ret len zfx outbufsize zs avail out if DBGFILTER log debug do uncompress returning u bytes n unsigned ret len return rc static int asf write packet AV Format Context s AV Packet pkt ASF Context asf s priv data AVIO Context pb s pb ASF Stream stream AV Codec Context codec uint32 t packet number int64 t pts int start sec int flags pkt flags int ret uint64 t offset avio tell pb codec s streams pkt stream index codec stream asf streams pkt stream index if codec codec type AVMEDIATYPEAUDIO flags AVPKTFLAGKEY pts pkt pts AVNOPTSVALUE pkt pts pkt dts av assert0 pts AVNOPTSVALUE if pts PREROLLTIME pts INTMAX 3 10000 LLASFINDEXEDINTERVALPREROLLTIME av log s AVLOGERROR input pts PR Id64 is invalid n pts return AVERROREINVAL pts 10000 asf duration FFMAX asf duration pts pkt duration 10000 packet number asf nb packets put frame s stream s streams pkt stream index pkt dts pkt data pkt size flags start sec int PREROLLTIME 10000 pts ASFINDEXEDINTERVAL 1 ASFINDEXEDINTERVAL if asf is streamed flags AVPKTFLAGKEY uint16 t packet count asf nb packets packet number ret update index s start sec packet number packet count offset if ret 0 return ret asf end sec start sec return 0 static int vc1 decode p mb intfr V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int val int first block 1 int dst idx off int skipped fourmv 0 twomv 0 int block cbp 0 pat block tt 0 int idx mbmode 0 mvbp int stride y fieldtx mquant v pq if v skip is raw skipped get bits1 gb else skipped v s mbskip table mb pos if skipped if v fourmvswitch idx mbmode get vlc2 gb v mbmode vlc table V C1 INTFR 4 MVMBMODEVLCBITS 2 else idx mbmode get vlc2 gb v mbmode vlc table V C1 INTFRNO N4 MVMBMODEVLCBITS 2 switch ff vc1 mbmode intfrp v fourmvswitch idx mbmode 0 case MVPMODEINTFR 4 MV fourmv 1 v blk mv type s block index 0 0 v blk mv type s block index 1 0 v blk mv type s block index 2 0 v blk mv type s block index 3 0 break case MVPMODEINTFR 4 MVFIELD fourmv 1 v blk mv type s block index 0 1 v blk mv type s block index 1 1 v blk mv type s block index 2 1 v blk mv type s block index 3 1 break case MVPMODEINTFR 2 MVFIELD twomv 1 v blk mv type s block index 0 1 v blk mv type s block index 1 1 v blk mv type s block index 2 1 v blk mv type s block index 3 1 break case MVPMODEINTFR 1 MV v blk mv type s block index 0 0 v blk mv type s block index 1 0 v blk mv type s block index 2 0 v blk mv type s block index 3 0 break if ff vc1 mbmode intfrp v fourmvswitch idx mbmode 0 MVPMODEINTFRINTRA s current picture f motion val 1 s block index 0 0 0 s current picture f motion val 1 s block index 0 1 0 s current picture f mb type mb pos MBTYPEINTRA s mb intra v is intra s mb x 1 for i 0 i 6 i v mb type 0 s block index i 1 fieldtx v fieldtx plane mb pos get bits1 gb mb has coeffs get bits1 gb if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 v s ac pred v acpred plane mb pos get bits1 gb GETMQUANT s current picture f qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 v mb type 0 s block index i s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if i 4 stride y s linesize fieldtx off fieldtx i 1 8 i 2 1 s linesize i 1 8 4 i 2 s linesize else stride y s uvlinesize off 0 s dsp put signed pixels clamped s block i s dest dst idx off stride y else mb has coeffs ff vc1 mbmode intfrp v fourmvswitch idx mbmode 3 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if ff vc1 mbmode intfrp v fourmvswitch idx mbmode 0 MVPMODEINTFR 2 MVFIELD v twomvbp get vlc2 gb v twomvbp vlc table V C1 2 MVBLOCKPATTERNVLCBITS 1 else if ff vc1 mbmode intfrp v fourmvswitch idx mbmode 0 MVPMODEINTFR 4 MV ff vc1 mbmode intfrp v fourmvswitch idx mbmode 0 MVPMODEINTFR 4 MVFIELD v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 s mb intra v is intra s mb x 0 for i 0 i 6 i v mb type 0 s block index i 0 fieldtx v fieldtx plane mb pos ff vc1 mbmode intfrp v fourmvswitch idx mbmode 1 dst idx 0 if fourmv mvbp v fourmvbp for i 0 i 6 i if i 4 dmv x dmv y 0 val mvbp 3 i 1 if val get mvdata interlaced v dmv x dmv y 0 vc1 pred mv intfr v i dmv x dmv y 0 v range x v range y v mb type 0 vc1 mc 4mv luma v i 0 else if i 4 vc1 mc 4mv chroma4 v else if twomv mvbp v twomvbp dmv x dmv y 0 if mvbp 2 get mvdata interlaced v dmv x dmv y 0 vc1 pred mv intfr v 0 dmv x dmv y 2 v range x v range y v mb type 0 vc1 mc 4mv luma v 0 0 vc1 mc 4mv luma v 1 0 dmv x dmv y 0 if mvbp 1 get mvdata interlaced v dmv x dmv y 0 vc1 pred mv intfr v 2 dmv x dmv y 2 v range x v range y v mb type 0 vc1 mc 4mv luma v 2 0 vc1 mc 4mv luma v 3 0 vc1 mc 4mv chroma4 v else mvbp ff vc1 mbmode intfrp v fourmvswitch idx mbmode 2 dmv x dmv y 0 if mvbp get mvdata interlaced v dmv x dmv y 0 vc1 pred mv intfr v 0 dmv x dmv y 1 v range x v range y v mb type 0 vc1 mc 1mv v 0 if cbp GETMQUANT s current picture f qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 if fieldtx off i 4 0 i 1 8 i 2 4 s linesize else off i 4 0 i 1 8 i 1 s linesize if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize fieldtx i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 else s mb intra v is intra s mb x 0 for i 0 i 6 i v mb type 0 s block index i 0 s dc val 0 s block index i 0 s current picture f mb type mb pos MBTYPESKIP s current picture f qscale table mb pos 0 v blk mv type s block index 0 0 v blk mv type s block index 1 0 v blk mv type s block index 2 0 v blk mv type s block index 3 0 vc1 pred mv intfr v 0 0 0 1 v range x v range y v mb type 0 vc1 mc 1mv v 0 if s mb x s mb width 1 memmove v is intra base v is intra sizeof v is intra base 0 s mb stride return 0 static int tgq decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Tgq Context s avctx priv data int x y ret int big endian AVR L32 buf 4 0x000 FFFFF if buf size 16 av log avctx AVLOGWARNING truncated header n return AVERRORINVALIDDATA bytestream2 init s gb buf 8 buf size 8 if big endian s width bytestream2 get be16u s gb s height bytestream2 get be16u s gb else s width bytestream2 get le16u s gb s height bytestream2 get le16u s gb if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height if s frame data 0 avctx release buffer avctx s frame tgq calculate qtable s bytestream2 get byteu s gb bytestream2 skip s gb 3 if s frame data 0 s frame key frame 1 s frame pict type AVPICTURETYPEI s frame buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret for y 0 y FFALIGN avctx height 16 4 y for x 0 x FFALIGN avctx width 16 4 x tgq decode mb s y x got frame 1 AV Frame data s frame return avpkt size static int gsm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data int res Get Bit Context gb const uint8 t buf avpkt data int buf size avpkt size int16 t samples if buf size avctx block align av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA frame nb samples avctx frame size if res ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return res samples int16 t frame data 0 switch avctx codec id case AVCODECIDGSM init get bits gb buf buf size 8 if get bits gb 4 0xd av log avctx AVLOGWARNING Missing GSM magic n res gsm decode block avctx samples gb if res 0 return res break case AVCODECIDGSMMS res ff msgsm decode block avctx samples buf if res 0 return res got frame ptr 1 return avctx block align static Asn1 Generic Decode Asn1 Der Set const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node Asn1 Generic child d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SET node data NULL c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL seq index 0 el max size max size d ptr buffer child Decode Asn1 Der Generic d ptr el max size depth seq index errcode node data child return Asn1 Generic node struct login settings login settings read pool t pool const struct ip addr local ip const struct ip addr remote ip const char local name const struct master service ssl settings ssl set r void other settings r struct master service settings input input const char error const struct setting parser context parser void const cache sets void sets unsigned int i count i zero input input roots login set roots input module login binary process name input service login binary protocol input local name local name if local ip NULL input local ip local ip if remote ip NULL input remote ip remote ip if set cache NULL set cache master service settings cache init master service input module input service if master service get service count master service 1 master service settings cache init filter set cache if master service settings cache read set cache input NULL parser error 0 i fatal Error reading configuration s error cache sets master service settings parser get others master service parser for count 0 input roots count NULL count i assert cache sets count NULL sets p new pool void count 1 for i 0 i count i sets i login setting dup pool input roots i cache sets i settings var expand login setting parser info sets 0 pool login set var expand table input ssl set r login setting dup pool master service ssl setting parser info settings parser get list parser 1 other settings r sets 1 return sets 0 void vp9 init second pass V P9 COMP cpi SVC const svc cpi svc const V P9 Encoder Config const oxcf cpi oxcf const int is two pass svc svc number spatial layers 1 svc number temporal layers 1 TWOPASS const twopass is two pass svc svc layer context svc spatial layer id twopass cpi twopass double frame rate FIRSTPASSSTATS stats zero stats twopass total stats zero stats twopass total left stats if twopass stats in end return stats twopass total stats stats twopass stats in end twopass total left stats stats frame rate 10000000 0 stats count stats duration if is two pass svc vp9 update spatial layer framerate cpi frame rate twopass bits left int64 t stats duration svc layer context svc spatial layer id target bandwidth 10000000 0 else vp9 new framerate cpi frame rate twopass bits left int64 t stats duration oxcf target bandwidth 10000000 0 twopass sr update lag 1 const double avg error stats coded error DOUBLEDIVIDECHECK stats count const FIRSTPASSSTATS s twopass stats in double modified error total 0 0 twopass modified error min avg error oxcf two pass vbrmin section 100 twopass modified error max avg error oxcf two pass vbrmax section 100 while s twopass stats in end modified error total calculate modified err twopass oxcf s s twopass modified error left modified error total cpi rc vbr bits off target 0 twopass kf zeromotion pct 100 twopass last kfgroup zeromotion pct 100 static void reset skip tx size V P9 COMMON cm TXSIZE max tx size int mi row mi col const int mis cm mi stride MODEINFO mi ptr cm mi for mi row 0 mi row cm mi rows mi row mi ptr mis for mi col 0 mi col cm mi cols mi col if mi ptr mi col src mi mbmi tx size max tx size mi ptr mi col src mi mbmi tx size max tx size void traverse commit list struct rev info revs show commit fn show commit show object fn show object void data int i struct commit commit struct strbuf base strbuf init base PATHMAX while commit get revision revs NULL if commit tree add pending tree revs commit tree show commit commit data for i 0 i revs pending nr i struct object array entry pending revs pending objects i struct object obj pending item const char name pending name const char path pending path if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN show object obj NULL name data continue if path path if obj type OBJTREE process tree revs struct tree obj show object NULL base path data continue if obj type OBJBLOB process blob revs struct blob obj show object NULL path data continue die unknown pending object s s oid to hex obj oid name object array clear revs pending strbuf release base static void nonrd pick partition V P9 COMP cpi const Tile Info const tile TOKENEXTRA tp int mi row int mi col BLOCKSIZE bsize int rate int64 t dist int do recon int64 t best rd PCTREE pc tree const SPEEDFEATURES const sf cpi sf const V P9 Encoder Config const oxcf cpi oxcf V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const int ms num 8x8 blocks wide lookup bsize 2 TOKENEXTRA tp orig tp PICKMODECONTEXT ctx pc tree none int i BLOCKSIZE subsize bsize int this rate sum rate 0 best rate INTMAX int64 t this dist sum dist 0 best dist IN T64 MAX int64 t sum rd 0 int do split bsize BLOCK 8 X8 int do rect 1 const int force horz split mi row ms cm mi rows const int force vert split mi col ms cm mi cols const int xss x e mbd plane 1 subsampling x const int yss x e mbd plane 1 subsampling y int partition none allowed force horz split force vert split int partition horz allowed force vert split yss xss bsize BLOCK 8 X8 int partition vert allowed force horz split xss yss bsize BLOCK 8 X8 void tp orig assert num 8x8 blocks wide lookup bsize num 8x8 blocks high lookup bsize if sf auto min max partition size partition none allowed bsize sf max partition size bsize sf min partition size partition horz allowed bsize sf max partition size bsize sf min partition size force horz split partition vert allowed bsize sf max partition size bsize sf min partition size force vert split do split bsize sf min partition size if sf use square partition only partition horz allowed force horz split partition vert allowed force vert split if partition none allowed nonrd pick sb modes cpi tile mi row mi col this rate this dist bsize ctx ctx mic mbmi xd mi 0 mbmi ctx skip txfm 0 x skip txfm 0 ctx skip x skip if this rate INTMAX int pl partition plane context xd mi row mi col bsize this rate cpi partition cost pl PARTITIONNONE sum rd RDCOST x rdmult x rddiv this rate this dist if sum rd best rd int64 t stop thresh 4096 int64 t stop thresh rd best rate this rate best dist this dist best rd sum rd if bsize BLOCK 8 X8 pc tree partitioning PARTITIONNONE stop thresh 8 b width log2 bsize b height log2 bsize stop thresh rd RDCOST x rdmult x rddiv 0 stop thresh if x e mbd lossless best rd stop thresh rd do split 0 do rect 0 store pred mv x ctx sum rd 0 if do split int pl partition plane context xd mi row mi col bsize sum rate cpi partition cost pl PARTITIONSPLIT subsize get subsize bsize PARTITIONSPLIT for i 0 i 4 sum rd best rd i const int x idx i 1 ms const int y idx i 1 ms if mi row y idx cm mi rows mi col x idx cm mi cols continue load pred mv x ctx nonrd pick partition cpi tile tp mi row y idx mi col x idx subsize this rate this dist 0 best rd sum rd pc tree split i if this rate INTMAX sum rd IN T64 MAX else sum rate this rate sum dist this dist sum rd RDCOST x rdmult x rddiv sum rate sum dist if sum rd best rd best rate sum rate best dist sum dist best rd sum rd pc tree partitioning PARTITIONSPLIT else if sf less rectangular check do rect partition none allowed if partition horz allowed do rect subsize get subsize bsize PARTITIONHORZ if sf adaptive motion search load pred mv x ctx nonrd pick sb modes cpi tile mi row mi col this rate this dist subsize pc tree horizontal 0 pc tree horizontal 0 mic mbmi xd mi 0 mbmi pc tree horizontal 0 skip txfm 0 x skip txfm 0 pc tree horizontal 0 skip x skip sum rd RDCOST x rdmult x rddiv sum rate sum dist if sum rd best rd mi row ms cm mi rows load pred mv x ctx nonrd pick sb modes cpi tile mi row ms mi col this rate this dist subsize pc tree horizontal 1 pc tree horizontal 1 mic mbmi xd mi 0 mbmi pc tree horizontal 1 skip txfm 0 x skip txfm 0 pc tree horizontal 1 skip x skip if this rate INTMAX sum rd IN T64 MAX else int pl partition plane context xd mi row mi col bsize this rate cpi partition cost pl PARTITIONHORZ sum rate this rate sum dist this dist sum rd RDCOST x rdmult x rddiv sum rate sum dist if sum rd best rd best rd sum rd best rate sum rate best dist sum dist pc tree partitioning PARTITIONHORZ if partition vert allowed do rect subsize get subsize bsize PARTITIONVERT if sf adaptive motion search load pred mv x ctx nonrd pick sb modes cpi tile mi row mi col this rate this dist subsize pc tree vertical 0 pc tree vertical 0 mic mbmi xd mi 0 mbmi pc tree vertical 0 skip txfm 0 x skip txfm 0 pc tree vertical 0 skip x skip sum rd RDCOST x rdmult x rddiv sum rate sum dist if sum rd best rd mi col ms cm mi cols load pred mv x ctx nonrd pick sb modes cpi tile mi row mi col ms this rate this dist subsize pc tree vertical 1 pc tree vertical 1 mic mbmi xd mi 0 mbmi pc tree vertical 1 skip txfm 0 x skip txfm 0 pc tree vertical 1 skip x skip if this rate INTMAX sum rd IN T64 MAX else int pl partition plane context xd mi row mi col bsize this rate cpi partition cost pl PARTITIONVERT sum rate this rate sum dist this dist sum rd RDCOST x rdmult x rddiv sum rate sum dist if sum rd best rd best rate sum rate best dist sum dist best rd sum rd pc tree partitioning PARTITIONVERT void best rd rate best rate dist best dist if best rate INTMAX return subsize get subsize bsize pc tree partitioning fill mode info sb cm x mi row mi col bsize subsize pc tree if best rate INTMAX best dist IN T64 MAX do recon int output enabled bsize BLOCK 64 X64 if oxcf aq mode COMPLEXITYAQ cm seg update map vp9 select in frame q segment cpi mi row mi col output enabled best rate if oxcf aq mode CYCLICREFRESHAQ vp9 cyclic refresh set rate and dist sb cpi cyclic refresh best rate best dist encode sb rt cpi tile tp mi row mi col output enabled bsize pc tree if bsize BLOCK 64 X64 assert tp orig tp assert best rate INTMAX assert best dist IN T64 MAX else assert tp orig tp int vp9 rc regulate q const V P9 COMP cpi int target bits per frame int active best quality int active worst quality const V P9 COMMON const cm cpi common int q active worst quality int last error INTMAX int i target bits per mb const double correction factor get rate correction factor cpi target bits per mb uint64 t target bits per frame BPERMBNORMBITS cm M Bs i active best quality do const int bits per mb at this q int vp9 rc bits per mb cm frame type i correction factor cm bit depth if bits per mb at this q target bits per mb if target bits per mb bits per mb at this q last error q i else q i 1 break else last error bits per mb at this q target bits per mb while i active worst quality return q static void model rd for sb V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum int i int64 t rate sum 0 int64 t dist sum 0 const int ref xd mi 0 src mi mbmi ref frame 0 unsigned int sse unsigned int var 0 unsigned int sum sse 0 const int shift 8 int rate int64 t dist x pred sse ref 0 for i 0 i MAXMBPLANE i struct macroblock plane const p x plane i struct macroblockd plane const pd xd plane i const BLOCKSIZE bs get plane block size bsize pd const TXSIZE max tx size max txsize lookup bs const BLOCKSIZE unit size txsize to bsize max tx size int bw 1 b width log2 lookup bs b width log2 lookup unit size int bh 1 b height log2 lookup bs b width log2 lookup unit size int idx idy int lw b width log2 lookup unit size 2 int lh b height log2 lookup unit size 2 sum sse 0 for idy 0 idy bh idy for idx 0 idx bw idx uint8 t src p src buf idy p src stride lh idx lw uint8 t dst pd dst buf idy pd dst stride lh idx lh int block idx idy 1 idx var cpi fn ptr unit size vf src p src stride dst pd dst stride sse x bsse i 2 block idx sse sum sse sse if x select tx size if x bsse i 2 block idx p quant thred 0 shift x skip txfm i 2 block idx 1 else if var p quant thred 1 shift x skip txfm i 2 block idx 2 else x skip txfm i 2 block idx 0 if i 0 x pred sse ref sse if cpi oxcf speed 4 int64 t rate int64 t dist int64 t square error sse int quantizer pd dequant 1 3 if quantizer 120 rate square error 280 quantizer 8 else rate 0 dist square error quantizer 8 rate sum rate dist sum dist else vp9 model rd from var lapndz sum sse 1 num pels log2 lookup bs pd dequant 1 3 rate dist rate sum rate dist sum dist out rate sum int rate sum out dist sum dist sum 4 Py Object Py String Decode Escape const char s Py ssize t len const char errors Py ssize t unicode const char recode encoding int c char p buf const char end Py Object v Py ssize t newlen if recode encoding len PYSSIZETMAX 4 Py Err Set String Py Exc Overflow Error string is too large return NULL newlen recode encoding 4 len len v Py String From String And Size char NULL newlen if v NULL return NULL p buf Py String As String v end s len while s end if s non esc ifdef Py USINGUNICODE if recode encoding s 0x80 Py Object u w char r const char t Py ssize t rn t s while t end t 0x80 t u Py Unicode Decode UT F8 s t s errors if u goto failed w Py Unicode As Encoded String u recode encoding errors Py DECREF u if w goto failed assert Py String Check w r Py String ASSTRING w rn Py String GETSIZE w Py MEMCPY p r rn p rn Py DECREF w s t else p s s if s end Py Err Set String Py Exc Value Error Trailing in string goto failed switch s case n break case p break case p break case p break case b p b break case f p 014 break case t p t break case n p n break case r p r break case v p 013 break case a p 007 break case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 c s 1 0 if s end 0 s s 7 c c 3 s 0 if s end 0 s s 7 c c 3 s 0 p c break case x if s 1 end isxdigit Py CHARMASK s 0 isxdigit Py CHARMASK s 1 unsigned int x 0 c Py CHARMASK s s if isdigit c x c 0 else if islower c x 10 c a else x 10 c A x x 4 c Py CHARMASK s s if isdigit c x c 0 else if islower c x 10 c a else x 10 c A p x break if errors strcmp errors strict 0 Py Err Set String Py Exc Value Error invalid x escape goto failed if strcmp errors replace 0 p else if strcmp errors ignore 0 else Py Err Format Py Exc Value Error decoding error unknown error handling code 400s errors goto failed if s end isxdigit Py CHARMASK s 0 s break Py Err Set String Py Exc Value Error Unicode escapes not legal when Unicode disabled goto failed s goto non esc static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t ctable 128 Qpeg Context const a avctx priv data AV Frame const p a pic uint8 t outdata int delta ret const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if avpkt size 0x86 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA bytestream2 init a buffer avpkt data avpkt size if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR reget buffer failed n return ret outdata a pic data 0 bytestream2 skip a buffer 4 bytestream2 get buffer a buffer ctable 128 bytestream2 skip a buffer 1 delta bytestream2 get byte a buffer if delta 0x10 qpeg decode intra a outdata a pic linesize 0 avctx width avctx height else qpeg decode inter a outdata a pic linesize 0 avctx width avctx height delta ctable a refdata if pal a pic palette has changed 1 memcpy a pal pal AVPALETTESIZE memcpy a pic data 1 a pal AVPALETTESIZE if ret av frame ref data a pic 0 return ret got frame 1 return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Prores Context ctx avctx priv data AV Frame picture avctx coded frame const uint8 t buf avpkt data int buf size avpkt size int frame hdr size pic num pic data size if buf size 28 buf size AVR B32 buf AVR B32 buf 4 FRAMEID av log avctx AVLOGERROR invalid frame n return AVERRORINVALIDDATAMOVEDATAPTR 8 frame hdr size decode frame header ctx buf buf size avctx if frame hdr size 0 return AVERRORINVALIDDATAMOVEDATAPTR frame hdr size if picture data 0 avctx release buffer avctx picture picture reference 0 if ff get buffer avctx picture 0 return 1 for pic num 0 ctx picture interlaced frame pic num 1 pic num pic data size decode picture header ctx buf buf size avctx if pic data size 0 return AVERRORINVALIDDATA if decode picture ctx pic num avctx return 1 MOVEDATAPTR pic data size got frame 1 AV Frame data avctx coded frame return avpkt size static void await reference mb row H264 Context const h Picture ref int mb y int ref field ref f reference 1 int ref field picture ref field picture int ref height 16 h mb height ref field picture if HAVETHREADS h avctx active thread type FFTHREADFRAME return ff thread await progress ref f FFMIN 16 mb y ref field picture ref height 1 ref field picture ref field static int svq3 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data SV Q3 Context s avctx priv data H264 Context h s h int buf size avpkt size int ret m i if buf size 0 if s next pic f data 0 h low delay s last frame output ret av frame ref data s next pic f if ret 0 return ret s last frame output 1 got frame 1 return 0 init get bits h gb buf 8 buf size h mb x h mb y h mb xy 0 if svq3 decode slice header avctx return 1 h pict type h slice type if h pict type AVPICTURETYPEBFFSWAP Picture s next pic s last pic av frame unref s cur pic f s cur pic f pict type h pict type s cur pic f key frame h pict type AVPICTURETYPEI ret get buffer avctx s cur pic if ret 0 return ret h cur pic ptr s cur pic av frame unref h cur pic f h cur pic s cur pic ret av frame ref h cur pic f s cur pic f if ret 0 return ret for i 0 i 16 i h block offset i 4 scan8 i scan8 0 7 4 h linesize scan8 i scan8 0 3 h block offset 48 i 4 scan8 i scan8 0 7 8 h linesize scan8 i scan8 0 3 for i 0 i 16 i h block offset 16 i h block offset 32 i 4 scan8 i scan8 0 7 4 h uvlinesize scan8 i scan8 0 3 h block offset 48 16 i h block offset 48 32 i 4 scan8 i scan8 0 7 8 h uvlinesize scan8 i scan8 0 3 if h pict type AVPICTURETYPEI if s last pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s last pic if ret 0 return ret memset s last pic f data 0 0 avctx height s last pic f linesize 0 memset s last pic f data 1 0x80 avctx height 2 s last pic f linesize 1 memset s last pic f data 2 0x80 avctx height 2 s last pic f linesize 2 if h pict type AVPICTURETYPEB s next pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s next pic if ret 0 return ret memset s next pic f data 0 0 avctx height s next pic f linesize 0 memset s next pic f data 1 0x80 avctx height 2 s next pic f linesize 1 memset s next pic f data 2 0x80 avctx height 2 s next pic f linesize 2 if avctx debug FFDEBUGPICTINFO av log h avctx AVLOGDEBUG c hpel d tpel d aqp d qp d slice num 02 X n av get picture type char h pict type s halfpel flag s thirdpel flag s adaptive quant h qscale h slice num if avctx skip frame AVDISCARDNONREF h pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY h pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return 0 if s next p frame damaged if h pict type AVPICTURETYPEB return 0 else s next p frame damaged 0 if h pict type AVPICTURETYPEB h frame num offset h slice num h prev frame num if h frame num offset 0 h frame num offset 256 if h frame num offset 0 h frame num offset h prev frame num offset av log h avctx AVLOGERROR error in B frame picture id n return 1 else h prev frame num h frame num h frame num h slice num h prev frame num offset h frame num h prev frame num if h prev frame num offset 0 h prev frame num offset 256 for m 0 m 2 m int i for i 0 i 4 i int j for j 1 j 4 j h ref cache m scan8 0 8 i j 1 if i 3 h ref cache m scan8 0 8 i j PARTNOTAVAILABLE for h mb y 0 h mb y h mb height h mb y for h mb x 0 h mb x h mb width h mb x unsigned mb type h mb xy h mb x h mb y h mb stride if get bits count h gb 7 h gb size in bits get bits count h gb 7 0 show bits h gb get bits count h gb 7 0 skip bits h gb s next slice index get bits count h gb h gb size in bits 8 buf size if svq3 decode slice header avctx return 1 mb type svq3 get ue golomb h gb if h pict type AVPICTURETYPEI mb type 8 else if h pict type AVPICTURETYPEB mb type 4 mb type 4 if mb type 33 svq3 decode mb s mb type av log h avctx AVLOGERROR error while decoding MB d d n h mb x h mb y return 1 if mb type 0 ff h264 hl decode mb h if h pict type AVPICTURETYPEB h low delay h cur pic mb type h mb x h mb y h mb stride h pict type AVPICTURETYPEP mb type 8 mb type 1 1 ff draw horiz band avctx NULL s cur pic s last pic f data 0 s last pic NULL 16 h mb y 16 h picture structure 0 0 h low delay h mb height 16 h mb width 16 if h pict type AVPICTURETYPEB h low delay ret av frame ref data s cur pic f else if s last pic f data 0 ret av frame ref data s last pic f if ret 0 return ret if s last pic f data 0 h low delay got frame 1 if h pict type AVPICTURETYPEBFFSWAP Picture s cur pic s next pic else av frame unref s cur pic f return buf size static void h245 setup channels packet info pinfo channel info t upcoming channel lcl rtp dyn payload t rtp dyn payload NULL struct srtp info dummy srtp info NULL if upcoming channel lcl return if strcmp upcoming channel lcl data type str t38fax if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 t38 add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num return if upcoming channel lcl rfc2198 0 rtp dyn payload rtp dyn payload new rtp dyn payload insert rtp dyn payload upcoming channel lcl rfc2198 red 8000 if upcoming channel lcl srtp flag dummy srtp info wmem new0 wmem file scope struct srtp info if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 srtp add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num upcoming channel lcl is video rtp dyn payload dummy srtp info if upcoming channel lcl media control addr addr type ATNONE upcoming channel lcl media control addr port 0 rtcp handle srtcp add address pinfo upcoming channel lcl media control addr addr upcoming channel lcl media control addr port 0 H245 pinfo fd num dummy srtp info static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cam Studio Context c avctx priv data AV Frame picture data int ret if buf size 2 av log avctx AVLOGERROR coded frame too small n return AVERRORINVALIDDATA if ret ff get buffer avctx picture 0 0 av log avctx AVLOGERROR get buffer failed n return ret switch buf 0 1 7 case 0 int outlen c decomp size inlen buf size 2 if av lzo1x decode c decomp buf outlen buf 2 inlen av log avctx AVLOGERROR error during lzo decompression n break case 1 if uncompress c decomp buf dlen buf 2 buf size 2 ZOK av log avctx AVLOGERROR error during zlib decompression n break return AVERRORENOSYS default av log avctx AVLOGERROR unknown compression n return AVERRORINVALIDDATA if buf 0 1 picture pict type AVPICTURETYPEI picture key frame 1 switch c bpp case 16 copy frame 16 picture c decomp buf c linelen c height break case 32 copy frame 32 picture c decomp buf c linelen c height break default copy frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height else picture pict type AVPICTURETYPEP picture key frame 0 switch c bpp case 16 add frame 16 picture c decomp buf c linelen c height break case 32 add frame 32 picture c decomp buf c linelen c height break default add frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height got frame 1 return buf size static int qcow2 open Block Driver State bs Q Dict options int flags Error errp BDRV Qcow State s bs opaque unsigned int len i int ret 0 Q Cow Header header Qemu Opts opts Error local err NULL uint64 t ext end uint64 t l1 vm state index const char opt overlap check int overlap check template 0 ret bdrv pread bs file 0 header sizeof header if ret 0 error setg errno errp ret Could not read qcow2 header goto fail be32 to cpus header magic be32 to cpus header version be64 to cpus header backing file offset be32 to cpus header backing file size be64 to cpus header size be32 to cpus header cluster bits be32 to cpus header crypt method be64 to cpus header l1 table offset be32 to cpus header l1 size be64 to cpus header refcount table offset be32 to cpus header refcount table clusters be64 to cpus header snapshots offset be32 to cpus header nb snapshots if header magic QCOWMAGIC error setg errp Image is not in qcow2 format ret EINVAL goto fail if header version 2 header version 3 report unsupported bs errp QCOW version d header version ret ENOTSUP goto fail s qcow version header version if header cluster bits MINCLUSTERBITS header cluster bits MAXCLUSTERBITS error setg errp Unsupported cluster size 2 i header cluster bits ret EINVAL goto fail s cluster bits header cluster bits s cluster size 1 s cluster bits s cluster sectors 1 s cluster bits 9 if header version 2 header incompatible features 0 header compatible features 0 header autoclear features 0 header refcount order 4 header header length 72 else be64 to cpus header incompatible features be64 to cpus header compatible features be64 to cpus header autoclear features be32 to cpus header refcount order be32 to cpus header header length if header header length 104 error setg errp qcow2 header too short ret EINVAL goto fail if header header length s cluster size error setg errp qcow2 header exceeds cluster size ret EINVAL goto fail if header header length sizeof header s unknown header fields size header header length sizeof header s unknown header fields g malloc s unknown header fields size ret bdrv pread bs file sizeof header s unknown header fields s unknown header fields size if ret 0 error setg errno errp ret Could not read unknown qcow2 header fields goto fail if header backing file offset s cluster size error setg errp Invalid backing file offset ret EINVAL goto fail if header backing file offset ext end header backing file offset else ext end 1 header cluster bits s incompatible features header incompatible features s compatible features header compatible features s autoclear features header autoclear features if s incompatible features QCO W2 INCOMPATMASK void feature table NULL qcow2 read extensions bs header header length ext end feature table NULL report unsupported feature bs errp feature table s incompatible features QCO W2 INCOMPATMASK ret ENOTSUP g free feature table goto fail if s incompatible features QCO W2 INCOMPATCORRUPT if flags BDRVORDWR flags BDRVOCHECK error setg errp qcow2 Image is corrupt cannot be opened read write ret EACCES goto fail if header refcount order 4 report unsupported bs errp d bit reference counts 1 header refcount order ret ENOTSUP goto fail s refcount order header refcount order if header crypt method QCOWCRYPTAES error setg errp Unsupported encryption method i header crypt method ret EINVAL goto fail s crypt method header header crypt method if s crypt method header bs encrypted 1 s l2 bits s cluster bits 3 s l2 size 1 s l2 bits bs total sectors header size 512 s csize shift 62 s cluster bits 8 s csize mask 1 s cluster bits 8 1 s cluster offset mask 1 LL s csize shift 1 s refcount table offset header refcount table offset s refcount table size header refcount table clusters s cluster bits 3 if header refcount table clusters qcow2 max refcount clusters s error setg errp Reference count table too large ret EINVAL goto fail ret validate table offset bs s refcount table offset s refcount table size sizeof uint64 t if ret 0 error setg errp Invalid reference count table offset goto fail if header nb snapshots QCOWMAXSNAPSHOTS error setg errp Too many snapshots ret EINVAL goto fail ret validate table offset bs header snapshots offset header nb snapshots sizeof Q Cow Snapshot Header if ret 0 error setg errp Invalid snapshot table offset goto fail s snapshots offset header snapshots offset s nb snapshots header nb snapshots if header l1 size 0x2000000 error setg errp Active L1 table too large ret EFBIG goto fail s l1 size header l1 size l1 vm state index size to l1 s header size if l1 vm state index INTMAX error setg errp Image is too big ret EFBIG goto fail s l1 vm state index l1 vm state index if s l1 size s l1 vm state index error setg errp L1 table is too small ret EINVAL goto fail ret validate table offset bs header l1 table offset header l1 size sizeof uint64 t if ret 0 error setg errp Invalid L1 table offset goto fail s l1 table offset header l1 table offset if s l1 size 0 s l1 table g malloc0 align offset s l1 size sizeof uint64 t 512 ret bdrv pread bs file s l1 table offset s l1 table s l1 size sizeof uint64 t if ret 0 error setg errno errp ret Could not read L1 table goto fail for i 0 i s l1 size i be64 to cpus s l1 table i s l2 table cache qcow2 cache create bs L2 CACHESIZE s refcount block cache qcow2 cache create bs REFCOUNTCACHESIZE s cluster cache g malloc s cluster size s cluster data qemu blockalign bs QCOWMAXCRYPTCLUSTERS s cluster size 512 s cluster cache offset 1 s flags flags ret qcow2 refcount init bs if ret 0 error setg errno errp ret Could not initialize refcount handling goto fail QLISTINIT s cluster allocs QTAILQINIT s discards if qcow2 read extensions bs header header length ext end NULL local err error propagate errp local err ret EINVAL goto fail if header backing file offset 0 len header backing file size if len MIN 1023 s cluster size header backing file offset error setg errp Backing file name too long ret EINVAL goto fail ret bdrv pread bs file header backing file offset bs backing file len if ret 0 error setg errno errp ret Could not read backing file name goto fail bs backing file len 0 ret qcow2 read snapshots bs if ret 0 error setg errno errp ret Could not read snapshots goto fail if bs read only flags BDRVOINCOMING s autoclear features s autoclear features 0 ret qcow2 update header bs if ret 0 error setg errno errp ret Could not update qcow2 header goto fail qemu co mutex init s lock if flags BDRVOCHECKBDRVOINCOMING bs read only s incompatible features QCO W2 INCOMPATDIRTY Bdrv Check Result result 0 ret qcow2 check bs result BDRVFIXERRORS if ret 0 error setg errno errp ret Could not repair dirty image goto fail opts qemu opts create qcow2 runtime opts NULL 0 error abort qemu opts absorb qdict opts options local err if local err error propagate errp local err ret EINVAL goto fail s use lazy refcounts qemu opt get bool opts QCO W2 OPTLAZYREFCOUNTS s compatible features QCO W2 COMPATLAZYREFCOUNTS s discard passthrough QCO W2 DISCARDNEVER false s discard passthrough QCO W2 DISCARDALWAYS true s discard passthrough QCO W2 DISCARDREQUEST qemu opt get bool opts QCO W2 OPTDISCARDREQUEST flags BDRVOUNMAP s discard passthrough QCO W2 DISCARDSNAPSHOT qemu opt get bool opts QCO W2 OPTDISCARDSNAPSHOT true s discard passthrough QCO W2 DISCARDOTHER qemu opt get bool opts QCO W2 OPTDISCARDOTHER false opt overlap check qemu opt get opts overlap check cached if strcmp opt overlap check none overlap check template 0 else if strcmp opt overlap check constant overlap check template QCO W2 OLCONSTANT else if strcmp opt overlap check cached overlap check template QCO W2 OLCACHED else if strcmp opt overlap check all overlap check template QCO W2 OLALL else error setg errp Unsupported value s for qcow2 option overlap check Allowed are either of the following none constant cached all opt overlap check qemu opts del opts ret EINVAL goto fail s overlap check 0 for i 0 i QCO W2 OLMAXBITNR i s overlap check qemu opt get bool opts overlap bool option names i overlap check template 1 i i qemu opts del opts if s use lazy refcounts s qcow version 3 error setg errp Lazy refcounts require a qcow2 image with at least qemu 1 1 compatibility level ret EINVAL goto fail Bdrv Check Result result 0 qcow2 check refcounts bs result 0 static int rc pick q and bounds one pass cbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc int active best quality int active worst quality calc active worst quality one pass cbr cpi int q int rtc minq ASSIGNMINQTABLE cm bit depth rtc minq if frame is intra only cm active best quality rc best quality if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else if cm current video frame 0 double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi use svc cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality active best quality get gf active quality rc q cm bit depth else if cm current video frame 1 if rc avg frame qindex INTERFRAME active worst quality active best quality rtc minq rc avg frame qindex INTERFRAME else active best quality rtc minq active worst quality else if rc avg frame qindex KEYFRAME active worst quality active best quality rtc minq rc avg frame qindex KEYFRAME else active best quality rtc minq active worst quality active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index static int remote Stream Handle Read struct qemud client client struct qemud client stream stream char buffer size t buffer Len REMOTEMESSAGEPAYLOADMAX int ret VIRDEBUG stream p stream if stream tx return 0 if VIRALLOCN buffer buffer Len 0 return 1 ret vir Stream Recv stream st buffer buffer Len if ret 2 ret 0 else if ret 0 remote error rerr memset rerr 0 sizeof rerr remote Dispatch Error rerr ret remote Serialize Stream Error client rerr stream procedure stream serial else stream tx 0 if ret 0 stream recv EOF 1 ret remote Send Stream Data client stream buffer ret VIRFREE buffer return ret static void qemu kvm cpu thread fn void arg CPU State cpu arg int r qemu mutex lock qemu global mutex qemu thread get self cpu thread cpu thread id qemu get thread id cpu single env cpu env ptr r kvm init vcpu cpu if r 0 fprintf stderr kvm init vcpu failed s n strerror r exit 1 qemu kvm init cpu signals cpu cpu created true qemu cond signal qemu cpu cond while 1 if cpu can run cpu r kvm cpu exec cpu if r EXCPDEBUG cpu handle guest debug cpu qemu kvm wait io event cpu return static int vc1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size n slices 0 i ret V C1 Context v avctx priv data Mpeg Enc Context s v s AV Frame pict data uint8 t buf2 NULL const uint8 t buf start buf int mb height n slices1 struct uint8 t buf Get Bit Context gb int mby start slices NULL tmp if buf size 0 buf size 4 AVR B32 buf V C1 CODEENDOFSEQ if s low delay 0 s next picture ptr if ret av frame ref pict s next picture ptr f 0 return ret s next picture ptr NULL got frame 1 return 0 if s avctx codec capabilities CODECCAPHWACCELVDPAU if v profile PROFILEADVANCED avctx pix fmt AVPIXFMTVDPAUWM V3 else avctx pix fmt AVPIXFMTVDPAUV C1 if avctx codec id AVCODECIDV C1 avctx codec id AVCODECIDV C1 IMAGE int buf size2 0 buf2 av mallocz buf size FFINPUTBUFFERPADDINGSIZE if ISMARKERAVR B32 buf const uint8 t start end next int size next buf for start buf end buf buf size next end start next next find next marker start 4 end size next start 4 if size 0 continue switch AVR B32 start case V C1 CODEFRAME if avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU buf start start buf size2 vc1 unescape buffer start 4 size buf2 break case V C1 CODEFIELD int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices break case V C1 CODEENTRYPOINT buf size2 vc1 unescape buffer start 4 size buf2 init get bits s gb buf2 buf size2 8 ff vc1 decode entry point avctx v s gb break case V C1 CODESLICE int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start get bits slices n slices gb 9 n slices break else if v interlace buf 0 0x C0 0x C0 const uint8 t divider int buf size3 divider find next marker buf buf buf size if divider buf buf size AVR B32 divider V C1 CODEFIELD av log avctx AVLOGERROR Error in WV C1 interlaced frame n goto err else tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer divider 4 buf buf size divider 4 slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices buf size2 vc1 unescape buffer buf divider buf buf2 else buf size2 vc1 unescape buffer buf buf size buf2 init get bits s gb buf2 buf size2 8 else init get bits s gb buf buf size 8 if v res sprite v new sprite get bits1 s gb v two sprites get bits1 s gb if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE if v new sprite avctx width avctx coded width v sprite width avctx height avctx coded height v sprite height else goto image if s context initialized s width avctx coded width s height avctx coded height ff vc1 decode end avctx if s context initialized if ff msmpeg4 decode init avctx 0 ff vc1 decode init alloc tables v 0 goto err s low delay avctx has b frames v res sprite if v profile PROFILEADVANCED s h edge pos avctx coded width s v edge pos avctx coded height if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 goto err s current picture ptr s picture i v pic header flag 0 if v profile PROFILEADVANCED if ff vc1 parse frame header v s gb 1 goto err else if ff vc1 parse frame header adv v s gb 1 goto err if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE s pict type AVPICTURETYPEI av log v s avctx AVLOGERROR Sprite decoder expected I frame n goto err s current picture ptr f repeat pict 0 if v rff s current picture ptr f repeat pict 1 else if v rptfrm s current picture ptr f repeat pict v rptfrm 2 s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable goto err if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL goto end if s next p frame damaged if s pict type AVPICTURETYPEB goto end else s next p frame damaged 0 if ff MPV frame start s avctx 0 goto err s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if CONFIGV C1 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau vc1 decode picture s buf start buf buf size buf start else if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 goto err if avctx hwaccel decode slice avctx buf start buf buf size buf start 0 goto err if avctx hwaccel end frame avctx 0 goto err else ff mpeg er frame start s v bits buf size 8 v end mb x s mb width if v field mode uint8 t tmp 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 tmp 0 v mv f last 0 tmp 1 v mv f last 1 v mv f last 0 v mv f next 0 v mv f last 1 v mv f next 1 v mv f next 0 v mv f 0 v mv f next 1 v mv f 1 v mv f 0 tmp 0 v mv f 1 tmp 1 mb height s mb height v field mode for i 0 i n slices i if i 0 slices i 1 mby start mb height if v field mode 0 av log v s avctx AVLOGERROR Slice d starts beyond picture boundary d d n i slices i 1 mby start mb height continue v second field 1 v blocks off s mb width s mb height 1 v mb off s mb stride s mb height 1 else v second field 0 v blocks off 0 v mb off 0 if i v pic header flag 0 if v field mode i n slices1 2 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Field header damaged n continue else if get bits1 s gb v pic header flag 1 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Slice header damaged n continue s start mb y i 0 0 FFMAX 0 slices i 1 mby start mb height if v field mode v second field s end mb y i n slices mb height FFMIN mb height slices i mby start mb height else s end mb y i n slices1 1 mb height FFMIN mb height slices i mby start mb height ff vc1 decode blocks v if i n slices s gb slices i gb if v field mode v second field 0 if s pict type AVPICTURETYPEB memcpy v mv f base v mv f next base 2 s b8 stride s mb height 2 1 s mb stride s mb height 1 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 av dlog s avctx Consumed i i bits n get bits count s gb s gb size in bits ff er frame end s er ff MPV frame end s if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE image avctx width avctx coded width v output width avctx height avctx coded height v output height if avctx skip frame AVDISCARDNONREF goto end got frame 1 else if s pict type AVPICTURETYPEB s low delay if ret av frame ref pict s current picture ptr f 0 goto err ff print debug info s s current picture ptr else if s last picture ptr NULL if ret av frame ref pict s last picture ptr f 0 goto err ff print debug info s s last picture ptr if s last picture ptr s low delay got frame 1 end av free buf2 for i 0 i n slices i av free slices i buf av free slices return buf size err av free buf2 for i 0 i n slices i av free slices i buf av free slices return 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic data const uint8 t psrc avpkt data uint16 t y u v int aligned width avctx width 47 48 48 int stride aligned width 8 3 if avpkt size stride avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA if ret ff get buffer avctx pic 0 0 return ret y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 pic pict type AVPICTURETYPEI pic key frame 1 val av le2ne32 src a val 0x3 FF b val 10 0x3 FF c val 20 0x3 static VALUE ossl x509name cmp VALUE self VALUE other int result result ossl x509name cmp0 self other if result 0 return IN T2 FIX 1 if result 0 return IN T2 FIX 1 return IN T2 FIX 0 static int tmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt TMV Context tmv avctx priv data const uint8 t src avpkt data uint8 t dst unsigned char cols avctx width 3 unsigned char rows avctx height 3 unsigned x y fg bg c int ret if tmv pic data 0 avctx release buffer avctx tmv pic if ret ff get buffer avctx tmv pic 0 av log avctx AVLOGERROR get buffer failed n return ret if avpkt size 2 char rows char cols av log avctx AVLOGERROR Input buffer too small truncated sample n got frame 0 return AVERRORINVALIDDATA tmv pic pict type AVPICTURETYPEI tmv pic key frame 1 dst tmv pic data 0 tmv pic palette has changed 1 memcpy tmv pic data 1 ff cga palette 16 4 for y 0 y char rows y for x 0 x char cols x c src bg src 4 fg src 0x F ff draw pc font dst x 8 tmv pic linesize 0 ff cga font 8 c fg bg dst tmv pic linesize 0 8 got frame 1 AV Frame data tmv pic return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Eight Bps Context const c avctx priv data const unsigned char encoded buf unsigned char pixptr pixptr end unsigned int height avctx height unsigned int dlen p row const unsigned char lp dp unsigned char count unsigned int px inc unsigned int planes c planes unsigned char planemap c planemap int ret if c pic data 0 avctx release buffer avctx c pic c pic reference 0 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret dp encoded planes height 1 if planes 4 planes px inc planes avctx pix fmt AVPIXFMTRG B32 for p 0 p planes p lp encoded p height 1 for row 0 row height row pixptr c pic data 0 row c pic linesize 0 planemap p pixptr end pixptr c pic linesize 0 dlen av be2ne16 const unsigned short lp row 2 while dlen 0 if dp 1 buf buf size return AVERRORINVALIDDATA if count dp 127 count dlen count 1 if pixptr count px inc pixptr end break if dp count buf buf size return AVERRORINVALIDDATA while count pixptr dp pixptr px inc else count 257 count if pixptr count px inc pixptr end break while count pixptr dp pixptr px inc dp dlen 2 if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static int remote Stream Handle Write Data struct qemud client client struct qemud client stream stream struct qemud client message msg remote error rerr int ret VIRDEBUG stream p proc d serial d len d offset d stream msg hdr proc msg hdr serial msg buffer Length msg buffer Offset memset rerr 0 sizeof rerr ret vir Stream Send stream st msg buffer msg buffer Offset msg buffer Length msg buffer Offset if ret 0 msg buffer Offset ret if msg buffer Offset msg buffer Length return 1 else if ret 2 return 1 else VIRINF O0 Stream send failed stream closed 1 remote Dispatch Conn Error rerr client conn return remote Serialize Reply Error client rerr msg hdr return 0 static uint dump events for db char db char query buff QUERYLENGTH char db name buff NAMELEN 2 3 name buff NAMELEN 2 3 char event name char delimiter QUERYLENGTHFILE sql file md result file MYSQLRES event res event list res MYSQLROW row event list row char db cl name MYCSNAMESIZE int db cl altered FALSEDBUGENTER dump events for db DBUGPRINT enter db s db mysql real escape string mysql db name buff db ulong strlen db print comment sql file 0 n n Dumping events for database s n n db if lock tables mysql query mysql LOCKTABLES mysql event READ if mysql query with error report mysql event list res show events DBUGRETURN 0 strcpy delimiter if mysql num rows event list res 0 if opt xml fputs t events n sql file else fprintf sql file n if fetch db collation db name buff db cl name sizeof db cl name DBUGRETURN 1 if switch character set results mysql binary DBUGRETURN 1 while event list row mysql fetch row event list res NULL event name quote name event list row 1 name buff 0 DBUGPRINT info retrieving CREATEEVENT for s name buff my snprintf query buff sizeof query buff SHOWCREATEEVENT s event name if mysql query with error report mysql event res query buff DBUGRETURN 1 while row mysql fetch row event res NULL if opt xml print xml row sql file event event res row Create Event continue if strlen row 3 0 char query str if opt drop fprintf sql file s n event name delimiter if create delimiter row 3 delimiter sizeof delimiter NULL fprintf stderr s Warning Can t create delimiter for event s n my progname short event name DBUGRETURN 1 fprintf sql file DELIMITER s n delimiter if mysql num fields event res 7 if switch db collation sql file db name buff delimiter db cl name row 6 db cl altered DBUGRETURN 1 switch cs variables sql file delimiter row 4 row 4 row 5 else fprintf sql file n WARNING old server version The following dump may be incomplete n n switch sql mode sql file delimiter row 1 switch time zone sql file delimiter row 2 query str cover definer clause row 3 strlen row 3 CSTRINGWITHLEN 50117 CSTRINGWITHLEN 50106 CSTRINGWITHLENEVENT fprintf sql file s n const char query str NULL query str row 3 const char delimiter my free query str restore time zone sql file delimiter restore sql mode sql file delimiter if mysql num fields event res 7 restore cs variables sql file delimiter if db cl altered if restore db collation sql file db name buff delimiter db cl name DBUGRETURN 1 mysql free result event res if opt xml fputs t events n sql file check io sql file else fprintf sql file DELIMITER n fprintf sql file n if switch character set results mysql default charset DBUGRETURN 1 mysql free result event list res if lock tables void mysql query with error report mysql 0 UNLOCKTABLESDBUGRETURN 0 static gpgme error t status handler void opaque int fd struct io cb data data struct io cb data opaque engine uiserver t uiserver engine uiserver t data handler value gpgme error t err 0 char line size t linelen do err assuan read line uiserver assuan ctx line linelen if err TRAC E3 DEBUGCTX gpgme status handler uiserver fd 0x x error from assuan d getting status line s fd err gpg strerror err else if linelen 3 line 0 E line 1 R line 2 R line 3 0 line 3 if line 3 err atoi line 4 if err err gpg error GPGERRGENERALTRAC E2 DEBUGCTX gpgme status handler uiserver fd 0x x ERR line mapped to s fd err gpg strerror err ok else if linelen 2 line 0 O line 1 K line 2 0 line 2 if uiserver status fnc err uiserver status fnc uiserver status fnc value GPGMESTATUSEOF if err uiserver colon fnc uiserver colon any uiserver colon any 0 err uiserver colon fnc uiserver colon fnc value NULLTRAC E2 DEBUGCTX gpgme status handler uiserver fd 0x x OK line final status s fd err gpg strerror err ok gpgme io close uiserver status cb fd return err else if linelen 2 line 0 D line 1 uiserver colon fnc char src line 2 char end line linelen char dst char aline uiserver colon attic line int alinelen uiserver colon attic linelen if uiserver colon attic linesize alinelen linelen 1 char newline realloc aline alinelen linelen 1 if newline err gpg error from syserror else aline newline uiserver colon attic linesize alinelen linelen 1 if err dst aline alinelen while err src end if src src 2 end src dst gpgme hextobyte src alinelen src 2 else dst src alinelen if dst n uiserver colon any 1 if alinelen 1 dst 1 r dst dst 0 err uiserver colon fnc uiserver colon fnc value aline if err dst aline alinelen 0 else dst TRAC E2 DEBUGCTX gpgme status handler uiserver fd 0x x D line final status s fd err gpg strerror err ok else if linelen 2 line 0 D line 1 uiserver inline data char src line 2 char end line linelen char dst src gpgme ssize t nwritten linelen 0 while src end if src src 2 end src dst gpgme hextobyte src src 2 else dst src linelen src line 2 while linelen 0 nwritten gpgme data write uiserver inline data src linelen if nwritten nwritten 0 errno EINTR nwritten linelen err gpg error from syserror break src nwritten linelen nwritten TRAC E2 DEBUGCTX gpgme status handler uiserver fd 0x x D inlinedata final status s fd err gpg strerror err ok else if linelen 2 line 0 S line 1 char rest gpgme status code t r rest strchr line 2 if rest rest line linelen else rest 0 r gpgme parse status line 2 if r 0 if uiserver status fnc err uiserver status fnc uiserver status fnc value r rest else fprintf stderr UNKNOWNSTATUS s s line 2 rest TRAC E3 DEBUGCTX gpgme status handler uiserver fd 0x x S line s final status s fd line 2 err gpg strerror err ok else if linelen 7 line 0 I line 1 N line 2 Q line 3 U line 4 I line 5 R line 6 E line 7 0 line 7 char keyword line 7 while keyword keyword default inq cb uiserver keyword assuan write line uiserver assuan ctx END while err assuan pending line uiserver assuan ctx return err static int rv34 set deblock coef R V34 Dec Context r Mpeg Enc Context s r s int hmvmask 0 vmvmask 0 i j int midx s mb x 2 s mb y 2 s b8 stride int16 t motion val 2 s current picture ptr f motion val 0 midx for j 0 j 16 j 8 for i 0 i 2 i if is mv diff gt 3 motion val i 1 vmvmask 0x11 j i 2 if j s mb y is mv diff gt 3 motion val i s b8 stride hmvmask 0x03 j i 2 motion val s b8 stride if s first slice line hmvmask 0x000 F if s mb x vmvmask 0x1111 if r rv30 vmvmask vmvmask 0x4444 1 hmvmask hmvmask 0x0 F00 4 if s mb x r deblock coefs s mb x 1 s mb y s mb stride vmvmask 0x1111 3 if s first slice line r deblock coefs s mb x s mb y 1 s mb stride hmvmask 0x F 12 return hmvmask vmvmask static void vacuum all databases vacuuming Options vacopts bool analyze in stages const char maintenance db const char host const char port const char username enum trivalue prompt password int concurrent Cons const char progname bool echo bool quiet P Gconn conn P Gresult result int stage int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn if analyze in stages for stage 0 stage ANALYZENUMSTAGES stage for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts stage NULL host port username prompt password concurrent Cons progname echo quiet else for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts ANALYZENOSTAGENULL host port username prompt password concurrent Cons progname echo quiet P Qclear result void evsignal dealloc struct event base base int i 0 if base sig ev signal added event del base sig ev signal base sig ev signal added 0 for i 0 i NSIG i if i base sig sh old max base sig sh old i NULL evsignal restore handler base i EVUTILCLOSESOCKET base sig ev signal pair 0 base sig ev signal pair 0 1 EVUTILCLOSESOCKET base sig ev signal pair 1 base sig ev signal pair 1 1 base sig sh old max 0 free base sig sh old static int split field copy Picture dest Picture src int parity int id add int match src reference parity if match COPYPICTURE dest src if parity PICTFRAME pic as field dest parity dest pic id 2 dest pic id id add return match void vp9 init dequantizer V P9 COMMON cm int q for q 0 q QINDEXRANGE q cm y dequant q 0 vp9 dc quant q cm y dc delta q cm y dequant q 1 vp9 ac quant q 0 cm uv dequant q 0 vp9 dc quant q cm uv dc delta q cm uv dequant q 1 vp9 ac quant q cm uv ac delta q static void choose partitioning V P9 COMP cpi const Tile Info const tile int mi row int mi col V P9 COMMON const cm cpi common MACROBLOCK x cpi mb MACROBLOCKD xd cpi mb e mbd int i j k v64x64 vt uint8 t s const uint8 t d int sp int dp int pixels wide 64 pixels high 64 int mv nearest mv near mv const Y V12 BUFFERCONFIG yv12 get ref frame buffer cpi LASTFRAME const struct scale factors const sf cm frame refs LASTFRAME 1 sf vp9 zero vt set offsets cpi tile mi row mi col BLOCK 64 X64 if xd mb to right edge 0 pixels wide xd mb to right edge 3 if xd mb to bottom edge 0 pixels high xd mb to bottom edge 3 s x plane 0 src buf sp x plane 0 src stride if cm frame type KEYFRAME vp9 setup pre planes xd 0 yv12 mi row mi col sf xd mi 0 mbmi ref frame 0 LASTFRAME xd mi 0 mbmi sb type BLOCK 64 X64 vp9 find best ref mvs xd cm allow high precision mv xd mi 0 mbmi ref mvs LASTFRAME nearest mv near mv xd mi 0 mbmi mv 0 nearest mv vp9 build inter predictors sby xd mi row mi col BLOCK 64 X64 d xd plane 0 dst buf dp xd plane 0 dst stride else d V P9 VAROFFS dp 0 for i 0 i 4 i const int x32 idx i 1 5 const int y32 idx i 1 5 for j 0 j 4 j const int x16 idx x32 idx j 1 4 const int y16 idx y32 idx j 1 4 v16x16 vst vt split i split j for k 0 k 4 k int x idx x16 idx k 1 3 int y idx y16 idx k 1 3 unsigned int sse 0 int sum 0 if x idx pixels wide y idx pixels high vp9 get8x8var s y idx sp x idx sp d y idx dp x idx dp sse sum fill variance sse sum 64 vst split k part variances none for i 0 i 4 i for j 0 j 4 j fill variance tree vt split i split j BLOCK 16 X16 fill variance tree vt split i BLOCK 32 X32 fill variance tree vt BLOCK 64 X64 if set vt partitioning cpi vt BLOCK 64 X64 mi row mi col for i 0 i 4 i const int x32 idx i 1 2 const int y32 idx i 1 2 if set vt partitioning cpi vt split i BLOCK 32 X32 mi row y32 idx mi col x32 idx for j 0 j 4 j const int x16 idx j 1 1 const int y16 idx j 1 1 set block size cpi mi row y32 idx y16 idx mi col x32 idx x16 idx BLOCK 16 X16 else for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 static int h261 decode mb skipped H261 Context h int mba1 int mba2 Mpeg Enc Context const s h s int i s mb intra 0 for i mba1 i mba2 i int j xy s mb x h gob number 1 2 11 i 11 s mb y h gob number 1 2 3 i 11 xy s mb x s mb y s mb stride ff init block index s ff update block index s for j 0 j 6 j s block last index j 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture f mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 h mtype MBTYPE H261 FIL ff MPV decode mb s s block return 0 void vp9 encode intra block plane MACROBLOCK x BLOCKSIZE bsize int plane const MACROBLOCKD const xd x e mbd struct encode b args arg x NULL xd mi 0 mbmi skip vp9 foreach transformed block in plane xd bsize plane encode block intra arg static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Anm Context s avctx priv data const int buf size avpkt size uint8 t dst dst end int count ret if ret avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret dst s frame data 0 dst end s frame data 0 s frame linesize 0 avctx height bytestream2 init s gb avpkt data buf size if bytestream2 get byte s gb 0x42 av log ask for sample avctx unknown record type n return buf size if bytestream2 get byte s gb av log ask for sample avctx padding bytes not supported n return buf size bytestream2 skip s gb 2 s x 0 do count type 0x7 F type 7 if count if OP type NULL s gb 1 count break else if type int pixel count bytestream2 get byte s gb pixel bytestream2 get byte s gb if OPNULL pixel count break else int pixel type bytestream2 get le16 s gb count type 0x3 FFF type 14 if count if type 0 break if type 2 av log ask for sample avctx unknown opcode return AVERRORPATCHWELCOME continue pixel type 3 bytestream2 get byte s gb 1 if type 1 count 0x4000 if OP type 2 s gb NULL pixel count break while bytestream2 get bytes left s gb 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size int ff wmv2 decode mb Mpeg Enc Context s int16 t block 6 64 Wmv2 Context const w Wmv2 Context s int cbp code i uint8 t coded val if w j type return 0 if s pict type AVPICTURETYPEP if ISSKIP s current picture mb type s mb y s mb stride s mb x s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 w hshift 0 return 0 code get vlc2 s gb ff mb non intra vlc w cbp table index table MBNONINTRAVLCBITS 3 if code 0 return 1 s mb intra code 0x40 6 cbp code 0x3f else s mb intra 1 code get vlc2 s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if code 0 av log s avctx AVLOGERRORII cbp illegal at d d n s mb x s mb y return 1 cbp 0 for i 0 i 6 i int val code 5 i 1 if i 4 int pred ff msmpeg4 coded block pred s i coded val val val pred coded val val cbp val 5 i if s mb intra int mx my wmv2 pred motion w mx my if cbp s dsp clear blocks s block 0 if s per mb rl table s rl table index decode012 s gb s rl chroma table index s rl table index if w abt flag w per mb abt w per block abt get bits1 s gb if w per block abt w abt type decode012 s gb else w per block abt 0 if wmv2 decode motion w mx my 0 return 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 mx s mv 0 0 1 my for i 0 i 6 i if wmv2 decode inter block w block i i cbp 5 i 1 0 av log s avctx AVLOGERROR nerror while decoding inter block d x d d n s mb x s mb y i return 1 else if s pict type AVPICTURETYPEP av dlog s avctx d d s inter intra pred cbp av dlog s avctx I at d d d 06 X n s mb x s mb y cbp 3 1 0 cbp 0x3 C 2 0 show bits s gb 24 s ac pred get bits1 s gb if s inter intra pred s h263 aic dir get vlc2 s gb ff inter intra vlc table INTERINTRAVLCBITS 1 av dlog s avctx d d d d s ac pred s h263 aic dir s mb x s mb y if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index s dsp clear blocks s block 0 for i 0 i 6 i if ff msmpeg4 decode block s block i i cbp 5 i 1 NULL 0 av log s avctx AVLOGERROR nerror while decoding intra block d x d d n s mb x s mb y i return 1 return 0 static int asf write packet AV Format Context s AV Packet pkt ASF Context asf s priv data AVIO Context pb s pb ASF Stream stream AV Codec Context codec uint32 t packet number int64 t pts int start sec int flags pkt flags int ret uint64 t offset avio tell pb codec s streams pkt stream index codec stream asf streams pkt stream index if codec codec type AVMEDIATYPEAUDIO flags AVPKTFLAGKEY pts pkt pts AVNOPTSVALUE pkt pts pkt dts av assert0 pts AVNOPTSVALUE if pts PREROLLTIME pts INTMAX 3 10000 LLASFINDEXEDINTERVALPREROLLTIME av log s AVLOGERROR input pts PR Id64 is invalid n pts return AVERROREINVAL pts 10000 asf duration FFMAX asf duration pts pkt duration 10000 packet number asf nb packets put frame s stream s streams pkt stream index pkt dts pkt data pkt size flags start sec int PREROLLTIME 10000 pts ASFINDEXEDINTERVAL 1 ASFINDEXEDINTERVAL if asf is streamed flags AVPKTFLAGKEY uint16 t packet count asf nb packets packet number ret update index s start sec packet number packet count offset if ret 0 return ret asf end sec start sec return 0 static void fill vaapi Ref Pic List VA Picture H264 Ref Pic List 32 Picture ref list unsigned int ref count unsigned int i n 0 for i 0 i ref count i if ref list i f reference fill vaapi pic Ref Pic List n ref list i 0 for n 32 n init vaapi pic Ref Pic List n static int mimic decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size int swap buf size buf size MIMICHEADERSIZE Mimic Context ctx avctx priv data Get Byte Context gb int is pframe int width height int quality num coeffs int res if buf size MIMICHEADERSIZE av log avctx AVLOGERROR insufficient data n return AVERRORINVALIDDATA bytestream2 init gb buf MIMICHEADERSIZE bytestream2 skip gb 2 quality bytestream2 get le16u gb width bytestream2 get le16u gb height bytestream2 get le16u gb bytestream2 skip gb 4 is pframe bytestream2 get le32u gb num coeffs bytestream2 get byteu gb bytestream2 skip gb 3 if ctx avctx int i if width 160 height 120 width 320 height 240 av log avctx AVLOGERROR invalid width height n return AVERRORINVALIDDATA ctx avctx avctx avctx width width avctx height height avctx pix fmt AVPIXFMTYU V420 P for i 0 i 3 i ctx num vblocks i height 3 i ctx num hblocks i width 3 i else if width ctx avctx width height ctx avctx height av log missing feature avctx resolution changing 1 return AVERRORPATCHWELCOME if is pframe ctx buf ptrs ctx prev index data 0 av log avctx AVLOGERROR decoding must start with keyframe n return AVERRORINVALIDDATA ctx buf ptrs ctx cur index reference 1 ctx buf ptrs ctx cur index pict type is pframe AVPICTURETYPEPAVPICTURETYPEI if res ff thread get buffer avctx ctx buf ptrs ctx cur index 0 av log avctx AVLOGERROR get buffer failed n return res ctx next prev index ctx cur index ctx next cur index ctx cur index 1 15 prepare avpic ctx ctx flipped ptrs ctx cur index ctx buf ptrs ctx cur index ff thread finish setup avctx av fast padded malloc ctx swap buf ctx swap buf size swap buf size if ctx swap buf return AVERRORENOMEM ctx dsp bswap buf ctx swap buf const uint32 t buf MIMICHEADERSIZE swap buf size 2 init get bits ctx gb ctx swap buf swap buf size 3 res decode ctx quality num coeffs is pframe ff thread report progress ctx buf ptrs ctx cur index INTMAX 0 if res 0 if avctx active thread type FFTHREADFRAME ff thread release buffer avctx ctx buf ptrs ctx cur index return res AV Frame data ctx buf ptrs ctx cur index got frame 1 ctx prev index ctx next prev index ctx cur index ctx next cur index if ctx buf ptrs ctx cur index data 0 ff thread release buffer avctx ctx buf ptrs ctx cur index return buf size int16 t ff h263 pred motion Mpeg Enc Context s int block int dir int px int py int wrap int16 t ABC mot val 2 static const int off 4 2 1 1 1 wrap s b8 stride mot val s current picture motion val dir s block index block A mot val 1 if s first slice line block 3 if block 0 if s mb x s resync mb x px py 0 else if s mb x 1 s resync mb x s h263 pred C mot val off block wrap if s mb x 0 px C 0 py C 1 else px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else if block 1 if s mb x 1 s resync mb x s h263 pred C mot val off block wrap px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else B mot val wrap C mot val off block wrap if s mb x s resync mb x A 0 A 1 0 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else B mot val wrap C mot val off block wrap px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val static void parse mb skip Wmv2 Context w int mb x mb y Mpeg Enc Context const s w s uint32 t const mb type s current picture ptr mb type w skip type get bits s gb 2 switch w skip type case SKIPTYPENONE for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEMPEG for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEROW for mb y 0 mb y s mb height mb y if get bits1 s gb for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPECOL for mb x 0 mb x s mb width mb x if get bits1 s gb for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break void ff h264 direct ref list init H264 Context const h Picture const ref1 h ref list 1 0 Picture const cur h cur pic ptr int list j field int sidx h picture structure 1 1 int ref1sidx ref1 reference 1 1 for list 0 list 2 list cur ref count sidx list h ref count list for j 0 j h ref count list j cur ref poc sidx list j 4 h ref list list j frame num h ref list list j reference 3 if h picture structure PICTFRAME memcpy cur ref count 1 cur ref count 0 sizeof cur ref count 0 memcpy cur ref poc 1 cur ref poc 0 sizeof cur ref poc 0 cur mbaff FRAMEMBAFF h col fieldoff 0 if h picture structure PICTFRAME int cur poc h cur pic ptr poc int col poc h ref list 1 field poc h col parity FFABS col poc 0 cur poc FFABS col poc 1 cur poc ref1sidx sidx h col parity else if h picture structure h ref list 1 0 reference h ref list 1 0 mbaff h col fieldoff 2 h ref list 1 0 reference 3 if h slice type nos AVPICTURETYPEB h direct spatial mv pred return for list 0 list 2 list fill colmap h h map col to list0 list sidx ref1sidx 0 if FRAMEMBAFF for field 0 field 2 field fill colmap h h map col to list0 field field list field field 1 static inline void vc1 pred b mv V C1 Context v int dmv x 2 int dmv y 2 int direct int mvtype Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int r x r y const uint8 t is intra v mb type 0 r x v range x r y v range y dmv x 0 1 s quarter sample dmv y 0 1 s quarter sample dmv x 1 1 s quarter sample dmv y 1 1 s quarter sample wrap s b8 stride xy s block index 0 if s mb intra s current picture f motion val 0 xy v blocks off 0 s current picture f motion val 0 xy v blocks off 1 s current picture f motion val 1 xy v blocks off 0 s current picture f motion val 1 xy v blocks off 1 0 return if v field mode s mv 0 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 1 s quarter sample s mv 0 0 0 av clip s mv 0 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 0 0 1 av clip s mv 0 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 s mv 1 0 0 av clip s mv 1 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 1 0 1 av clip s mv 1 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 if direct s current picture f motion val 0 xy v blocks off 0 s mv 0 0 0 s current picture f motion val 0 xy v blocks off 1 s mv 0 0 1 s current picture f motion val 1 xy v blocks off 0 s mv 1 0 0 s current picture f motion val 1 xy v blocks off 1 s mv 1 0 1 return if mvtype BMVTYPEFORWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 0 xy 2 A s current picture f motion val 0 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 0 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 0 0 0 px dmv x 0 r x r x 1 1 r x s mv 0 0 1 py dmv y 0 r y r y 1 1 r y if mvtype BMVTYPEBACKWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 1 xy 2 A s current picture f motion val 1 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 1 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 1 0 0 px dmv x 1 r x r x 1 1 r x s mv 1 0 1 py dmv y 1 r y r y 1 1 r y s current picture f motion val 0 xy 0 s mv 0 0 0 s current picture f motion val 0 xy 1 s mv 0 0 1 s current picture f motion val 1 xy 0 s mv 1 0 0 s current picture f motion val 1 xy 1 s mv 1 0 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt T M2 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size 3 AV Frame const p l pic int offset T M2 HEADERSIZE int i t ret uint8 t swbuf swbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if swbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n av free swbuf return ret l dsp bswap buf uint32 t swbuf const uint32 t buf buf size 2 if ret tm2 read header l swbuf 0 av free swbuf return ret for i 0 i T M2 NUMSTREAMS i if offset buf size av free swbuf return AVERRORINVALIDDATA t tm2 read stream l swbuf offset tm2 stream order i buf size offset if t 0 av free swbuf return t offset t p key frame tm2 decode blocks l p if p key frame p pict type AVPICTURETYPEI else p pict type AVPICTURETYPEP l cur l cur got frame 1 ret av frame ref data l pic av free swbuf return ret 0 ret buf size static int ws snd decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int in size out size ret int sample 128 uint8 t samples uint8 t samples end if buf size return 0 if buf size 4 av log avctx AVLOGERROR packet is too small n return AVERROREINVAL out size AVR L16 buf 0 in size AVR L16 buf 2 buf 4 if in size buf size av log avctx AVLOGERROR Frame data is larger than input buffer n return 1 frame nb samples out size if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples frame data 0 samples end samples out size if in size out size memcpy samples buf out size got frame ptr 1 return buf size while samples samples end buf avpkt data buf size int code smp size uint8 t count code buf 6 count buf 0x3 F buf switch code case 0 smp 4 count 1 break case 1 smp 2 count 1 break case 2 smp count 0x20 1 count 1 break default smp count 1 break if samples end samples smp break size code 2 count 0x20 code 3 0 count 1 if buf avpkt data size buf size break switch code case 0 for count count 0 count code buf sample code 0x3 2 sample av clip uint8 sample samples sample sample code 2 0x3 2 sample av clip uint8 sample samples sample sample code 4 0x3 2 sample av clip uint8 sample samples sample sample code 6 2 sample av clip uint8 sample samples sample break case 1 for count count 0 count code buf sample ws adpcm 4bit code 0x F sample av clip uint8 sample samples sample sample ws adpcm 4bit code 4 sample av clip uint8 sample samples sample break case 2 if count 0x20 int8 t t t count t 3 sample t 3 sample av clip uint8 sample samples sample else memcpy samples buf smp samples smp buf smp sample buf 1 break default memset samples sample smp samples smp frame nb samples samples frame data 0 got frame ptr 1 return buf size int jbig2 decode generic mmr Jbig2 Ctx ctx Jbig2 Segment segment const Jbig2 Generic Region Params params const byte data size t size Jbig2 Image image Jbig2 Mmr Ctx mmr const uint32 t rowstride image stride byte dst image data byte ref NULL uint32 t y int code 0 jbig2 decode mmr init mmr image width image height data size for y 0 y image height y memset dst 0 rowstride code jbig2 decode mmr line mmr ref dst if code 0 return code ref dst dst rowstride return code static int g722 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt G722 Context c avctx priv data AV Frame frame data int16 t out buf int j ret const int skip 8 c bits per codeword const int16 t quantizer table low inv quants skip Get Bit Context gb frame nb samples avpkt size 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out buf int16 t frame data 0 init get bits gb avpkt data avpkt size 8 for j 0 j avpkt size j int ilow ihigh rlow rhigh dhigh int xout1 xout2 ihigh get bits gb 2 ilow get bits gb 6 skip skip bits gb skip rlow av clip c band 0 scale factor quantizer table ilow 10 c band 0 s predictor 16384 16383 ff g722 update low predictor c band 0 ilow 2 skip dhigh c band 1 scale factor ff g722 high inv quant ihigh 10 rhigh av clip dhigh c band 1 s predictor 16384 16383 ff g722 update high predictor c band 1 dhigh ihigh c prev samples c prev samples pos rlow rhigh c prev samples c prev samples pos rlow rhigh ff g722 apply qmf c prev samples c prev samples pos 24 xout1 xout2 out buf av clip int16 xout1 11 out buf av clip int16 xout2 11 if c prev samples pos PREVSAMPLESBUFSIZE memmove c prev samples c prev samples c prev samples pos 22 22 sizeof c prev samples 0 c prev samples pos 22 got frame ptr 1 return avpkt size static void hscroll AV Codec Context avctx Ansi Context s avctx priv data int i if s y avctx height s font height s y s font height return i 0 for i avctx height s font height i memcpy s frame data 0 i s frame linesize 0 s frame data 0 i s font height s frame linesize 0 avctx width for i avctx height i memset s frame data 0 i s frame linesize 0 DEFAULTBGCOLOR avctx width static void update state rt V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col int bsize V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg xd mi 0 src mi ctx mic xd mi 0 src mi xd mi 0 if cpi oxcf aq mode CYCLICREFRESHAQ seg enabled vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 vp9 init plane quantizers cpi x if is inter block mbmi vp9 update mv count cm xd if cm interp filter SWITCHABLE const int pred ctx vp9 get pred context switchable interp xd cm counts switchable interp pred ctx mbmi interp filter x skip ctx skip x skip txfm 0 mbmi segment id 0 ctx skip txfm 0 static int mpeg field start Mpeg Enc Context s const uint8 t buf int buf size AV Codec Context avctx s avctx Mpeg1 Context s1 Mpeg1 Context s if s first field s picture structure PICTFRAME if ff MPV frame start s avctx 0 return 1 ff mpeg er frame start s s current picture ptr f repeat pict 0 if s repeat first field if s progressive sequence if s top field first s current picture ptr f repeat pict 4 else s current picture ptr f repeat pict 2 else if s progressive frame s current picture ptr f repeat pict 1 s current picture ptr f pan scan s1 pan scan if HAVETHREADS avctx active thread type FFTHREADFRAME ff thread finish setup avctx else int i if s current picture ptr av log s avctx AVLOGERROR first field missing n return 1 if s avctx hwaccel s avctx slice flags SLICEFLAGALLOWFIELD if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode first field n for i 0 i 4 i s current picture f data i s current picture ptr f data i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture ptr f linesize i if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 return 1 if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration if ff xvmc field start s avctx 0 return 1 return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Zmbv Context const c avctx priv data int zret ZOK int len buf size int hi ver lo ver ret uint8 t tmp if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret c flags buf 0 buf len if c flags ZMBVKEYFRAME hi ver buf 0 lo ver buf 1 c comp buf 2 c fmt buf 3 c bw buf 4 c bh buf 5 c decode intra NULL c decode xor NULL buf 6 len 6 av log avctx AVLOGDEBUG Flags X ver i i comp i fmt i blk ix i n c flags hi ver lo ver c comp c fmt c bw c bh if hi ver 0 lo ver 1 av log ask for sample avctx Unsupported version i i n hi ver lo ver return AVERRORPATCHWELCOME if c bw 0 c bh 0 av log ask for sample avctx Unsupported block size ix i n c bw c bh return AVERRORPATCHWELCOME if c comp 0 c comp 1 av log ask for sample avctx Unsupported compression type i n c comp return AVERRORPATCHWELCOME switch c fmt case ZMBVFMT 8 BPP c bpp 8 c decode intra zmbv decode intra c decode xor zmbv decode xor 8 break case ZMBVFMT 15 BPP case ZMBVFMT 16 BPP c bpp 16 c decode intra zmbv decode intra c decode xor zmbv decode xor 16 break c decode intra zmbv decode intra c decode xor zmbv decode xor 24 break c decode intra zmbv decode intra c decode xor zmbv decode xor 32 break default c decode intra NULL c decode xor NULL av log ask for sample avctx Unsupported for now format i n c fmt return AVERRORPATCHWELCOME zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN tmp av realloc c cur avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c cur tmp tmp av realloc c prev avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c prev tmp c bx c width c bw 1 c bw c by c height c bh 1 c bh if c decode intra NULL av log avctx AVLOGERROR Error Got no format or no keyframe n return AVERRORINVALIDDATA if c comp 0 memcpy c decomp buf buf len c decomp size 1 else c zstream total in c zstream total out 0 c zstream next in buf c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZSYNCFLUSH if zret ZOK zret ZSTREAMEND av log avctx AVLOGERROR inflate error d n zret return AVERRORINVALIDDATA c decomp len c zstream total out if c flags ZMBVKEYFRAME c pic key frame 1 c pic pict type AVPICTURETYPEI c decode intra c else c pic key frame 0 c pic pict type AVPICTURETYPEP if c decomp len c decode xor c uint8 t out src int i j out c pic data 0 src c cur switch c fmt case ZMBVFMT 8 BPP for j 0 j c height j for i 0 i c width i out i 3 0 c pal src 3 0 out i 3 1 c pal src 3 1 out i 3 2 c pal src 3 2 src out c pic linesize 0 break case ZMBVFMT 15 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x7 C00 7 out i 3 1 tmp 0x03 E0 2 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break case ZMBVFMT 16 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x F800 8 out i 3 1 tmp 0x07 E0 3 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break j c height j memcpy out src c width 3 src c width 3 out c pic linesize 0 break j c height j for i 0 i c width i uint32 t tmp AVR L32 src src 4 AVW B24 out i 3 tmp out c pic linesize 0 break default av log avctx AVLOGERROR Cannot handle format i n c fmt FFSWAP uint8 t c cur c prev got frame 1 AV Frame data c pic return buf size kadm5 ret t kadm5 modify principal void server handle kadm5 principal ent t entry long mask int ret ret2 i kadm5 policy ent rec pol krb5 boolean have pol FALSE krb5 db entry kdb krb5 tl data tl data orig osa princ ent rec adb kadm5 server handle t handle server handle CHECKHANDLE server handle krb5 clear error message handle context if mask KAD M5 PRINCIPAL mask KAD M5 LASTPWDCHANGE mask KAD M5 MODTIME mask KAD M5 MODNAME mask KAD M5 MKVNO mask KAD M5 AUXATTRIBUTES mask KAD M5 KEYDATA mask KAD M5 LASTSUCCESS mask KAD M5 LASTFAILED return KAD M5 BADMASK if mask ALLPRINCMASK return KAD M5 BADMASK if mask KAD M5 POLICY mask KAD M5 POLICYCLR return KAD M5 BADMASK if entry kadm5 principal ent t NULL return EINVAL if mask KAD M5 TLDATA tl data orig entry tl data while tl data orig if tl data orig tl data type 256 return KAD M5 BADTLTYPE tl data orig tl data orig tl data next ret kdb get entry handle entry principal kdb adb if ret return ret if mask KAD M5 POLICY ret get policy handle entry policy pol have pol if ret goto done adb aux attributes KAD M5 POLICY if adb policy free adb policy adb policy strdup entry policy if have pol if pol pw max life ret krb5 dbe lookup last pwd change handle context kdb kdb pw expiration if ret goto done kdb pw expiration pol pw max life else kdb pw expiration 0 if mask KAD M5 POLICYCLR adb aux attributes KAD M5 POLICY free adb policy adb policy NULL adb aux attributes KAD M5 POLICY kdb pw expiration 0 if mask KAD M5 ATTRIBUTES kdb attributes entry attributes if mask KAD M5 MAXLIFE kdb max life entry max life if mask KAD M5 PRINCEXPIRETIME kdb expiration entry princ expire time if mask KAD M5 PWEXPIRATION kdb pw expiration entry pw expiration if mask KAD M5 MAXRLIFE kdb max renewable life entry max renewable life if mask KAD M5 KVNO for i 0 i kdb n key data i kdb key data i key data kvno entry kvno if mask KAD M5 TLDATA krb5 tl data tl for tl entry tl data tl tl tl tl data next ret krb5 dbe update tl data handle context kdb tl if ret goto done if mask KAD M5 FAILAUTHCOUNT if entry fail auth count 0 ret KAD M5 BADSERVERPARAMS goto done kdb fail auth count 0 kdb mask mask ret k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPRECOMMIT entry mask if ret goto done ret kdb put entry handle kdb adb if ret goto done void k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPOSTCOMMIT entry mask ret KAD M5 OK done if have pol ret2 kadm5 free policy ent handle lhandle pol ret ret ret ret2 kdb free entry handle kdb adb return ret static void block rd txfm int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct rdcost block args args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi int64 t rd1 rd2 rd if args skip return if is inter block mbmi vp9 encode block intra x plane block plane bsize tx size mbmi skip dist block plane block tx size args else if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args else if x skip txfm plane 2 block tx size 1 2 tran low t const coeff BLOCKOFFSET x plane plane coeff block tran low t const dqcoeff BLOCKOFFSET xd plane plane dqcoeff block vp9 xform quant dc x plane block plane bsize tx size args sse x bsse plane 2 block tx size 1 4 args dist args sse if x plane plane eobs block args dist args sse coeff 0 coeff 0 coeff 0 dqcoeff 0 coeff 0 dqcoeff 0 2 else x plane plane eobs block 0 args sse x bsse plane 2 block tx size 1 4 args dist args sse else vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args rate block plane block plane bsize tx size args rd1 RDCOST x rdmult x rddiv args rate args dist rd2 RDCOST x rdmult x rddiv 0 args sse rd MIN rd1 rd2 if plane 0 x zcoeff blk tx size block x plane plane eobs block rd1 rd2 xd lossless args this rate args rate args this dist args dist args this sse args sse args this rd rd if args this rd args best rd args skip 1 return static int rv10 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg Enc Context s avctx priv data int i AV Frame pict data int slice count const uint8 t slices hdr NULL av dlog avctx frame d size d n avctx frame number buf size if buf size 0 return 0 if avctx slice count slice count buf 1 buf size if slice count buf size 8 slice count av log avctx AVLOGERROR Invalid slice count d n slice count return AVERRORINVALIDDATA slices hdr buf 4 buf 8 slice count buf size 8 slice count else slice count avctx slice count for i 0 i slice count i unsigned offset get slice offset avctx slices hdr i int size size2 if offset buf size return AVERRORINVALIDDATA if i 1 slice count size buf size offset else size get slice offset avctx slices hdr i 1 offset if i 2 slice count size2 buf size offset else size2 get slice offset avctx slices hdr i 2 offset if size 0 size2 0 offset FFMAX size size2 buf size return AVERRORINVALIDDATA if rv10 decode packet avctx buf offset size size2 8 size i if s current picture ptr NULL s mb y s mb height ff er frame end s er ff MPV frame end s if s pict type AVPICTURETYPEB s low delay pict s current picture ptr f else if s last picture ptr NULL pict s last picture ptr f if s last picture ptr s low delay got frame 1 ff print debug info s pict s current picture ptr NULL return avpkt size static bool get variable range Planner Info root Variable Stat Data vardata Oid sortop Datum min Datum max Datum tmin 0 Datum tmax 0 bool have data false int16 typ Len bool typ By Val Oid opfuncoid Datum values int nvalues int i return false int main int argc char argv using std string if argc 2 fprintf stderr One argument the input filename must be provided n return 1 string filename argv 1 string outfilename filename substr 0 filename find last of ttf fprintf stdout Processing s s n filename c str outfilename c str string input woff2 Get File Content filename size t decompressed size woff2 Compute WOF F2 Final Size reinterpret cast const uint8 t input data input size string output decompressed size 0 const bool ok woff2 Convert WOF F2 To TTF reinterpret cast uint8 t output 0 decompressed size reinterpret cast const uint8 t input data input size if ok fprintf stderr Decompression failed n return 1 woff2 Set File Contents outfilename output return 0 static void slurm rpc job will run slurm msg t msg DEFTIMERS int error code SLURMSUCCESS struct job record job ptr NULL job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint16 t port slurm addr t resp addr will run response msg t resp NULL char err msg NULL job submit user msg NULL if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED goto send reply STARTTIMER debug2 Processing RPCREQUESTJOBWILLRUN from uid d uid if is valid will run user job desc msg uid error code ESLURMUSERIDMISSING error Security violation JOBWILLRUNRPC from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTJOBWILLRUN lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if slurm get peer addr msg conn fd resp addr job desc msg resp host xmalloc 16 slurm get ip str resp addr port job desc msg resp host 16 dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job write lock if job desc msg job id NOVAL job desc msg pack job offset NOVAL error code job allocate job desc msg false true resp true uid job ptr err msg msg protocol version else error code job start data job desc msg resp unlock slurmctld job write lock ENDTIME R2 slurm rpc job will run else if errno error code errno else error code SLURMERROR send reply if error code debug2 slurm rpc job will run s slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else if resp slurm msg t response msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg address msg address response msg conn msg conn response msg msg type RESPONSEJOBWILLRUN response msg data resp resp job submit user msg job submit user msg job submit user msg NULL slurm send node msg msg conn fd response msg slurm free will run response msg resp debug2 slurm rpc job will run success s TIMESTR else debug2 slurm rpc job will run success s TIMESTR if job desc msg job id NOVAL slurm send rc msg msg SLURMSUCCESS xfree err msg xfree job submit user msg static VALUE ossl asn1 decode0 unsigned char pp long length long offset int depth int yield long num read unsigned char start p const unsigned char p0 long len 0 inner read 0 off offset hlen int tag tc j VALUE asn1data tag class p pp start p p0 p j AS N1 get object p0 len tag tc length p unsigned char p0 if j 0x80 ossl raise e AS N1 Error NULL if len length ossl raise e AS N1 Error value is too short if tc VAS N1 PRIVATEVAS N1 PRIVATE tag class sym PRIVATE else if tc VAS N1 CONTEXTSPECIFICVAS N1 CONTEXTSPECIFIC tag class sym CONTEXTSPECIFIC else if tc VAS N1 APPLICATIONVAS N1 APPLICATION tag class sym APPLICATION else tag class sym UNIVERSAL hlen p start if yield VALUE arg rb ary new rb ary push arg LON G2 NUM depth rb ary push arg LON G2 NUM offset rb ary push arg LON G2 NUM hlen rb ary push arg LON G2 NUM len rb ary push arg j VAS N1 CONSTRUCTED Qtrue Qfalse rb ary push arg ossl asn1 class2sym tc rb ary push arg IN T2 NUM tag rb yield arg if j VAS N1 CONSTRUCTED pp hlen off hlen asn1data int ossl asn1 decode0 cons pp length len off depth yield j tag tag class inner read inner read hlen else if j 0x01 len 0 ossl raise e AS N1 Error Infinite length for primitive value asn1data int ossl asn1 decode0 prim pp len hlen tag tag class inner read off hlen len if num read num read inner read if len 0 inner read hlen len ossl raise e AS N1 Error Type mismatch Bytes read ld Bytes available ld inner read hlen len offset off return asn1data int ff get qtpalette int codec id AVIO Context pb uint32 t palette int tmp bit depth color table id greyscale i avio seek pb 82 SEEKCUR tmp avio rb16 pb bit depth tmp 0x1 F greyscale tmp 0x20 color table id avio rb16 pb if greyscale codec id AVCODECIDCINEPAK return 0 if bit depth 1 bit depth 2 bit depth 4 bit depth 8 uint32 t color count color start color end uint32 t a r g b if greyscale bit depth 1 color table id int color index color dec color count 1 bit depth color index 255 color dec 256 color count 1 for i 0 i color count i r g b color index palette i 0x FFU 24 r 16 g 8 b color index color dec if color index 0 color index 0 else if color table id const uint8 t color table color count 1 bit depth if bit depth 1 color table ff qt default palette 2 else if bit depth 2 color table ff qt default palette 4 else if bit depth 4 color table ff qt default palette 16 else color table ff qt default palette 256 for i 0 i color count i r color table i 3 0 g color table i 3 1 b color table i 3 2 palette i 0x FFU 24 r 16 g 8 b else color start avio rb32 pb avio rb16 pb color end avio rb16 pb if color start 255 color end 255 for i color start i color end i a avio r8 pb avio r8 pb r avio r8 pb avio r8 pb g avio r8 pb avio r8 pb b avio r8 pb avio r8 pb palette i a 24 r 16 g 8 b return 1 return 0 static void alloc mode context V P9 COMMON cm int num 4x4 blk PICKMODECONTEXT ctx const int num blk num 4x4 blk 4 4 num 4x4 blk const int num pix num blk 4 int i k ctx num 4x4 blk num blk CHECKMEMERROR cm ctx zcoeff blk vpx calloc num 4x4 blk sizeof uint8 t for i 0 i MAXMBPLANE i for k 0 k 3 k CHECKMEMERROR cm ctx coeff i k vpx memalign 16 num pix sizeof ctx coeff i k CHECKMEMERROR cm ctx qcoeff i k vpx memalign 16 num pix sizeof ctx qcoeff i k CHECKMEMERROR cm ctx dqcoeff i k vpx memalign 16 num pix sizeof ctx dqcoeff i k CHECKMEMERROR cm ctx eobs i k vpx memalign 16 num pix sizeof ctx eobs i k ctx coeff pbuf i k ctx coeff i k ctx qcoeff pbuf i k ctx qcoeff i k ctx dqcoeff pbuf i k ctx dqcoeff i k ctx eobs pbuf i k ctx eobs i k void vp9 rd pick intra mode sb V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd struct macroblockd plane const pd xd plane int rate y 0 rate uv 0 rate y tokenonly 0 rate uv tokenonly 0 int y skip 0 uv skip 0 int64 t dist y 0 dist uv 0 tx cache TXMODES 0 TXSIZE max uv tx size x skip encode 0 ctx skip 0 xd mi 0 src mi mbmi ref frame 0 INTRAFRAME if bsize BLOCK 8 X8 if rd pick intra sby mode cpi x rate y rate y tokenonly dist y y skip bsize tx cache best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip bsize max uv tx size else y skip 0 if rd pick intra sub 8x8 y mode cpi x rate y rate y tokenonly dist y best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip BLOCK 8 X8 max uv tx size if y skip uv skip returnrate rate y rate uv rate y tokenonly rate uv tokenonly vp9 cost bit vp9 get skip prob cm xd 1 returndist dist y dist uv vp9 zero ctx tx rd diff else int i returnrate rate y rate uv vp9 cost bit vp9 get skip prob cm xd 0 returndist dist y dist uv if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i if tx cache i IN T64 MAX tx cache cm tx mode IN T64 MAX ctx tx rd diff i tx cache i tx cache cm tx mode else ctx tx rd diff i 0 ctx mic xd mi 0 src mi int main int argc char argv const char globfile one two three NULL char tmpdir 32 struct passwd pw const char cwd int test int fail 0 int i struct test case struct ts if argc 1 command line test argv 1 return 0 cwd getcwd NULL 0 tmpnam tmpdir if mkdir tmpdir SIRWXU chdir tmpdir return 1 else int fd for i 0 globfile i i if fd creat globfile i SIRUSRSIWUSR 1 close fd return 1 if app register atfork register fork NULLNULL 0 printf Failed to register fork handler n return 1 for test 0 test case test retval 1 test if testit test case test fail pw getpwnam root if pw NULL ts retval 0 ts env NULL ts words root ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail ts retval 0 ts env pw pw dir ts words var root x ts flags 0 ts wordc 1 ts wordv 0 x ts ifs IFS if testit ts fail setenv HOME dummy home 1 ts retval 0 ts env NULL ts words foo ts flags 0 ts wordc 2 ts wordv 0 dummy home ts wordv 1 dummy home foo ts ifs IFS if testit ts fail pw getpwuid getuid if pw NULL unsetenv HOME ts retval 0 ts env NULL ts words ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail puts tests completed now cleaning up for i 0 globfile i i remove globfile i if cwd NULL cwd chdir cwd rmdir tmpdir printf tests failed d n fail return fail 0 static void adjust arnr filter V P9 COMP cpi int distance int group boost int arnr frames int arnr strength const V P9 Encoder Config const oxcf cpi oxcf const int frames after arf vp9 lookahead depth cpi lookahead distance 1 int frames fwd cpi oxcf arnr max frames 1 1 int frames bwd int q frames strength if frames fwd frames after arf frames fwd frames after arf if frames fwd distance frames fwd distance frames bwd frames fwd if frames bwd distance frames bwd oxcf arnr max frames 1 0x1 frames frames bwd 1 frames fwd if cpi common current video frame 1 q int vp9 convert qindex to q cpi rc avg frame qindex INTERFRAME else q int vp9 convert qindex to q cpi rc avg frame qindex KEYFRAME if q 16 strength oxcf arnr strength else strength oxcf arnr strength 16 q 2 if strength 0 strength 0 if frames group boost 150 frames group boost 150 frames frames 1 if strength group boost 300 strength group boost 300 if cpi oxcf pass 2 cpi multi arf allowed const GFGROUP const gf group cpi twopass gf group if gf group rf level gf group index GFARFSTD strength 1 arnr frames frames arnr strength strength static int ohci service iso td OHCI State ohci struct ohci ed ed int completion int dir size t len 0 const char str NULL int pid int ret int i USB Device dev USB Endpoint ep struct ohci iso td iso td uint32 t addr uint16 t starting frame int16 t relative frame number int frame count uint32 t start offset next offset end offset 0 uint32 t start addr end addr addr ed head OHCIDPTRMASK if ohci read iso td ohci addr iso td trace usb ohci iso td read failed addr ohci die ohci return 0 starting frame OHCIBM iso td flags TDSF frame count OHCIBM iso td flags TDFC relative frame number USUB ohci frame number starting frame trace usb ohci iso td head ed head OHCIDPTRMASK ed tail OHCIDPTRMASK iso td flags iso td bp iso td next iso td be ohci frame number starting frame frame count relative frame number trace usb ohci iso td head offset iso td offset 0 iso td offset 1 iso td offset 2 iso td offset 3 iso td offset 4 iso td offset 5 iso td offset 6 iso td offset 7 if relative frame number 0 trace usb ohci iso td relative frame number neg relative frame number return 1 else if relative frame number frame count trace usb ohci iso td relative frame number big relative frame number frame count OHCISETBM iso td flags TDCCOHCICCDATAOVERRUN ed head OHCIDPTRMASK ed head iso td next OHCIDPTRMASK iso td next ohci done ohci done addr i OHCIBM iso td flags TDDI if i ohci done count ohci done count i if ohci put iso td ohci addr iso td ohci die ohci return 1 return 0 dir OHCIBM ed flags EDD switch dir case OHCITDDIRIN str in pid USBTOKENIN break case OHCITDDIROUT str out pid USBTOKENOUT break case OHCITDDIRSETUP str setup pid USBTOKENSETUP break default trace usb ohci iso td bad direction dir return 1 if iso td bp iso td be trace usb ohci iso td bad bp be iso td bp iso td be return 1 start offset iso td offset relative frame number next offset iso td offset relative frame number 1 if OHCIBM start offset TDPSWCC 0xe relative frame number frame count OHCIBM next offset TDPSWCC 0xe trace usb ohci iso td bad cc not accessed start offset next offset return 1 if relative frame number frame count start offset next offset trace usb ohci iso td bad cc overrun start offset next offset return 1 if start offset 0x1000 0 start addr iso td bp OHCIPAGEMASK start offset OHCIOFFSETMASK else start addr iso td be OHCIPAGEMASK start offset OHCIOFFSETMASK if relative frame number frame count end offset next offset 1 if end offset 0x1000 0 end addr iso td bp OHCIPAGEMASK end offset OHCIOFFSETMASK else end addr iso td be OHCIPAGEMASK end offset OHCIOFFSETMASK else end addr iso td be if start addr OHCIPAGEMASK end addr OHCIPAGEMASK len end addr OHCIOFFSETMASK 0x1001 start addr OHCIOFFSETMASK else len end addr start addr 1 if len dir OHCITDDIRIN if ohci copy iso td ohci start addr end addr ohci usb buf len DMADIRECTIONTODEVICE ohci die ohci return 1 if completion bool int req relative frame number frame count OHCIBM iso td flags TDDI 0 dev ohci find device ohci OHCIBM ed flags EDFA ep usb ep get dev pid OHCIBM ed flags EDEN usb packet setup ohci usb packet pid ep 0 addr false int req usb packet addbuf ohci usb packet ohci usb buf len usb handle packet dev ohci usb packet if ohci usb packet status USBRETASYNC usb device flush ep queue dev ep return 1 if ohci usb packet status USBRETSUCCESS ret ohci usb packet actual length else ret ohci usb packet status trace usb ohci iso td so start offset end offset start addr end addr str len ret if dir OHCITDDIRIN ret 0 ret len if ohci copy iso td ohci start addr end addr ohci usb buf ret DMADIRECTIONFROMDEVICE ohci die ohci return 1 OHCISETBM iso td offset relative frame number TDPSWCCOHCICCNOERROROHCISETBM iso td offset relative frame number TDPSWSIZE ret else if dir OHCITDDIROUT ret len OHCISETBM iso td offset relative frame number TDPSWCCOHCICCNOERROROHCISETBM iso td offset relative frame number TDPSWSIZE 0 else if ret ssize t len trace usb ohci iso td data overrun ret len OHCISETBM iso td offset relative frame number TDPSWCCOHCICCDATAOVERRUNOHCISETBM iso td offset relative frame number TDPSWSIZE len else if ret 0 trace usb ohci iso td data underrun ret OHCISETBM iso td offset relative frame number TDPSWCCOHCICCDATAUNDERRUN else switch ret case USBRETIOERROR case USBRETNODEVOHCISETBM iso td offset relative frame number TDPSWCCOHCICCDEVICENOTRESPONDINGOHCISETBM iso td offset relative frame number TDPSWSIZE 0 break case USBRETNAK case USBRETSTALL trace usb ohci iso td nak ret OHCISETBM iso td offset relative frame number TDPSWCCOHCICCSTALLOHCISETBM iso td offset relative frame number TDPSWSIZE 0 break default trace usb ohci iso td bad response ret OHCISETBM iso td offset relative frame number TDPSWCCOHCICCUNDEXPETEDPID break if relative frame number frame count OHCISETBM iso td flags TDCCOHCICCNOERROR ed head OHCIDPTRMASK ed head iso td next OHCIDPTRMASK iso td next ohci done ohci done addr i OHCIBM iso td flags TDDI if i ohci done count ohci done count i if ohci put iso td ohci addr iso td ohci die ohci return 1 static void rd auto partition range V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE min block size BLOCKSIZE max block size V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO mi xd mi 0 src mi const int left in image xd left available mi 1 src mi const int above in image xd up available mi xd mi stride src mi const int row8x8 remaining tile mi row end mi row const int col8x8 remaining tile mi col end mi col int bh bw BLOCKSIZE min size BLOCK 4 X4 BLOCKSIZE max size BLOCK 64 X64 int i 0 int bs hist BLOCKSIZES 0 if left in image above in image cm frame type KEYFRAME min size BLOCK 64 X64 max size BLOCK 4 X4 if cm frame type KEYFRAMEMODEINFO prev mi cm prev mip cm mi stride 1 mi row xd mi stride mi col get sb partition size range xd prev mi min size max size bs hist if left in image MODEINFO left sb64 mi mi MIBLOCKSIZE src mi get sb partition size range xd left sb64 mi min size max size bs hist if above in image MODEINFO above sb64 mi mi xd mi stride MIBLOCKSIZE src mi get sb partition size range xd above sb64 mi min size max size bs hist if cpi sf auto min max partition size RELAXEDNEIGHBORINGMINMAX min size min partition size min size max size max partition size max size else if cpi sf auto min max partition size CONSTRAINNEIGHBORINGMINMAX int sum 0 int first moment 0 int second moment 0 int var unnormalized 0 for i 0 i BLOCKSIZES i sum bs hist i first moment bs hist i i second moment bs hist i i i var unnormalized second moment first moment first moment sum if var unnormalized 4 sum int mean first moment sum min size min partition size mean max size max partition size mean else min size min partition size min size max size max partition size max size max size find partition size max size row8x8 remaining col8x8 remaining bh bw min size MIN min size max size if cpi sf use square partition only next square size max size min size min size next square size max size min block size min size max block size max size void vp9 initialize me consts V P9 COMP cpi int qindex case VPXBITS 8 cpi mb sadperbit16 sad per bit16lut 8 qindex cpi mb sadperbit4 sad per bit4lut 8 qindex break case VPXBITS 10 cpi mb sadperbit16 sad per bit16lut 10 qindex cpi mb sadperbit4 sad per bit4lut 10 qindex break case VPXBITS 12 cpi mb sadperbit16 sad per bit16lut 12 qindex cpi mb sadperbit4 sad per bit4lut 12 qindex break default assert 0 bit depth should be VPXBITS 8 VPXBITS 10 or VPXBITS 12 int vp9 get compressed data V P9 COMP cpi unsigned int frame flags size t size uint8 t dest int64 t time stamp int64 t time end int flush const V P9 Encoder Config const oxcf cpi oxcf V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd RATECONTROL const rc cpi rc struct vpx usec timer cmptimer Y V12 BUFFERCONFIG force src buffer NULL struct lookahead entry last source NULL struct lookahead entry source NULLMVREFERENCEFRAME ref frame int arf src index if is two pass svc cpi vpx usec timer start cmptimer vp9 set high precision mv cpi ALTREFHIGHPRECISIONMV cm reset frame context 0 cm refresh frame context 1 cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 arf src index get arf src index cpi if arf src index assert arf src index rc frames to key if source vp9 lookahead peek cpi lookahead arf src index NULL cpi alt ref source source int i for i cpi svc spatial layer id 1 i 0 i if oxcf ss play alternate i cpi gld fb idx cpi svc layer context i alt ref idx break cpi svc layer context cpi svc spatial layer id has alt frame 1 vp9 temporal filter cpi arf src index vp9 extend frame borders cpi alt ref buffer force src buffer cpi alt ref buffer cm show frame 0 cpi refresh alt ref frame 1 cpi refresh golden frame 0 cpi refresh last frame 0 rc is src frame alt ref 0 rc source alt ref pending 0 static my bool get view structure char table char db MYSQLRES table res MYSQLROW row MYSQLFIELD field char result table opt quoted table char table buff NAMELEN 2 3 char table buff2 NAMELEN 2 3 char query QUERYLENGTHFILE sql file md result file DBUGENTER get view structure if opt no create info DBUGRETURN 0 verbose msg Retrieving view structure for table s n table dynstr append checked insert pat opt quoted opt keywords 1 0 opt quoted table quote name table table buff2 0 if switch character set results mysql binary DBUGRETURN 1 my snprintf query sizeof query SHOWCREATETABLE s result table if mysql query with error report mysql table res query switch character set results mysql default charset DBUGRETURN 0 field mysql fetch field direct table res 0 if strcmp field name View 0 mysql free result table res switch character set results mysql default charset verbose msg It s base table skipped n DBUGRETURN 0 if path if sql file open sql file for table table OWRONLY mysql free result table res DBUGRETURN 1 write header sql file db print comment sql file 0 n n Final view structure for view s n n n result table fprintf sql file n opt quoted table if opt drop fprintf sql file n opt quoted table check io sql file my snprintf query sizeof query SELECTCHECKOPTIONDEFINERSECURITYTYPECHARACTERSETCLIENTCOLLATIONCONNECTIONFROM information schema views WHERE table name s AND table schema s table db if mysql query mysql query row mysql fetch row table res fprintf sql file n row 1 check io sql file mysql free result table res else char ptr ulong lengths char search buf 256 replace buf 256 ulong search len replace len DYNAMICSTRING ds view row mysql fetch row table res lengths mysql fetch lengths table res init dynamic string checked ds view row 1 lengths 1 1 1024 mysql free result table res if table res mysql store result mysql row mysql fetch row table res if table res mysql free result table res dynstr free ds view DB error mysql when trying to save the result of SHOWCREATETABLE in ds view DBUGRETURN 1 lengths mysql fetch lengths table res if strcmp row 0 NONE ptr search buf search len ulong strxmov ptr WITH row 0 CHECKOPTION Null S ptr ptr replace buf replace len ulong strxmov ptr n n n n n n n n n n n n n const char row 3 const char row 3 const char row 4 const char ds view str check io sql file mysql free result table res dynstr free ds view if switch character set results mysql default charset DBUGRETURN 1 if sql file md result file fputs n sql file write footer sql file my fclose sql file MYFMYWMEDBUGRETURN 0 static int dissect CPM Connect tvbuff t tvb packet info pinfo proto tree parent tree gboolean in void private data proto item ti proto tree tree gint offset 16 guint len guint32 version struct message data data NULL struct mswsp ct ct NULL ti proto tree add item parent tree hf mswsp msg tvb offset 1 ENCNA tree proto item add subtree ti ett mswsp msg proto item set text ti CPM Connect s in In Out col append str pinfo cinfo COLINFO Connect ti proto tree add item ret uint tree hf mswsp msg Connect Version tvb offset 4 ENCLITTLEENDIAN version ct get create converstation data pinfo if ct data find or create message data ct pinfo 0x C8 in private data if data data content version version offset 4 if in guint32 blob size1 off blob size2 off proto tree pad tree pad tree proto tree add subtree tree tvb offset 0 ett mswsp pad ti Padding proto tree add item tree hf mswsp msg Connect In Client Is Remote tvb offset 4 ENCLITTLEENDIAN offset 4 blob size1 off offset offset 4 offset parse padding tvb offset 8 pad tree paddingcb Blob2 blob size2 off offset offset 4 offset parse padding tvb offset 16 pad tree padding len tvb unicode strsize tvb offset proto tree add item tree hf mswsp msg Connect In Machine Name tvb offset len ENCLITTLEENDIANENCUCS 2 offset len len tvb unicode strsize tvb offset ti proto tree add item tree hf mswsp msg Connect In User Name tvb offset len ENCLITTLEENDIANENCUCS 2 offset len offset parse padding tvb offset 8 pad tree paddingc Prop Sets offset parse Property Set Array tvb offset blob size1 off tree pad tree Prop Sets offset parse padding tvb offset 8 pad tree padding Ext Propset offset parse Property Set Array tvb offset blob size2 off tree pad tree Ext Propset offset parse padding tvb offset 8 pad tree DISSECTORASSERT offset int tvb reported length tvb proto tree move item tree ti proto tree get parent pad tree else return tvb reported length tvb static int bmv aud decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int blocks 0 total blocks i int ret int16 t output samples int scale 2 total blocks buf if buf size total blocks 65 1 av log avctx AVLOGERROR expected d bytes got d n total blocks 65 1 buf size return AVERRORINVALIDDATA frame nb samples total blocks 32 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret output samples int16 t frame data 0 for blocks 0 blocks total blocks blocks uint8 t code buf code code 1 code 7 scale 0 bmv aud mults code 0x F scale 1 bmv aud mults code 4 for i 0 i 32 i output samples av clip int16 scale 0 int8 t buf 5 output samples av clip int16 scale 1 int8 t buf 5 got frame ptr 1 return buf size static int execute code AV Codec Context avctx int c Ansi Context s avctx priv data int ret i width height switch c case A s y FFMAX s y s nb args 0 s args 0 s font height s font height 0 break case B s y FFMIN s y s nb args 0 s args 0 s font height s font height avctx height s font height break case C s x FFMIN s x s nb args 0 s args 0 FONTWIDTHFONTWIDTH avctx width FONTWIDTH break case D s x FFMAX s x s nb args 0 s args 0 FONTWIDTHFONTWIDTH 0 break case H case f s y s nb args 0 av clip s args 0 1 s font height 0 avctx height s font height 0 s x s nb args 1 av clip s args 1 1 FONTWIDTH 0 avctx width FONTWIDTH 0 break case h case l if s nb args 2 s args 0 DEFAULTSCREENMODE switch s args 0 case 0 case 1 case 4 case 5 case 13 case 19 s font ff cga font s font height 8 width 40 3 height 25 3 break case 2 case 3 s font ff vga16 font s font height 16 width 80 3 height 25 4 break case 6 case 14 s font ff cga font s font height 8 width 80 3 height 25 3 break case 7 break case 15 case 16 s font ff cga font s font height 8 width 80 3 height 43 3 break case 17 case 18 s font ff cga font s font height 8 width 80 3 height 60 4 break default av log ask for sample avctx unsupported screen mode n if width avctx width height avctx height if s frame data 0 avctx release buffer avctx s frame avcodec set dimensions avctx width height ret ff get buffer avctx s frame if ret 0 av log avctx AVLOGERROR get buffer failed n return ret s frame pict type AVPICTURETYPEI s frame palette has changed 1 memcpy s frame data 1 ff cga palette 16 4 erase screen avctx else if c l erase screen avctx break case J switch s args 0 case 0 erase line avctx s x avctx width s x if s y avctx height s font height memset s frame data 0 s y s font height s frame linesize 0 DEFAULTBGCOLOR avctx height s y s font height s frame linesize 0 break case 1 erase line avctx 0 s x if s y 0 memset s frame data 0 DEFAULTBGCOLOR s y s frame linesize 0 break case 2 erase screen avctx break case K switch s args 0 case 0 erase line avctx s x avctx width s x break case 1 erase line avctx 0 s x break case 2 erase line avctx 0 avctx width break case m if s nb args 0 s nb args 1 s args 0 0 for i 0 i FFMIN s nb args MAXNBARGS i int m s args i if m 0 s attributes 0 s fg DEFAULTFGCOLOR s bg DEFAULTBGCOLOR else if m 1 m 2 m 4 m 5 m 7 m 8 s attributes 1 m 1 else if m 30 m 38 s fg ansi to cga m 30 else if m 39 s fg ansi to cga DEFAULTFGCOLOR else if m 40 m 47 s bg ansi to cga m 40 else if m 49 s fg ansi to cga DEFAULTBGCOLOR else av log ask for sample avctx unsupported rendition parameter n break case n case R break case s s sx s x s sy s y break case u s x av clip s sx 0 avctx width FONTWIDTH s y av clip s sy 0 avctx height s font height break default av log ask for sample avctx unsupported escape code n break return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic avctx coded frame const uint32 t src const uint32 t avpkt data int aligned width FFALIGN avctx width 64 uint8 t dst line if pic data 0 avctx release buffer avctx pic if avpkt size 4 aligned width avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 dst line pic data 0 for h 0 h avctx height h uint16 t dst uint16 t dst line for w 0 w avctx width w uint32 t pixel av be2ne32 src uint16 t r g b if avctx codec id AVCODECID R210 b pixel 6 g pixel 4 0xffc0 r pixel 14 0xffc0 else b pixel 4 g pixel 6 0xffc0 r pixel 16 0xffc0 dst r r 10 dst g g 10 dst b b 10 src aligned width avctx width dst line pic linesize 0 got frame 1 AV Frame data avctx coded frame return avpkt size static int combined motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv int64 t best rd sofar MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 const int step param cpi sf mv fullpel search step param const int sadpb x sadperbit16 MV mvp full const int ref mbmi ref frame 0 const MV ref mv mbmi ref mvs ref 0 as mv int dis int rate mode const int tmp col min x mv col min const int tmp col max x mv col max const int tmp row min x mv row min const int tmp row max x mv row max int rv 0 int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref if cpi common show frame x pred mv sad ref 3 x pred mv sad LASTFRAME return rv if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv assert x mv best ref index ref 2 if x mv best ref index ref 2 mvp full mbmi ref mvs ref x mv best ref index ref as mv else mvp full x pred mv ref mvp full col 3 mvp full row 3 vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 0 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max mvp full row tmp mv as mv row 8 mvp full col tmp mv as mv col 8 rate mv vp9 mv bit cost mvp full ref mv x nmvjointcost x mvcost MVCOSTWEIGHT rate mode cpi inter mode cost mbmi mode context ref INTEROFFSETNEWMV rv RDCOST x rdmult x rddiv rate mv rate mode 0 best rd sofar if rv cpi find fractional mv step x tmp mv as mv ref mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return rv static void init config struct V P9 COMP cpi V P9 Encoder Config oxcf V P9 COMMON const cm cpi common cpi oxcf oxcf cpi framerate oxcf init framerate cm profile oxcf profile cm bit depth oxcf bit depth cm color space UNKNOWN cm width oxcf width cm height oxcf height vp9 alloc compressor data cpi cpi svc number spatial layers oxcf ss number layers cpi svc number temporal layers oxcf ts number layers if cpi svc number temporal layers 1 cpi oxcf rc mode VPXCBR cpi svc number temporal layers 1 cpi svc number spatial layers 1 cpi oxcf pass 2 vp9 init layer context cpi vp9 change config cpi oxcf cpi static mb pct 0 cpi ref frame flags 0 init buffer indices cpi set tile limits cpi int crypto authenticate and decrypt struct crypto instance instance unsigned char buf int buf len struct crypto config header cch struct crypto config header buf const char guessed str if buf len sizeof struct crypto config header log printf instance log level security Received message is too short ignoring return 1 if cch crypto cipher type CRYPTOCIPHERTYPE 2 3 guessed str NULL if cch crypto cipher type 0x C0 cch crypto hash type 0x70 cch crypto cipher type 0x70 cch crypto hash type 0x C0 guessed str Corosync 3 x else if cch crypto cipher type CRYPTOCIPHERTYPE 2 2 guessed str Corosync 2 2 else if cch crypto cipher type 0x01 guessed str unencrypted Kronosnet else if cch crypto cipher type 0 cch crypto cipher type 5 guessed str unencrypted Corosync 2 0 2 1 1 x Open AIS else guessed str encrypted Kronosnet Corosync 2 0 2 1 1 x Open AIS or unknown log printf instance log level security Unsupported incoming packet probably sent by s Rejecting guessed str return 1 if cch crypto hash type CRYPTOHASHTYPE 2 3 log printf instance log level security Incoming packet has different hash type Rejecting return 1 if authenticate nss 2 3 instance buf buf len 0 return 1 if cch pad0 0 cch pad1 0 log printf instance log level security Incoming packet appears to have features not supported by this version of corosync Rejecting return 1 if decrypt nss 2 3 instance buf buf len 0 return 1 cch NULL memmove buf buf sizeof struct crypto config header buf len return 0 static inline void vc1 pred b mv V C1 Context v int dmv x 2 int dmv y 2 int direct int mvtype Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int r x r y const uint8 t is intra v mb type 0 r x v range x r y v range y dmv x 0 1 s quarter sample dmv y 0 1 s quarter sample dmv x 1 1 s quarter sample dmv y 1 1 s quarter sample wrap s b8 stride xy s block index 0 if s mb intra s current picture f motion val 0 xy v blocks off 0 s current picture f motion val 0 xy v blocks off 1 s current picture f motion val 1 xy v blocks off 0 s current picture f motion val 1 xy v blocks off 1 0 return if v field mode s mv 0 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 1 s quarter sample s mv 0 0 0 av clip s mv 0 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 0 0 1 av clip s mv 0 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 s mv 1 0 0 av clip s mv 1 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 1 0 1 av clip s mv 1 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 if direct s current picture f motion val 0 xy v blocks off 0 s mv 0 0 0 s current picture f motion val 0 xy v blocks off 1 s mv 0 0 1 s current picture f motion val 1 xy v blocks off 0 s mv 1 0 0 s current picture f motion val 1 xy v blocks off 1 s mv 1 0 1 return if mvtype BMVTYPEFORWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 0 xy 2 A s current picture f motion val 0 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 0 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 0 0 0 px dmv x 0 r x r x 1 1 r x s mv 0 0 1 py dmv y 0 r y r y 1 1 r y if mvtype BMVTYPEBACKWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 1 xy 2 A s current picture f motion val 1 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 1 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 1 0 0 px dmv x 1 r x r x 1 1 r x s mv 1 0 1 py dmv y 1 r y r y 1 1 r y s current picture f motion val 0 xy 0 s mv 0 0 0 s current picture f motion val 0 xy 1 s mv 0 0 1 s current picture f motion val 1 xy 0 s mv 1 0 0 s current picture f motion val 1 xy 1 s mv 1 0 1 static int get twopass worst quality const V P9 COMP cpi const FIRSTPASSSTATS stats int section target bandwidth const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf if section target bandwidth 0 return rc worst quality else const int num mbs cpi common M Bs const double section err stats coded error stats count const double err per mb section err num mbs const double speed term 1 0 0 04 oxcf speed const int target norm bits per mb uint64 t section target bandwidth BPERMBNORMBITS num mbs int q int is svc upper layer 0 if is two pass svc cpi cpi svc spatial layer id 0 is svc upper layer 1 for q rc best quality q rc worst quality q const double factor calc correction factor err per mb ERRDIVISOR is svc upper layer SVCFACTORPTLOWFACTORPTLOWFACTORPTHIGH q const int bits per mb vp9 rc bits per mb INTERFRAME q factor speed term if bits per mb target norm bits per mb break if cpi oxcf rc mode VPXCQ q MAX q oxcf cq level return q static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Dxa Dec Context const c avctx priv data uint8 t outptr srcptr tmpptr unsigned long dsize int i j compr ret int stride int orig buf size buf size int pc 0 if buf 0 C buf 1 M buf 2 A buf 3 P int r g b buf 4 for i 0 i 256 i r buf g buf b buf c pal i r 16 g 8 b pc 1 buf size 768 4 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed pc outptr frame data 0 srcptr c decomp buf tmpptr c prev data 0 stride frame linesize 0 if buf 0 N buf 1 U buf 2 L buf 3 L compr 1 else compr buf 4 dsize c dsize if compr 4 compr 1 uncompress c decomp buf dsize buf 9 buf size 9 ZOK av log avctx AVLOGERROR Uncompress failed n return AVERRORUNKNOWN switch compr case 1 frame key frame 0 frame pict type AVPICTURETYPEP if c prev data 0 memcpy frame data 0 c prev data 0 frame linesize 0 avctx height else memset frame data 0 0 frame linesize 0 avctx height frame key frame 1 frame pict type AVPICTURETYPEI break case 2 case 3 case 4 case 5 frame key frame compr 1 frame pict type compr 1 AVPICTURETYPEPAVPICTURETYPEI for j 0 j avctx height j if compr 1 for i 0 i avctx width i outptr i srcptr i tmpptr i tmpptr stride else memcpy outptr srcptr avctx width outptr stride srcptr avctx width break case 12 case 13 frame key frame 0 frame pict type AVPICTURETYPEP decode 13 avctx c frame data 0 frame linesize 0 srcptr c prev data 0 break default av log avctx AVLOGERROR Unknown unsupported compression type d n buf 4 return AVERRORINVALIDDATA av frame unref c prev if ret av frame ref c prev frame 0 return ret got frame 1 return orig buf size static void vp3 decode flush AV Codec Context avctx Vp3 Decode Context s avctx priv data if s golden frame f ff thread release buffer avctx s golden frame if s last frame f ff thread release buffer avctx s last frame if s current frame f ff thread release buffer avctx s current frame static inline int pic is unused Mpeg Enc Context s Picture pic if pic f data 0 NULL return 1 if pic needs realloc pic reference DELAYEDPICREF return 1 return 0 static void loop filter rows mt const Y V12 BUFFERCONFIG const frame buffer V P9 COMMON const cm struct macroblockd plane planes MAXMBPLANE int start int stop int y only V P9 Lf Sync const lf sync int num lf workers const int num planes y only 1 MAXMBPLANE int r c const int sb cols mi cols aligned to sb cm mi cols MIBLOCKSIZELO G2 for r start r stop r num lf workers const int mi row r MIBLOCKSIZELO G2 MODEINFO const mi cm mi grid visible mi row cm mi stride for c 0 c sb cols c const int mi col c MIBLOCKSIZELO G2 LOOPFILTERMASK lfm int plane sync read lf sync r c vp9 setup dst planes planes frame buffer mi row mi col vp9 setup mask cm mi row mi col mi mi col cm mi stride lfm for plane 0 plane num planes plane vp9 filter block plane cm planes plane mi row lfm sync write lf sync r c sb cols void vp9 xform quant dc MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 vp9 fdct32x32 1 src diff coeff diff stride vp9 quantize dc 32x32 coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 16 X16 vp9 fdct16x16 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 8 X8 vp9 fdct8x8 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break default assert 0 break static int amrwb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMRWB Context ctx avctx priv data AV Frame frame data AMRWB Frame cf ctx frame const uint8 t buf avpkt data int buf size avpkt size int expected fr size header size float buf out float spare vector AMRWBSFRSIZE float fixed gain factor float synth fixed vector float synth fixed gain float voice fac stab fac float synth exc AMRWBSFRSIZE float hb exc AMRWBSFRSIZE 16k float hb samples AMRWBSFRSIZE 16k float hb gain int sub i ret frame nb samples 4 AMRWBSFRSIZE 16k if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 header size decode mime header ctx buf if ctx fr cur mode MODESID av log avctx AVLOGERROR Invalid mode d n ctx fr cur mode return AVERRORINVALIDDATA expected fr size cf sizes wb ctx fr cur mode 7 3 1 if buf size expected fr size av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size got frame ptr 0 return AVERRORINVALIDDATA if ctx fr quality ctx fr cur mode MODESID av log avctx AVLOGERROR Encountered a bad or corrupted frame n if ctx fr cur mode MODESID av log missing feature avctx SID mode 1 return AVERRORPATCHWELCOME ff amr bit reorder uint16 t ctx frame sizeof AMRWB Frame buf header size amr bit orderings by mode ctx fr cur mode if ctx fr cur mode MODE 6k60 decode isf indices 36b cf isp id ctx isf cur else decode isf indices 46b cf isp id ctx isf cur isf add mean and past ctx isf cur ctx isf q past ff set min dist lsf ctx isf cur MINISFSPACINGLPORDER 1 stab fac stability factor ctx isf cur ctx isf past final ctx isf cur LPORDER 1 2 0 ff acelp lsf2lspd ctx isp 3 ctx isf cur LPORDER if ctx first frame ctx first frame 0 memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof double interpolate isp ctx isp ctx isp sub4 past for sub 0 sub 4 sub ff amrwb lsp2lpc ctx isp sub ctx lp coef sub LPORDER for sub 0 sub 4 sub const AMRWB Sub Frame cur subframe cf subframe sub float sub buf buf out sub AMRWBSFRSIZE 16k decode pitch vector ctx cur subframe sub decode fixed vector ctx fixed vector cur subframe pul ih cur subframe pul il ctx fr cur mode pitch sharpening ctx ctx fixed vector decode gains cur subframe vq gain ctx fr cur mode fixed gain factor ctx pitch gain 0 ctx fixed gain 0 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c ctx fixed vector ctx fixed vector AMRWBSFRSIZEAMRWBSFRSIZE ctx prediction error ENERGYMEAN energy pred fac voice fac voice factor ctx pitch vector ctx pitch gain 0 ctx fixed vector ctx fixed gain 0 ctx tilt coef voice fac 0 25 0 25 for i 0 i AMRWBSFRSIZE i ctx excitation i ctx pitch gain 0 ctx excitation i ctx fixed gain 0 ctx fixed vector i ctx excitation i truncf ctx excitation i synth fixed gain noise enhancer ctx fixed gain 0 ctx prev tr gain voice fac stab fac synth fixed vector anti sparseness ctx ctx fixed vector spare vector pitch enhancer synth fixed vector voice fac synthesis ctx ctx lp coef sub synth exc synth fixed gain synth fixed vector ctx samples az LPORDER de emphasis ctx samples up UPSMEMSIZE ctx samples az LPORDERPREEMPHFAC ctx demph mem ff acelp apply order 2 transfer function ctx samples up UPSMEMSIZE ctx samples up UPSMEMSIZE hpf zeros hpf 31 poles hpf 31 gain ctx hpf 31 mem AMRWBSFRSIZE upsample 5 4 sub buf ctx samples up UPSFIRSIZEAMRWBSFRSIZE 16k ff acelp apply order 2 transfer function hb samples ctx samples up UPSMEMSIZE hpf zeros hpf 400 poles hpf 400 gain ctx hpf 400 mem AMRWBSFRSIZE hb gain find hb gain ctx hb samples cur subframe hb gain cf vad scaled hb excitation ctx hb exc synth exc hb gain hb synthesis ctx sub ctx samples hb LPORDER 16k hb exc ctx isf cur ctx isf past final hb fir filter hb samples bpf 6 7 coef ctx bpf 6 7 mem ctx samples hb LPORDER 16k if ctx fr cur mode MODE 23k85 hb fir filter hb samples lpf 7 coef ctx lpf 7 mem hb samples for i 0 i AMRWBSFRSIZE 16k i sub buf i sub buf i hb samples i 1 0f 1 15 update sub state ctx memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof ctx isp 3 0 memcpy ctx isf past final ctx isf cur LPORDER sizeof float got frame ptr 1 return expected fr size static void txfm rd in plane MACROBLOCK x int rate int64 t distortion int skippable int64 t sse int64 t ref best rd int plane BLOCKSIZE bsize TXSIZE tx size int use fast coef casting MACROBLOCKD const xd x e mbd const struct macroblockd plane const pd xd plane plane struct rdcost block args args vp9 zero args args x x args best rd ref best rd args use fast coef costing use fast coef casting if plane 0 xd mi 0 mbmi tx size tx size vp9 get entropy contexts bsize tx size pd args t above args t left args so get scan xd tx size pd plane type 0 vp9 foreach transformed block in plane xd bsize plane block rd txfm args if args skip rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 else distortion args this dist rate args this rate sse args this sse skippable vp9 is skippable in plane x bsize plane static void rv34 pred mv b R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mb pos s mb x s mb y s mb stride int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 0 C 2 0 int has A 0 has B 0 has C 0 int mx my int i j Picture cur pic s current picture ptr const int mask dir MBTYPE L1 MBTYPE L0 int type cur pic mb type mb pos if r avail cache 6 1 type mask A 0 cur pic motion val dir mv pos 1 0 A 1 cur pic motion val dir mv pos 1 1 has A 1 if r avail cache 6 4 type mask B 0 cur pic motion val dir mv pos s b8 stride 0 B 1 cur pic motion val dir mv pos s b8 stride 1 has B 1 if r avail cache 6 4 r avail cache 6 2 type mask C 0 cur pic motion val dir mv pos s b8 stride 2 0 C 1 cur pic motion val dir mv pos s b8 stride 2 1 has C 1 else if s mb x 1 s mb width r avail cache 6 5 type mask C 0 cur pic motion val dir mv pos s b8 stride 1 0 C 1 cur pic motion val dir mv pos s b8 stride 1 1 has C 1 rv34 pred b vector ABC has A has B has C mx my mx r dmv dir 0 my r dmv dir 1 for j 0 j 2 j for i 0 i 2 i cur pic motion val dir mv pos i j s b8 stride 0 mx cur pic motion val dir mv pos i j s b8 stride 1 my if block type R V34 MBBBACKWARD block type R V34 MBBFORWARDZER O8x2 cur pic motion val dir mv pos s b8 stride static int dissect q931 ie cs0 tvbuff t tvb packet info pinfo proto tree tree void data U dissect q931 I Es tvb pinfo NULL tree FALSE 0 0 return tvb captured length tvb static int alloc addbyter int output FILE data struct asprintf infop struct asprintf data unsigned char outc unsigned char output if infop buffer infop buffer malloc 32 if infop buffer infop fail 1 return 1 infop alloc 32 infop len 0 else if infop len 1 infop alloc char newptr newptr realloc infop buffer infop alloc 2 if newptr infop fail 1 return 1 infop buffer newptr infop alloc 2 infop buffer infop len outc infop len return outc static int rc pick q and bounds two pass const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality cpi twopass active worst quality int q if frame is intra only cm vp9 is upper layer key frame cpi if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc active worst quality if cm width cm height 352 288 q adj factor 0 25 q adj factor 0 05 0 001 double cpi twopass kf zeromotion pct q val vp9 convert qindex to q active best quality active best quality vp9 compute qdelta rc q val q val q adj factor else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q else active best quality get gf active quality rc q else if oxcf rc mode VPXQ active best quality cq level else active best quality inter minq active worst quality if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality const GFGROUP const gf group cpi twopass gf group const double rate factor deltas RATEFACTORLEVELS 1 00 1 00 1 50 1 75 2 00 const double rate factor rate factor deltas gf group rf level gf group index int qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality rate factor top index active worst quality qdelta top index top index bottom index top index bottom index q active best quality static int archive read format cpio read header struct archive read a struct archive entry entry struct cpio cpio const void h struct archive string conv sconv size t namelength size t name pad int r cpio struct cpio a format data sconv cpio opt sconv if sconv NULL if cpio init default conversion cpio sconv default archive string default conversion for read a archive cpio init default conversion 1 sconv cpio sconv default r cpio read header a cpio entry namelength name pad if r ARCHIVEWARN return r h archive read ahead a namelength name pad NULL if h NULL return ARCHIVEFATAL if archive entry copy pathname l entry const char h namelength sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Pathname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Pathname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN cpio entry offset 0 archive read consume a namelength name pad if archive entry filetype entry AEIFLNK if cpio entry bytes remaining 1024 1024 archive set error a archive ENOMEM Rejecting malformed cpio archive symlink contents exceed 1 megabyte return ARCHIVEFATAL h archive read ahead a size t cpio entry bytes remaining NULL if h NULL return ARCHIVEFATAL if archive entry copy symlink l entry const char h size t cpio entry bytes remaining sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Linkname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Linkname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN archive read consume a cpio entry bytes remaining cpio entry bytes remaining 0 if namelength 11 strcmp const char h TRAILER 0 archive clear error a archive return ARCHIVEEOF if record hardlink a cpio entry ARCHIVEOK return ARCHIVEFATAL return r gcry error t gcry pk verify gcry sexp t s sig gcry sexp t s hash gcry sexp t s pkey gcry module t module key NULL module sig NULL gcry mpi t pkey NULL hash NULL sig NULL struct pk encoding ctx ctx gcry err code t rc REGISTERDEFAULTPUBKEYS rc sexp to key s pkey 0 GCRYPKUSAGESIGNNULL pkey module key NULL if rc goto leave rc sexp to sig s sig sig module sig if rc goto leave if module key mod id module sig mod id rc GPGERRCONFLICT goto leave init encoding ctx ctx PUBKEYOPVERIFY gcry pk get nbits s pkey rc sexp data to mpi s hash hash ctx if rc goto leave rc pubkey verify module key mod id hash sig pkey ctx leave if pkey release mpi array pkey gcry free pkey if sig release mpi array sig gcry free sig if hash mpi free hash if module key module sig ath mutex lock pubkeys registered lock if module key gcry module release module key if module sig gcry module release module sig ath mutex unlock pubkeys registered lock return gcry error rc static int ir2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ir2 Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p s picture int start ret if ret ff reget buffer avctx p 0 av log s avctx AVLOGERROR reget buffer failed n return ret start 48 if start buf size av log s avctx AVLOGERROR input buffer size too small d n buf size return AVERRORINVALIDDATA s decode delta buf 18 i buf size i buf i ff reverse buf i if s decode delta if ret ir2 decode plane s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret else if ret ir2 decode plane inter s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret if ret av frame ref picture s picture 0 return ret got frame 1 return buf size static int ipvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Ipvideo Context s avctx priv data int ret s decoding map size avctx width avctx height 8 8 2 if buf size s decoding map size return buf size s decoding map buf bytestream2 init s stream ptr buf s decoding map size buf size s decoding map size s current frame reference 3 if ret ff get buffer avctx s current frame 0 av log avctx AVLOGERROR Interplay Video get buffer failed n return ret if s is 16bpp const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s current frame palette has changed 1 memcpy s pal pal AVPALETTESIZE ipvideo decode opcodes s got frame 1 AV Frame data s current frame if s second last frame data 0 avctx release buffer avctx s second last frame s second last frame s last frame s last frame s current frame s current frame data 0 NULL return buf size static void rv40 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int alpha beta beta Y beta C int q int mbtype 4 int mb strong 4 int clip 4 int cbp 4 int uvcbp 4 2 unsigned mvmasks 4 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r cbp luma mb pos r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int y h deblock y v deblock int c v deblock 2 c h deblock 2 int clip left int avail 4 unsigned y to deblock int c to deblock 2 q s current picture ptr f qscale table mb pos alpha rv40 alpha tab q beta rv40 beta tab q beta Y beta C beta 3 if s width s height 176 144 beta Y beta avail 0 1 avail 1 row avail 2 mb x avail 3 row s mb height 1 for i 0 i 4 i if avail i int pos mb pos neighbour offs x i neighbour offs y i s mb stride mvmasks i r deblock coefs pos mbtype i s current picture ptr f mb type pos cbp i r cbp luma pos uvcbp i 0 r cbp chroma pos 0x F uvcbp i 1 r cbp chroma pos 4 else mvmasks i 0 mbtype i mbtype 0 cbp i 0 uvcbp i 0 uvcbp i 1 0 mb strong i ISINTRA mbtype i ISSEPARATEDC mbtype i clip i rv40 filter clip tbl mb strong i 1 q y to deblock mvmasks POSCUR mvmasks POSBOTTOM 16 y h deblock y to deblock cbp POSCUR 4 MASKYTOPROW cbp POSTOPMASKYLASTROW 12 y v deblock y to deblock cbp POSCUR 1 MASKYLEFTCOL cbp POSLEFTMASKYRIGHTCOL 3 if mb x y v deblock MASKYLEFTCOL if row y h deblock MASKYTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM y h deblock MASKYTOPROW 16 for i 0 i 2 i c to deblock i uvcbp POSBOTTOM i 4 uvcbp POSCUR i c v deblock i c to deblock i uvcbp POSCUR i 1 MASKCLEFTCOL uvcbp POSLEFT i MASKCRIGHTCOL 1 c h deblock i c to deblock i uvcbp POSTOP i MASKCLASTROW 2 uvcbp POSCUR i 2 if mb x c v deblock i MASKCLEFTCOL if row c h deblock i MASKCTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM c h deblock i MASKCTOPROW 4 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j int clip cur y to deblock MASKCUR ij clip POSCUR 0 int dither j ij i 4 if y h deblock MASKBOTTOM ij rv40 adaptive loop filter r rdsp Y 4 s linesize s linesize dither y to deblock MASKBOTTOM ij clip POSCUR 0 clip cur alpha beta beta Y 0 0 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 else clip left y to deblock MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 0 1 if j y h deblock MASKCUR i mb strong POSCUR mb strong POSTOP rv40 adaptive loop filter r rdsp Y s linesize dither clip cur mvmasks POSTOPMASKTOP i clip POSTOP 0 alpha beta beta Y 0 1 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 1 1 for k 0 k 2 k for j 0 j 2 j C s current picture ptr f data k 1 mb x 8 row 8 j 4 s uvlinesize for i 0 i 2 i C 4 int ij i j 2 int clip cur c to deblock k MASKCUR ij clip POSCUR 0 if c h deblock k MASKCUR ij 2 int clip bot c to deblock k MASKCUR ij 2 clip POSCUR 0 rv40 adaptive loop filter r rdsp C 4 s uvlinesize s uvlinesize i 8 clip bot clip cur alpha beta beta C 1 0 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 else clip left c to deblock k MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 0 1 if j c h deblock k MASKCUR ij mb strong POSCUR mb strong POSTOP int clip top uvcbp POSTOP k MASKCUR ij 2 clip POSTOP 0 rv40 adaptive loop filter r rdsp C s uvlinesize i 8 clip cur clip top alpha beta beta C 1 1 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 1 1 int ff generate sliding window mmcos H264 Context h int first slice MMCO mmco temp MAXMMCOCOUNT mmco first slice h mmco mmco temp int mmco index 0 i assert h long ref count h short ref count h sps ref frame count if h short ref count h long ref count h short ref count h sps ref frame count FIELDPICTURE h first field h cur pic ptr f reference mmco 0 opcode MMCOSHOR T2 UNUSED mmco 0 short pic num h short ref h short ref count 1 frame num mmco index 1 if FIELDPICTURE mmco 0 short pic num 2 mmco 1 opcode MMCOSHOR T2 UNUSED mmco 1 short pic num mmco 0 short pic num 1 mmco index 2 if first slice h mmco index mmco index else if first slice mmco index 0 mmco index h mmco index i check opcodes h mmco mmco temp mmco index av log h avctx AVLOGERROR Inconsistent MMCO state between slices d d d n mmco index h mmco index i return AVERRORINVALIDDATA return 0 static int16 t wmv2 pred motion Wmv2 Context w int px int py Mpeg Enc Context const s w s int xy wrap diff type int16 t ABC mot val wrap s b8 stride xy s block index 0 mot val s current picture motion val 0 xy A s current picture motion val 0 xy 1 B s current picture motion val 0 xy wrap C s current picture motion val 0 xy 2 wrap if s mb x s first slice line s mspel w top left mv flag diff FFMAXFFABSA 0 B 0 FFABSA 1 B 1 else diff 0 if diff 8 type get bits1 s gb else type 2 if type 0 px A 0 py A 1 else if type 1 px B 0 py B 1 else if s first slice line px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic data const uint8 t psrc avpkt data uint16 t y u v int aligned width avctx width 47 48 48 int stride aligned width 8 3 if avpkt size stride avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA if ret ff get buffer avctx pic 0 0 return ret y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 pic pict type AVPICTURETYPEI pic key frame 1 val av le2ne32 src a val 0x3 FF b val 10 0x3 FF c val 20 0x3 static void setup mi V P9 COMMON cm cm mi cm mip cm mi stride 1 cm prev mi cm prev mip cm mi stride 1 cm mi grid visible cm mi grid base cm mi stride 1 cm prev mi grid visible cm prev mi grid base cm mi stride 1 vpx memset cm mip 0 cm mi stride cm mi rows 1 sizeof cm mip vpx memset cm mi grid base 0 cm mi stride cm mi rows 1 sizeof cm mi grid base clear mi border cm cm prev mip struct login settings login settings read pool t pool const struct ip addr local ip const struct ip addr remote ip const char local name const struct master service ssl settings ssl set r void other settings r struct master service settings input input const char error const struct setting parser context parser void const cache sets void sets unsigned int i count i zero input input roots login set roots input module login binary process name input service login binary protocol input local name local name if local ip NULL input local ip local ip if remote ip NULL input remote ip remote ip if set cache NULL set cache master service settings cache init master service input module input service if master service get service count master service 1 master service settings cache init filter set cache if master service settings cache read set cache input NULL parser error 0 i fatal Error reading configuration s error cache sets master service settings parser get others master service parser for count 0 input roots count NULL count i assert cache sets count NULL sets p new pool void count 1 for i 0 i count i sets i login setting dup pool input roots i cache sets i settings var expand login setting parser info sets 0 pool login set var expand table input ssl set r login setting dup pool master service ssl setting parser info settings parser get list parser 1 other settings r sets 1 return sets 0 static void encode rd sb row V P9 COMP cpi const Tile Info const tile int mi row TOKENEXTRA tp V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd SPEEDFEATURES const sf cpi sf int mi col vpx memset xd left context 0 sizeof xd left context vpx memset xd left seg context 0 sizeof xd left seg context for mi col tile mi col start mi col tile mi col end mi col MIBLOCKSIZE int dummy rate int64 t dummy dist int i if sf adaptive pred interp filter for i 0 i 64 i cpi leaf tree i pred interp filter SWITCHABLE for i 0 i 64 i cpi pc tree i vertical 0 pred interp filter SWITCHABLE cpi pc tree i vertical 1 pred interp filter SWITCHABLE cpi pc tree i horizontal 0 pred interp filter SWITCHABLE cpi pc tree i horizontal 1 pred interp filter SWITCHABLE vp9 zero cpi mb pred mv cpi pc root index 0 if sf partition search type SEARCHPARTITION sf use lastframe partitioning sf partition search type FIXEDPARTITION sf partition search type VARBASEDPARTITION sf partition search type VARBASEDFIXEDPARTITION const int idx str cm mi stride mi row mi col MODEINFO mi cm mi idx str MODEINFO prev mi cm prev mip cm mi stride 1 idx str src mi cpi mb source variance UINTMAX if sf partition search type FIXEDPARTITION set offsets cpi tile mi row mi col BLOCK 64 X64 set fixed partitioning cpi tile mi mi row mi col sf always this block size rd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 cpi pc root else if cpi skippable frame sf partition search type VARBASEDFIXEDPARTITIONBLOCKSIZE bsize set offsets cpi tile mi row mi col BLOCK 64 X64 bsize get rd var based fixed partition cpi mi row mi col set fixed partitioning cpi tile mi mi row mi col bsize rd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 cpi pc root else if sf partition search type VARBASEDPARTITION choose partitioning cpi tile mi row mi col rd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 cpi pc root else GFGROUP gf grp cpi twopass gf group int last was mid sequence overlay 0 if cpi oxcf pass 2 gf grp index if gf grp update type gf grp index 1 OVERLAYUPDATE last was mid sequence overlay 1 if cpi rc frames since key sf last partitioning redo frequency 0 last was mid sequence overlay cm prev mi 0 cm show frame 0 cm frame type KEYFRAME cpi rc is src frame alt ref sf use lastframe partitioning LASTFRAMEPARTITIONLOWMOTION sb has motion cm prev mi sf lf motion threshold if sf auto min max partition size set offsets cpi tile mi row mi col BLOCK 64 X64 rd auto partition range cpi tile mi row mi col sf min partition size sf max partition size rd pick partition cpi tile tp mi row mi col BLOCK 64 X64 dummy rate dummy dist IN T64 MAX cpi pc root else if sf constrain copy partition sb has motion cm prev mi sf lf motion threshold constrain copy partitioning cpi tile mi prev mi mi row mi col BLOCK 16 X16 else copy partitioning cm mi prev mi rd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 cpi pc root else if sf auto min max partition size set offsets cpi tile mi row mi col BLOCK 64 X64 rd auto partition range cpi tile mi row mi col sf min partition size sf max partition size rd pick partition cpi tile tp mi row mi col BLOCK 64 X64 dummy rate dummy dist IN T64 MAX cpi pc root static struct cvec range struct vars v celt a celt b int cases int nchrs struct cvec cv celt c cc if a b before a b ERRREGERANGE return NULL if cases cv getcvec v 0 1 NOERRN addrange cv a b return cv nchrs b a 1 if nchrs 0 nchrs 100000 nchrs 100000 cv getcvec v nchrs 1 NOERRN addrange cv a b for c a c b c cc pg wc tolower chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc cc pg wc toupper chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc if CANCELREQUESTED v re ERRREGCANCEL return NULL return cv static int avs decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size Avs Context const avs avctx priv data AV Frame picture data AV Frame const p avs picture const uint8 t table vect uint8 t out int i j x y stride ret vect w 3 vect h 3 Avs Video Sub Type sub type Avs Block Type type Get Bit Context change map if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR reget buffer failed n return ret p pict type AVPICTURETYPEP p key frame 0 out avs picture data 0 stride avs picture linesize 0 if buf end buf 4 return AVERRORINVALIDDATA sub type buf 0 type buf 1 buf 4 if type AVSPALETTE int first last uint32 t pal uint32 t avs picture data 1 first AVR L16 buf last first AVR L16 buf 2 if first 256 last 256 buf end buf 4 4 3 last first return AVERRORINVALIDDATA buf 4 for i first i last i buf 3 pal i buf 0 18 buf 1 10 buf 2 2 sub type buf 0 type buf 1 buf 4 if type AVSVIDEO return AVERRORINVALIDDATA switch sub type case AVSIFRAME p pict type AVPICTURETYPEI p key frame 1 case AVSPFRAME 3 X3 vect w 3 vect h 3 break case AVSPFRAME 2 X2 vect w 2 vect h 2 break case AVSPFRAME 2 X3 vect w 2 vect h 3 break default return AVERRORINVALIDDATA if buf end buf 256 vect w vect h return AVERRORINVALIDDATA table buf 256 vect w vect h if sub type AVSIFRAME int map size 318 vect w 7 8 198 vect h if buf end table map size return AVERRORINVALIDDATA init get bits change map table map size 8 table map size for y 0 y 198 y vect h for x 0 x 318 x vect w if sub type AVSIFRAME get bits1 change map if buf end table 1 return AVERRORINVALIDDATA vect buf table vect w vect h for j 0 j vect w j out y 0 stride x j vect 0 vect w j out y 1 stride x j vect 1 vect w j if vect h 3 out y 2 stride x j vect 2 vect w j if sub type AVSIFRAME align get bits change map if ret av frame ref picture avs picture 0 return ret got frame 1 return buf size static int pnm decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size PNM Context const s avctx priv data AV Frame picture data AV Frame const p s picture int i j n linesize h upgrade 0 unsigned char ptr int components sample len ret s bytestream start s bytestream buf s bytestream end buf buf size if ret ff pnm decode header avctx s 0 return ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 switch avctx pix fmt default return AVERROREINVAL case AVPIXFMTRG B48 BE n avctx width 6 components 3 sample len 16 goto do read case AVPIXFMTRG B24 n avctx width 3 components 3 sample len 8 goto do read case AVPIXFMTGRA Y8 n avctx width components 1 sample len 8 if s maxval 255 upgrade 1 goto do read case AVPIXFMTGRA Y16 BE case AVPIXFMTGRA Y16 LE n avctx width 2 components 1 sample len 16 if s maxval 65535 upgrade 2 goto do read case AVPIXFMTMONOWHITE case AVPIXFMTMONOBLACK n avctx width 7 3 components 1 sample len 1 do read ptr p data 0 linesize p linesize 0 if s bytestream n avctx height s bytestream end return AVERRORINVALIDDATA if s type 4 for i 0 i avctx height i Put Bit Context pb init put bits pb ptr linesize for j 0 j avctx width components j unsigned int c 0 int v 0 while s bytestream s bytestream end s bytestream 0 s bytestream 9 s bytestream if s bytestream s bytestream end return AVERRORINVALIDDATA do v 10 v c c s bytestream 0 while c 9 put bits pb sample len 1 sample len 1 v s maxval 1 s maxval flush put bits pb ptr linesize else for i 0 i avctx height i if upgrade memcpy ptr s bytestream n else if upgrade 1 unsigned int j f 255 128 s maxval 2 s maxval for j 0 j n j ptr j s bytestream j f 64 7 else if upgrade 2 unsigned int j v f 65535 32768 s maxval 2 s maxval for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize break case AVPIXFMTYU V420 P case AVPIXFMTYU V420 P9 BE case AVPIXFMTYU V420 P10 BE unsigned char ptr1 ptr2 n avctx width ptr p data 0 linesize p linesize 0 if s maxval 256 n 2 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i memcpy ptr s bytestream n s bytestream n ptr linesize ptr1 p data 1 ptr2 p data 2 n 1 h avctx height 1 for i 0 i h i memcpy ptr1 s bytestream n s bytestream n memcpy ptr2 s bytestream n s bytestream n ptr1 p linesize 1 ptr2 p linesize 2 break case AVPIXFMTYU V420 P16 uint16 t ptr1 ptr2 const int f 65535 32768 s maxval 2 s maxval unsigned int j v n avctx width 2 ptr p data 0 linesize p linesize 0 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize ptr1 uint16 t p data 1 ptr2 uint16 t p data 2 n 1 h avctx height 1 for i 0 i h i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr1 j v f 16384 15 s bytestream n for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr2 j v f 16384 15 s bytestream n ptr1 p linesize 1 2 ptr2 p linesize 2 2 break case AVPIXFMTRG B32 ptr p data 0 linesize p linesize 0 if s bytestream avctx width avctx height 4 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i int j r g b a for j 0 j avctx width j r s bytestream g s bytestream b s bytestream a s bytestream uint32 t ptr j a 24 r 16 g 8 b ptr linesize break picture s picture got frame 1 return s bytestream s bytestream start static int qcelp decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size QCELP Context q avctx priv data AV Frame frame data float outbuffer int i ret float quantized lspf 10 lpc 10 float gain 16 float formant mem frame nb samples 160 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret outbuffer float frame data 0 if q bitrate determine bitrate avctx buf size buf IFQ warn insufficient frame quality avctx bitrate cannot be determined goto erasure if q bitrate RATEOCTAVE q first16bits AVR B16 buf 0x FFFF warn insufficient frame quality avctx Bitrate is 1 8 and first 16 bits are on goto erasure if q bitrate SILENCE const QCELP Bitmap bitmaps qcelp unpacking bitmaps per rate q bitrate const QCELP Bitmap bitmaps end qcelp unpacking bitmaps per rate q bitrate qcelp unpacking bitmaps lengths q bitrate uint8 t unpacked data uint8 t q frame init get bits q gb buf 8 buf size memset q frame 0 sizeof QCELP Frame for bitmaps bitmaps end bitmaps unpacked data bitmaps index get bits q gb bitmaps bitlen bitmaps bitpos if q frame reserved warn insufficient frame quality avctx Wrong data in reserved frame area goto erasure if q bitrate RATEQUARTER codebook sanity check for rate quarter q frame cbgain warn insufficient frame quality avctx Codebook gain sanity check failed goto erasure if q bitrate RATEHALF for i 0 i 4 i if q frame pfrac i q frame plag i 124 warn insufficient frame quality avctx Cannot initialize pitch filter goto erasure decode gain and index q gain compute svector q gain outbuffer if decode lspf q quantized lspf 0 warn insufficient frame quality avctx Badly received packets in frame goto erasure apply pitch filters q outbuffer if q bitrate IFQ erasure q bitrate IFQ q erasure count decode gain and index q gain compute svector q gain outbuffer decode lspf q quantized lspf apply pitch filters q outbuffer else q erasure count 0 formant mem q formant mem 10 for i 0 i 4 i interpolate lpc q quantized lspf lpc i ff celp lp synthesis filterf formant mem lpc outbuffer i 40 40 10 formant mem 40 postfilter q outbuffer lpc memcpy q formant mem q formant mem 160 10 sizeof float memcpy q prev lspf quantized lspf sizeof q prev lspf q prev bitrate q bitrate got frame ptr 1 return buf size static int mpeg field start Mpeg Enc Context s const uint8 t buf int buf size AV Codec Context avctx s avctx Mpeg1 Context s1 Mpeg1 Context s if s first field s picture structure PICTFRAME if ff MPV frame start s avctx 0 return 1 ff mpeg er frame start s s current picture ptr f repeat pict 0 if s repeat first field if s progressive sequence if s top field first s current picture ptr f repeat pict 4 else s current picture ptr f repeat pict 2 else if s progressive frame s current picture ptr f repeat pict 1 s current picture ptr f pan scan s1 pan scan if HAVETHREADS avctx active thread type FFTHREADFRAME ff thread finish setup avctx else int i if s current picture ptr av log s avctx AVLOGERROR first field missing n return 1 if s avctx hwaccel s avctx slice flags SLICEFLAGALLOWFIELD if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode first field n for i 0 i 4 i s current picture f data i s current picture ptr f data i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture ptr f linesize i if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 return 1 if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration if ff xvmc field start s avctx 0 return 1 return 0 static int32 t append Privateuse To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status void had Posix char buf ULOCFULLNAMECAPACITY char tmp Append ULOCFULLNAMECAPACITYU Error Code tmp Status UZEROERROR int32 t len i int32 t reslen 0 if UFAILURE status return 0 len uloc get Variant locale ID buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR return 0 if len 0 char p p Priv U Bool b Next TRUEU Bool first Value TRUEU Bool write Value p Priv NULL p buf while b Next write Value FALSE if p SEP p LOCALESEP p 0 if p 0 b Next FALSE else p 0 if p Priv NULL for i 0 p Priv i 0 i p Priv i uprv tolower p Priv i if is Privateuse Value Subtag p Priv 1 if first Value if is Variant Subtag p Priv 1 write Value TRUE else write Value TRUE else if strict status UILLEGALARGUMENTERROR break else break if write Value if reslen capacity tmp Append reslen SEP if first Value if reslen capacity tmp Append reslen PRIVATEUSEKEY if reslen capacity tmp Append reslen SEP len int32 t uprv strlen PRIVUSEVARIANTPREFIX if reslen capacity uprv memcpy tmp Append reslen PRIVUSEVARIANTPREFIX uprv min len capacity reslen reslen len if reslen capacity tmp Append reslen SEP first Value FALSE len int32 t uprv strlen p Priv if reslen capacity uprv memcpy tmp Append reslen p Priv uprv min len capacity reslen reslen len p Priv NULL else if p Priv NULL p Priv p p if UFAILURE status return 0 if USUCCESS status len reslen if reslen capacity uprv memcpy append At tmp Append uprv min len capacity reslen u terminate Chars append At capacity reslen status return reslen static void single motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv MACROBLOCKD xd x e mbd const V P9 COMMON cm cpi common MBMODEINFO mbmi xd mi 0 mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 int bestsme INTMAX int step param int sadpb x sadperbit16 MV mvp full int ref mbmi ref frame 0 MV ref mv mbmi ref mvs ref 0 as mv int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref MV pred mv 3 pred mv 0 mbmi ref mvs ref 0 as mv pred mv 1 mbmi ref mvs ref 1 as mv pred mv 2 x pred mv ref if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv if cpi sf mv auto mv step size cm show frame step param vp9 init search range x max mv context ref cpi mv step param 2 else step param cpi mv step param if cpi sf adaptive motion search bsize BLOCK 64 X64 int boffset 2 b width log2 BLOCK 64 X64 MIN b height log2 bsize b width log2 bsize step param MAX step param boffset if cpi sf adaptive motion search int bwl b width log2 bsize int bhl b height log2 bsize int i int tlevel x pred mv sad ref bwl bhl 4 if tlevel 5 step param 2 for i LASTFRAME i ALTREFFRAME cm show frame i if x pred mv sad ref 3 x pred mv sad i x pred mv ref row 0 x pred mv ref col 0 tmp mv as int INVALIDMV if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return mvp full pred mv x mv best ref index ref mvp full col 3 mvp full row 3 bestsme vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis cpi find fractional mv step x tmp mv as mv ref mv cm allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 rate mv vp9 mv bit cost tmp mv as mv ref mv x nmvjointcost x mvcost MVCOSTWEIGHT if cpi sf adaptive motion search x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i void ff h264 direct ref list init H264 Context const h Picture const ref1 h ref list 1 0 Picture const cur h cur pic ptr int list j field int sidx h picture structure 1 1 int ref1sidx ref1 reference 1 1 for list 0 list 2 list cur ref count sidx list h ref count list for j 0 j h ref count list j cur ref poc sidx list j 4 h ref list list j frame num h ref list list j reference 3 if h picture structure PICTFRAME memcpy cur ref count 1 cur ref count 0 sizeof cur ref count 0 memcpy cur ref poc 1 cur ref poc 0 sizeof cur ref poc 0 cur mbaff FRAMEMBAFF h col fieldoff 0 if h picture structure PICTFRAME int cur poc h cur pic ptr poc int col poc h ref list 1 field poc h col parity FFABS col poc 0 cur poc FFABS col poc 1 cur poc ref1sidx sidx h col parity else if h picture structure h ref list 1 0 reference h ref list 1 0 mbaff h col fieldoff 2 h ref list 1 0 reference 3 if h slice type nos AVPICTURETYPEB h direct spatial mv pred return for list 0 list 2 list fill colmap h h map col to list0 list sidx ref1sidx 0 if FRAMEMBAFF for field 0 field 2 field fill colmap h h map col to list0 field field list field field 1 static char create argv command struct rule rule struct process process struct iovec argv size t count i j stdin arg char req argv NULL const char program for count 0 argv count NULL count if rule sudo user NULL req argv xcalloc count 1 sizeof char else req argv xcalloc count 5 sizeof char if rule sudo user NULL req argv 0 xstrdup PATHSUDO req argv 1 xstrdup u req argv 2 xstrdup rule sudo user req argv 3 xstrdup req argv 4 xstrdup rule program j 5 else program strrchr rule program if program NULL program rule program else program req argv 0 xstrdup program j 1 if rule stdin arg 1 stdin arg count 1 else stdin arg size t rule stdin arg for i 1 i count i const char data argv i iov base size t length argv i iov len if i stdin arg process input evbuffer new if process input NULL die internal error cannot create input buffer if evbuffer add process input data length 0 die internal error cannot add data to input buffer continue if length 0 req argv j xstrdup else req argv j xstrndup data length j req argv j NULL return req argv void xps begin opacity xps document doc const fz matrix ctm const fz rect area char base uri xps resource dict char opacity att fz xml opacity mask tag float opacity if opacity att opacity mask tag return opacity 1 if opacity att opacity fz atof opacity att if opacity mask tag strcmp fz xml tag opacity mask tag Solid Color Brush char scb opacity att fz xml att opacity mask tag Opacity char scb color att fz xml att opacity mask tag Color if scb opacity att opacity opacity fz atof scb opacity att if scb color att fz colorspace colorspace float samples FZMAXCOLORS xps parse color doc base uri scb color att colorspace samples opacity opacity samples 0 opacity mask tag NULL if doc opacity top 1 nelem doc opacity doc opacity doc opacity top 1 doc opacity doc opacity top opacity doc opacity top if opacity mask tag fz begin mask doc dev area 0 NULLNULL xps parse brush doc ctm area base uri dict opacity mask tag fz end mask doc dev kadm5 ret t kadm5 modify principal void server handle kadm5 principal ent t entry long mask int ret ret2 i kadm5 policy ent rec pol krb5 boolean have pol FALSE krb5 db entry kdb krb5 tl data tl data orig osa princ ent rec adb kadm5 server handle t handle server handle CHECKHANDLE server handle krb5 clear error message handle context if mask KAD M5 PRINCIPAL mask KAD M5 LASTPWDCHANGE mask KAD M5 MODTIME mask KAD M5 MODNAME mask KAD M5 MKVNO mask KAD M5 AUXATTRIBUTES mask KAD M5 KEYDATA mask KAD M5 LASTSUCCESS mask KAD M5 LASTFAILED return KAD M5 BADMASK if mask ALLPRINCMASK return KAD M5 BADMASK if mask KAD M5 POLICY mask KAD M5 POLICYCLR return KAD M5 BADMASK if entry kadm5 principal ent t NULL return EINVAL if mask KAD M5 TLDATA tl data orig entry tl data while tl data orig if tl data orig tl data type 256 return KAD M5 BADTLTYPE tl data orig tl data orig tl data next ret kdb get entry handle entry principal kdb adb if ret return ret if mask KAD M5 POLICY ret get policy handle entry policy pol have pol if ret goto done adb aux attributes KAD M5 POLICY if adb policy free adb policy adb policy strdup entry policy if have pol if pol pw max life ret krb5 dbe lookup last pwd change handle context kdb kdb pw expiration if ret goto done kdb pw expiration pol pw max life else kdb pw expiration 0 if mask KAD M5 POLICYCLR adb aux attributes KAD M5 POLICY free adb policy adb policy NULL adb aux attributes KAD M5 POLICY kdb pw expiration 0 if mask KAD M5 ATTRIBUTES kdb attributes entry attributes if mask KAD M5 MAXLIFE kdb max life entry max life if mask KAD M5 PRINCEXPIRETIME kdb expiration entry princ expire time if mask KAD M5 PWEXPIRATION kdb pw expiration entry pw expiration if mask KAD M5 MAXRLIFE kdb max renewable life entry max renewable life if mask KAD M5 KVNO for i 0 i kdb n key data i kdb key data i key data kvno entry kvno if mask KAD M5 TLDATA krb5 tl data tl for tl entry tl data tl tl tl tl data next ret krb5 dbe update tl data handle context kdb tl if ret goto done if mask KAD M5 FAILAUTHCOUNT if entry fail auth count 0 ret KAD M5 BADSERVERPARAMS goto done kdb fail auth count 0 kdb mask mask ret k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPRECOMMIT entry mask if ret goto done ret kdb put entry handle kdb adb if ret goto done void k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPOSTCOMMIT entry mask ret KAD M5 OK done if have pol ret2 kadm5 free policy ent handle lhandle pol ret ret ret ret2 kdb free entry handle kdb adb return ret static int m authenticate struct Client client p struct Client source p int parc const char parv struct Client agent p NULL struct Client saslserv p NULL if Is Capable source p CLICAPSASL return 0 if strlen client p id 3 exit client client p client p client p Mixing client and server protocol return 0 if parv 1 strchr parv 1 exit client client p client p client p Malformed AUTHENTICATE return 0 saslserv p find named client Config File Entry sasl service if saslserv p NULL Is Service saslserv p sendto one source p form str ERRSASLABORTED me name Empty String source p name source p name return 0 if source p local Client sasl complete source p local Client sasl agent 0 source p local Client sasl complete 0 if strlen parv 1 400 sendto one source p form str ERRSASLTOOLONG me name Empty String source p name source p name return 0 if source p id strcpy source p id generate uid add to id hash source p id source p if source p local Client sasl agent agent p find id source p local Client sasl agent if agent p NULL sendto one saslserv p s ENCAP s SASL s s H s s me id saslserv p servptr name source p id saslserv p id source p host source p sockhost if strcmp parv 1 EXTERNAL source p certfp NULL sendto one saslserv p s ENCAP s SASL s s S s s me id saslserv p servptr name source p id saslserv p id parv 1 source p certfp else sendto one saslserv p s ENCAP s SASL s s S s me id saslserv p servptr name source p id saslserv p id parv 1 rb strlcpy source p local Client sasl agent saslserv p id IDLEN else sendto one agent p s ENCAP s SASL s s C s me id agent p servptr name source p id agent p id parv 1 source p local Client sasl out return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet pkt Bink Context const c avctx priv data AV Frame frame data Get Bit Context gb int plane plane idx ret int bits count pkt size 3 if c version b if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret else if ret ff reget buffer avctx c last 0 av log avctx AVLOGERROR reget buffer failed n return ret if ret av frame ref frame c last 0 return ret init get bits gb pkt data bits count if c has alpha if c version i skip bits long gb 32 if ret bink decode plane c frame gb 3 0 0 return ret if c version i skip bits long gb 32 for plane 0 plane 3 plane plane idx plane c swap planes plane plane 3 if c version b if ret bink decode plane c frame gb plane idx plane 0 return ret else if ret binkb decode plane c frame gb plane idx avctx frame number plane 0 return ret if get bits count gb bits count break emms c if c version b av frame unref c last if ret av frame ref c last frame 0 return ret got frame 1 return pkt size static int truespeech decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size TS Context c avctx priv data int i j int16 t samples int iterations ret iterations buf size 32 if iterations av log avctx AVLOGERROR Too small input buffer d bytes need at least 32 bytes n buf size return 1 frame nb samples iterations 240 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 memset samples 0 iterations 240 sizeof samples for j 0 j iterations j truespeech read frame c buf buf 32 truespeech correlate filter c truespeech filters merge c for i 0 i 4 i truespeech apply twopoint filter c i truespeech place pulses c samples i truespeech update filters c samples i truespeech synth c samples i samples 60 truespeech save prevvec c got frame ptr 1 return buf size static int decode cabac mb skip H264 Context h int mb x int mb y int mba xy mbb xy int ctx 0 if FRAMEMBAFF int mb xy mb x mb y 1 h mb stride mba xy mb xy 1 if mb y 1 h slice table mba xy h slice num MBFIELDISINTERLACED h cur pic mb type mba xy mba xy h mb stride if MBFIELD mbb xy mb xy h mb stride if mb y 1 h slice table mbb xy h slice num ISINTERLACED h cur pic mb type mbb xy mbb xy h mb stride else mbb xy mb x mb y 1 h mb stride else int mb xy h mb xy mba xy mb xy 1 mbb xy mb xy h mb stride FIELDPICTURE if h slice table mba xy h slice num ISSKIP h cur pic mb type mba xy ctx if h slice table mbb xy h slice num ISSKIP h cur pic mb type mbb xy ctx if h slice type nos AVPICTURETYPEB ctx 13 return get cabac noinline h cabac h cabac state 11 ctx void vp9 pick filter level const Y V12 BUFFERCONFIG sd V P9 COMP cpi LPFPICKMETHOD method V P9 COMMON const cm cpi common struct loopfilter const lf cm lf lf sharpness level cm frame type KEYFRAME 0 cpi oxcf sharpness if method LPFPICKMINIMALLPF lf filter level lf filter level 0 else if method LPFPICKFROMQ const int min filter level 0 const int max filter level get max filter level cpi const int q vp9 ac quant cm base qindex 0 int filt guess ROUNDPOWEROFTWO q 20723 1015158 18 if cm frame type KEYFRAME filt guess 4 lf filter level clamp filt guess min filter level max filter level else lf filter level search filter level sd cpi method static int decode udvm multitype operand guint8 buff guint operand address guint16 value guint test bits guint bytecode guint offset operand address guint16 operand guint32 result guint8 temp data guint16 temp data16 guint16 memmory addr 0 value 0 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 0xc0 6 switch test bits case 0 operand buff operand address value operand offset break case 1 memmory addr bytecode 0x3f 2 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset break case 2 test bits bytecode 0xe0 5 if test bits 5 temp data buff operand address 0x1f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data value operand offset offset 2 else test bits bytecode 0xf0 4 if test bits 9 temp data buff operand address 0x0f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 61440 value operand offset offset 2 else test bits bytecode 0x08 3 if test bits 1 result 1 buff operand address 0x07 8 operand result 0xffff value operand offset else test bits bytecode 0x0e 1 if test bits 3 result 1 buff operand address 0x01 6 operand result 0xffff value operand offset else offset temp data16 buff operand address 1 0xffff 8 temp data16 temp data16 buff operand address 2 0xffff if bytecode 0x01 1 memmory addr temp data16 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 break case 3 test bits bytecode 0x20 5 if test bits 1 operand buff operand address 0x1f 65504 value operand offset else memmory addr buff operand address 0x1f memmory addr memmory addr 8 memmory addr memmory addr buff operand address 1 0xffff temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 default break return offset void jpc qmfb split colgrp jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr JPCQMFBCOLGRPSIZE srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr JPCQMFBCOLGRPSIZE if buf splitbuf jas free buf static guint32 dissect minivideopacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet gboolean rtp marker proto item item ts tvb get ntohs tvb offset rtp marker ts 0x8000 TRUEFALSE ts 0x8000 iax packet iax2 get packet data for minipacket pinfo scallno TRUE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add item iax2 tree hf iax2 minividts tvb offset 2 ENCBIGENDIAN iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts proto tree add item iax2 tree hf iax2 minividmarker tvb offset 2 ENCBIGENDIAN else iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini video packet source call d timestamp ums s scallno ts rtp marker Mark dissect payload tvb offset pinfo iax2 tree main tree ts TRUE iax packet iax packet first time FALSE return offset static void event process active struct event base base struct event ev struct event list activeq NULL int i short ncalls for i 0 i base nactivequeues i if TAILQFIRST base activequeues i NULL activeq base activequeues i break assert activeq NULL for ev TAILQFIRST activeq ev ev TAILQFIRST activeq if ev ev events EVPERSIST event queue remove base ev EVLISTACTIVE else event del ev ncalls ev ev ncalls ev ev pncalls ncalls while ncalls ncalls ev ev ncalls ncalls ev ev callback int ev ev fd ev ev res ev ev arg if event gotsig base event break return static void choose tx size from rd V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t psse int64 t tx cache TXMODES int64 t ref best rd BLOCKSIZE bs const TXSIZE max tx size max txsize lookup bs V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi vp9 prob skip prob vp9 get skip prob cm xd int r TXSIZES 2 s TXSIZES int64 t d TXSIZES sse TXSIZES int64 t rd TXSIZES 2 IN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAX int n m int s0 s1 const TXSIZE max mode tx size tx mode to biggest tx size cm tx mode int64 t best rd IN T64 MAXTXSIZE best tx max tx size const vp9 prob tx probs get tx probs2 max tx size xd cm fc tx probs assert skip prob 0 s0 vp9 cost bit skip prob 0 s1 vp9 cost bit skip prob 1 for n max tx size n 0 n txfm rd in plane x r n 0 d n s n sse n ref best rd 0 bs n cpi sf use fast coef costing r n 1 r n 0 if r n 0 INTMAX for m 0 m n n int max tx size m if m n r n 1 vp9 cost zero tx probs m else r n 1 vp9 cost one tx probs m if d n IN T64 MAX rd n 0 rd n 1 IN T64 MAX else if s n rd n 0 rd n 1 RDCOST x rdmult x rddiv s1 d n else rd n 0 RDCOST x rdmult x rddiv r n 0 s0 d n rd n 1 RDCOST x rdmult x rddiv r n 1 s0 d n if cpi sf tx size search breakout rd n 1 IN T64 MAX n int max tx size rd n 1 rd n 1 1 s n 1 break if rd n 1 best rd best tx n best rd rd n 1 mbmi tx size cm tx mode TXMODESELECT best tx MIN max tx size max mode tx size distortion d mbmi tx size rate r mbmi tx size cm tx mode TXMODESELECT skip s mbmi tx size psse sse mbmi tx size tx cache ONLY 4 X4 rd TX 4 X4 0 tx cache ALLOW 8 X8 rd TX 8 X8 0 tx cache ALLOW 16 X16 rd MIN max tx size TX 16 X16 0 tx cache ALLOW 32 X32 rd MIN max tx size TX 32 X32 0 if max tx size TX 32 X32 best tx TX 32 X32 tx cache TXMODESELECT rd TX 32 X32 1 else if max tx size TX 16 X16 best tx TX 16 X16 tx cache TXMODESELECT rd TX 16 X16 1 else if rd TX 8 X8 1 rd TX 4 X4 1 tx cache TXMODESELECT rd TX 8 X8 1 else tx cache TXMODESELECT rd TX 4 X4 1 int vp9 receive raw frame V P9 COMP cpi unsigned int frame flags Y V12 BUFFERCONFIG sd int64 t time stamp int64 t end time V P9 COMMON cm cpi common struct vpx usec timer timer int res 0 const int subsampling x sd uv width sd y width const int subsampling y sd uv height sd y height check initial width cpi subsampling x subsampling y vpx usec timer start timer else endif res vp9 lookahead push cpi lookahead sd time stamp end time frame flags if res res 1 vpx usec timer mark timer cpi time receive data vpx usec timer elapsed timer if cm profile PROFILE 0 cm profile PROFILE 2 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM Non 4 2 0 color space requires profile 1 or 3 res 1 if cm profile PROFILE 1 cm profile PROFILE 3 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM 4 2 0 color space requires profile 0 or 2 res 1 return res static int find best 16x16 intra V P9 COMP cpi PREDICTIONMODE pbest mode MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd PREDICTIONMODE best mode 1 mode unsigned int best err INTMAX for mode DCPRED mode TMPRED mode unsigned int err xd mi 0 src mi mbmi mode mode vp9 predict intra block xd 0 2 TX 16 X16 mode x plane 0 src buf x plane 0 src stride xd plane 0 dst buf xd plane 0 dst stride 0 0 0 err vp9 sad16x16 x plane 0 src buf x plane 0 src stride xd plane 0 dst buf xd plane 0 dst stride if err best err best err err best mode mode if pbest mode pbest mode best mode return best err static void dump Databases P Gconn conn P Gresult res int i if server version 70100 res execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 else res execute Query conn SELECT datname FROM pg database ORDERBY 1 for i 0 i P Qntuples res i int ret char dbname P Qgetvalue res i 0 PQ Exp Buffer Data connectbuf if verbose fprintf stderr s dumping database s n progname dbname init PQ Exp Buffer connectbuf append Psql Meta Connect connectbuf dbname fprintf OPF s n connectbuf data term PQ Exp Buffer connectbuf fprintf OPFSET default transaction read only off n n if filename fclose OPF ret run Pg Dump dbname if ret 0 fprintf stderr s pg dump failed on database s exiting n progname dbname exit nicely 1 if filename OPF fopen filename PGBINARYA if OPF fprintf stderr s could not re open the output file s s n progname filename strerror errno exit nicely 1 P Qclear res static tvbuff t decompress sigcomp message tvbuff t bytecode tvb tvbuff t message tvb packet info pinfo proto tree udvm tree gint udvm mem dest gint print flags gint hf id gint header len gint byte code state len gint byte code id len gint udvm start ip tvbuff t decomp tvb guint8 buff guint8 wmem alloc0 wmem packet scope UDVMMEMORYSIZE char string 2 guint8 out buff guint32 i 0 guint16 n 0 guint16 m 0 guint16 x guint k 0 guint16 H guint16 old H guint offset 0 guint start offset guint result dest guint code length 0 guint8 current instruction guint current address guint operand address guint input address guint16 output address 0 gint next operand address guint8 octet guint8 msb guint8 lsb guint16 byte copy right guint16 byte copy left guint16 input bit order guint16 stack location guint16 stack fill guint16 result guint msg end tvb reported length remaining message tvb 0 guint16 result code 0 guint16 old input bit order 0 guint16 remaining bits 0 guint16 input bits 0 guint8 bit order 0 gboolean outside huffman boundaries TRUE gboolean print in loop FALSE guint16 instruction address guint8 no of state create 0 guint16 state length buff 5 guint16 state address buff 5 guint16 state instruction buff 5 guint16 state minimum access length buff 5 guint32 used udvm cycles 0 guint cycles per bit guint maximum UDVM cycles guint8 sha1buff unsigned char sha1 digest buf STATEBUFFERSIZE sha1 context ctx proto item addr item NULL ti NULL guint16 length guint16 at address guint16 destination guint16 addr guint16 value guint16 p id start guint16 p id length guint16 state begin guint16 state length guint16 state address guint16 state instruction guint16 operand 1 guint16 operand 2 guint16 value 1 guint16 value 2 guint16 at address 1 guint16 at address 2 guint16 at address 3 guint16 j guint16 bits n guint16 lower bound n guint16 upper bound n guint16 uncompressed n guint16 position guint16 ref destination guint16 multy offset guint16 output start guint16 output length guint16 minimum access length guint16 state retention priority guint16 requested feedback location guint16 returned parameters location guint16 start value gboolean print level 1 FALSE gboolean print level 2 FALSE gboolean print level 3 FALSE gint show instr detail level 0 switch print flags case 0 break case 1 print level 1 TRUE show instr detail level 1 break case 2 print level 1 TRUE print level 2 TRUE show instr detail level 1 break case 3 print level 1 TRUE print level 2 TRUE print level 3 TRUE show instr detail level 2 break default print level 1 TRUE show instr detail level 1 break buff 0 UDVMMEMORYSIZE 8 0x00 FF buff 1 UDVMMEMORYSIZE 0x00 FF buff 2 0 buff 3 16 buff 4 0 buff 5 1 buff 6 byte code id len 8 0x00 FF buff 7 byte code id len 0x00 FF buff 8 byte code state len 8 0x00 FF buff 9 byte code state len 0x00 FF code length tvb reported length remaining bytecode tvb 0 cycles per bit buff 2 8 cycles per bit cycles per bit buff 3 maximum UDVM cycles 8 header len msg end 1000 cycles per bit proto tree add uint udvm tree hf sigcomp message length bytecode tvb offset 1 msg end proto tree add uint udvm tree hf sigcomp byte code length bytecode tvb offset 1 code length proto tree add uint udvm tree hf sigcomp max udvm cycles bytecode tvb offset 1 maximum UDVM cycles i udvm mem dest if print level 3 proto tree add uint udvm tree hf sigcomp load bytecode into udvm start bytecode tvb offset 1 i while code length offset i UDVMMEMORYSIZE buff i tvb get guint8 bytecode tvb offset if print level 3 proto tree add uint format udvm tree hf sigcomp instruction code bytecode tvb offset 1 buff i Addr u Instruction code 0x 02x i buff i i offset current address udvm start ip input address 0 proto tree add uint format udvm tree hf sigcomp udvm execution stated bytecode tvb offset 1 current address UDVMEXECUTIONSTARTED at Address u Message size u current address msg end out buff guint8 g malloc UDVMMEMORYSIZE offset 0 execute next instruction if used udvm cycles maximum UDVM cycles result code 15 goto decompression failure used udvm cycles current instruction buff current address 0xffff if show instr detail level 2 addr item proto tree add uint format udvm tree hf sigcomp current instruction bytecode tvb offset 1 current instruction Addr u s d current address val to str ext const current instruction udvm instruction code vals ext INVALIDINSTRUCTION current instruction offset switch current instruction case SIGCOMPINSTRDECOMPRESSIONFAILURE if result code 0 result code 9 proto tree add uint format udvm tree hf sigcomp decompression failure NULL 0 0 current address Addr u DECOMPRESSIONFAILURE 0 current address proto tree add uint udvm tree hf sigcomp wireshark udvm diagnostic NULL 0 0 result code if output address 0 decomp tvb tvb new child real data message tvb out buff output address output address tvb set free cb decomp tvb g free add new data source pinfo decomp tvb Decompressed Sig Comp message Incomplete proto tree add expert udvm tree pinfo ei sigcomp sigcomp message decompression failure decomp tvb 0 1 return decomp tvb g free out buff return NULL break case SIGCOMPINSTRAND if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u AND operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTROR if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u OR operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRNOT if show instr detail level 2 proto item append text addr item operand 1 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u NOT operand 1 u current address operand 1 result operand 1 0xffff lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRLSHIFT if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 ti proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 if operand 2 15 expert add info pinfo ti ei sigcomp invalid shift value break offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u LSHIFT operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRRSHIFT if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 ti proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 if operand 2 15 expert add info pinfo ti ei sigcomp invalid shift value break offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u RSHIFT operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRADD if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u ADD operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction case SIGCOMPINSTRSUBTRACT if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u SUBTRACT operand 1 u operand 2 u current address operand 1 operand 2 result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRMULTIPLY if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u MULTIPLY operand 1 u operand 2 u current address operand 1 operand 2 if operand 2 0 result code 4 goto decompression failure result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRDIVIDE if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u DIVIDE operand 1 u operand 2 u current address operand 1 operand 2 if operand 2 0 result code 4 goto decompression failure result operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRREMAINDER if show instr detail level 2 proto item append text addr item operand 1 operand 2 start offset offset operand address current address 1 next operand address dissect udvm reference operand memory buff operand address operand 1 result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 1 bytecode tvb offset next operand address operand address operand 1 Addr u operand 1 u operand address operand 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address operand 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm operand 2 bytecode tvb offset next operand address operand address operand 2 Addr u operand 2 u operand address operand 2 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u REMAINDER operand 1 u operand 2 u current address operand 1 operand 2 if operand 2 0 result code 4 goto decompression failure result operand 1 operand 2 operand 1 operand 2 lsb result 0xff msb result 8 buff result dest msb buff result dest 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading result u at u result result dest current address next operand address goto execute next instruction break case SIGCOMPINSTRSORTASCENDING if show instr detail level 2 proto item append text addr item start n k proto tree add expert udvm tree pinfo ei sigcomp execution of this instruction is not implemented bytecode tvb 0 1 break case SIGCOMPINSTRSORTDESCENDING if show instr detail level 2 proto item append text addr item start n k proto tree add expert udvm tree pinfo ei sigcomp execution of this instruction is not implemented bytecode tvb 0 1 break case SIGCOMPINSTRSHA 1 if show instr detail level 2 proto item append text addr item position length destination operand address current address 1 next operand address decode udvm multitype operand buff operand address position if next operand address 0 goto decompression failure if print level 1 proto tree add uint format udvm tree hf udvm position bytecode tvb offset next operand address operand address position Addr u position u operand address position offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if print level 1 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address dissect udvm reference operand memory buff operand address ref destination result dest if next operand address 0 goto decompression failure if print level 1 proto tree add uint format udvm tree hf udvm ref dest bytecode tvb offset next operand address operand address ref destination Addr u destination u operand address ref destination offset next operand address operand address used udvm cycles used udvm cycles length n 0 k position byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb 0 1 NULL byte copy right u byte copy right sha1 starts ctx while n length guint16 handle now length if k byte copy right byte copy right k length n handle now byte copy right position if k handle now UDVMMEMORYSIZE n handle now UDVMMEMORYSIZE goto decompression failure sha1 update ctx buff k handle now k k handle now 0xffff n n handle now 0xffff if k byte copy right k byte copy left sha1 finish ctx sha1 digest buf k ref destination for n 0 n STATEBUFFERSIZE n buff k sha1 digest buf n k k 1 0xffff n if k byte copy right k byte copy left if print level 2 proto tree add bytes with length udvm tree hf sigcomp calculated sha 1 message tvb 0 1 sha1 digest buf STATEBUFFERSIZE current address next operand address goto execute next instruction break case SIGCOMPINSTRLOAD if show instr detail level 2 proto item append text addr item address value start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address addr if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm address bytecode tvb offset next operand address operand address addr Addr u Address u operand address addr offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address value if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm value bytecode tvb offset next operand address operand address value Addr u Value u operand address value offset next operand address operand address lsb value 0xff msb value 8 buff addr msb buff addr 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u LOAD address u value u current address addr value proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Loading bytes at u Value u 0x x addr value value current address next operand address goto execute next instruction break case SIGCOMPINSTRMULTILOAD if show instr detail level 2 proto item append text addr item address n value 0 value n 1 start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address addr if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm address bytecode tvb offset next operand address operand address addr Addr u Address u operand address addr offset next operand address operand address operand address next operand address next operand address decode udvm literal operand buff operand address n if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm literal num bytecode tvb offset next operand address operand address n Addr u n u operand address n offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u MULTILOAD address u n u value 0 value d current address addr n n 1 operand address next operand address used udvm cycles used udvm cycles n while n 0 n n 1 next operand address decode udvm multitype operand buff operand address value if next operand address 0 goto decompression failure lsb value 0xff msb value 8 if addr UDVMMEMORYSIZE 1 goto decompression failure buff addr msb buff addr 1 0xffff lsb length next operand address operand address if print level 1 proto tree add none format udvm tree hf sigcomp loading result bytecode tvb 0 1 Addr u Value 5u Loading bytes at 5u Value 5u 0x x operand address value addr value value addr addr 2 operand address next operand address current address next operand address goto execute next instruction break case SIGCOMPINSTRPUSH if show instr detail level 2 proto item append text addr item value start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address value if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm value bytecode tvb offset next operand address operand address value Addr u Value u operand address value offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u PUSH value u current address value current address next operand address stack location buff 70 8 buff 71 stack fill buff stack location 8 buff stack location 1 0x FFFF addr stack location stack fill 2 2 0x FFFF if addr UDVMMEMORYSIZE 1 goto decompression failure buff addr value 8 0x00 FF buff addr 1 0x FFFF value 0x00 FF if stack location UDVMMEMORYSIZE 1 goto decompression failure stack fill stack fill 1 0x FFFF buff stack location stack fill 8 0x00 FF buff stack location 1 0x FFFF stack fill 0x00 FF goto execute next instruction break case SIGCOMPINSTRPOP if show instr detail level 2 proto item append text addr item value start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address destination if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm address bytecode tvb offset next operand address operand address destination Addr u Value u operand address destination offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u POP address u current address destination current address next operand address stack location buff 70 8 buff 71 stack fill buff stack location 8 buff stack location 1 0x FFFF if stack fill 0 result code 16 goto decompression failure if stack location UDVMMEMORYSIZE 1 goto decompression failure stack fill stack fill 1 0x FFFF buff stack location stack fill 8 0x00 FF buff stack location 1 0x FFFF stack fill 0x00 FF addr stack location stack fill 2 2 0x FFFF if addr UDVMMEMORYSIZE 1 goto decompression failure value buff addr 8 buff addr 1 0x FFFF if destination UDVMMEMORYSIZE 1 goto decompression failure buff destination value 8 0x00 FF buff destination 1 0x FFFF value 0x00 FF goto execute next instruction break case SIGCOMPINSTRCOPY if show instr detail level 2 proto item append text addr item position length destination start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address position if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm position bytecode tvb offset next operand address operand address position Addr u position u operand address position offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address destination if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm ref dest bytecode tvb offset next operand address operand address destination Addr u Destination u operand address destination offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u COPY position u length u destination u current address position length destination current address next operand address n 0 k destination byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy right u byte copy right while n length buff k buff position if print level 2 proto tree add uint format udvm tree hf sigcomp copying value message tvb input address 1 buff position Copying value u 0x x to Addr u buff position buff position k position position 1 0xffff k k 1 0xffff n if k byte copy right k byte copy left if position byte copy right position byte copy left used udvm cycles used udvm cycles length goto execute next instruction break case SIGCOMPINSTRCOPYLITERAL if show instr detail level 2 proto item append text addr item position length destination start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address position if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm position bytecode tvb offset next operand address operand address position Addr u position u operand address position offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address dissect udvm reference operand memory buff operand address ref destination result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm ref dest bytecode tvb offset next operand address operand address ref destination Addr u destination u operand address ref destination offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u COPYLITERAL position u length u destination u current address position length ref destination current address next operand address n 0 k ref destination byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy right u byte copy right while n length buff k buff position if print level 2 proto tree add uint format udvm tree hf sigcomp copying value message tvb input address 1 buff position Copying value u 0x x to Addr u buff position buff position k position position 1 0xffff k k 1 0xffff n if k byte copy right k byte copy left if position byte copy right position byte copy left buff result dest k 8 buff result dest 1 0xffff k 0x00ff used udvm cycles used udvm cycles length goto execute next instruction break case SIGCOMPINSTRCOPYOFFSET if show instr detail level 2 proto item append text addr item offset length destination start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address multy offset if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm offset bytecode tvb offset next operand address operand address multy offset Addr u offset u operand address multy offset offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address dissect udvm reference operand memory buff operand address ref destination result dest if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm ref dest bytecode tvb offset next operand address operand address ref destination Addr u destination u operand address ref destination offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u COPYOFFSET offset u length u destination u current address multy offset length result dest current address next operand address byte copy left buff 64 8 byte copy left byte copy left buff 65 byte copy right buff 66 8 byte copy right byte copy right buff 67 for position ref destination i 0 i multy offset i if position byte copy left position byte copy right 1 0xffff else position position 1 0xffff if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy left u byte copy right u position u byte copy left byte copy right position n 0 k ref destination if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy left u byte copy right u byte copy left byte copy right while n length buff k buff position if print level 2 proto tree add uint format udvm tree hf sigcomp copying value message tvb input address 1 buff position Copying value 5u 0x x from Addr u to Addr u buff position buff position position k n k k 1 0xffff position position 1 0xffff if k byte copy right k byte copy left if position byte copy right position byte copy left buff result dest k 8 buff result dest 1 k 0x00ff used udvm cycles used udvm cycles length goto execute next instruction break case SIGCOMPINSTRMEMSET if show instr detail level 2 proto item append text addr item address length start value offset start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address addr if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm address bytecode tvb offset next operand address operand address addr Addr u Address u operand address addr offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address start value if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm start value bytecode tvb offset next operand address operand address start value Addr u start value u operand address start value offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address multy offset if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm offset bytecode tvb offset next operand address operand address multy offset Addr u offset u operand address multy offset offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u MEMSET address u length u start value u offset u current address addr length start value multy offset current address next operand address n 0 k addr byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy left u byte copy right u byte copy left byte copy right while n length if k byte copy right k byte copy left buff k start value n multy offset 0xff if print level 2 proto tree add uint format udvm tree hf sigcomp storing value message tvb input address 1 buff k Storing value u 0x x at Addr u buff k buff k k k k 1 0xffff n used udvm cycles used udvm cycles length goto execute next instruction break case SIGCOMPINSTRJUMP if show instr detail level 2 proto item append text addr item address start offset offset operand address current address 1 next operand address decode udvm address operand buff operand address at address current address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u JUMP address u current address at address current address at address goto execute next instruction break case SIGCOMPINSTRCOMPARE if show instr detail level 2 proto item append text addr item value 1 value 2 address 1 address 2 address 3 start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address value 1 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm value bytecode tvb offset next operand address operand address value 1 Addr u Value u operand address value 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address value 2 if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm value bytecode tvb offset next operand address operand address value 2 Addr u Value u operand address value 2 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address at address 1 if next operand address 0 goto decompression failure at address 1 current address at address 1 0xffff if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address 1 Addr u Address u operand address at address 1 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address at address 2 if next operand address 0 goto decompression failure at address 2 current address at address 2 0xffff if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address 2 Addr u Address u operand address at address 2 offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address at address 3 if next operand address 0 goto decompression failure at address 3 current address at address 3 0xffff if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address 3 Addr u Address u operand address at address 3 offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u COMPARE value 1 u value 2 u address 1 u address 2 u address 3 u current address value 1 value 2 at address 1 at address 2 at address 3 if value 1 value 2 current address at address 1 if value 1 value 2 current address at address 2 if value 1 value 2 current address at address 3 goto execute next instruction break case SIGCOMPINSTRCALL if show instr detail level 2 proto item append text addr item address PUSH addr start offset offset operand address current address 1 next operand address decode udvm address operand buff operand address at address current address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u CALL address u current address at address current address next operand address stack location buff 70 8 buff 71 stack fill buff stack location 8 buff stack location 1 0x FFFF addr stack location stack fill 2 2 0x FFFF if addr UDVMMEMORYSIZE 1 goto decompression failure buff addr current address 8 0x00 FF buff addr 1 0x FFFF current address 0x00 FF stack fill stack fill 1 0x FFFF if stack location UDVMMEMORYSIZE 1 goto decompression failure buff stack location stack fill 8 0x00 FF buff stack location 1 0x FFFF stack fill 0x00 FF current address at address goto execute next instruction break case SIGCOMPINSTRRETURN stack location buff 70 8 buff 71 stack fill buff stack location 8 buff stack location 1 0x FFFF if stack fill 0 result code 16 goto decompression failure stack fill stack fill 1 0x FFFF if stack location UDVMMEMORYSIZE 1 goto decompression failure buff stack location stack fill 8 0x00 FF buff stack location 1 0x FFFF stack fill 0x00 FF addr stack location stack fill 2 2 0x FFFF at address buff addr 8 buff addr 1 0x FFFF current address at address goto execute next instruction break case SIGCOMPINSTRSWITCH instruction address current address if show instr detail level 2 proto item append text addr item n j address 0 address 1 address n 1 operand address current address 1 next operand address decode udvm literal operand buff operand address n if next operand address 0 goto decompression failure if print level 2 proto tree add uint format udvm tree hf udvm literal num bytecode tvb offset next operand address operand address n Addr u n u operand address n offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address j if next operand address 0 goto decompression failure if print level 2 proto tree add uint format udvm tree hf udvm j bytecode tvb offset next operand address operand address j Addr u j u operand address j offset next operand address operand address operand address next operand address m 0 while m n next operand address decode udvm multitype operand buff operand address at address 1 if next operand address 0 goto decompression failure at address 1 instruction address at address 1 0xffff if print level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address 1 Addr u Address u operand address at address 1 offset next operand address operand address if j m current address at address 1 operand address next operand address m if j n j n result code 5 goto decompression failure if current address UDVMMEMORYSIZE result code 6 goto decompression failure used udvm cycles used udvm cycles n goto execute next instruction break case SIGCOMPINSTRCRC if show instr detail level 2 proto item append text addr item value position length address start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address value if next operand address 0 goto decompression failure if print level 2 proto tree add uint format udvm tree hf udvm value bytecode tvb offset next operand address operand address value Addr u Value u operand address value offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address position if next operand address 0 goto decompression failure if print level 2 proto tree add uint format udvm tree hf udvm position bytecode tvb offset next operand address operand address position Addr u position u operand address position offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if print level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address at address if next operand address 0 goto decompression failure at address current address at address 0xffff if print level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address used udvm cycles used udvm cycles length n 0 k position byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 result 0 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb 0 1 NULL byte copy right u byte copy right while n length guint16 handle now length n if k byte copy right byte copy right k length n handle now byte copy right k if k handle now UDVMMEMORYSIZE goto decompression failure result crc16 ccitt seed buff k handle now guint16 result 0xffff k k handle now 0xffff n n handle now 0xffff if k byte copy right k byte copy left result result 0xffff if print level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Calculated CRC u result if result value current address at address else current address next operand address goto execute next instruction break case SIGCOMPINSTRINPUTBYTES if show instr detail level 2 proto item append text addr item length destination address start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u Length u operand address length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address destination if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm destination bytecode tvb offset next operand address operand address destination Addr u Destination u operand address destination offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address at address if next operand address 0 goto decompression failure at address current address at address 0xffff if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u INPUTBYTES length u destination u address u current address length destination at address n 0 k destination byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 1 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy right u byte copy right remaining bits 0 input bits 0 while n length if input address msg end 1 current address at address result code 14 goto execute next instruction if k byte copy right k byte copy left octet tvb get guint8 message tvb input address buff k octet if print level 1 proto tree add uint format udvm tree hf sigcomp loading value message tvb input address 1 octet Loading value u 0x x at Addr u octet octet k input address k k 1 0xffff n used udvm cycles used udvm cycles length current address next operand address goto execute next instruction break case SIGCOMPINSTRINPUTBITS if show instr detail level 2 proto item append text addr item length destination address start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm length bytecode tvb offset next operand address operand address length Addr u length u operand address length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address destination if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm destination bytecode tvb offset next operand address operand address destination Addr u Destination u operand address destination offset next operand address operand address operand address next operand address next operand address decode udvm address operand buff operand address at address current address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u INPUTBITS length u destination u address u current address length destination at address current address next operand address input bit order buff 68 8 input bit order input bit order buff 69 if length 16 result code 7 goto decompression failure if input bit order 7 result code 8 goto decompression failure bit order input bit order 0x0004 2 value decomp dispatch get bits message tvb udvm tree bit order buff old input bit order remaining bits input bits input address length result code msg end print level 1 if result code 11 current address at address goto execute next instruction msb value 8 lsb value 0x00ff if destination UDVMMEMORYSIZE 1 goto decompression failure buff destination msb buff destination 1 0xffff lsb if print level 1 proto tree add none format udvm tree hf sigcomp loading result message tvb input address 1 Loading value u 0x x at Addr u remaining bits u value value destination remaining bits goto execute next instruction break case SIGCOMPINSTRINPUTHUFFMAN if show instr detail level 2 proto item append text addr item destination address n bits 1 lower bound 1 upper bound 1 uncompressed 1 bits n lower bound n upper bound n uncompressed n start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address destination if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm destination bytecode tvb offset next operand address operand address destination Addr u Destination u operand address destination offset next operand address operand address operand address next operand address next operand address decode udvm address operand buff operand address at address current address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm at address bytecode tvb offset next operand address operand address at address Addr u Address u operand address at address offset next operand address operand address operand address next operand address next operand address decode udvm literal operand buff operand address n if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm literal num bytecode tvb offset next operand address operand address n Addr u n u operand address n offset next operand address operand address operand address next operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u INPUTHUFFMAN destination u address u n u bits 1 lower 1 upper 1 unc 1 bits d lower d upper d unc d current address destination at address n n n n n used udvm cycles used udvm cycles n input bit order buff 68 8 input bit order input bit order buff 69 bit order input bit order 0x0002 1 j 1 H 0 m n outside huffman boundaries TRUE print in loop print level 3 while m 0 next operand address decode udvm multitype operand buff operand address bits n if next operand address 0 goto decompression failure if print in loop proto tree add uint format udvm tree hf udvm bits bytecode tvb offset next operand address operand address bits n Addr u bits n u operand address bits n if bits n 31 break offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address lower bound n if next operand address 0 goto decompression failure if print in loop proto tree add uint format udvm tree hf udvm lower bound bytecode tvb offset next operand address operand address lower bound n Addr u lower bound n u operand address lower bound n offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address upper bound n if next operand address 0 goto decompression failure if print in loop proto tree add uint format udvm tree hf udvm upper bound bytecode tvb offset next operand address operand address upper bound n Addr u upper bound n u operand address upper bound n offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address uncompressed n if next operand address 0 goto decompression failure if print in loop proto tree add uint format udvm tree hf udvm uncompressed bytecode tvb offset next operand address operand address uncompressed n Addr u uncompressed n u operand address uncompressed n offset next operand address operand address operand address next operand address if outside huffman boundaries k decomp dispatch get bits message tvb udvm tree bit order buff old input bit order remaining bits input bits input address bits n result code msg end print level 1 if result code 11 current address at address goto execute next instruction old HHHH bits n k if print level 3 proto tree add bytes format udvm tree hf sigcomp set hu bytecode tvb 0 1 NULL Set H u H u 2 bits j u k u H old H 1 bits n k if H lower bound n H upper bound n outside huffman boundaries TRUE else outside huffman boundaries FALSE print in loop FALSE if print level 2 proto tree add bytes format udvm tree hf sigcomp set hu bytecode tvb 0 1 NULLH u H u uncompressed n u lower bound n u H uncompressed n lower bound n H uncompressed n lower bound n HH uncompressed n lower bound n msb H 8 lsb H 0x00ff if destination UDVMMEMORYSIZE 1 goto decompression failure buff destination msb buff destination 1 0xffff lsb if print level 1 proto tree add uint format udvm tree hf sigcomp loading h message tvb input address 1 H Loading H u 0x x at Addr u j u remaining bits u HH destination n m 1 remaining bits m m 1 if outside huffman boundaries result code 10 goto decompression failure current address next operand address goto execute next instruction break case SIGCOMPINSTRSTATEACCESS if show instr detail level 2 proto item append text addr item partial identifier start partial identifier length state begin state length state address state instruction start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address p id start if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf partial identifier start bytecode tvb offset next operand address operand address p id start Addr u partial identifier start u operand address p id start offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address p id length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf partial identifier length bytecode tvb offset next operand address operand address p id length Addr u partial identifier length u operand address p id length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state begin if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf state begin bytecode tvb offset next operand address operand address state begin Addr u state begin u operand address state begin offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state length bytecode tvb offset next operand address operand address state length Addr u state length u operand address state length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state address bytecode tvb offset next operand address operand address state address Addr u state address u operand address state address offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state instruction if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state instr bytecode tvb offset next operand address operand address state instruction Addr u state instruction u operand address state instruction offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u STATEACCESS 31 partial identifier start u partial identifier length u state begin u state length u state address u state instruction u current address p id start p id length state begin state length state address state instruction current address next operand address byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 2 proto tree add bytes format udvm tree hf sigcomp byte copy message tvb input address 1 NULL byte copy right u byte copy left u byte copy right byte copy left result code udvm state access message tvb udvm tree buff p id start p id length state begin state length state address state instruction hf id if result code 0 goto decompression failure used udvm cycles used udvm cycles state length goto execute next instruction break case SIGCOMPINSTRSTATECREATE if show instr detail level 2 proto item append text addr item state length state address state instruction minimum access length state retention priority start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address state length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state length bytecode tvb offset next operand address operand address state length Addr u state length u operand address state length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state address bytecode tvb offset next operand address operand address state address Addr u state address u operand address state address offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state instruction if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state instr bytecode tvb offset next operand address operand address state instruction Addr u state instruction u operand address state instruction offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address minimum access length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm min acc len bytecode tvb offset next operand address operand address minimum access length Addr u minimum access length u operand address minimum access length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state retention priority if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state ret pri bytecode tvb offset next operand address operand address state retention priority Addr u state retention priority u operand address state retention priority offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u STATECREATE 32 state length u state address u state instruction u minimum access length u state retention priority u current address state length state address state instruction minimum access length state retention priority current address next operand address no of state create if no of state create 4 result code 12 goto decompression failure if minimum access length 6 minimum access length STATEBUFFERSIZE result code 1 goto decompression failure if state retention priority 65535 result code 13 goto decompression failure state length buff no of state create state length state address buff no of state create state address state instruction buff no of state create state instruction state minimum access length buff no of state create minimum access length used udvm cycles used udvm cycles state length byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 n 0 k state address while n state length if k byte copy right k byte copy left string 0 buff k string 1 0 if print level 3 proto tree add uint format udvm tree hf sigcomp state value bytecode tvb 0 0 buff k Addr 5u State value u 0x x ASCII s k buff k buff k format text string 1 k k 1 0xffff n goto execute next instruction break case SIGCOMPINSTRSTATEFREE if show instr detail level 2 proto item append text addr item partial identifier start partial identifier length start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address p id start if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf partial identifier start bytecode tvb offset next operand address operand address p id start Addr u partial identifier start u operand address p id start offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address p id length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf partial identifier length bytecode tvb offset next operand address operand address p id length Addr u partial identifier length u operand address p id length offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u STATEFREE partial identifier start u partial identifier length u current address p id start p id length current address next operand address udvm state free buff p id start p id length goto execute next instruction break case SIGCOMPINSTROUTPUT if show instr detail level 2 proto item append text addr item output start output length start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address output start if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm output start bytecode tvb offset next operand address operand address output start Addr u output start u operand address output start offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address output length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm output length bytecode tvb offset next operand address operand address output length Addr u output length u operand address output length offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u OUTPUT output start u output length u current address output start output length current address next operand address n 0 k output start byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 if print level 3 proto tree add bytes format udvm tree hf sigcomp byte copy bytecode tvb 0 1 NULL byte copy right u byte copy right while n output length if k byte copy right k byte copy left out buff output address buff k string 0 buff k string 1 0 if print level 3 proto tree add uint format udvm tree hf sigcomp output value bytecode tvb 0 1 buff k Output value u 0x x ASCII s from Addr u output to dispatcher position u buff k buff k format text string 1 k output address k k 1 0xffff output address n used udvm cycles used udvm cycles output length goto execute next instruction break case SIGCOMPINSTRENDMESSAGE if show instr detail level 2 proto item append text addr item requested feedback location state instruction minimum access length state retention priority start offset offset operand address current address 1 next operand address decode udvm multitype operand buff operand address requested feedback location if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm req feedback loc bytecode tvb offset next operand address operand address requested feedback location Addr u requested feedback location u operand address requested feedback location offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address returned parameters location if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm ret param loc bytecode tvb offset next operand address operand address returned parameters location Addr u returned parameters location u operand address returned parameters location offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state length bytecode tvb offset next operand address operand address state length Addr u state length u operand address state length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state address if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state address bytecode tvb offset next operand address operand address state address Addr u state address u operand address state address offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state instruction if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state instr bytecode tvb offset next operand address operand address state instruction Addr u state instruction u operand address state instruction offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address minimum access length if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm min acc len bytecode tvb offset next operand address operand address minimum access length Addr u minimum access length u operand address minimum access length offset next operand address operand address operand address next operand address next operand address decode udvm multitype operand buff operand address state retention priority if next operand address 0 goto decompression failure if show instr detail level 2 proto tree add uint format udvm tree hf udvm state ret pri bytecode tvb offset next operand address operand address state retention priority Addr u state retention priority u operand address state retention priority offset next operand address operand address if show instr detail level 1 proto tree add none format udvm tree hf sigcomp decompress instruction bytecode tvb start offset offset start offset Addr u ENDMESSAGE requested feedback location u returned parameters location u state length u state address u state instruction u minimum access length u state retention priority u current address requested feedback location returned parameters location state length state address state instruction minimum access length state retention priority no of state create if no of state create 4 result code 12 goto decompression failure state length buff no of state create state length state address buff no of state create state address state instruction buff no of state create state instruction state minimum access length buff no of state create minimum access length proto tree add uint udvm tree hf sigcomp num state create bytecode tvb 0 0 no of state create if no of state create 0 memset sha1 digest buf 0 STATEBUFFERSIZE n 1 byte copy right buff 66 8 byte copy right byte copy right buff 67 byte copy left buff 64 8 byte copy left byte copy left buff 65 while n no of state create 1 sha1buff guint8 g malloc state length buff n 8 sha1buff 0 state length buff n 8 sha1buff 1 state length buff n 0xff sha1buff 2 state address buff n 8 sha1buff 3 state address buff n 0xff sha1buff 4 state instruction buff n 8 sha1buff 5 state instruction buff n 0xff sha1buff 6 state minimum access length buff n 8 sha1buff 7 state minimum access length buff n 0xff if print level 3 proto tree add bytes with length udvm tree hf sigcomp sha1buff bytecode tvb 0 1 sha1buff 8 k state address buff n for x 0 x state length buff n x if k byte copy right k byte copy left sha1buff 8 x buff k k k 1 0xffff sha1 starts ctx sha1 update ctx guint8 sha1buff state length buff n 8 sha1 finish ctx sha1 digest buf if print level 3 proto tree add bytes with length udvm tree hf sigcomp sha1 digest bytecode tvb 0 1 sha1 digest buf STATEBUFFERSIZE proto tree add item udvm tree hf sigcomp creating state bytecode tvb 0 1 ENCNA proto tree add string udvm tree hf id bytecode tvb 0 0 bytes to str wmem packet scope sha1 digest buf STATEMINACCESSLEN n decomp tvb tvb new child real data message tvb out buff output address output address tvb set free cb decomp tvb g free add new data source pinfo decomp tvb Decompressed Sig Comp message proto tree add item udvm tree hf sigcomp sigcomp message decompressed decomp tvb 0 1 ENCNA used udvm cycles state length proto tree add uint udvm tree hf sigcomp max udvm cycles bytecode tvb 0 0 maximum UDVM cycles proto tree add uint udvm tree hf sigcomp used udvm cycles bytecode tvb 0 0 used udvm cycles return decomp tvb break default expert add info format pinfo addr item ei sigcomp invalid instruction Addr u Invalid instruction u 0x x current address current instruction current instruction break g free out buff return NULL decompression failure proto tree add expert format udvm tree pinfo ei sigcomp decompression failure bytecode tvb 0 1 DECOMPRESSIONFAILURE s val to str result code result code vals Unknown u g free out buff return void jpc qmfb split colres jpc fix t a int numrows int numcols int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr numcols srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr numcols if buf splitbuf jas free buf static void adjust arnr filter V P9 COMP cpi int distance int group boost int arnr frames int arnr strength const V P9 Encoder Config const oxcf cpi oxcf const int frames after arf vp9 lookahead depth cpi lookahead distance 1 int frames fwd cpi oxcf arnr max frames 1 1 int frames bwd int q frames strength if frames fwd frames after arf frames fwd frames after arf if frames fwd distance frames fwd distance frames bwd frames fwd if frames bwd distance frames bwd oxcf arnr max frames 1 0x1 frames frames bwd 1 frames fwd if cpi common current video frame 1 q int vp9 convert qindex to q cpi rc avg frame qindex INTERFRAME else q int vp9 convert qindex to q cpi rc avg frame qindex KEYFRAME if q 16 strength oxcf arnr strength else strength oxcf arnr strength 16 q 2 if strength 0 strength 0 if frames group boost 150 frames group boost 150 frames frames 1 if strength group boost 300 strength group boost 300 if cpi oxcf pass 2 cpi multi arf allowed const GFGROUP const gf group cpi twopass gf group if gf group rf level gf group index GFARFSTD strength 1 arnr frames frames arnr strength strength static int dissect udvm reference operand memory guint8 buff guint operand address guint16 value guint result dest guint bytecode guint16 operand guint offset operand address guint test bits guint8 temp data guint16 temp data16 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 7 if test bits 1 test bits bytecode 6 if test bits 2 temp data buff operand address 0x3f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 2 else operand address operand buff operand address 8 operand operand buff operand address 1 0xffff result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 3 else operand bytecode 0x7f operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset if offset UDVMMEMORYSIZE result dest UDVMMEMORYSIZE 1 return 1 return offset static void auto partition range V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE min block size BLOCKSIZE max block size V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO mi 8x8 xd mi const int left in image xd left available mi 8x8 1 src mi const int above in image xd up available mi 8x8 xd mi stride src mi int row8x8 remaining tile mi row end mi row int col8x8 remaining tile mi col end mi col int bh bw BLOCKSIZE min size BLOCK 32 X32 BLOCKSIZE max size BLOCK 8 X8 int bsl mi width log2 BLOCK 64 X64 const int search range ctrl mi row mi col bsl get chessboard index cm current video frame 0x1 if search range ctrl left in image above in image cm frame type KEYFRAME int block MODEINFO mi BLOCKSIZE sb type if left in image MODEINFO cur mi mi mi 8x8 1 src mi for block 0 block MIBLOCKSIZE block cur mi mi block xd mi stride src mi sb type cur mi cur mi mbmi sb type 0 min size MIN min size sb type max size MAX max size sb type if above in image mi mi 8x8 xd mi stride MIBLOCKSIZE src mi for block 0 block MIBLOCKSIZE block sb type mi block src mi mi block src mi mbmi sb type 0 min size MIN min size sb type max size MAX max size sb type min size min partition size min size max size find partition size max size row8x8 remaining col8x8 remaining bh bw min size MIN min size max size min size MAX min size BLOCK 8 X8 max size MIN max size BLOCK 32 X32 else min size BLOCK 8 X8 max size BLOCK 32 X32 min block size min size max block size max size static int finish frame AV Codec Context avctx AV Frame pict R V34 Dec Context r avctx priv data Mpeg Enc Context s r s int got picture 0 ret ff er frame end s er ff MPV frame end s s mb num left 0 if HAVETHREADS s avctx active thread type FFTHREADFRAME ff thread report progress s current picture ptr tf INTMAX 0 if s pict type AVPICTURETYPEB s low delay if ret av frame ref pict s current picture ptr f 0 return ret ff print debug info s s current picture ptr got picture 1 else if s last picture ptr NULL if ret av frame ref pict s last picture ptr f 0 return ret ff print debug info s s last picture ptr got picture 1 return got picture static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size C93 Decoder Context const c93 avctx priv data AV Frame const newpic c93 pictures c93 currentpic AV Frame const oldpic c93 pictures c93 currentpic 1 AV Frame picture data Get Byte Context gb uint8 t out int stride ret i x y b bt 0 c93 currentpic 1 newpic reference 1 newpic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLEFFBUFFERHINTSREADABLE if ret avctx reget buffer avctx newpic 0 av log avctx AVLOGERROR reget buffer failed n return ret stride newpic linesize 0 bytestream2 init gb buf buf size b bytestream2 get byte gb if b C93 FIRSTFRAME newpic pict type AVPICTURETYPEI newpic key frame 1 else newpic pict type AVPICTURETYPEP newpic key frame 0 for y 0 y HEIGHT y 8 out newpic data 0 y stride for x 0 x WIDTH x 8 uint8 t copy from oldpic data 0 unsigned int offset j uint8 t cols 4 grps 4 C93 Block Type block type if bt bt bytestream2 get byte gb block type bt 0x0 F switch block type case C93 8 X8 FROMPREV offset bytestream2 get le16 gb if ret copy block avctx out copy from offset 8 stride 0 return ret break case C93 4 X4 FROMCURR copy from newpic data 0 case C93 4 X4 FROMPREV for j 0 j 8 j 4 for i 0 i 8 i 4 offset bytestream2 get le16 gb if ret copy block avctx out j stride i copy from offset 4 stride 0 return ret break case C93 8 X8 2 COLOR bytestream2 get buffer gb cols 2 for i 0 i 8 i draw n color out i stride stride 8 1 1 cols NULL bytestream2 get byte gb break case C93 4 X4 2 COLOR case C93 4 X4 4 COLOR case C93 4 X4 4 COLORGRP for j 0 j 8 j 4 for i 0 i 8 i 4 if block type C93 4 X4 2 COLOR bytestream2 get buffer gb cols 2 draw n color out i j stride stride 4 4 1 cols NULL bytestream2 get le16 gb else if block type C93 4 X4 4 COLOR bytestream2 get buffer gb cols 4 draw n color out i j stride stride 4 4 2 cols NULL bytestream2 get le32 gb else bytestream2 get buffer gb grps 4 draw n color out i j stride stride 4 4 1 cols grps bytestream2 get le16 gb break case C93 NOOP break case C93 8 X8 INTRA for j 0 j 8 j bytestream2 get buffer gb out j stride 8 break default av log avctx AVLOGERROR unexpected type x at dx d n block type x y return AVERRORINVALIDDATA bt 4 out 8 if b C93 HASPALETTE uint32 t palette uint32 t newpic data 1 for i 0 i 256 i palette i bytestream2 get be24 gb newpic palette has changed 1 else if oldpic data 1 memcpy newpic data 1 oldpic data 1 256 4 picture newpic got frame 1 return buf size static int qtrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Qtrle Context s avctx priv data int header start line int height row ptr int has palette 0 int ret bytestream2 init s g avpkt data avpkt size if ret ff reget buffer avctx s frame 0 av log s avctx AVLOGERROR reget buffer failed n return ret if avpkt size 8 goto done bytestream2 seek s g 4 SEEKSET header bytestream2 get be16 s g if header 0x0008 if avpkt size 14 goto done start line bytestream2 get be16 s g bytestream2 skip s g 2 height bytestream2 get be16 s g bytestream2 skip s g 2 else start line 0 height s avctx height row ptr s frame linesize 0 start line switch avctx bits per coded sample case 1 case 33 qtrle decode 1bpp s row ptr height break case 2 case 34 qtrle decode 2n4bpp s row ptr height 2 has palette 1 break case 4 case 36 qtrle decode 2n4bpp s row ptr height 4 has palette 1 break case 8 case 40 qtrle decode 8bpp s row ptr height has palette 1 break case 16 qtrle decode 16bpp s row ptr height break case 24 qtrle decode 24bpp s row ptr height break case 32 qtrle decode 32bpp s row ptr height break default av log s avctx AVLOGERROR Unsupported colorspace d bits sample n avctx bits per coded sample break if has palette const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE done if ret av frame ref data s frame 0 return ret got frame 1 return avpkt size static bool vmxnet tx pkt parse headers struct Vmxnet Tx Pkt pkt struct iovec l2 hdr l3 hdr size t bytes read size t full ip6hdr len uint16 t l3 proto assert pkt l2 hdr pkt vec VMXNETTXPKT L2 HDRFRAG l3 hdr pkt vec VMXNETTXPKT L3 HDRFRAG bytes read iov to buf pkt raw pkt raw frags 0 l2 hdr iov base ETHMAX L2 HDRLEN if bytes read sizeof struct eth header l2 hdr iov len 0 return false l2 hdr iov len sizeof struct eth header switch be16 to cpu PKTGETETHHDR l2 hdr iov base h proto case ETHPVLAN l2 hdr iov len sizeof struct vlan header break case ETHPDVLAN l2 hdr iov len 2 sizeof struct vlan header break if bytes read l2 hdr iov len l2 hdr iov len 0 return false l3 proto eth get l3 proto l2 hdr iov base l2 hdr iov len switch l3 proto case ETHPIP l3 hdr iov base g malloc ETHMAXI P4 HDRLEN bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base sizeof struct ip header if bytes read sizeof struct ip header l3 hdr iov len 0 return false l3 hdr iov len IPHDRGETLEN l3 hdr iov base pkt l4proto struct ip header l3 hdr iov base ip p bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len sizeof struct ip header l3 hdr iov base sizeof struct ip header l3 hdr iov len sizeof struct ip header if bytes read l3 hdr iov len sizeof struct ip header l3 hdr iov len 0 return false break case ETHPIP V6 if eth parse ipv6 hdr pkt raw pkt raw frags l2 hdr iov len pkt l4proto full ip6hdr len l3 hdr iov len 0 return false l3 hdr iov base g malloc full ip6hdr len bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base full ip6hdr len if bytes read full ip6hdr len l3 hdr iov len 0 return false else l3 hdr iov len full ip6hdr len break default l3 hdr iov len 0 break vmxnet tx pkt calculate hdr len pkt pkt packet type get eth packet type l2 hdr iov base return true int x catch free colors Display dpy X Error Event err if err request code X Free Colors return 0 return x error handler orighandler dpy err static void inverse transform block MACROBLOCKD xd int plane int block TXSIZE tx size uint8 t dst int stride int eob struct macroblockd plane const pd xd plane plane if eob 0 TXTYPE tx type DCTDCT tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block if xd lossless tx type DCTDCT vp9 iwht4x4 add dqcoeff dst stride eob else const PLANETYPE plane type pd plane type switch tx size case TX 4 X4 tx type get tx type 4x4 plane type xd block vp9 iht4x4 add tx type dqcoeff dst stride eob break case TX 8 X8 tx type get tx type plane type xd vp9 iht8x8 add tx type dqcoeff dst stride eob break case TX 16 X16 tx type get tx type plane type xd vp9 iht16x16 add tx type dqcoeff dst stride eob break case TX 32 X32 tx type DCTDCT vp9 idct32x32 add dqcoeff dst stride eob break default assert 0 Invalid transform size if eob 1 vpx memset dqcoeff 0 2 sizeof dqcoeff 0 else if tx type DCTDCT tx size TX 16 X16 eob 10 vpx memset dqcoeff 0 4 4 tx size sizeof dqcoeff 0 else if tx size TX 32 X32 eob 34 vpx memset dqcoeff 0 256 sizeof dqcoeff 0 else vpx memset dqcoeff 0 16 tx size 1 sizeof dqcoeff 0 int vp9 receive raw frame V P9 COMP cpi unsigned int frame flags Y V12 BUFFERCONFIG sd int64 t time stamp int64 t end time V P9 COMMON cm cpi common struct vpx usec timer timer int res 0 const int subsampling x sd uv width sd y width const int subsampling y sd uv height sd y height check initial width cpi subsampling x subsampling y vpx usec timer start timer else endif res vp9 lookahead push cpi lookahead sd time stamp end time frame flags if res res 1 vpx usec timer mark timer cpi time receive data vpx usec timer elapsed timer if cm profile PROFILE 0 cm profile PROFILE 2 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM Non 4 2 0 color space requires profile 1 or 3 res 1 if cm profile PROFILE 1 cm profile PROFILE 3 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM 4 2 0 color space requires profile 0 or 2 res 1 return res void safeputs netdissect options ndo const u char s const u int maxlen u int idx 0 while idx maxlen s safeputchar ndo s idx s static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt WN V1 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data unsigned char YUV int i j ret int prev y 0 prev u 0 prev v 0 uint8 t rbuf rbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if rbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n av free rbuf return ret p key frame 1 for i 8 i buf size i rbuf i ff reverse buf i init get bits l gb rbuf 8 buf size 8 8 if buf 2 4 6 l shift 2 else l shift 8 buf 2 4 if l shift 4 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 4 if l shift 1 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 1 Y p data 0 U p data 1 V p data 2 for j 0 j avctx height j for i 0 i avctx width 2 i Y i 2 wnv1 get code l prev y prev u U i wnv1 get code l prev u prev y Y i 2 1 wnv1 get code l Y i 2 prev v V i wnv1 get code l prev v Y p linesize 0 U p linesize 1 V p linesize 2 got frame 1 av free rbuf return buf size static int sdp parse fmtp config h264 AV Format Context s AV Stream stream Payload Context h264 data const char attr const char value AV Codec Parameters par stream codecpar if strcmp attr packetization mode av log s AVLOGDEBUGRTP Packetization Mode d n atoi value h264 data packetization mode atoi value if h264 data packetization mode 1 av log s AVLOGERROR Interleaved RTP mode is not supported yet n else if strcmp attr profile level id if strlen value 6 parse profile level id s h264 data value else if strcmp attr sprop parameter sets int ret if value strlen value 1 av log s AVLOGWARNING Missing PPS in sprop parameter sets ignoring n return 0 par extradata size 0 av freep par extradata ret ff h264 parse sprop parameter sets s par extradata par extradata size value av log s AVLOGDEBUG Extradata set to p size d n par extradata par extradata size return ret return 0 static int decode frame header Prores Context ctx const uint8 t buf const int data size AV Codec Context avctx int hdr size version width height flags const uint8 t ptr hdr size AVR B16 buf if hdr size data size av log avctx AVLOGERROR frame data too small n return AVERRORINVALIDDATA version AVR B16 buf 2 if version 2 av log avctx AVLOGERROR unsupported header version d n version return AVERRORINVALIDDATA width AVR B16 buf 8 height AVR B16 buf 10 if width avctx width height avctx height av log avctx AVLOGERROR picture dimension changed old d x d new d x d n avctx width avctx height width height return AVERRORINVALIDDATA ctx frame type buf 12 2 3 if ctx frame type 2 av log avctx AVLOGERROR unsupported frame type d n ctx frame type return AVERRORINVALIDDATA ctx chroma factor buf 12 6 3 ctx mb chroma factor ctx chroma factor 2 ctx num chroma blocks 1 ctx chroma factor 1 switch ctx chroma factor case 2 avctx pix fmt AVPIXFMTYU V422 P10 break case 3 avctx pix fmt AVPIXFMTYU V444 P10 break default av log avctx AVLOGERROR unsupported picture format d n ctx pic format return AVERRORINVALIDDATA if ctx scantable type ctx frame type if ctx frame type ff init scantable ctx dsp idct permutation ctx scantable ff prores progressive scan else ff init scantable ctx dsp idct permutation ctx scantable ff prores interlaced scan ctx scantable type ctx frame type if ctx frame type ctx picture interlaced frame 1 ctx picture top field first ctx frame type 1 else ctx picture interlaced frame 0 avctx color primaries buf 14 avctx color trc buf 15 avctx colorspace buf 16 ctx alpha info buf 17 0xf if ctx alpha info av log missing feature avctx Alpha channel 0 ctx qmat changed 0 ptr buf 20 flags buf 19 if flags 2 if ptr buf hdr size 64 av log avctx AVLOGERROR header data too small n return AVERRORINVALIDDATA if memcmp ctx qmat luma ptr 64 memcpy ctx qmat luma ptr 64 ctx qmat changed 1 ptr 64 else memset ctx qmat luma 4 64 ctx qmat changed 1 if flags 1 if ptr buf hdr size 64 av log avctx AVLOGERROR header data too small n return 1 if memcmp ctx qmat chroma ptr 64 memcpy ctx qmat chroma ptr 64 ctx qmat changed 1 else memset ctx qmat chroma 4 64 ctx qmat changed 1 return hdr size static guint32 dissect minipacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet proto item item ts tvb get ntohs tvb offset iax packet iax2 get packet data for minipacket pinfo scallno FALSE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add uint iax2 tree hf iax2 minits tvb offset 2 ts iax2 add ts fields pinfo iax2 tree iax packet guint16 ts else iax2 add ts fields pinfo iax2 tree iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini packet source call d timestamp ums scallno ts dissect payload tvb offset pinfo iax2 tree main tree ts FALSE iax packet iax packet first time FALSE return offset static int mpeg4 decode partitioned mb Mpeg Enc Context s int16 t block 6 64 int cbp mb type const int xy s mb x s mb y s mb stride mb type s current picture f mb type xy cbp s cbp table xy s use intra dc vlc s qscale s intra dc threshold if s current picture f qscale table xy s qscale ff set qscale s s current picture f qscale table xy if s pict type AVPICTURETYPEP s pict type AVPICTURETYPES int i for i 0 i 4 i s mv 0 i 0 s current picture f motion val 0 s block index i 0 s mv 0 i 1 s current picture f motion val 0 s block index i 1 s mb intra ISINTRA mb type if ISSKIP mb type for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s mcsel 1 s mb skipped 0 else s mcsel 0 s mb skipped 1 else if s mb intra s ac pred ISACPRED s current picture f mb type xy else if s mb intra s mv dir MVDIRFORWARD if IS 8 X8 mb type s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 else s mb intra 1 s ac pred ISACPRED s current picture f mb type xy if ISSKIP mb type int i s dsp clear blocks s block 0 for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 s mb intra s rvlc 0 av log s avctx AVLOGERROR texture corrupted at d d d n s mb x s mb y s mb intra return 1 cbp cbp if s mb num left 0 if mpeg4 is resync s return SLICEEND else return SLICENOEND else if mpeg4 is resync s const int delta s mb x 1 s mb width 2 1 if s cbp table xy delta return SLICEEND return int vp9 get compressed data V P9 COMP cpi unsigned int frame flags size t size uint8 t dest int64 t time stamp int64 t time end int flush const V P9 Encoder Config const oxcf cpi oxcf V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd RATECONTROL const rc cpi rc struct vpx usec timer cmptimer Y V12 BUFFERCONFIG force src buffer NULL struct lookahead entry last source NULL struct lookahead entry source NULLMVREFERENCEFRAME ref frame int arf src index if is two pass svc cpi vpx usec timer start cmptimer vp9 set high precision mv cpi ALTREFHIGHPRECISIONMV cm reset frame context 0 cm refresh frame context 1 cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 arf src index get arf src index cpi if arf src index assert arf src index rc frames to key if source vp9 lookahead peek cpi lookahead arf src index NULL cpi alt ref source source int i for i cpi svc spatial layer id 1 i 0 i if oxcf ss play alternate i cpi gld fb idx cpi svc layer context i alt ref idx break cpi svc layer context cpi svc spatial layer id has alt frame 1 vp9 temporal filter cpi arf src index vp9 extend frame borders cpi alt ref buffer force src buffer cpi alt ref buffer cm show frame 0 cpi refresh alt ref frame 1 cpi refresh golden frame 0 cpi refresh last frame 0 rc is src frame alt ref 0 rc source alt ref pending 0 void vp9 setup in frame q adj V P9 COMP cpi V P9 COMMON const cm cpi common struct segmentation const seg cm seg vp9 clear system state if cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame cpi rc is src frame alt ref int segment const int aq strength get aq c strength cm base qindex const int active segments aq c active segments aq strength vpx memset cpi segmentation map 0 cm mi rows cm mi cols vpx memset cpi complexity map 0 cm mi rows cm mi cols vp9 clearall segfeatures seg if cpi rc sb64 target rate 256 vp9 disable segmentation seg return vp9 enable segmentation seg seg abs delta SEGMENTDELTADATA vp9 disable segfeature seg 0 SEGLVLALTQ for segment 1 segment active segments segment int qindex delta vp9 compute qdelta by rate cpi rc cm frame type cm base qindex aq c q adj factor aq strength segment if cm base qindex 0 cm base qindex qindex delta 0 qindex delta cm base qindex 1 if cm base qindex qindex delta 0 vp9 enable segfeature seg segment SEGLVLALTQ vp9 set segdata seg segment SEGLVLALTQ qindex delta static int evhttp parse request line struct evhttp request req char line char method char uri char version method strsep line if line NULL return 1 uri strsep line if line NULL return 1 version strsep line if line NULL return 1 if strcmp method GET 0 req type EVHTTPREQGET else if strcmp method POST 0 req type EVHTTPREQPOST else if strcmp method HEAD 0 req type EVHTTPREQHEAD else event debug s bad method s on request p from s func method req req remote host return 1 if strcmp version HTTP 1 0 0 req major 1 req minor 0 else if strcmp version HTTP 1 1 0 req major 1 req minor 1 else event debug s bad version s on request p from s func version req req remote host return 1 if req uri strdup uri NULL event debug s evhttp decode uri func return 1 if strlen req uri 0 req uri 0 req flags EVHTTPPROXYREQUEST return 0 static void find next key frame V P9 COMP cpi FIRSTPASSSTATS this frame int i j RATECONTROL const rc cpi rc TWOPASS const twopass cpi twopass GFGROUP const gf group twopass gf group const V P9 Encoder Config const oxcf cpi oxcf const FIRSTPASSSTATS first frame this frame const FIRSTPASSSTATS const start position twopass stats in FIRSTPASSSTATS next frame FIRSTPASSSTATS last frame int kf bits 0 int loop decay counter 0 double decay accumulator 1 0 double av decay accumulator 0 0 double zero motion accumulator 1 0 double boost score 0 0 double kf mod err 0 0 double kf group err 0 0 double recent loop decay 8 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 vp9 zero next frame cpi common frame type KEYFRAME vp9 zero gf group rc this key frame forced rc next key frame forced rc source alt ref active 0 cpi multi arf last grp enabled 0 rc frames till gf update due 0 rc frames to key 1 twopass kf group bits 0 twopass kf group error left 0 kf mod err calculate modified err twopass oxcf this frame i 0 while twopass stats in twopass stats in end rc frames to key cpi oxcf key freq kf group err calculate modified err twopass oxcf this frame last frame this frame input stats twopass this frame if cpi oxcf auto key twopass stats in twopass stats in end double loop decay rate if test candidate kf twopass last frame this frame twopass stats in break loop decay rate get prediction decay rate cpi common twopass stats in recent loop decay i 8 loop decay rate decay accumulator 1 0 for j 0 j 8 j decay accumulator recent loop decay j if detect transition to still twopass i cpi oxcf key freq i loop decay rate decay accumulator break rc frames to key if rc frames to key 2 cpi oxcf key freq break else rc frames to key i if cpi oxcf auto key rc frames to key cpi oxcf key freq FIRSTPASSSTATS tmp frame first frame rc frames to key 2 reset fpf position twopass start position kf group err 0 for i 0 i rc frames to key i kf group err calculate modified err twopass oxcf tmp frame input stats twopass tmp frame rc next key frame forced 1 else if twopass stats in twopass stats in end rc frames to key cpi oxcf key freq rc next key frame forced 1 else rc next key frame forced 0 if is two pass svc cpi cpi svc number temporal layers 1 int count 1 cpi svc number temporal layers 1 1 int new frame to key rc frames to key count count int j for j 0 j new frame to key rc frames to key j if EOF input stats twopass this frame break kf group err calculate modified err twopass oxcf this frame rc frames to key new frame to key if twopass stats in twopass stats in end kf group err calculate modified err twopass oxcf this frame if twopass bits left 0 twopass modified error left 0 0 const int max bits frame max bits rc cpi oxcf int64 t max grp bits twopass kf group bits int64 t twopass bits left kf group err twopass modified error left max grp bits int64 t max bits int64 t rc frames to key if twopass kf group bits max grp bits twopass kf group bits max grp bits else twopass kf group bits 0 twopass kf group bits MAX 0 twopass kf group bits reset fpf position twopass start position decay accumulator 1 0 boost score 0 0 for i 0 i rc frames to key 1 i if EOF input stats twopass next frame break zero motion accumulator MIN zero motion accumulator get zero motion factor cpi common next frame if i rc max gf interval i rc max gf interval 4 decay accumulator 0 5 const double frame boost calc frame boost cpi this frame 0 KFMAXBOOST if detect flash twopass 0 const double loop decay rate get prediction decay rate cpi common next frame decay accumulator loop decay rate decay accumulator MAX decay accumulator MINDECAYFACTOR av decay accumulator decay accumulator loop decay counter boost score decay accumulator frame boost av decay accumulator double loop decay counter reset fpf position twopass start position twopass kf zeromotion pct int zero motion accumulator 100 0 twopass section intra rating calculate section intra ratio start position twopass stats in end rc frames to key rc kf boost int av decay accumulator boost score rc kf boost MAX rc kf boost rc frames to key 3 rc kf boost MAX rc kf boost MINKFBOOST kf bits calculate boost bits rc frames to key 1 rc kf boost twopass kf group bits twopass kf group bits kf bits gf group bit allocation 0 kf bits gf group update type 0 KFUPDATE gf group rf level 0 KFSTD twopass kf group error left int kf group err kf mod err twopass modified error left kf group err int ieee80211 radiotap iterator init struct ieee80211 radiotap iterator iterator struct ieee80211 radiotap header radiotap header int max length const struct ieee80211 radiotap vendor namespaces vns if max length int sizeof struct ieee80211 radiotap header return EINVAL if radiotap header it version return EINVAL if max length get unaligned le16 radiotap header it len return EINVAL iterator rtheader radiotap header iterator max length get unaligned le16 radiotap header it len iterator arg index 0 iterator bitmap shifter get unaligned le32 radiotap header it present iterator arg guint8 radiotap header sizeof radiotap header iterator reset on ext 0 iterator next ns data NULL iterator next bitmap radiotap header it present iterator next bitmap iterator vns vns iterator current namespace radiotap ns iterator is radiotap ns 1 iterator overrides NULL if ITERATORVALID iterator sizeof guint32 return EINVAL while get unaligned le32 iterator arg 1 UIEE E80211 RADIOTAPEXT iterator arg sizeof guint32 if ITERATORVALID iterator sizeof guint32 return EINVAL iterator arg sizeof guint32 static void rv34 pred mv rv3 R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j k int mx my int avail r avail cache avail indexes 0 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail 4 2 if avail 4 avail 1 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride 2 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 2 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv 0 0 my r dmv 0 1 for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k s current picture ptr f motion val k mv pos i j s b8 stride 0 mx s current picture ptr f motion val k mv pos i j s b8 stride 1 my static void pred temp direct motion H264 Context const h int mb type int b8 stride 2 int b4 stride h b stride int mb xy h mb xy mb y h mb y int mb type col 2 const int16 t l1mv0 2 l1mv1 2 const int8 t l1ref0 l1ref1 const int is b8x8 IS 8 X8 mb type unsigned int sub mb type int i8 i4 assert h ref list 1 0 reference 3 await reference mb row h h ref list 1 0 h mb y ISINTERLACED mb type if ISINTERLACED h ref list 1 0 mb type mb xy if ISINTERLACED mb type mb y h mb y 1 h col parity mb xy h mb x h mb y 1 h col parity h mb stride b8 stride 0 else mb y h col fieldoff mb xy h mb stride h col fieldoff goto single col else if ISINTERLACED mb type mb y h mb y 1 mb xy h mb x h mb y 1 h mb stride mb type col 0 h ref list 1 0 mb type mb xy mb type col 1 h ref list 1 0 mb type mb xy h mb stride b8 stride 2 4 h mb stride b4 stride 6 if ISINTERLACED mb type col 0 ISINTERLACED mb type col 1 mb type col 0 MBTYPEINTERLACED mb type col 1 MBTYPEINTERLACED sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if mb type col 0 MBTYPE 16x16 ORINTRA mb type col 1 MBTYPE 16x16 ORINTRA is b8x8 mb type MBTYPE 16x8 MBTYPE L0 L1 MBTYPEDIREC T2 else mb type MBTYPE 8x8 MBTYPE L0 L1 else single col mb type col 0 mb type col 1 h ref list 1 0 mb type mb xy sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if is b8x8 mb type col 0 MBTYPE 16x16 ORINTRA mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 else if is b8x8 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 mb type MBTYPE L0 L1 MBTYPEDIREC T2 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 else if h sps direct 8x8 inference flag sub mb type MBTYPE 8x8 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 mb type MBTYPE 8x8 MBTYPE L0 L1 await reference mb row h h ref list 1 0 mb y l1mv0 h ref list 1 0 motion val 0 h mb2b xy mb xy l1mv1 h ref list 1 0 motion val 1 h mb2b xy mb xy l1ref0 h ref list 1 0 ref index 0 4 mb xy l1ref1 h ref list 1 0 ref index 1 4 mb xy if b8 stride if h mb y 1 l1ref0 2 l1ref1 2 l1mv0 2 b4 stride l1mv1 2 b4 stride const int map col to list0 2 h map col to list0 0 h map col to list0 1 const int dist scale factor h dist scale factor int ref offset if FRAMEMBAFFISINTERLACED mb type map col to list0 0 h map col to list0 field h mb y 1 0 map col to list0 1 h map col to list0 field h mb y 1 1 dist scale factor h dist scale factor field h mb y 1 ref offset h ref list 1 0 mbaff 4 mb type col 0 3 if ISINTERLACED mb type ISINTERLACED mb type col 0 int y shift 2 ISINTERLACED mb type assert h sps direct 8x8 inference flag for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col y8 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue ref0 l1ref0 x8 y8 b8 stride if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 x8 y8 b8 stride ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 const int16 t mv col l1mv x8 3 y8 b4 stride int my col mv col 1 y shift 2 int mx scale mv col 0 128 8 int my scale my col 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my my col 4 return if IS 16 X16 mb type int ref mv0 mv1 fill rectangle h ref cache 1 scan8 0 4 4 8 0 1 if ISINTRA mb type col 0 ref mv0 mv1 0 else const int ref0 l1ref0 0 0 map col to list0 0 l1ref0 0 ref offset map col to list0 1 l1ref1 0 ref offset const int scale dist scale factor ref0 const int16 t mv col l1ref0 0 0 l1mv0 0 l1mv1 0 int mv l0 2 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 ref ref0 mv0 pack16to32 mv l0 0 mv l0 1 mv1 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 fill rectangle h ref cache 0 scan8 0 4 4 8 ref 1 fill rectangle h mv cache 0 scan8 0 4 4 8 mv0 4 fill rectangle h mv cache 1 scan8 0 4 4 8 mv1 4 else for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col 0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue assert b8 stride 2 ref0 l1ref0 i8 if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 i8 ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 if ISSUB 8 X8 sub mb type const int16 t mv col l1mv x8 3 y8 3 b4 stride int mx scale mv col 0 128 8 int my scale mv col 1 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my mv col 1 4 else for i4 0 i4 4 i4 const int16 t mv col l1mv x8 2 i4 1 y8 2 i4 1 b4 stride int16 t mv l0 h mv cache 0 scan8 i8 4 i4 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 AVW N32 A h mv cache 1 scan8 i8 4 i4 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 void vp8 mbpost proc down c unsigned char dst int pitch int rows int cols int flimit int r c i const short rv3 vp8 rv 63 rand for c 0 c cols c unsigned char s dst c int sumsq 0 int sum 0 unsigned char d 16 const short rv2 rv3 c 17 127 for i 8 i 0 i s i pitch s 0 for i rows i rows 17 i s i pitch s rows 1 pitch for i 8 i 6 i sumsq s i pitch s i pitch sum s i pitch for r 0 r rows 8 r sumsq s 7 pitch s 7 pitch s 8 pitch s 8 pitch sum s 7 pitch s 8 pitch d r 15 s 0 if sumsq 15 sum sum flimit d r 15 rv2 r 127 sum s 0 4 if r 8 s 8 pitch d r 8 15 s pitch gcry error t gcry pk verify gcry sexp t s sig gcry sexp t s hash gcry sexp t s pkey gcry module t module key NULL module sig NULL gcry mpi t pkey NULL hash NULL sig NULL struct pk encoding ctx ctx gcry err code t rc REGISTERDEFAULTPUBKEYS rc sexp to key s pkey 0 GCRYPKUSAGESIGNNULL pkey module key NULL if rc goto leave rc sexp to sig s sig sig module sig if rc goto leave if module key mod id module sig mod id rc GPGERRCONFLICT goto leave init encoding ctx ctx PUBKEYOPVERIFY gcry pk get nbits s pkey rc sexp data to mpi s hash hash ctx if rc goto leave rc pubkey verify module key mod id hash sig pkey ctx leave if pkey release mpi array pkey gcry free pkey if sig release mpi array sig gcry free sig if hash mpi free hash if module key module sig ath mutex lock pubkeys registered lock if module key gcry module release module key if module sig gcry module release module sig ath mutex unlock pubkeys registered lock return gcry error rc static int escape124 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Escape124 Context s avctx priv data Get Bit Context gb unsigned frame flags frame size unsigned i unsigned superblock index cb index 1 superblock col index 0 superblocks per row avctx width 8 skip 1 uint16 t old frame data new frame data unsigned old stride new stride AV Frame new frame 0 init get bits gb buf buf size 8 if can safely read gb 64 return 1 frame flags get bits long gb 32 frame size get bits long gb 32 if frame flags 0x114 frame flags 0x7800000 av log NULLAVLOGDEBUG Skipping frame n got frame 1 AV Frame data s frame return frame size for i 0 i 3 i if frame flags 1 17 i unsigned cb depth cb size if i 2 cb size get bits long gb 20 cb depth av log2 cb size 1 1 else cb depth get bits gb 4 if i 0 cb size 1 cb depth else cb size s num superblocks cb depth av free s codebooks i blocks s codebooks i unpack codebook gb cb depth cb size if s codebooks i blocks return 1 new frame reference 3 if ff get buffer avctx new frame av log avctx AVLOGERROR get buffer failed n return 1 new frame data uint16 t new frame data 0 new stride new frame linesize 0 2 old frame data uint16 t s frame data 0 old stride s frame linesize 0 2 for superblock index 0 superblock index s num superblocks superblock index Macro Block mb Super Block sb unsigned multi mask 0 if skip 1 skip decode skip count gb if skip copy superblock new frame data new stride old frame data old stride else copy superblock sb pixels 8 old frame data old stride while can safely read gb 1 get bits1 gb unsigned mask mb decode macroblock s gb cb index superblock index mask get bits gb 16 multi mask mask for i 0 i 16 i if mask mask matrix i insert mb into sb sb mb i if can safely read gb 1 get bits1 gb unsigned inv mask get bits gb 4 for i 0 i 4 i if inv mask 1 i multi mask 0x F i 4 else multi mask get bits gb 4 i 4 for i 0 i 16 i if multi mask mask matrix i if can safely read gb 1 break mb decode macroblock s gb cb index superblock index insert mb into sb sb mb i else if frame flags 1 16 while can safely read gb 1 get bits1 gb mb decode macroblock s gb cb index superblock index insert mb into sb sb mb get bits gb 4 copy superblock new frame data new stride sb pixels 8 superblock col index new frame data 8 if old frame data old frame data 8 if superblock col index superblocks per row new frame data new stride 8 superblocks per row 8 if old frame data old frame data old stride 8 superblocks per row 8 superblock col index 0 skip av log NULLAVLOGDEBUG Escape sizes i i i n frame size buf size get bits count gb 8 if s frame data 0 avctx release buffer avctx s frame AV Frame data s frame new frame got frame 1 return frame size static void reindex system catalogs const char dbname const char host const char port const char username enum trivalue prompt password const char progname bool echo bool verbose P Gconn conn PQ Exp Buffer Data sql conn connect Database dbname host port username prompt password progname false false init PQ Exp Buffer sql append PQ Exp Buffer sql REINDEX if verbose append PQ Exp Buffer sql VERBOSE append PQ Exp Buffer sql SYSTEM s P Qdb conn if execute Maintenance Command conn sql data echo fprintf stderr s reindexing of system catalogs failed s progname P Qerror Message conn P Qfinish conn exit 1 P Qfinish conn term PQ Exp Buffer sql static void main get appheader xd3 stream stream main file ifile main file output main file sfile uint8 t apphead usize t appheadsz int ret if option use appheader return ret xd3 get appheader stream apphead appheadsz if ret 0 return if appheadsz 0 char start char apphead char slash int place 0 char parsed 4 memset parsed 0 sizeof parsed while slash strchr start NULL slash 0 parsed place start start slash 1 parsed place start if place 2 place 4 main get appheader params output parsed 1 output ifile if place 4 main get appheader params sfile parsed 2 0 source ifile option use appheader 0 return static int roq encode frame AV Codec Context avctx AV Packet pkt const AV Frame frame int got packet Roq Context enc avctx priv data int size ret enc avctx avctx enc frame to enc frame if frame quality enc lambda frame quality 1 else enc lambda 2 ROQLAMBDASCALE size enc width enc height 64 138 7 8 256 6 4 8 if ret ff alloc packet pkt size 0 av log avctx AVLOGERROR Error getting output packet with size d n size return ret enc out buf pkt data if enc frames Since Keyframe avctx gop size enc frames Since Keyframe 0 if enc first frame if ff get buffer avctx enc current frame 0 ff get buffer avctx enc last frame 0 av log avctx AVLOGERROR Ro Q get buffer failed n return 1 roq write video info chunk enc enc first frame 0 roq encode video enc pkt size enc out buf pkt data if enc frames Since Keyframe 1 pkt flags AVPKTFLAGKEY got packet 1 return 0 static int xan decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Xan Context s avctx priv data int ftype int ret s pic reference 1 s pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx s pic av log s avctx AVLOGERROR reget buffer failed n return ret bytestream2 init s gb avpkt data avpkt size ftype bytestream2 get le32 s gb switch ftype case 0 ret xan decode frame type0 avctx break case 1 ret xan decode frame type1 avctx break default av log avctx AVLOGERROR Unknown frame type d n ftype return AVERRORINVALIDDATA if ret return ret got frame 1 AV Frame data s pic return avpkt size static void cirrus mem writeb mode4and5 16bpp Cirrus VGA State s unsigned mode unsigned offset uint32 t mem value int x unsigned val mem value uint8 t dst dst s vga vram ptr offset s cirrus addr mask for x 0 x 8 x if val 0x80 dst s cirrus shadow gr1 dst 1 s vga gr 0x11 else if mode 5 dst s cirrus shadow gr0 dst 1 s vga gr 0x10 val 1 dst 2 memory region set dirty s vga vram offset 16 int16 t ff h263 pred motion Mpeg Enc Context s int block int dir int px int py int wrap int16 t ABC mot val 2 static const int off 4 2 1 1 1 wrap s b8 stride mot val s current picture motion val dir s block index block A mot val 1 if s first slice line block 3 if block 0 if s mb x s resync mb x px py 0 else if s mb x 1 s resync mb x s h263 pred C mot val off block wrap if s mb x 0 px C 0 py C 1 else px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else if block 1 if s mb x 1 s resync mb x s h263 pred C mot val off block wrap px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else B mot val wrap C mot val off block wrap if s mb x s resync mb x A 0 A 1 0 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else B mot val wrap C mot val off block wrap px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val int event reinit struct event base base const struct eventop evsel base evsel void evbase base evbase int res 0 struct event ev if evsel need reinit return 0 if base sig ev signal added event queue remove base base sig ev signal EVLISTINSERTED if base sig ev signal ev flags EVLISTACTIVE event queue remove base base sig ev signal EVLISTACTIVE base sig ev signal added 0 if base evsel dealloc NULL base evsel dealloc base base evbase evbase base evbase evsel init base if base evbase NULL event errx 1 s could not reinitialize event mechanism func TAILQFOREACH ev base eventqueue ev next if evsel add evbase ev 1 res 1 return res static int ec G F2m montgomery point multiply const ECGROUP group ECPOINT r const BIGNUM scalar const ECPOINT point BNCTX ctx BIGNUM x1 x2 z1 z2 int ret 0 i BNULONG mask word if r point E Cerr ECFECG F2 MMONTGOMERYPOINTMULTIPLYECRINVALIDARGUMENT return 0 if scalar NULLBN is zero scalar point NULLECPOINT is at infinity group point return ECPOINT set to infinity group r if point Z is one return 0 BNCTX start ctx x1 BNCTX get ctx z1 BNCTX get ctx if z1 NULL goto err x2 r X z2 r Y bn wexpand x1 group field top bn wexpand z1 group field top bn wexpand x2 group field top bn wexpand z2 group field top if BNG F2m mod arr x1 point X group poly goto err if BN one z1 goto err if group meth field sqr group z2 x1 ctx goto err if group meth field sqr group x2 z2 ctx goto err if BNG F2m add x2 x2 group b goto err i scalar top 1 mask BNTBIT word scalar d i while word mask mask 1 mask 1 if mask i mask BNTBIT for i 0 i word scalar d i while mask BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top if gf2m Madd group point X x2 z2 x1 z1 ctx goto err if gf2m Mdouble group x1 z1 ctx goto err BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top mask 1 mask BNTBIT i gf2m Mxy group point X point Y x1 z1 x2 z2 ctx if i 0 goto err else if i 1 if ECPOINT set to infinity group r goto err else if BN one r Z goto err r Z is one 1 BN set negative r X 0 BN set negative r Y 0 ret 1 err BNCTX end ctx return ret static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt WN V1 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data unsigned char YUV int i j ret int prev y 0 prev u 0 prev v 0 uint8 t rbuf rbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if rbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n av free rbuf return ret p key frame 1 for i 8 i buf size i rbuf i ff reverse buf i init get bits l gb rbuf 8 buf size 8 8 if buf 2 4 6 l shift 2 else l shift 8 buf 2 4 if l shift 4 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 4 if l shift 1 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 1 Y p data 0 U p data 1 V p data 2 for j 0 j avctx height j for i 0 i avctx width 2 i Y i 2 wnv1 get code l prev y prev u U i wnv1 get code l prev u prev y Y i 2 1 wnv1 get code l Y i 2 prev v V i wnv1 get code l prev v Y p linesize 0 U p linesize 1 V p linesize 2 got frame 1 av free rbuf return buf size int write output void int fd struct filter op fop struct filter header fh size t ninst i u char data ninst compile tree fop if fop NULL return ENOTHANDLED if ninst 0 return EINVALID fd open EFGBLOPTIONS output file OCREATORDWROTRUNCOBINARY 0644 ONERROR fd 1 Can t create file s EFGBLOPTIONS output file fprintf stdout Writing output to s EFGBLOPTIONS output file fflush stdout fh magic htons ECFILTERMAGIC strncpy fh version ECVERSION sizeof fh version fh data sizeof fh data create data segment fh fop ninst write fd fh sizeof struct filter header write fd data fh code fh data for i 0 i ninst i print progress bar fop i write fd fop i sizeof struct filter op close fd fprintf stdout done n n fprintf stdout Script encoded into d instructions n n int i 1 return Selectivity scalararraysel containment Planner Info root Node leftop Node rightop Oid elemtype bool is Equality bool use Or int var Relid Selectivity selec Variable Stat Data vardata Datum constval Type Cache Entry typentry Fmgr Info cmpfunc examine variable root rightop var Relid vardata if vardata rel Release Variable Stats vardata return 1 0 if Is A leftop Const Release Variable Stats vardata return 1 0 if Const leftop constisnull Release Variable Stats vardata return Selectivity 0 0 constval Const leftop constvalue typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid Release Variable Stats vardata return 1 0 cmpfunc typentry cmp proc finfo if is Equality use Or use Or if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata cmpfunc fn oid Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if use Or get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 if use Or selec mcelem array contain overlap selec values nvalues numbers nnumbers constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec values nvalues numbers nnumbers constval 1 hist nhist OIDARRAYCONTAINEDOP cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc selec 1 0 stats stanullfrac else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc Release Variable Stats vardata if is Equality selec 1 0 selec CLAMPPROBABILITY selec return selec void ff h263 update motion val Mpeg Enc Context s const int mb xy s mb y s mb stride s mb x const int wrap s b8 stride const int xy s block index 0 s current picture f mbskip table mb xy s mb skipped if s mv type MVTYPE 8 X8 int motion x motion y if s mb intra motion x 0 motion y 0 else if s mv type MVTYPE 16 X16 motion x s mv 0 0 0 motion y s mv 0 0 1 else int i motion x s mv 0 0 0 s mv 0 1 0 motion y s mv 0 0 1 s mv 0 1 1 motion x motion x 1 motion x 1 for i 0 i 2 i s p field mv table i 0 mb xy 0 s mv 0 i 0 s p field mv table i 0 mb xy 1 s mv 0 i 1 s current picture f ref index 0 4 mb xy s current picture f ref index 0 4 mb xy 1 s field select 0 0 s current picture f ref index 0 4 mb xy 2 s current picture f ref index 0 4 mb xy 3 s field select 0 1 s current picture f motion val 0 xy 0 motion x s current picture f motion val 0 xy 1 motion y s current picture f motion val 0 xy 1 0 motion x s current picture f motion val 0 xy 1 1 motion y s current picture f motion val 0 xy wrap 0 motion x s current picture f motion val 0 xy wrap 1 motion y s current picture f motion val 0 xy 1 wrap 0 motion x s current picture f motion val 0 xy 1 wrap 1 motion y if s encoding if s mv type MVTYPE 8 X8 s current picture f mb type mb xy MBTYPE L0 MBTYPE 8x8 else if s mb intra s current picture f mb type mb xy MBTYPEINTRA else s current picture f mb type mb xy MBTYPE L0 MBTYPE 16x16 static int vp3 init thread copy AV Codec Context avctx Vp3 Decode Context s avctx priv data s superblock coding NULL s all fragments NULL s coded fragment list 0 NULL s dct tokens base NULL s superblock fragments NULL s macroblock coding NULL s motion val 0 NULL s motion val 1 NULL s edge emu buffer NULL return init frames s AS N1 BITSTRING c2i AS N1 BITSTRINGAS N1 BITSTRING a const unsigned char pp long len AS N1 BITSTRING ret NULL const unsigned char p unsigned char s int i if len 1 i AS N1 RSTRINGTOOSHORT goto err if a NULL a NULL if ret MAS N1 BITSTRING new NULL return NULL else ret a p pp i p ret flags AS N1 STRINGFLAGBITSLEFT 0x07 ret flags AS N1 STRINGFLAGBITSLEFT i 0x07 if len 1 s unsigned char OPENSSL malloc int len if s NULL i ERRRMALLOCFAILURE goto err memcpy s p int len s len 1 0xff i p len else s NULL ret length int len if ret data NULLOPENSSL free ret data ret data s ret type VAS N1 BITSTRING if a NULL a ret pp p return ret err AS N1err AS N1 F C2 IAS N1 BITSTRING i if ret NULL a NULL a ret MAS N1 BITSTRING free ret return static void tokenize b int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct tokenize b args const args arg V P9 COMP cpi args cpi MACROBLOCKD xd args xd TOKENEXTRA tp args tp uint8 t token cache 32 32 struct macroblock plane p cpi mb plane plane struct macroblockd plane pd xd plane plane MBMODEINFO mbmi xd mi 0 mbmi int pt int c TOKENEXTRA t tp int eob p eobs block const PLANETYPE type pd plane type const int16 t qcoeff BLOCKOFFSET p qcoeff block const int segment id mbmi segment id const int16 t scan nb const scan order so const int ref is inter block mbmi unsigned int const counts COEFFCONTEXTSENTROPYTOKENS cpi coef counts tx size type ref vp9 prob const coef probs COEFFCONTEXTSUNCONSTRAINEDNODES cpi common fc coef probs tx size type ref unsigned int const eob branch COEFFCONTEXTS cpi common counts eob branch tx size type ref const uint8 t const band get band translate tx size const int seg eob get tx eob cpi common seg segment id tx size int aoff loff txfrm block to raster xy plane bsize tx size block aoff loff pt get entropy context tx size pd above context aoff pd left context loff so get scan xd tx size type block scan so scan nb so neighbors c 0 while c eob int v 0 int skip eob 0 v qcoeff scan c while v add token no extra t coef probs band c pt ZEROTOKEN skip eob counts band c pt eob branch band c pt skip eob skip eob 1 token cache scan c 0 c pt get coef context nb token cache c v qcoeff scan c add token t coef probs band c pt vp9 dct value tokens ptr v extra uint8 t vp9 dct value tokens ptr v token uint8 t skip eob counts band c pt eob branch band c pt skip eob token cache scan c vp9 pt energy class vp9 dct value tokens ptr v token c pt get coef context nb token cache c if c seg eob add token no extra t coef probs band c pt EOBTOKEN 0 counts band c pt eob branch band c pt tp t vp9 set contexts xd pd plane bsize tx size c 0 aoff loff static int slirp smb Slirp State s const char exported dir struct in addr vserver addr char smb conf 128 char smb cmdline 128 struct passwd passwd FILE f passwd getpwuid geteuid if passwd error report failed to retrieve user name return 1 if access CONFIGSMBDCOMMANDFOK error report could not find s please install it CONFIGSMBDCOMMAND return 1 if access exported dir ROKXOK error report error accessing shared directory s s exported dir strerror errno return 1 snprintf s smb dir sizeof s smb dir tmp qemu smb XXXXXX if mkdtemp s smb dir error report could not create samba server dir s s smb dir s smb dir 0 0 return 1 snprintf smb conf sizeof smb conf s s s smb dir smb conf f fopen smb conf w if f slirp smb cleanup s error report could not create samba server configuration file s smb conf return 1 fprintf f global n private dir s n interfaces 127 0 0 1 n bind interfaces only yes n pid directory s n lock directory s n state directory s n cache directory s n ncalrpc dir scalrpc n log file s log smbd n smb passwd file s smbpasswd n security user n map to guest Bad User n load printers no n printing bsd n disable spoolss yes n usershare max shares 0 n qemu n path s n read only no n guest ok yes n force user s n s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir exported dir passwd pw name fclose f snprintf smb cmdline sizeof smb cmdline s l s s s CONFIGSMBDCOMMAND s smb dir smb conf if slirp add exec s slirp 0 smb cmdline vserver addr 139 0 slirp add exec s slirp 0 smb cmdline vserver addr 445 0 slirp smb cleanup s error report conflicting invalid smbserver address return 1 return 0 static int rv34 decode intra mb header R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s Get Bit Context gb s gb int mb pos s mb x s mb y s mb stride int t r is16 get bits1 gb if r is16 s current picture ptr mb type mb pos MBTYPEINTR A16x16 r block type R V34 MBTYPEINTR A16x16 t get bits gb 2 fill rectangle intra types 4 4 r intra types stride t sizeof intra types 0 r luma vlc 2 else if r rv30 if get bits1 gb av log s avctx AVLOGERROR Need DQUANT n s current picture ptr mb type mb pos MBTYPEINTRA r block type R V34 MBTYPEINTRA if r decode intra types r gb intra types 0 return 1 r luma vlc 1 r chroma vlc 0 r cur vlcs choose vlc set r si quant r si vlc set 0 return rv34 decode cbp gb r cur vlcs r is16 int crypto authenticate and decrypt struct crypto instance instance unsigned char buf int buf len struct crypto config header cch struct crypto config header buf const char guessed str if buf len sizeof struct crypto config header log printf instance log level security Received message is too short ignoring return 1 if cch crypto cipher type CRYPTOCIPHERTYPE 2 3 guessed str NULL if cch crypto cipher type 0x C0 cch crypto hash type 0x70 cch crypto cipher type 0x70 cch crypto hash type 0x C0 guessed str Corosync 3 x else if cch crypto cipher type CRYPTOCIPHERTYPE 2 2 guessed str Corosync 2 2 else if cch crypto cipher type 0x01 guessed str unencrypted Kronosnet else if cch crypto cipher type 0 cch crypto cipher type 5 guessed str unencrypted Corosync 2 0 2 1 1 x Open AIS else guessed str encrypted Kronosnet Corosync 2 0 2 1 1 x Open AIS or unknown log printf instance log level security Unsupported incoming packet probably sent by s Rejecting guessed str return 1 if cch crypto hash type CRYPTOHASHTYPE 2 3 log printf instance log level security Incoming packet has different hash type Rejecting return 1 if authenticate nss 2 3 instance buf buf len 0 return 1 if cch pad0 0 cch pad1 0 log printf instance log level security Incoming packet appears to have features not supported by this version of corosync Rejecting return 1 if decrypt nss 2 3 instance buf buf len 0 return 1 cch NULL memmove buf buf sizeof struct crypto config header buf len return 0 Selectivity scalararraysel containment Planner Info root Node leftop Node rightop Oid elemtype bool is Equality bool use Or int var Relid Selectivity selec Variable Stat Data vardata Datum constval Type Cache Entry typentry Fmgr Info cmpfunc examine variable root rightop var Relid vardata if vardata rel Release Variable Stats vardata return 1 0 if Is A leftop Const Release Variable Stats vardata return 1 0 if Const leftop constisnull Release Variable Stats vardata return Selectivity 0 0 constval Const leftop constvalue typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid Release Variable Stats vardata return 1 0 cmpfunc typentry cmp proc finfo if is Equality use Or use Or if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata cmpfunc fn oid Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if use Or get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 if use Or selec mcelem array contain overlap selec values nvalues numbers nnumbers constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec values nvalues numbers nnumbers constval 1 hist nhist OIDARRAYCONTAINEDOP cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc selec 1 0 stats stanullfrac else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc Release Variable Stats vardata if is Equality selec 1 0 selec CLAMPPROBABILITY selec return selec static int amrwb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMRWB Context ctx avctx priv data AV Frame frame data AMRWB Frame cf ctx frame const uint8 t buf avpkt data int buf size avpkt size int expected fr size header size float buf out float spare vector AMRWBSFRSIZE float fixed gain factor float synth fixed vector float synth fixed gain float voice fac stab fac float synth exc AMRWBSFRSIZE float hb exc AMRWBSFRSIZE 16k float hb samples AMRWBSFRSIZE 16k float hb gain int sub i ret frame nb samples 4 AMRWBSFRSIZE 16k if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 header size decode mime header ctx buf if ctx fr cur mode MODESID av log avctx AVLOGERROR Invalid mode d n ctx fr cur mode return AVERRORINVALIDDATA expected fr size cf sizes wb ctx fr cur mode 7 3 1 if buf size expected fr size av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size got frame ptr 0 return AVERRORINVALIDDATA if ctx fr quality ctx fr cur mode MODESID av log avctx AVLOGERROR Encountered a bad or corrupted frame n if ctx fr cur mode MODESID av log missing feature avctx SID mode 1 return AVERRORPATCHWELCOME ff amr bit reorder uint16 t ctx frame sizeof AMRWB Frame buf header size amr bit orderings by mode ctx fr cur mode if ctx fr cur mode MODE 6k60 decode isf indices 36b cf isp id ctx isf cur else decode isf indices 46b cf isp id ctx isf cur isf add mean and past ctx isf cur ctx isf q past ff set min dist lsf ctx isf cur MINISFSPACINGLPORDER 1 stab fac stability factor ctx isf cur ctx isf past final ctx isf cur LPORDER 1 2 0 ff acelp lsf2lspd ctx isp 3 ctx isf cur LPORDER if ctx first frame ctx first frame 0 memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof double interpolate isp ctx isp ctx isp sub4 past for sub 0 sub 4 sub ff amrwb lsp2lpc ctx isp sub ctx lp coef sub LPORDER for sub 0 sub 4 sub const AMRWB Sub Frame cur subframe cf subframe sub float sub buf buf out sub AMRWBSFRSIZE 16k decode pitch vector ctx cur subframe sub decode fixed vector ctx fixed vector cur subframe pul ih cur subframe pul il ctx fr cur mode pitch sharpening ctx ctx fixed vector decode gains cur subframe vq gain ctx fr cur mode fixed gain factor ctx pitch gain 0 ctx fixed gain 0 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c ctx fixed vector ctx fixed vector AMRWBSFRSIZEAMRWBSFRSIZE ctx prediction error ENERGYMEAN energy pred fac voice fac voice factor ctx pitch vector ctx pitch gain 0 ctx fixed vector ctx fixed gain 0 ctx tilt coef voice fac 0 25 0 25 for i 0 i AMRWBSFRSIZE i ctx excitation i ctx pitch gain 0 ctx excitation i ctx fixed gain 0 ctx fixed vector i ctx excitation i truncf ctx excitation i synth fixed gain noise enhancer ctx fixed gain 0 ctx prev tr gain voice fac stab fac synth fixed vector anti sparseness ctx ctx fixed vector spare vector pitch enhancer synth fixed vector voice fac synthesis ctx ctx lp coef sub synth exc synth fixed gain synth fixed vector ctx samples az LPORDER de emphasis ctx samples up UPSMEMSIZE ctx samples az LPORDERPREEMPHFAC ctx demph mem ff acelp apply order 2 transfer function ctx samples up UPSMEMSIZE ctx samples up UPSMEMSIZE hpf zeros hpf 31 poles hpf 31 gain ctx hpf 31 mem AMRWBSFRSIZE upsample 5 4 sub buf ctx samples up UPSFIRSIZEAMRWBSFRSIZE 16k ff acelp apply order 2 transfer function hb samples ctx samples up UPSMEMSIZE hpf zeros hpf 400 poles hpf 400 gain ctx hpf 400 mem AMRWBSFRSIZE hb gain find hb gain ctx hb samples cur subframe hb gain cf vad scaled hb excitation ctx hb exc synth exc hb gain hb synthesis ctx sub ctx samples hb LPORDER 16k hb exc ctx isf cur ctx isf past final hb fir filter hb samples bpf 6 7 coef ctx bpf 6 7 mem ctx samples hb LPORDER 16k if ctx fr cur mode MODE 23k85 hb fir filter hb samples lpf 7 coef ctx lpf 7 mem hb samples for i 0 i AMRWBSFRSIZE 16k i sub buf i sub buf i hb samples i 1 0f 1 15 update sub state ctx memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof ctx isp 3 0 memcpy ctx isf past final ctx isf cur LPORDER sizeof float got frame ptr 1 return expected fr size static void vp3 draw horiz band Vp3 Decode Context s int y int h cy i int offset AVNUMDATAPOINTERS if HAVETHREADS s avctx active thread type FFTHREADFRAME int y flipped s flipped image s avctx height y y ff thread report progress s current frame y flipped s avctx height INTMAX y flipped 1 0 if s avctx draw horiz band NULL return h y s last slice end s last slice end y y h if s flipped image y s avctx height y h cy y s chroma y shift offset 0 s current frame f linesize 0 y offset 1 s current frame f linesize 1 cy offset 2 s current frame f linesize 2 cy for i 3 i AVNUMDATAPOINTERS i offset i 0 emms c s avctx draw horiz band s avctx s current frame f offset y 3 h static inline void ff mpeg4 set one direct mv Mpeg Enc Context s int mx int my int i int xy s block index i uint16 t time pp s pp time uint16 t time pb s pb time int p mx p my p mx s next picture f motion val 0 xy 0 if unsigned p mx tab bias tab size s mv 0 i 0 s direct scale mv 0 p mx tab bias mx s mv 1 i 0 mx s mv 0 i 0 p mx s direct scale mv 1 p mx tab bias else s mv 0 i 0 p mx time pb time pp mx s mv 1 i 0 mx s mv 0 i 0 p mx p mx time pb time pp time pp p my s next picture f motion val 0 xy 1 if unsigned p my tab bias tab size s mv 0 i 1 s direct scale mv 0 p my tab bias my s mv 1 i 1 my s mv 0 i 1 p my s direct scale mv 1 p my tab bias else s mv 0 i 1 p my time pb time pp my s mv 1 i 1 my s mv 0 i 1 p my p my time pb time pp time pp int main int argc char argv char inputbuf 4096 unsigned char buf size t len gpg error t err if argc 2 strcmp argv 1 to str fread inputbuf 1 sizeof inputbuf stdin if feof stdin fail read error or input too large fail not yet implemented else if argc 2 strcmp argv 1 to der fread inputbuf 1 sizeof inputbuf stdin if feof stdin fail read error or input too large err ksba dn str2der inputbuf buf len fail if err err fwrite buf len 1 stdout else if argc 1 test 0 test 1 test 2 else fprintf stderr usage t dnparser to str to der n return 1 return 0 static int vp3 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Vp3 Decode Context s avctx priv data Get Bit Context gb int i ret init get bits gb buf buf size 8 if s theora get bits1 gb av log avctx AVLOGERROR Header packet passed to frame decoder skipping n return 1 s keyframe get bits1 gb if s theora skip bits gb 1 for i 0 i 3 i s last qps i s qps i s nqps 0 do s qps s nqps get bits gb 6 while s theora 0x030200 s nqps 3 get bits1 gb for i s nqps i 3 i s qps i 1 if s avctx debug FFDEBUGPICTINFO av log s avctx AVLOGINFOV P3 sframe d Q index d n s keyframe key avctx frame number 1 s qps 0 s skip loop filter s filter limit values s qps 0 avctx skip loop filter s keyframe AVDISCARDALLAVDISCARDNONKEY if s qps 0 s last qps 0 init loop filter s for i 0 i s nqps i if s qps i s last qps i s qps 0 s last qps 0 init dequantizer s i if avctx skip frame AVDISCARDNONKEY s keyframe return buf size s current frame f pict type s keyframe AVPICTURETYPEIAVPICTURETYPEP if ff thread get buffer avctx s current frame AVGETBUFFERFLAGREF 0 av log s avctx AVLOGERROR get buffer failed n goto error if s edge emu buffer s edge emu buffer av malloc 9 FFABS s current frame f linesize 0 if s keyframe if s theora skip bits gb 4 skip bits gb 4 if s version s version get bits gb 5 if avctx frame number 0 av log s avctx AVLOGDEBUGVP version d n s version if s version s theora if get bits1 gb av log s avctx AVLOGERROR Warning unsupported keyframe coding type n skip bits gb 2 else if s golden frame f data 0 av log s avctx AVLOGWARNING vp3 first frame not a keyframe n s golden frame f pict type AVPICTURETYPEI if ff thread get buffer avctx s golden frame AVGETBUFFERFLAGREF 0 av log s avctx AVLOGERROR get buffer failed n goto error ff thread release buffer avctx s last frame if ret ff thread ref frame s last frame s golden frame 0 goto error ff thread report progress s last frame INTMAX 0 memset s all fragments 0 s fragment count sizeof Vp3 Fragment ff thread finish setup avctx if unpack superblocks s gb av log s avctx AVLOGERROR error in unpack superblocks n goto error if unpack modes s gb av log s avctx AVLOGERROR error in unpack modes n goto error if unpack vectors s gb av log s avctx AVLOGERROR error in unpack vectors n goto error if unpack block qpis s gb av log s avctx AVLOGERROR error in unpack block qpis n goto error if unpack dct coeffs s gb av log s avctx AVLOGERROR error in unpack dct coeffs n goto error for i 0 i 3 i int height s height i s chroma y shift if s flipped image s data offset i 0 else s data offset i height 1 s current frame f linesize i s last slice end 0 for i 0 i s c superblock height i render slice s i for i 0 i 3 i int row s height 3 i s chroma y shift 1 apply loop filter s i row row 1 vp3 draw horiz band s s avctx height if ret av frame ref data s current frame f 0 return ret got frame 1 if HAVETHREADS s avctx active thread type FFTHREADFRAME ret update frames avctx if ret 0 return ret return buf size error ff thread report progress s current frame INTMAX 0 if HAVETHREADS s avctx active thread type FFTHREADFRAME av frame unref s current frame f return 1 static VALUE ossl cipher pkcs5 keyivgen int argc VALUE argv VALUE self EVPCIPHERCTX ctx const EVPMD digest VALUE vpass vsalt viter vdigest unsigned char key EVPMAXKEYLENGTH iv EVPMAXIVLENGTH salt NULL int iter rb scan args argc argv 13 vpass vsalt viter vdigest String Value vpass if NILP vsalt String Value vsalt if RSTRINGLEN vsalt PKC S5 SALTLEN ossl raise e Cipher Error salt must be an 8 octet string salt unsigned char RSTRINGPTR vsalt iter NILP viter 2048 NU M2 INT viter digest NILP vdigest EVP md5 Get Digest Ptr vdigest Get Cipher self ctx EVP Bytes To Key EVPCIPHERCTX cipher ctx digest salt unsigned char RSTRINGPTR vpass RSTRINGLENINT vpass iter key iv if EVP Cipher Init ex ctx NULLNULL key iv 1 1 ossl raise e Cipher Error NULLOPENSSL cleanse key sizeof key OPENSSL cleanse iv sizeof iv rb ivar set self id key set Qtrue return Qnil int dtls1 get record SSL s int ssl major ssl minor int i n SS L3 RECORD rr unsigned char p NULL unsigned short version DTL S1 BITMAP bitmap unsigned int is next epoch rr RECORDLAYER get rrec s rlayer again if dtls1 process buffered records s 0 return 1 if dtls1 get processed record s return 1 if RECORDLAYER get rstate s rlayer SSLSTREADBODYRECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH n ssl3 read n s DTL S1 RTHEADERLENGTHSS L3 BUFFER get len s rlayer rbuf 0 1 if n 0 return n if RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTHRECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADBODY p RECORDLAYER get packet s rlayer if s msg callback s msg callback 0 0 SS L3 RTHEADER p DTL S1 RTHEADERLENGTH s s msg callback arg rr type p ssl major p ssl minor p version ssl major 8 ssl minor n2s p rr epoch memcpy RECORDLAYER get read sequence s rlayer 2 p 6 p 6 n2s p rr length if s first packet if version s version rr length 0 RECORDLAYER reset packet length s rlayer goto again if version 0xff00 s version 0xff00 rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length SS L3 RTMAXENCRYPTEDLENGTH rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH i rr length n ssl3 read n s i i 1 1 if n i rr length 0 RECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADHEADER bitmap dtls1 get bitmap s rr is next epoch if bitmap NULL rr length 0 RECORDLAYER reset packet length s rlayer goto again rr length 0 RECORDLAYER reset packet length s rlayer goto again static void ppp hdlc netdissect options ndo const u char p int length u char b s t c int i proto const void se if length 0 return b uint8 t malloc length if b NULL return for s u char p t b i length i 0 i c s if c 0x7d if i 1 i c s 0x20 else continue t c se ndo ndo snapend ndo ndo snapend t length t b if length 1 goto trunc proto b switch proto case PPPIP ip print ndo b 1 length 1 goto cleanup case PPPIP V6 ip6 print ndo b 1 length 1 goto cleanup default break if length 2 goto trunc proto EXTRACT 16 BITS b switch proto case PPPADDRESS 8 PPPCONTROL if length 4 goto trunc proto EXTRACT 16 BITS b 2 handle ppp ndo proto b 4 length 4 break default handle ppp ndo proto b 2 length 2 break cleanup ndo ndo snapend se free b return trunc ndo ndo snapend se free b NDPRINT ndo ppp int ff MPV frame start Mpeg Enc Context s AV Codec Context avctx int i ret Picture pic s mb skipped 0 if s out format FMT H264 s codec id AVCODECIDSV Q3 if s pict type AVPICTURETYPEB s last picture ptr s last picture ptr s next picture ptr s last picture ptr f data 0 ff mpeg unref picture s s last picture ptr if s encoding for i 0 i MAXPICTURECOUNT i if s picture i s last picture ptr s picture i s next picture ptr s picture i reference s picture i needs realloc if avctx active thread type FFTHREADFRAME av log avctx AVLOGERROR releasing zombie picture n ff mpeg unref picture s s picture i if s encoding ff release unused pictures s 1 if s current picture ptr s current picture ptr f data 0 NULL pic s current picture ptr else i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i pic s picture i pic reference 0 if s droppable if s codec id AVCODECID H264 pic reference s picture structure else if s pict type AVPICTURETYPEB pic reference 3 pic f coded picture number s coded picture number if ff alloc picture s pic 0 0 return 1 s current picture ptr pic s current picture ptr f top field first s top field first if s codec id AVCODECIDMPE G1 VIDEO s codec id AVCODECIDMPE G2 VIDEO if s picture structure PICTFRAME s current picture ptr f top field first s picture structure PICTTOPFIELD s first field s current picture ptr f interlaced frame s progressive frame s progressive sequence s current picture ptr field picture s picture structure PICTFRAME s current picture ptr f pict type s pict type s current picture ptr f key frame s pict type AVPICTURETYPEI ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret if s codec id AVCODECID H264 s pict type AVPICTURETYPEB s last picture ptr s next picture ptr if s droppable s next picture ptr s current picture ptr av dlog s avctx L p N p C p L p N p C p type d drop d n s last picture ptr s next picture ptr s current picture ptr s last picture ptr s last picture ptr f data 0 NULL s next picture ptr s next picture ptr f data 0 NULL s current picture ptr s current picture ptr f data 0 NULL s pict type s droppable if s codec id AVCODECID H264 if s last picture ptr NULL s last picture ptr f data 0 NULL s pict type AVPICTURETYPEI s picture structure PICTFRAME int h chroma shift v chroma shift av pix fmt get chroma sub sample s avctx pix fmt h chroma shift v chroma shift if s pict type AVPICTURETYPEI av log avctx AVLOGERROR warning first frame is no keyframe n else if s picture structure PICTFRAME av log avctx AVLOGINFO allocate dummy last picture for field based first keyframe n i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s last picture ptr s picture i if ff alloc picture s s last picture ptr 0 0 s last picture ptr NULL return 1 memset s last picture ptr f data 0 0 avctx height s last picture ptr f linesize 0 memset s last picture ptr f data 1 0x80 avctx height v chroma shift s last picture ptr f linesize 1 memset s last picture ptr f data 2 0x80 avctx height v chroma shift s last picture ptr f linesize 2 ff thread report progress s last picture ptr tf INTMAX 0 ff thread report progress s last picture ptr tf INTMAX 1 if s next picture ptr NULL s next picture ptr f data 0 NULL s pict type AVPICTURETYPEB i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s next picture ptr s picture i if ff alloc picture s s next picture ptr 0 0 s next picture ptr NULL return 1 ff thread report progress s next picture ptr tf INTMAX 0 ff thread report progress s next picture ptr tf INTMAX 1 if s codec id AVCODECID H264 if s last picture ptr ff mpeg unref picture s s last picture if s last picture ptr f data 0 ret ff mpeg ref picture s s last picture s last picture ptr 0 return ret if s next picture ptr ff mpeg unref picture s s next picture if s next picture ptr f data 0 ret ff mpeg ref picture s s next picture s next picture ptr 0 return ret assert s pict type AVPICTURETYPEI s last picture ptr s last picture ptr f data 0 if s picture structure PICTFRAME s out format FMT H264 int i for i 0 i 4 i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture f linesize i s current picture f linesize i 2 s last picture f linesize i 2 s next picture f linesize i 2 s err recognition avctx err recognition if s mpeg quant s codec id AVCODECIDMPE G2 VIDEO s dct unquantize intra s dct unquantize mpeg2 intra s dct unquantize inter s dct unquantize mpeg2 inter else if s out format FMT H263 s out format FMT H261 s dct unquantize intra s dct unquantize h263 intra s dct unquantize inter s dct unquantize h263 inter else s dct unquantize intra s dct unquantize mpeg1 intra s dct unquantize inter s dct unquantize mpeg1 inter if s dct error sum assert s avctx noise reduction s encoding update noise reduction s if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration return ff xvmc field start s avctx return 0 static void dissect rtp rfc2198 tvbuff t tvb packet info pinfo proto tree tree gint offset 0 guint8 octet1 int cnt gboolean hdr follow TRUE proto item ti NULL proto tree rfc2198 tree NULL proto tree rfc2198 hdr tree NULL rfc2198 hdr hdr last hdr new rfc2198 hdr hdr chain NULL struct rtp conversation info p conv data NULL gchar payload type str p conv data struct rtp conversation info p get proto data wmem file scope pinfo proto rtp 0 ti proto tree add text tree tvb offset 1 RFC 2198 Redundant Audio Data rfc2198 tree proto item add subtree ti ett rtp rfc2198 hdr last NULL cnt 0 while hdr follow cnt payload type str NULL hdr new wmem new wmem packet scope rfc2198 hdr hdr new next NULL octet1 tvb get guint8 tvb offset hdr new pt RTPPAYLOADTYPE octet1 hdr follow octet1 0x80 if hdr new pt 95 hdr new pt 128 if p conv data p conv data rtp dyn payload encoding name and rate t encoding name and rate pt NULL encoding name and rate pt encoding name and rate t g hash table lookup p conv data rtp dyn payload hdr new pt if encoding name and rate pt payload type str encoding name and rate pt encoding name ti proto tree add text rfc2198 tree tvb offset hdr follow 4 1 Header u cnt rfc2198 hdr tree proto item add subtree ti ett rtp rfc2198 hdr proto tree add item rfc2198 hdr tree hf rtp rfc2198 follow tvb offset 1 ENCBIGENDIAN proto tree add uint format value rfc2198 hdr tree hf rtp payload type tvb offset 1 octet1 s u payload type str payload type str val to str ext const hdr new pt rtp payload type vals ext Unknown hdr new pt proto item append text ti PT s payload type str payload type str val to str ext hdr new pt rtp payload type vals ext Unknown u offset 1 if hdr follow proto tree add item rfc2198 hdr tree hf rtp rfc2198 tm off tvb offset 2 ENCBIGENDIAN proto tree add item rfc2198 hdr tree hf rtp rfc2198 bl len tvb offset 1 2 ENCBIGENDIAN hdr new len tvb get ntohs tvb offset 1 0x03 FF proto item append text ti len u hdr new len offset 3 else hdr new len 1 hdr follow FALSE if hdr last hdr last next hdr new else hdr chain hdr new hdr last hdr new hdr last hdr chain while hdr last hdr last offset offset if hdr last next hdr last len tvb reported length remaining tvb offset dissect rtp data tvb pinfo tree rfc2198 tree hdr last offset hdr last len hdr last len hdr last pt offset hdr last len hdr last hdr last next void ff h263 loop filter Mpeg Enc Context s int qp c const int linesize s linesize const int uvlinesize s uvlinesize const int xy s mb y s mb stride s mb x uint8 t dest y s dest 0 uint8 t dest cb s dest 1 uint8 t dest cr s dest 2 if ISSKIP s current picture mb type xy qp c s qscale s dsp h263 v loop filter dest y 8 linesize linesize qp c s dsp h263 v loop filter dest y 8 linesize 8 linesize qp c else qp c 0 if s mb y int qp dt qp tt qp tc if ISSKIP s current picture mb type xy s mb stride qp tt 0 else qp tt s current picture qscale table xy s mb stride if qp c qp tc qp c else qp tc qp tt if qp tc const int chroma qp s chroma qscale table qp tc s dsp h263 v loop filter dest y linesize qp tc s dsp h263 v loop filter dest y 8 linesize qp tc s dsp h263 v loop filter dest cb uvlinesize chroma qp s dsp h263 v loop filter dest cr uvlinesize chroma qp if qp tt s dsp h263 h loop filter dest y 8 linesize 8 linesize qp tt if s mb x if qp tt ISSKIP s current picture mb type xy 1 s mb stride qp dt qp tt else qp dt s current picture qscale table xy 1 s mb stride if qp dt const int chroma qp s chroma qscale table qp dt s dsp h263 h loop filter dest y 8 linesize linesize qp dt s dsp h263 h loop filter dest cb 8 uvlinesize uvlinesize chroma qp s dsp h263 h loop filter dest cr 8 uvlinesize uvlinesize chroma qp if qp c s dsp h263 h loop filter dest y 8 linesize qp c if s mb y 1 s mb height s dsp h263 h loop filter dest y 8 linesize 8 linesize qp c if s mb x int qp lc if qp c ISSKIP s current picture mb type xy 1 qp lc qp c else qp lc s current picture qscale table xy 1 if qp lc s dsp h263 h loop filter dest y linesize qp lc if s mb y 1 s mb height const int chroma qp s chroma qscale table qp lc s dsp h263 h loop filter dest y 8 linesize linesize qp lc s dsp h263 h loop filter dest cb uvlinesize chroma qp s dsp h263 h loop filter dest cr uvlinesize chroma qp static void set offsets V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE bsize MACROBLOCK const x cpi mb V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd MBMODEINFO mbmi const int mi width num 8x8 blocks wide lookup bsize const int mi height num 8x8 blocks high lookup bsize const struct segmentation const seg cm seg set skip context xd mi row mi col set modeinfo offsets cm xd mi row mi col mbmi xd mi 0 src mi mbmi vp9 setup dst planes xd plane get frame new buffer cm mi row mi col x mv row min mi row mi height MISIZEV P9 INTERPEXTEND x mv col min mi col mi width MISIZEV P9 INTERPEXTEND x mv row max cm mi rows mi row MISIZEV P9 INTERPEXTEND x mv col max cm mi cols mi col MISIZEV P9 INTERPEXTEND assert mi col mi width 1 mi row mi height 1 set mi row col xd tile mi row mi height mi col mi width cm mi rows cm mi cols vp9 setup src planes x cpi Source mi row mi col x rddiv cpi rd RDDIV x rdmult cpi rd RDMULT if seg enabled if cpi oxcf aq mode VARIANCEAQ const uint8 t const map seg update map cpi segmentation map cm last frame seg map mbmi segment id vp9 get segment id cm map bsize mi row mi col vp9 init plane quantizers cpi x x encode breakout cpi segment encode breakout mbmi segment id else mbmi segment id 0 x encode breakout cpi encode breakout static int decode frame Wmall Decode Ctx s Get Bit Context gb s gb int more frames 0 len 0 i ret s frame nb samples s samples per frame if ret ff get buffer s avctx s frame 0 0 av log s avctx AVLOGERROR not enough space for the output samples n s packet loss 1 return ret for i 0 i s num channels i s samples 16 i int16 t s frame extended data i s samples 32 i int32 t s frame extended data i if s len prefix len get bits gb s log2 frame size if decode tilehdr s s packet loss 1 return 0 if s dynamic range compression s drc gain get bits gb 8 if get bits1 gb int av unused skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx start skip i n skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx end skip i n skip s parsed all subframes 0 for i 0 i s num channels i s channel i decoded samples 0 s channel i cur subframe 0 while s parsed all subframes if decode subframe s 0 s packet loss 1 return 0 av dlog s avctx Frame done n if s skip frame s skip frame 0 if s len prefix if len get bits count gb s frame offset 2 av log s avctx AVLOGERROR frame i would have to skip i bits n s frame num len get bits count gb s frame offset 1 s packet loss 1 return 0 skip bits long gb len get bits count gb s frame offset 1 more frames get bits1 gb s frame num return more frames static int ipvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Ipvideo Context s avctx priv data int ret s decoding map size avctx width avctx height 8 8 2 if buf size s decoding map size return buf size s decoding map buf bytestream2 init s stream ptr buf s decoding map size buf size s decoding map size s current frame reference 3 if ret ff get buffer avctx s current frame 0 av log avctx AVLOGERROR Interplay Video get buffer failed n return ret if s is 16bpp const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s current frame palette has changed 1 memcpy s pal pal AVPALETTESIZE ipvideo decode opcodes s got frame 1 AV Frame data s current frame if s second last frame data 0 avctx release buffer avctx s second last frame s second last frame s last frame s last frame s current frame s current frame data 0 NULL return buf size static guint16 dissect mpa fpdu tvbuff t tvb packet info pinfo proto tree tree mpa state t state struct tcpinfo tcpinfo guint8 endpoint proto item mpa item NULL proto item mpa header item NULL proto tree mpa tree NULL proto tree mpa header tree NULL guint8 pad length guint16 ulpdu length exp ulpdu length guint32 offset total length guint32 num of m 0 if state minfo endpoint valid get first marker offset state tcpinfo endpoint 0 offset MPAMARKERLEN else offset 0 ulpdu length guint16 tvb get ntohs tvb offset if state minfo endpoint valid num of m number of markers state tcpinfo endpoint pad length fpdu pad length ulpdu length exp ulpdu length expected ulpdu length state tcpinfo endpoint if exp ulpdu length exp ulpdu length ulpdu length pad length return 0 mpa packetlist pinfo MPAFPDU mpa item proto tree add item tree proto iwarp mpa tvb 0 1 ENCNA mpa tree proto item add subtree mpa item ett mpa mpa header item proto tree add item mpa tree hf mpa fpdu tvb offset 1 ENCNA mpa header tree proto item add subtree mpa header item ett mpa proto tree add uint mpa header tree hf mpa ulpdu length tvb offset MPAULPDULENGTHLEN ulpdu length if state minfo endpoint valid num of m 0 total length fpdu total length tcpinfo if pad length 0 proto tree add item mpa header tree hf mpa pad tvb pad offset tcpinfo total length pad length pad length ENCNA dissect fpdu crc tvb mpa header tree state total length MPACRCLEN num of m MPAMARKERLEN ulpdu length pad length MPAULPDULENGTHLEN dissect fpdu markers tvb mpa tree state tcpinfo endpoint else offset MPAULPDULENGTHLEN ulpdu length if pad length 0 proto tree add item mpa header tree hf mpa pad tvb offset pad length ENCNA offset pad length dissect fpdu crc tvb mpa header tree state offset ulpdu length pad length MPAULPDULENGTHLEN return ulpdu length static int dissect CPM Get Rows tvbuff t tvb packet info pinfo proto tree parent tree gboolean in void private data struct mswsp ct ct NULL gint offset 16 proto item item proto tree tree proto tree seek tree guint32 e Type 0 item proto tree add item parent tree hf mswsp msg tvb offset in 0 1 ENCNA tree proto item add subtree item ett mswsp msg proto item set text item Get Rows s in In Out col append str pinfo cinfo COLINFO Get Rows ct get create converstation data pinfo if in struct message data data NULL proto tree add item tree hf mswsp msg cpmgetrows hcursor tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows rowstotransfer tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows rowwidth tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows cbseek tvb offset 4 ENCLITTLEENDIAN offset 4 data find or create message data ct pinfo 0x CC in private data if data data content rowsin cbreserved tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmgetrows cbreserved tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows cbreadbuffer tvb offset 4 ENCLITTLEENDIAN offset 4 if data data content rowsin ulclientbase tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmgetrows ulclientbase tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows fbwdfetch tvb offset 4 ENCLITTLEENDIAN offset 4 e Type tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmgetrows etype tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows chapt tvb offset 4 ENCLITTLEENDIAN offset 4 seek tree proto tree add subtree tree tvb offset 0 ett Seek Description NULL Seek Description switch e Type case 0 break case 1 parse C Row Seek Next tvb offset seek tree C Row Seek Next break case 2 parse C Row Seek At tvb offset seek tree C Row Seek At break case 3 parse C Row Seek At Ratio tvb offset seek tree C Row Seek At Ratio break case 4 parse C Row Seek By Bookmark tvb offset seek tree C Row Seek By Ratio break default break else guint32 num rows 0 proto item ti proto tree pad tree proto tree add subtree tree tvb offset 0 ett mswsp pad ti Padding struct CPM Set Bindings In bindingsin find binding msg data ct pinfo private data struct rows data rowsin find rowsin msg data ct pinfo private data gboolean b 64bit mode FALSE gboolean b has arch is 64bit mode ct pinfo b 64bit mode private data num rows tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmgetrows crowsreturned tvb offset 4 ENCLITTLEENDIAN offset 4 e Type tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmgetrows etype tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmgetrows chapt tvb offset 4 ENCLITTLEENDIAN offset 4 seek tree proto tree add subtree tree tvb offset 0 ett Seek Description NULL Seek Description switch e Type case 0 break case 1 parse C Row Seek Next tvb offset seek tree C Row Seek Next break case 2 parse C Row Seek At tvb offset seek tree C Row Seek At break case 3 parse C Row Seek At Ratio tvb offset seek tree C Row Seek At Ratio break case 4 parse C Row Seek By Bookmark tvb offset seek tree C Row Seek By Ratio break default break if b has arch bindingsin rowsin offset parse padding tvb offset rowsin cbreserved pad tree padding Rows parse Rows Buffer tvb offset num rows bindingsin rowsin b 64bit mode tree Rows else gint nbytes tvb reported length remaining tvb offset proto tree add expert format tree pinfo ei missing msg context tvb offset nbytes Undissected d bytes due to missing preceding msg s nbytes return tvb reported length tvb static char create argv command struct rule rule struct process process struct iovec argv size t count i j stdin arg char req argv NULL const char program for count 0 argv count NULL count if rule sudo user NULL req argv xcalloc count 1 sizeof char else req argv xcalloc count 5 sizeof char if rule sudo user NULL req argv 0 xstrdup PATHSUDO req argv 1 xstrdup u req argv 2 xstrdup rule sudo user req argv 3 xstrdup req argv 4 xstrdup rule program j 5 else program strrchr rule program if program NULL program rule program else program req argv 0 xstrdup program j 1 if rule stdin arg 1 stdin arg count 1 else stdin arg size t rule stdin arg for i 1 i count i const char data argv i iov base size t length argv i iov len if i stdin arg process input evbuffer new if process input NULL die internal error cannot create input buffer if evbuffer add process input data length 0 die internal error cannot add data to input buffer continue if length 0 req argv j xstrdup else req argv j xstrndup data length j req argv j NULL return req argv void jpc qmfb split col jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZE jpc fix t buf splitbuf register jpc fix t srcptr register jpc fix t dstptr register int n register int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr srcptr dstptr srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr srcptr dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr srcptr dstptr stride srcptr if buf splitbuf jas free buf static void handle raw login char packet int len struct query q int fd int userid char myhash 16 if len 16 return if userid 0 userid created users return if users userid active users userid disabled return if users userid authenticated return if users userid last pkt 60 time NULL return if debug 1 fprintf stderr IN login raw len d from user d n len userid login calculate myhash 16 password users userid seed 1 if memcmp packet myhash 16 0 struct sockaddr in tempin users userid last pkt time NULL memcpy users userid q q sizeof struct query tempin struct sockaddr in q from memcpy users userid host tempin sin addr sizeof struct in addr user set conn type userid CONNRAWUDP login calculate myhash 16 password users userid seed 1 send raw fd myhash 16 userid RAWHDRCMDLOGIN q users userid authenticated raw 1 static VALUE ossl cipher init int argc VALUE argv VALUE self int mode EVPCIPHERCTX ctx unsigned char key EVPMAXKEYLENGTH p key NULL unsigned char iv EVPMAXIVLENGTH p iv NULLVALUE pass init v if rb scan args argc argv 02 pass init v 0 VALUE cname rb class path rb obj class self rb warn arguments for PR Is VALUE encrypt and PR Is VALUE decrypt were deprecated use PR Is VALUE pkcs5 keyivgen to derive key and IV cname cname cname String Value pass Get Cipher self ctx if NILP init v memcpy iv Open SSL for Ruby rulez sizeof iv else String Value init v if EVPMAXIVLENGTHRSTRINGLEN init v memset iv 0 EVPMAXIVLENGTH memcpy iv RSTRINGPTR init v RSTRINGLEN init v else memcpy iv RSTRINGPTR init v sizeof iv EVP Bytes To Key EVPCIPHERCTX cipher ctx EVP md5 iv unsigned char RSTRINGPTR pass RSTRINGLENINT pass 1 key NULL p key key p iv iv else Get Cipher self ctx if EVP Cipher Init ex ctx NULLNULL p key p iv mode 1 ossl raise e Cipher Error NULL if p key rb ivar set self id key set Qtrue return self static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Fraps Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data AV Frame const f s frame uint32 t header unsigned int version header size unsigned int x y const uint32 t buf32 uint32 t luma1 luma2 cb cr uint32 t offs 4 int i j ret is chroma planes enum AV Pixel Format pix fmt header AVR L32 buf version header 0xff header size header 1 30 8 4 if version 5 av log avctx AVLOGERROR This file is encoded with Fraps version d This codec can only decode versions 5 n version return AVERRORPATCHWELCOME buf 4 if header size 8 buf 4 pix fmt version 1 AVPIXFMTBG R24 AVPIXFMTYUV J420 P if avctx pix fmt pix fmt f data 0 avctx release buffer avctx f avctx pix fmt pix fmt switch version case 0 default if buf size avctx width avctx height 3 2 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 2 header size return AVERRORINVALIDDATA if avctx width 8 0 avctx height 2 0 av log avctx AVLOGERROR Invalid frame size dx d n avctx width avctx height return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI buf32 const uint32 t buf for y 0 y avctx height 2 y luma1 uint32 t f data 0 y 2 f linesize 0 luma2 uint32 t f data 0 y 2 1 f linesize 0 cr uint32 t f data 1 y f linesize 1 cb uint32 t f data 2 y f linesize 2 for x 0 x avctx width x 8 luma1 buf32 luma1 buf32 luma2 buf32 luma2 buf32 cr buf32 cb buf32 break case 1 if buf size avctx width avctx height 3 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 header size return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI for y 0 y avctx height y memcpy f data 0 avctx height y 1 f linesize 0 buf y avctx width 3 3 avctx width break case 2 case 4 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i is chroma i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data i f linesize i avctx width is chroma avctx height is chroma buf offs i offs i 1 offs i is chroma 1 0 av log avctx AVLOGERROR Error decoding plane i n i return ret break case 3 case 5 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data 0 i f linesize 0 avctx height 1 f linesize 0 avctx width avctx height buf offs i offs i 1 offs i 0 3 0 av log avctx AVLOGERROR Error decoding plane i n i return ret for j 0 j avctx height j for i 0 i avctx width i f data 0 0 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 f data 0 2 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 break frame f got frame 1 return buf size static gpgme error t status handler void opaque int fd struct io cb data data struct io cb data opaque engine gpgsm t gpgsm engine gpgsm t data handler value gpgme error t err 0 char line size t linelen do err assuan read line gpgsm assuan ctx line linelen if err TRAC E3 DEBUGCTX gpgme status handler gpgsm fd 0x x error from assuan d getting status line s fd err gpg strerror err else if linelen 3 line 0 E line 1 R line 2 R line 3 0 line 3 if line 3 err atoi line 4 if err err gpg error GPGERRGENERALTRAC E2 DEBUGCTX gpgme status handler gpgsm fd 0x x ERR line mapped to s fd err gpg strerror err ok else if linelen 2 line 0 O line 1 K line 2 0 line 2 if gpgsm status fnc err gpgsm status fnc gpgsm status fnc value GPGMESTATUSEOF if err gpgsm colon fnc gpgsm colon any gpgsm colon any 0 err gpgsm colon fnc gpgsm colon fnc value NULLTRAC E2 DEBUGCTX gpgme status handler gpgsm fd 0x x OK line final status s fd err gpg strerror err ok gpgme io close gpgsm status cb fd return err else if linelen 2 line 0 D line 1 gpgsm colon fnc char src line 2 char end line linelen char dst char aline gpgsm colon attic line int alinelen gpgsm colon attic linelen if gpgsm colon attic linesize alinelen linelen 1 char newline realloc aline alinelen linelen 1 if newline err gpg error from syserror else aline newline gpgsm colon attic linesize linelen 1 if err dst aline alinelen while err src end if src src 2 end src dst gpgme hextobyte src alinelen src 2 else dst src alinelen if dst n gpgsm colon any 1 if alinelen 1 dst 1 r dst dst 0 err gpgsm colon fnc gpgsm colon fnc value aline if err dst aline alinelen 0 else dst TRAC E2 DEBUGCTX gpgme status handler gpgsm fd 0x x D line final status s fd err gpg strerror err ok else if linelen 2 line 0 D line 1 gpgsm inline data char src line 2 char end line linelen char dst src gpgme ssize t nwritten linelen 0 while src end if src src 2 end src dst gpgme hextobyte src src 2 else dst src linelen src line 2 while linelen 0 nwritten gpgme data write gpgsm inline data src linelen if nwritten nwritten 0 errno EINTR nwritten linelen err gpg error from syserror break src nwritten linelen nwritten TRAC E2 DEBUGCTX gpgme status handler gpgsm fd 0x x D inlinedata final status s fd err gpg strerror err ok else if linelen 2 line 0 S line 1 char rest gpgme status code t r rest strchr line 2 if rest rest line linelen else rest 0 r gpgme parse status line 2 if r 0 if gpgsm status fnc err gpgsm status fnc gpgsm status fnc value r rest else fprintf stderr UNKNOWNSTATUS s s line 2 rest TRAC E3 DEBUGCTX gpgme status handler gpgsm fd 0x x S line s final status s fd line 2 err gpg strerror err ok else if linelen 7 line 0 I line 1 N line 2 Q line 3 U line 4 I line 5 R line 6 E line 7 0 line 7 char keyword line 7 while keyword keyword default inq cb gpgsm keyword assuan write line gpgsm assuan ctx END while err assuan pending line gpgsm assuan ctx return err static Asn1 Generic Decode Asn1 Der Sequence const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length parsed bytes numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SEQUENCE c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size node length d length if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL parsed bytes 0 seq index 0 while parsed bytes d length el max size max size d ptr buffer Asn1 Generic child Decode Asn1 Der Generic d ptr el max size depth seq index errcode if child NULL if errcode errcode 0 Der Free node return NULL break int ret Asn1 Sequence Append node child if ret 1 Der Free child break parsed bytes child length d ptr child length seq index return Asn1 Generic node static uint dump events for db char db char query buff QUERYLENGTH char db name buff NAMELEN 2 3 name buff NAMELEN 2 3 char event name char delimiter QUERYLENGTHFILE sql file md result file MYSQLRES event res event list res MYSQLROW row event list row char db cl name MYCSNAMESIZE int db cl altered FALSEDBUGENTER dump events for db DBUGPRINT enter db s db mysql real escape string mysql db name buff db ulong strlen db print comment sql file 0 n n Dumping events for database s n n db if lock tables mysql query mysql LOCKTABLES mysql event READ if mysql query with error report mysql event list res show events DBUGRETURN 0 strcpy delimiter if mysql num rows event list res 0 if opt xml fputs t events n sql file else fprintf sql file n if fetch db collation db name buff db cl name sizeof db cl name DBUGRETURN 1 if switch character set results mysql binary DBUGRETURN 1 while event list row mysql fetch row event list res NULL event name quote name event list row 1 name buff 0 DBUGPRINT info retrieving CREATEEVENT for s name buff my snprintf query buff sizeof query buff SHOWCREATEEVENT s event name if mysql query with error report mysql event res query buff DBUGRETURN 1 while row mysql fetch row event res NULL if opt xml print xml row sql file event event res row Create Event continue if strlen row 3 0 char query str if opt drop fprintf sql file s n event name delimiter if create delimiter row 3 delimiter sizeof delimiter NULL fprintf stderr s Warning Can t create delimiter for event s n my progname short event name DBUGRETURN 1 fprintf sql file DELIMITER s n delimiter if mysql num fields event res 7 if switch db collation sql file db name buff delimiter db cl name row 6 db cl altered DBUGRETURN 1 switch cs variables sql file delimiter row 4 row 4 row 5 else fprintf sql file n WARNING old server version The following dump may be incomplete n n switch sql mode sql file delimiter row 1 switch time zone sql file delimiter row 2 query str cover definer clause row 3 strlen row 3 CSTRINGWITHLEN 50117 CSTRINGWITHLEN 50106 CSTRINGWITHLENEVENT fprintf sql file s n const char query str NULL query str row 3 const char delimiter my free query str restore time zone sql file delimiter restore sql mode sql file delimiter if mysql num fields event res 7 restore cs variables sql file delimiter if db cl altered if restore db collation sql file db name buff delimiter db cl name DBUGRETURN 1 mysql free result event res if opt xml fputs t events n sql file check io sql file else fprintf sql file DELIMITER n fprintf sql file n if switch character set results mysql default charset DBUGRETURN 1 mysql free result event list res if lock tables void mysql query with error report mysql 0 UNLOCKTABLESDBUGRETURN 0 static void rd auto partition range V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE min block size BLOCKSIZE max block size V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO mi xd mi 0 src mi const int left in image xd left available mi 1 src mi const int above in image xd up available mi xd mi stride src mi const int row8x8 remaining tile mi row end mi row const int col8x8 remaining tile mi col end mi col int bh bw BLOCKSIZE min size BLOCK 4 X4 BLOCKSIZE max size BLOCK 64 X64 int i 0 int bs hist BLOCKSIZES 0 if left in image above in image cm frame type KEYFRAME min size BLOCK 64 X64 max size BLOCK 4 X4 if cm frame type KEYFRAMEMODEINFO prev mi cm prev mip cm mi stride 1 mi row xd mi stride mi col get sb partition size range xd prev mi min size max size bs hist if left in image MODEINFO left sb64 mi mi MIBLOCKSIZE src mi get sb partition size range xd left sb64 mi min size max size bs hist if above in image MODEINFO above sb64 mi mi xd mi stride MIBLOCKSIZE src mi get sb partition size range xd above sb64 mi min size max size bs hist if cpi sf auto min max partition size RELAXEDNEIGHBORINGMINMAX min size min partition size min size max size max partition size max size else if cpi sf auto min max partition size CONSTRAINNEIGHBORINGMINMAX int sum 0 int first moment 0 int second moment 0 int var unnormalized 0 for i 0 i BLOCKSIZES i sum bs hist i first moment bs hist i i second moment bs hist i i i var unnormalized second moment first moment first moment sum if var unnormalized 4 sum int mean first moment sum min size min partition size mean max size max partition size mean else min size min partition size min size max size max partition size max size max size find partition size max size row8x8 remaining col8x8 remaining bh bw min size MIN min size max size if cpi sf use square partition only next square size max size min size min size next square size max size min block size min size max block size max size static void set block thresholds const V P9 COMMON cm RDOPT rd int i bsize segment id for segment id 0 segment id MAXSEGMENTS segment id const int qindex clamp vp9 get qindex cm seg segment id cm base qindex cm y dc delta q 0 MAXQ const int q compute rd thresh factor qindex for bsize 0 bsize BLOCKSIZES bsize const int t q rd thresh block size factor bsize const int thresh max INTMAX t if bsize BLOCK 8 X8 for i 0 i MAXMODES i rd threshes segment id bsize i rd thresh mult i thresh max rd thresh mult i t 4 INTMAX else for i 0 i MAXREFS i rd threshes segment id bsize i rd thresh mult sub8x8 i thresh max rd thresh mult sub8x8 i t 4 void vp9 set rd speed thresholds V P9 COMP cpi int i RDOPT const rd cpi rd SPEEDFEATURES const sf cpi sf for i 0 i MAXMODES i rd thresh mult i cpi oxcf mode BEST 500 0 rd thresh mult THRNEARESTMV 0 rd thresh mult THRNEARESTG 0 rd thresh mult THRNEARESTA 0 rd thresh mult THRDC 1000 rd thresh mult THRNEWMV 1000 rd thresh mult THRNEWA 1000 rd thresh mult THRNEWG 1000 rd thresh mult THRNEWMV sf elevate newmv thresh rd thresh mult THRNEARMV 1000 rd thresh mult THRNEARA 1000 rd thresh mult THRCOMPNEARESTLA 1000 rd thresh mult THRCOMPNEARESTGA 1000 rd thresh mult THRTM 1000 rd thresh mult THRCOMPNEARLA 1500 rd thresh mult THRCOMPNEWLA 2000 rd thresh mult THRNEARG 1000 rd thresh mult THRCOMPNEARGA 1500 rd thresh mult THRCOMPNEWGA 2000 rd thresh mult THRZEROMV 2000 rd thresh mult THRZEROG 2000 rd thresh mult THRZEROA 2000 rd thresh mult THRCOMPZEROLA 2500 rd thresh mult THRCOMPZEROGA 2500 rd thresh mult THRHPRED 2000 rd thresh mult THRVPRED 2000 rd thresh mult THR D45 PRED 2500 rd thresh mult THR D135 PRED 2500 rd thresh mult THR D117 PRED 2500 rd thresh mult THR D153 PRED 2500 rd thresh mult THR D207 PRED 2500 rd thresh mult THR D63 PRED 2500 if cpi ref frame flags V P9 LASTFLAG rd thresh mult THRNEWMVINTMAX rd thresh mult THRNEARESTMVINTMAX rd thresh mult THRZEROMVINTMAX rd thresh mult THRNEARMVINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult THRNEARESTGINTMAX rd thresh mult THRZEROGINTMAX rd thresh mult THRNEARGINTMAX rd thresh mult THRNEWGINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult THRNEARESTAINTMAX rd thresh mult THRZEROAINTMAX rd thresh mult THRNEARAINTMAX rd thresh mult THRNEWAINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROLAINTMAX rd thresh mult THRCOMPNEARESTLAINTMAX rd thresh mult THRCOMPNEARLAINTMAX rd thresh mult THRCOMPNEWLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROGAINTMAX rd thresh mult THRCOMPNEARESTGAINTMAX rd thresh mult THRCOMPNEARGAINTMAX rd thresh mult static void set partition range V P9 COMMON cm MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize BLOCKSIZE min bs BLOCKSIZE max bs int mi width num 8x8 blocks wide lookup bsize int mi height num 8x8 blocks high lookup bsize int idx idy MODEINFO mi MODEINFO prev mi cm prev mi grid visible mi row cm mi stride mi col BLOCKSIZE bs min size max size min size BLOCK 64 X64 max size BLOCK 4 X4 if prev mi for idy 0 idy mi height idy for idx 0 idx mi width idx mi prev mi idy cm mi stride idx bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd left available for idy 0 idy mi height idy mi xd mi idy cm mi stride 1 bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd up available for idx 0 idx mi width idx mi xd mi idx cm mi stride bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if min size max size min size min partition size min size max size max partition size max size min bs min size max bs max size static inline void vc1 pred mv intfr V C1 Context v int n int dmv x int dmv y int mvn int r x int r y uint8 t is intra Mpeg Enc Context s v s int xy wrap off 0 int A 2 B 2 C 2 int px py int a valid 0 b valid 0 c valid 0 int field a field b field c int total valid num samefield num oppfield int pos c pos b n adj wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture motion val 0 xy 0 0 s mv 0 n 1 s current picture motion val 0 xy 1 0 s current picture motion val 1 xy 0 0 s current picture motion val 1 xy 1 0 if mvn 1 s current picture motion val 0 xy 1 0 0 s current picture motion val 0 xy 1 1 0 s current picture motion val 0 xy wrap 0 0 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy wrap 1 0 0 s current picture motion val 0 xy wrap 1 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture motion val 1 xy 1 0 0 s current picture motion val 1 xy 1 1 0 s current picture motion val 1 xy wrap 0 0 s current picture motion val 1 xy wrap 1 0 s current picture motion val 1 xy wrap 1 0 0 s current picture motion val 1 xy wrap 1 1 0 return off n 0 n 1 1 1 if s mb x n 1 n 3 if v blk mv type xy v blk mv type xy v blk mv type xy 1 A 0 s current picture motion val 0 xy 1 0 A 1 s current picture motion val 0 xy 1 1 a valid 1 else A 0 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 1 off wrap 0 1 1 A 1 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 off wrap 1 1 1 a valid 1 if n 1 v is intra s mb x 1 a valid 0 A 0 A 1 0 else A 0 A 1 0 B 0 B 1 C 0 C 1 0 if n 0 n 1 v blk mv type xy if s first slice line if v is intra s mb x s mb stride b valid 1 n adj n 2 pos b s block index n adj 2 wrap if v blk mv type pos b v blk mv type xy n adj n 2 n 1 B 0 s current picture motion val 0 s block index n adj 2 wrap 0 B 1 s current picture motion val 0 s block index n adj 2 wrap 1 if v blk mv type pos b v blk mv type xy B 0 B 0 s current picture motion val 0 s block index n adj 2 2 wrap 0 1 1 B 1 B 1 s current picture motion val 0 s block index n adj 2 2 wrap 1 1 1 if s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 2 pos c s block index 2 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 2 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index n adj 2 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index n adj 2 2 wrap 2 1 1 if s mb x s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 3 pos c s block index 3 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 1 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index 1 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index 1 2 wrap 2 1 1 else c valid 0 else pos b s block index 1 b valid 1 B 0 s current picture motion val 0 pos b 0 B 1 s current picture motion val 0 pos b 1 pos c s block index 0 c valid 1 C 0 s current picture motion val 0 pos c 0 C 1 s current picture motion val 0 pos c 1 total valid a valid b valid c valid if s mb x n 1 n 3 A 0 A 1 0 if s first slice line v blk mv type xy s first slice line n 2 B 0 B 1 C 0 C 1 0 if v blk mv type xy if s mb width 1 px B 0 py B 1 else if total valid 2 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if total valid if a valid px A 0 py A 1 if b valid px B 0 py B 1 if c valid px C 0 py C 1 else px py 0 else if a valid field a A 1 4 1 0 else field a 0 if b valid field b B 1 4 1 0 else field b 0 if c valid field c C 1 4 1 0 else field c 0 num oppfield field a field b field c num samefield total valid num oppfield if total valid 3 if num samefield 3 num oppfield 3 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if num samefield num oppfield px field a A 0 B 0 py field a A 1 B 1 else px field a A 0 B 0 py field a A 1 B 1 else if total valid 2 if num samefield num oppfield if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else px py 0 else if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else if total valid 1 px a valid A 0 b valid B 0 C 0 py a valid A 1 b valid B 1 C 1 else px py 0 s mv 0 n 0 s current picture motion val 0 xy 0 px dmv x r x r x 1 1 r x s mv 0 n 1 s current picture motion val 0 xy 1 py dmv y r y r y 1 1 r y if mvn 1 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 1 s current picture motion val 0 xy 1 else if mvn 2 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s mv 0 n 1 0 s mv 0 n 0 s mv 0 n 1 1 s mv 0 n 1 static int dissect diameter base framed ipv6 prefix tvbuff t tvb packet info pinfo U proto tree tree void data diam sub dis t diam sub dis diam sub dis t data guint8 prefix len prefix len bytes proto tree add item tree hf framed ipv6 prefix reserved tvb 0 1 ENCBIGENDIAN proto tree add item tree hf framed ipv6 prefix length tvb 1 1 ENCBIGENDIAN prefix len tvb get guint8 tvb 1 prefix len bytes prefix len 8 if prefix len 8 prefix len bytes proto tree add item tree hf framed ipv6 prefix bytes tvb 2 prefix len bytes ENCNA if prefix len bytes 16 proto tree add item tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes ENCNA else struct e in6 addr value address addr memset value bytes 0 sizeof value tvb memcpy tvb guint8 value bytes 2 prefix len bytes value bytes prefix len bytes value bytes prefix len bytes 0xff prefix len 8 proto tree add ipv6 tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes value set address addr ATI Pv6 16 value bytes diam sub dis avp str wmem strdup printf wmem packet scope s u address to str wmem packet scope addr prefix len return prefix len bytes 2 static int dissect diameter base framed ipv6 prefix tvbuff t tvb packet info pinfo U proto tree tree void data diam sub dis t diam sub dis diam sub dis t data guint8 prefix len prefix len bytes proto tree add item tree hf framed ipv6 prefix reserved tvb 0 1 ENCBIGENDIAN proto tree add item tree hf framed ipv6 prefix length tvb 1 1 ENCBIGENDIAN prefix len tvb get guint8 tvb 1 prefix len bytes prefix len 8 if prefix len 8 prefix len bytes proto tree add item tree hf framed ipv6 prefix bytes tvb 2 prefix len bytes ENCNA if prefix len bytes 16 proto tree add item tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes ENCNA else struct e in6 addr value address addr memset value bytes 0 sizeof value tvb memcpy tvb guint8 value bytes 2 prefix len bytes value bytes prefix len bytes value bytes prefix len bytes 0xff prefix len 8 proto tree add ipv6 tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes value set address addr ATI Pv6 16 value bytes diam sub dis avp str wmem strdup printf wmem packet scope s u address to str wmem packet scope addr prefix len return prefix len bytes 2 int ff wmv2 decode mb Mpeg Enc Context s int16 t block 6 64 Wmv2 Context const w Wmv2 Context s int cbp code i uint8 t coded val if w j type return 0 if s pict type AVPICTURETYPEP if ISSKIP s current picture mb type s mb y s mb stride s mb x s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 w hshift 0 return 0 code get vlc2 s gb ff mb non intra vlc w cbp table index table MBNONINTRAVLCBITS 3 if code 0 return 1 s mb intra code 0x40 6 cbp code 0x3f else s mb intra 1 code get vlc2 s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if code 0 av log s avctx AVLOGERRORII cbp illegal at d d n s mb x s mb y return 1 cbp 0 for i 0 i 6 i int val code 5 i 1 if i 4 int pred ff msmpeg4 coded block pred s i coded val val val pred coded val val cbp val 5 i if s mb intra int mx my wmv2 pred motion w mx my if cbp s dsp clear blocks s block 0 if s per mb rl table s rl table index decode012 s gb s rl chroma table index s rl table index if w abt flag w per mb abt w per block abt get bits1 s gb if w per block abt w abt type decode012 s gb else w per block abt 0 if wmv2 decode motion w mx my 0 return 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 mx s mv 0 0 1 my for i 0 i 6 i if wmv2 decode inter block w block i i cbp 5 i 1 0 av log s avctx AVLOGERROR nerror while decoding inter block d x d d n s mb x s mb y i return 1 else if s pict type AVPICTURETYPEP av dlog s avctx d d s inter intra pred cbp av dlog s avctx I at d d d 06 X n s mb x s mb y cbp 3 1 0 cbp 0x3 C 2 0 show bits s gb 24 s ac pred get bits1 s gb if s inter intra pred s h263 aic dir get vlc2 s gb ff inter intra vlc table INTERINTRAVLCBITS 1 av dlog s avctx d d d d s ac pred s h263 aic dir s mb x s mb y if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index s dsp clear blocks s block 0 for i 0 i 6 i if ff msmpeg4 decode block s block i i cbp 5 i 1 NULL 0 av log s avctx AVLOGERROR nerror while decoding intra block d x d d n s mb x s mb y i return 1 return 0 static int encode picture lossless AV Codec Context avctx AV Packet pkt const AV Frame pict int got packet Mpeg Enc Context const s avctx priv data M Jpeg Context const m s mjpeg ctx const int width s width const int height s height AV Frame const p s current picture f const int predictor avctx prediction method 1 const int mb width width s mjpeg hsample 0 1 s mjpeg hsample 0 const int mb height height s mjpeg vsample 0 1 s mjpeg vsample 0 int ret max pkt size FFMINBUFFERSIZE if avctx pix fmt AVPIXFMTBGRA max pkt size width height 3 4 else max pkt size mb width mb height 3 4 s mjpeg hsample 0 s mjpeg vsample 0 if ret ff alloc packet pkt max pkt size 0 av log avctx AVLOGERROR Error getting output packet of size d n max pkt size return ret init put bits s pb pkt data pkt size av frame unref p ret av frame ref p pict if ret 0 return ret p pict type AVPICTURETYPEI p key frame 1 ff mjpeg encode picture header s s header bits put bits count s pb if avctx pix fmt AVPIXFMTBGRA int x y i const int linesize p linesize 0 uint16 t buffer 4 void s rd scratchpad int left 3 top 3 topleft 3 for i 0 i 3 i buffer 0 i 1 9 1 for y 0 y height y const int modified predictor y predictor 1 uint8 t ptr p data 0 linesize y if s pb buf end s pb buf put bits count s pb 3 width 3 4 av log s avctx AVLOGERROR encoded frame too large n return 1 for i 0 i 3 i top i left i topleft i buffer 0 i for x 0 x width x buffer x 1 ptr 4 x 0 ptr 4 x 1 0x100 buffer x 2 ptr 4 x 2 ptr 4 x 1 0x100 buffer x 0 ptr 4 x 0 2 ptr 4 x 1 ptr 4 x 2 2 for i 0 i 3 i int pred diff PREDICT pred topleft i top i left i modified predictor topleft i top i top i buffer x 1 i left i buffer x i diff left i pred 0x100 0x1 FF 0x100 if i 0 ff mjpeg encode dc s diff m huff size dc luminance m huff code dc luminance else ff mjpeg encode dc s diff m huff size dc chrominance m huff code dc chrominance else int mb x mb y i for mb y 0 mb y mb height mb y if s pb buf end s pb buf put bits count s pb 3 mb width 4 3 s mjpeg hsample 0 s mjpeg vsample 0 av log s avctx AVLOGERROR encoded frame too large n return 1 for mb x 0 mb x mb width mb x if mb x 0 mb y 0 for i 0 i 3 i uint8 t ptr int x y h v linesize h s mjpeg hsample i v s mjpeg vsample i linesize p linesize i for y 0 y v y for x 0 x h x int pred ptr p data i linesize v mb y y h mb x x if y 0 mb y 0 if x 0 mb x 0 pred 128 else pred ptr 1 else if x 0 mb x 0 pred ptr linesize else PREDICT pred ptr linesize 1 ptr linesize ptr 1 predictor if i 0 ff mjpeg encode dc s ptr pred m huff size dc luminance m huff code dc luminance else ff mjpeg encode dc s ptr pred m huff size dc chrominance m huff code dc chrominance else for i 0 i 3 i uint8 t ptr int x y h v linesize h s mjpeg hsample i v s mjpeg vsample i linesize p linesize i for y 0 y v y for x 0 x h x int pred ptr p data i linesize v mb y y h mb x x PREDICT pred ptr linesize 1 ptr linesize ptr 1 predictor if i 0 ff mjpeg encode dc s ptr pred m huff size dc luminance m huff code dc luminance else ff mjpeg encode dc s ptr pred m huff size dc chrominance m huff code dc chrominance emms c ff mjpeg encode picture trailer s s picture number flush put bits s pb pkt size put bits ptr s pb s pb buf pkt flags AVPKTFLAGKEY got packet 1 return 0 static int lag decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Lagarith Context l avctx priv data AV Frame const p l picture uint8 t frametype 0 uint32 t offset gu 0 offset bv 0 offset ry 9 uint32 t offs 4 uint8 t srcs 4 dst int i j planes 3 AV Frame picture data if p data 0 ff thread release buffer avctx p p reference 0 p key frame 1 frametype buf 0 offset gu AVR L32 buf 1 offset bv AVR L32 buf 5 switch frametype case FRAMESOLIDRGBA avctx pix fmt AVPIXFMTRG B32 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 dst p data 0 for j 0 j avctx height j for i 0 i avctx width i AVW N32 dst i 4 offset gu dst p linesize 0 break case FRAMEARITHRGBA avctx pix fmt AVPIXFMTRG B32 planes 4 offset ry 4 offs 3 AVR L32 buf 9 case FRAMEARITHRG B24 case FRAMEURG B24 if frametype FRAMEARITHRG B24 frametype FRAMEURG B24 avctx pix fmt AVPIXFMTRG B24 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 offs 0 offset bv offs 1 offset gu offs 2 offset ry if l rgb planes l rgb stride FFALIGN avctx width 16 l rgb planes av malloc l rgb stride avctx height planes 1 if l rgb planes av log avctx AVLOGERROR cannot allocate temporary buffer n return AVERRORENOMEM for i 0 i planes i srcs i l rgb planes i 1 l rgb stride avctx height l rgb stride if offset ry buf size offset gu buf size offset bv buf size planes 4 offs 3 buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA for i 0 i planes i lag decode arith plane l srcs i avctx width avctx height l rgb stride buf offs i buf size offs i dst p data 0 for i 0 i planes i srcs i l rgb planes i l rgb stride avctx height for j 0 j avctx height j for i 0 i avctx width i uint8 t r g b a r srcs 0 i g srcs 1 i b srcs 2 i r g b g if frametype FRAMEARITHRGBA a srcs 3 i AVW N32 dst i 4 MKBETAG a r g b else dst i 3 0 r dst i 3 1 g dst i 3 2 b dst p linesize 0 for i 0 i planes i srcs i l rgb stride break case FRAMEARITHYU Y2 avctx pix fmt AVPIXFMTYU V422 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 1 avctx width 2 avctx height p linesize 1 buf offset gu buf size offset gu lag decode arith plane l p data 2 avctx width 2 avctx height p linesize 2 buf offset bv buf size offset bv break case FRAMEARITHY V12 avctx pix fmt AVPIXFMTYU V420 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf offset gu buf size offset gu lag decode arith plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf offset bv buf size offset bv break default av log avctx AVLOGERROR Unsupported Lagarith frame type x n frametype return 1 picture p got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t ctable 128 Qpeg Context const a avctx priv data AV Frame const p a pic uint8 t outdata int delta ret const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if avpkt size 0x86 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA bytestream2 init a buffer avpkt data avpkt size if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR reget buffer failed n return ret outdata a pic data 0 bytestream2 skip a buffer 4 bytestream2 get buffer a buffer ctable 128 bytestream2 skip a buffer 1 delta bytestream2 get byte a buffer if delta 0x10 qpeg decode intra a outdata a pic linesize 0 avctx width avctx height else qpeg decode inter a outdata a pic linesize 0 avctx width avctx height delta ctable a refdata if pal a pic palette has changed 1 memcpy a pal pal AVPALETTESIZE memcpy a pic data 1 a pal AVPALETTESIZE if ret av frame ref data a pic 0 return ret got frame 1 return avpkt size static int decode udvm multitype operand guint8 buff guint operand address guint16 value guint test bits guint bytecode guint offset operand address guint16 operand guint32 result guint8 temp data guint16 temp data16 guint16 memmory addr 0 value 0 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 0xc0 6 switch test bits case 0 operand buff operand address value operand offset break case 1 memmory addr bytecode 0x3f 2 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset break case 2 test bits bytecode 0xe0 5 if test bits 5 temp data buff operand address 0x1f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data value operand offset offset 2 else test bits bytecode 0xf0 4 if test bits 9 temp data buff operand address 0x0f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 61440 value operand offset offset 2 else test bits bytecode 0x08 3 if test bits 1 result 1 buff operand address 0x07 8 operand result 0xffff value operand offset else test bits bytecode 0x0e 1 if test bits 3 result 1 buff operand address 0x01 6 operand result 0xffff value operand offset else offset temp data16 buff operand address 1 0xffff 8 temp data16 temp data16 buff operand address 2 0xffff if bytecode 0x01 1 memmory addr temp data16 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 break case 3 test bits bytecode 0x20 5 if test bits 1 operand buff operand address 0x1f 65504 value operand offset else memmory addr buff operand address 0x1f memmory addr memmory addr 8 memmory addr memmory addr buff operand address 1 0xffff temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 default break return offset static ulong get sort uint count va list args va start args count ulong sort 0 DBUGASSERT count 4 while count char start str va arg args char uint chars 0 uint wild pos 0 if start str for str str if str wild prefix str 1 str else if str wild many str wild one wild pos uint str start 1 if wild pos 1 str wild many str 0 wild pos break chars 128 sort sort 8 wild pos min wild pos 127 chars va end args return sort void vp9 rd pick intra mode sb V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd struct macroblockd plane const pd xd plane int rate y 0 rate uv 0 rate y tokenonly 0 rate uv tokenonly 0 int y skip 0 uv skip 0 int64 t dist y 0 dist uv 0 tx cache TXMODES 0 TXSIZE max uv tx size x skip encode 0 ctx skip 0 xd mi 0 src mi mbmi ref frame 0 INTRAFRAME if bsize BLOCK 8 X8 if rd pick intra sby mode cpi x rate y rate y tokenonly dist y y skip bsize tx cache best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip bsize max uv tx size else y skip 0 if rd pick intra sub 8x8 y mode cpi x rate y rate y tokenonly dist y best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip BLOCK 8 X8 max uv tx size if y skip uv skip returnrate rate y rate uv rate y tokenonly rate uv tokenonly vp9 cost bit vp9 get skip prob cm xd 1 returndist dist y dist uv vp9 zero ctx tx rd diff else int i returnrate rate y rate uv vp9 cost bit vp9 get skip prob cm xd 0 returndist dist y dist uv if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i if tx cache i IN T64 MAX tx cache cm tx mode IN T64 MAX ctx tx rd diff i tx cache i tx cache cm tx mode else ctx tx rd diff i 0 ctx mic xd mi 0 src mi static void cpu signal int sig if cpu single env cpu exit ENVGETCPU cpu single env exit request 1 static int vble decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VBLE Context ctx avctx priv data AV Frame pic avctx coded frame Get Bit Context gb const uint8 t src avpkt data int version int offset 0 int width uv avctx width 2 height uv avctx height 2 pic reference 0 if pic data 0 avctx release buffer avctx pic if ff get buffer avctx pic 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI version AVR L32 src if version 1 av log avctx AVLOGWARNING Unsupported VBLE Version d n version init get bits gb src 4 avpkt size 4 8 if vble unpack ctx gb 0 av log avctx AVLOGERROR Invalid Code n return AVERRORINVALIDDATA vble restore plane ctx 0 offset avctx width avctx height if ctx avctx flags CODECFLAGGRAY offset avctx width avctx height vble restore plane ctx 1 offset width uv height uv offset width uv height uv vble restore plane ctx 2 offset width uv height uv got frame 1 AV Frame data pic return avpkt size static gboolean logcat read packet struct logcat phdr logcat FILET fh struct wtap pkthdr phdr Buffer buf int err gchar err info gint bytes read gint packet size guint16 payload length guint tmp 2 guint8 pd bytes read file read tmp 2 fh if bytes read 2 err file error fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return FALSE payload length pletoh16 tmp if logcat version 1 packet size 5 4 payload length else if logcat version 2 packet size 6 4 payload length else return FALSE buffer assure space buf packet size pd buffer start ptr buf memcpy pd tmp 2 bytes read file read pd 2 packet size 2 fh if bytes read packet size 2 err file error fh err info if err 0 err WTAPERRSHORTREAD return FALSE phdr rec type RECTYPEPACKET phdr presence flags WTAPHASTS phdr ts secs time t pletoh32 pd 12 phdr ts nsecs int pletoh32 pd 16 phdr caplen packet size phdr len packet size phdr pseudo header logcat version logcat version return static int cavs decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AVS Context h avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data uint32 t stc 1 int input size const uint8 t buf end const uint8 t buf ptr if buf size 0 if h low delay h DPB 0 f data 0 got frame 1 picture h DPB 0 f if h cur f data 0 avctx release buffer avctx h cur f FFSWAPAVS Frame h cur h DPB 0 return 0 buf ptr buf buf end buf buf size for buf ptr avpriv mpv find start code buf ptr buf end stc if stc 0x FFFFF E00 buf ptr buf end return FFMAX 0 buf ptr buf input size buf end buf ptr 8 switch stc case CAVSSTARTCODE init get bits h gb buf ptr input size decode seq header h break case PICISTARTCODE if h got keyframe if h DPB 0 f data 0 avctx release buffer avctx h DPB 0 f if h DPB 1 f data 0 avctx release buffer avctx h DPB 1 f h got keyframe 1 case PICPBSTARTCODE got frame 0 if h got keyframe break init get bits h gb buf ptr input size h stc stc if decode pic h break got frame 1 if h cur f pict type AVPICTURETYPEB if h DPB 1 f data 0 picture h DPB 1 f else got frame 0 else picture h cur f break case EXTSTARTCODE break case USERSTARTCODE break default if stc SLICEMAXSTARTCODE init get bits h gb buf ptr input size decode slice header h h gb break static int bfi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Get Byte Context g int buf size avpkt size BFI Context bfi avctx priv data uint8 t dst bfi dst uint8 t src dst offset colour1 colour2 uint8 t frame end bfi dst avctx width avctx height uint32 t pal int i j ret height avctx height if bfi frame data 0 avctx release buffer avctx bfi frame bfi frame reference 1 if ret ff get buffer avctx bfi frame 0 av log avctx AVLOGERROR get buffer failed n return ret bytestream2 init g avpkt data buf size if avctx frame number bfi frame pict type AVPICTURETYPEI bfi frame key frame 1 if avctx extradata size 768 av log NULLAVLOGERROR Palette is too large n return AVERRORINVALIDDATA pal uint32 t bfi frame data 1 for i 0 i avctx extradata size 3 i int shift 16 pal 0 for j 0 j 3 j shift 8 pal avctx extradata i 3 j 2 avctx extradata i 3 j 4 shift pal bfi frame palette has changed 1 else bfi frame pict type AVPICTURETYPEP bfi frame key frame 0 bytestream2 skip g 4 while dst frame end static const uint8 t lentab 4 0 2 0 1 unsigned int byte bytestream2 get byte g av uninit offset unsigned int code byte 6 unsigned int length byte 0x C0 if bytestream2 get bytes left g av log avctx AVLOGERROR Input resolution larger than actual frame n return AVERRORINVALIDDATA if length 0 if code 1 length bytestream2 get byte g offset bytestream2 get le16 g else length bytestream2 get le16 g if code 2 length 0 break else if code 1 offset bytestream2 get byte g if dst length lentab code frame end break switch code case 0 if length bytestream2 get bytes left g av log avctx AVLOGERROR Frame larger than buffer n return AVERRORINVALIDDATA bytestream2 get buffer g dst length dst length break case 1 dst offset dst offset length 4 if dst offset bfi dst break while length dst dst offset break case 2 dst length break case 3 colour1 bytestream2 get byte g colour2 bytestream2 get byte g while length dst colour1 dst colour2 break src bfi dst dst bfi frame data 0 while height memcpy dst src avctx width src avctx width dst bfi frame linesize 0 got frame 1 AV Frame data bfi frame return buf size static void fill colmap H264 Context h int map 2 16 32 int list int field int colfield int mbafi Picture const ref1 h ref list 1 0 int j old ref rfield int start mbafi 16 0 int end mbafi 16 2 h ref count 0 h ref count 0 int interl mbafi h picture structure PICTFRAME memset map list 0 sizeof map list for rfield 0 rfield 2 rfield for old ref 0 old ref ref1 ref count colfield list old ref int poc ref1 ref poc colfield list old ref if interl poc 3 else if interl poc 3 3 poc poc 3 rfield 1 for j start j end j if 4 h ref list 0 j frame num h ref list 0 j reference 3 poc int cur ref mbafi j 16 field j if ref1 mbaff map list 2 old ref rfield field 16 cur ref if rfield field interl map list old ref cur ref break static void encode block intra int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane int16 t coeff BLOCKOFFSET p coeff block int16 t qcoeff BLOCKOFFSET p qcoeff block int16 t dqcoeff BLOCKOFFSET pd dqcoeff block const scan order scan order TXTYPE tx type PREDICTIONMODE mode const int bwl b width log2 plane bsize const int diff stride 4 1 bwl uint8 t src dst int16 t src diff uint16 t eob p eobs block const int src stride p src stride const int dst stride pd dst stride int i j txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j dst stride i src p src buf 4 j src stride i src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 scan order vp9 default scan orders TX 32 X32 mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 6 bwl TX 32 X32 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 32 32 src diff diff stride src src stride dst dst stride fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 idct32x32 add dqcoeff dst dst stride eob break case TX 16 X16 tx type get tx type pd plane type xd scan order vp9 scan orders TX 16 X16 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 4 bwl TX 16 X16 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 16 16 src diff diff stride src src stride dst dst stride vp9 fht16x16 src diff coeff diff stride tx type vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht16x16 add tx type dqcoeff dst dst stride eob break case TX 8 X8 tx type get tx type pd plane type xd scan order vp9 scan orders TX 8 X8 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 2 bwl TX 8 X8 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 8 8 src diff diff stride src src stride dst dst stride vp9 fht8x8 src diff coeff diff stride tx type vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht8x8 add tx type dqcoeff dst dst stride eob break case TX 4 X4 tx type get tx type 4x4 pd plane type xd block scan order vp9 scan orders TX 4 X4 tx type mode plane 0 get y mode xd mi 0 block mbmi uv mode vp9 predict intra block xd block bwl TX 4 X4 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 4 4 src diff diff stride src src stride dst dst stride if tx type DCTDCT vp9 fht4x4 src diff coeff diff stride tx type else x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob if tx type DCTDCT x itxm add dqcoeff dst dst stride eob else vp9 iht4x4 16 add dqcoeff dst dst stride tx type break default assert 0 break if eob args skip 0 static int imc decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int ret i IMC Context q avctx priv data LOCALALIGNED 16 uint16 t buf16 IMCBLOCKSIZE 2 if buf size IMCBLOCKSIZE avctx channels av log avctx AVLOGERROR frame too small n return AVERRORINVALIDDATA frame nb samples COEFFS if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for i 0 i avctx channels i q out samples float frame extended data i q dsp bswap16 buf buf16 const uint16 t buf IMCBLOCKSIZE 2 init get bits q gb const uint8 t buf16 IMCBLOCKSIZE 8 buf IMCBLOCKSIZE if ret imc decode block avctx q i 0 return ret if avctx channels 2 q fdsp butterflies float float frame extended data 0 float frame extended data 1 COEFFS got frame ptr 1 return IMCBLOCKSIZE avctx channels void vp9 dec build inter predictors sb MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane 0 plane MAXMBPLANE plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x dec build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else dec build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static Asn1 Generic Decode Asn1 Der Printable String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 PRINTSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL strlcpy a str const char d ptr length 1 a str length 0 d ptr length a length d ptr buffer return a static int output data MLP Decode Context m unsigned int substr AV Frame frame int got frame ptr AV Codec Context avctx m avctx Sub Stream s m substream substr unsigned int i out ch 0 int32 t data 32 int16 t data 16 int ret int is32 m avctx sample fmt AVSAMPLEFMT S32 if m avctx channels s max matrix channel 1 av log m avctx AVLOGERROR channel count mismatch n return AVERRORINVALIDDATA if s blockpos av log avctx AVLOGERROR No samples to output n return AVERRORINVALIDDATA frame nb samples s blockpos if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret data 32 int32 t frame data 0 data 16 int16 t frame data 0 for i 0 i s blockpos i for out ch 0 out ch s max matrix channel out ch int mat ch s ch assign out ch int32 t sample m sample buffer i mat ch s output shift mat ch s lossless check data sample 0xffffff mat ch if is32 data 32 sample 8 else data 16 sample 8 got frame ptr 1 return 0 void ff vdpau h264 set reference frames H264 Context h struct vdpau render state render render ref Vdp Reference Frame H264 rf rf2 Picture pic int i list pic frame idx render struct vdpau render state h cur pic ptr f data 0 assert render rf render info h264 reference Frames 0 list 2 list Picture lp list h long ref h short ref int ls list 16 h short ref count for i 0 i ls i pic lp i if pic pic reference continue pic frame idx pic long ref pic pic id pic frame num render ref struct vdpau render state pic f data 0 assert render ref rf2 render info h264 reference Frames 0 while rf2 rf if rf2 surface render ref surface rf2 is long term pic long ref rf2 frame idx pic frame idx break rf2 if rf2 rf rf2 top is reference pic reference PICTTOPFIELDVDPTRUEVDPFALSE rf2 bottom is reference pic reference PICTBOTTOMFIELDVDPTRUEVDPFALSE continue if rf render info h264 reference Frames H264 RFCOUNT continue rf surface render ref surface rf is long term pic long ref rf top is reference pic reference PICTTOPFIELDVDPTRUEVDPFALSE rf bottom is reference pic reference PICTBOTTOMFIELDVDPTRUEVDPFALSE rf field order cnt 0 pic field poc 0 rf field order cnt 1 pic field poc 1 rf frame idx pic frame idx rf for rf render info h264 reference Frames H264 RFCOUNT rf rf surface VDPINVALIDHANDLE rf is long term 0 rf top is reference 0 rf bottom is reference 0 rf field order cnt 0 0 rf field order cnt 1 0 rf frame idx 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Kmvc Context const ctx avctx priv data uint8 t out src int i ret int header int blocksize const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL bytestream2 init ctx g avpkt data avpkt size if ctx pic data 0 avctx release buffer avctx ctx pic ctx pic reference 1 ctx pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx ctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret header bytestream2 get byte ctx g if bytestream2 peek byte ctx g 127 bytestream2 skip ctx g 3 for i 0 i 127 i ctx pal i header 0x81 bytestream2 get be24 ctx g bytestream2 skip ctx g 1 bytestream2 seek ctx g 127 4 3 SEEKCUR if header KMVCKEYFRAME ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP if header KMVCPALETTE ctx pic palette has changed 1 for i 1 i ctx palsize i ctx pal i bytestream2 get be24 ctx g if pal ctx pic palette has changed 1 memcpy ctx pal pal AVPALETTESIZE if ctx setpal ctx setpal 0 ctx pic palette has changed 1 memcpy ctx pic data 1 ctx pal 1024 blocksize bytestream2 get byte ctx g if blocksize 8 blocksize 127 av log avctx AVLOGERROR Block size i n blocksize return AVERRORINVALIDDATA memset ctx cur 0 320 200 switch header KMVCMETHOD case 0 case 1 memcpy ctx cur ctx prev 320 200 break case 3 kmvc decode intra 8x8 ctx avctx width avctx height break case 4 kmvc decode inter 8x8 ctx avctx width avctx height break default av log avctx AVLOGERROR Unknown compression method i n header KMVCMETHOD return AVERRORINVALIDDATA out ctx pic data 0 src ctx cur for i 0 i avctx height i memcpy out src avctx width src 320 out ctx pic linesize 0 if ctx cur ctx frm0 ctx cur ctx frm1 ctx prev ctx frm0 else ctx cur ctx frm0 ctx prev ctx frm1 got frame 1 AV Frame data ctx pic return avpkt size void vp9 tokenize sb V P9 COMP cpi TOKENEXTRA t int dry run BLOCKSIZE bsize V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi TOKENEXTRA t backup t const int ctx vp9 get skip context xd const int skip inc vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP struct tokenize b args arg cpi xd t if mbmi skip if dry run cm counts skip ctx 1 skip inc reset skip context xd bsize if dry run t t backup return if dry run cm counts skip ctx 0 skip inc vp9 foreach transformed block xd bsize tokenize b arg else vp9 foreach transformed block xd bsize set entropy context b arg t t backup static int adx decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data int buf size avpkt size ADX Context c avctx priv data int16 t samples int samples offset const uint8 t buf avpkt data int num blocks ch ret if c eof got frame ptr 0 return buf size if c header parsed buf size 2 AVR B16 buf 0x8000 int header size if ret avpriv adx decode header avctx buf buf size header size c coeff 0 av log avctx AVLOGERROR error parsing ADX header n return AVERRORINVALIDDATA c channels avctx channels c header parsed 1 if buf size header size return AVERRORINVALIDDATA buf header size buf size header size if c header parsed return AVERRORINVALIDDATA num blocks buf size BLOCKSIZE c channels if num blocks buf size BLOCKSIZE avctx channels if buf size 4 AVR B16 buf 0x8000 c eof 1 got frame ptr 0 return avpkt size return AVERRORINVALIDDATA frame nb samples num blocks BLOCKSAMPLES if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame extended data samples offset 0 while num blocks for ch 0 ch c channels ch if adx decode c samples ch samples offset buf ch c eof 1 buf avpkt data avpkt size break buf size BLOCKSIZE buf BLOCKSIZE samples offset BLOCKSAMPLES got frame ptr 1 return buf avpkt data static int gsm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data int res Get Bit Context gb const uint8 t buf avpkt data int buf size avpkt size int16 t samples if buf size avctx block align av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA frame nb samples avctx frame size if res ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return res samples int16 t frame data 0 switch avctx codec id case AVCODECIDGSM init get bits gb buf buf size 8 if get bits gb 4 0xd av log avctx AVLOGWARNING Missing GSM magic n res gsm decode block avctx samples gb if res 0 return res break case AVCODECIDGSMMS res ff msgsm decode block avctx samples buf if res 0 return res got frame ptr 1 return avctx block align static int dissect pcp message tvbuff t tvb packet info pinfo proto tree tree void data U proto item root pcp item proto tree pcp tree conversation t conversation pcp conv info t pcp conv info guint32 packet type gint32 err bytes int offset 0 col set str pinfo cinfo COLPROTOCOLPCP col clear pinfo cinfo COLINFO conversation find or create conversation pinfo pcp conv info pcp conv info t conversation get proto data conversation proto pcp if pcp conv info NULL pcp conv info pcp conv info t wmem alloc wmem file scope sizeof pcp conv info t conversation add proto data conversation proto pcp pcp conv info pcp conv info pmid name candidates wmem array new wmem file scope sizeof guint8 pcp conv info pmid to name wmem map new wmem file scope g direct hash g direct equal pcp conv info last pmns names frame 0 pcp conv info last processed pmns names frame 0 root pcp item proto tree add item tree proto pcp tvb 0 1 ENCNA pcp tree proto item add subtree root pcp item ett pcp packet type tvb get ntohl tvb 4 if pinfo srcport PCPPORT pinfo srcport PMPROXYPORT col set str pinfo cinfo COLINFO Server Client else col set str pinfo cinfo COLINFO Client Server proto tree add item pcp tree hf pcp pdu length tvb offset 4 ENCBIGENDIAN offset 4 proto tree add item pcp tree hf pcp pdu type tvb offset 4 ENCBIGENDIAN offset 4 proto tree add item pcp tree hf pcp pdu pid tvb offset 4 ENCBIGENDIAN offset 4 switch packet type case PCPPDUCREDS dissect pcp message creds tvb pinfo pcp tree offset break case PCPPDUSTARTORERROR err bytes tvb get ntohl tvb offset if err bytes 0 dissect pcp message error tvb pinfo pcp tree offset else dissect pcp message start tvb pinfo pcp tree offset break case PCPPDUPMNSTRAVERSE dissect pcp message pmns traverse tvb pinfo pcp tree offset break case PCPPDUPMNSNAMES dissect pcp message pmns names tvb pinfo pcp tree offset break case PCPPDUPMNSCHILD dissect pcp message pmns child tvb pinfo pcp tree offset break case PCPPDUPMNSIDS dissect pcp message pmns ids tvb pinfo pcp tree offset break case PCPPDUPROFILE dissect pcp message profile tvb pinfo pcp tree offset break case PCPPDUFETCH dissect pcp message fetch tvb pinfo pcp tree offset break case PCPPDURESULT dissect pcp message result tvb pinfo pcp tree offset break case PCPPDUDESCREQ dissect pcp message desc req tvb pinfo pcp tree offset break case PCPPDUDESC dissect pcp message desc tvb pinfo pcp tree offset break case PCPPDUINSTANCEREQ dissect pcp message instance req tvb pinfo pcp tree offset break case PCPPDUINSTANCE dissect pcp message instance tvb pinfo pcp tree offset break case PCPPDUTEXTREQ dissect pcp message text req tvb pinfo pcp tree offset break case PCPPDUTEXT dissect pcp message text tvb pinfo pcp tree offset break case PCPPDUUSERAUTH dissect pcp message user auth tvb pinfo pcp tree offset break default col append str pinfo cinfo COLINFOUNIMPLEMENTEDTYPE expert add info pinfo pcp tree ei pcp unimplemented packet type break return tvb captured length tvb int mdb search Operation op Slap Reply rs struct mdb info mdb struct mdb info op o bd be private ID id cursor nsubs ncand cscope ID lastid NOIDID candidates MDBIDLUMSIZEID iscopes MDBIDLDBSIZEI D2 scopes void stack Entry e NULL base NULL Entry matched NULL Attribute Name attrs slap mask t mask time t stoptime int manage DS Ait int tentries 0 Id Scopes isc MDB cursor mci mcd ww ctx wwctx slap callback cb 0 mdb op info opinfo 0 moi opinfo MDB txn ltid NULL Debug LDAPDEBUGTRACELDAPXSTRING mdb search n 0 0 0 attrs op oq search rs attrs manage DS Ait get manage DS Ait op rs sr err mdb opinfo get op mdb 1 moi switch rs sr err case 0 break default send ldap error op rs LDAPOTHER internal error return rs sr err ltid moi moi txn rs sr err mdb cursor open ltid mdb mi id2entry mci if rs sr err send ldap error op rs LDAPOTHER internal error return rs sr err rs sr err mdb cursor open ltid mdb mi dn2id mcd if rs sr err mdb cursor close mci send ldap error op rs LDAPOTHER internal error return rs sr err scopes scope chunk get op stack search stack op isc mt ltid isc mc mcd isc scopes scopes isc oscope op ors scope isc sctmp stack if op ors deref LDAPDEREFFINDINGMDBIDLZERO candidates dn2entry retry rs sr err mdb dn2entry op ltid mcd op o req ndn e nsubs 1 switch rs sr err case MDBNOTFOUND matched e e NULL break case 0 break case LDAPBUSY send ldap error op rs LDAPBUSY ldap server busy goto done default send ldap error op rs LDAPOTHER internal error goto done if op ors deref LDAPDEREFFINDING if matched is entry alias matched struct berval stub stub bv val op o req ndn bv val stub bv len op o req ndn bv len matched e nname bv len 1 e deref base op rs matched matched ltid candidates NULL if e build new dn op o req ndn e e nname stub op o tmpmemctx mdb entry return op e matched NULL goto dn2entry retry else if e is entry alias e e deref base op rs e matched ltid candidates NULL if e NULL struct berval matched dn BERBVNULL if matched NULL Ber Varray erefs NULL if access allowed op matched slap schema si ad entry NULLACLDISCLOSENULL rs sr err LDAPNOSUCHOBJECT else ber dupbv matched dn matched e name erefs is entry referral matched get entry referrals op matched NULL if rs sr err MDBNOTFOUND rs sr err LDAPREFERRAL rs sr matched matched dn bv val mdb entry return op matched matched NULL if erefs rs sr ref referral rewrite erefs matched dn op o req dn op oq search rs scope ber bvarray free erefs else rs sr ref referral rewrite default referral NULL op o req dn op oq search rs scope rs sr err rs sr ref NULLLDAPREFERRALLDAPNOSUCHOBJECT send ldap result op rs if rs sr ref ber bvarray free rs sr ref rs sr ref NULL if BERBVISNULL matched dn ber memfree matched dn bv val rs sr matched NULL goto done if access allowed mask op e slap schema si ad entry NULLACLSEARCHNULL mask if ACLGRANT mask ACLDISCLOSE rs sr err LDAPNOSUCHOBJECT else rs sr err LDAPINSUFFICIENTACCESS mdb entry return op e send ldap result op rs goto done if manage DS Ait is entry referral e struct berval matched dn BERBVNULL Ber Varray erefs NULL ber dupbv matched dn e e name erefs get entry referrals op e rs sr err LDAPREFERRAL mdb entry return op e e NULL if erefs rs sr ref referral rewrite erefs matched dn op o req dn op oq search rs scope ber bvarray free erefs if rs sr ref rs sr text bad referral object Debug LDAPDEBUGTRACELDAPXSTRING mdb search entry is referral n 0 0 0 rs sr matched matched dn bv val send ldap result op rs ber bvarray free rs sr ref rs sr ref NULL ber memfree matched dn bv val rs sr matched NULL goto done if get assert op test filter op e get assertion op LDAPCOMPARETRUE rs sr err LDAPASSERTIONFAILED mdb entry return op e send ldap result op rs goto done stoptime op o time op ors tlimit base e e NULL if op oq search rs scope LDAPSCOPEBASE rs sr err base candidate op o bd base candidates scopes 0 mid 0 ncand 1 else if op ors scope LDAPSCOPEONELEVEL size t nkids MDB val key data key mv data base e id key mv size sizeof ID mdb cursor get mcd key data MDBSET mdb cursor count mcd nkids nsubs nkids 1 else if base e id MDB stat ms mdb stat ltid mdb mi id2entry ms nsubs ms ms entries MDBIDLZERO candidates scopes 0 mid 1 scopes 1 mid base e id scopes 1 mval mv data NULL rs sr err search candidates op rs base isc mci candidates stack ncand MDBIDLN candidates if base e id ncand NOIDMDB stat ms mdb stat ltid mdb mi id2entry ms if base e id nsubs ms ms entries if ncand NOID ncand ms ms entries cursor 0 if candidates 0 0 Debug LDAPDEBUGTRACELDAPXSTRING mdb search no candidates n 0 0 0 goto nochange if op ors limit op ors limit lms s unchecked 1 ncand unsigned op ors limit lms s unchecked rs sr err LDAPADMINLIMITEXCEEDED send ldap result op rs rs sr err LDAPSUCCESS goto done if op ors limit NULL op ors limit lms s pr hide tentries ncand wwctx flag 0 if moi opinfo cb sc writewait mdb writewait cb sc private wwctx wwctx txn ltid wwctx mcd NULL cb sc next op o callback op o callback cb if get pagedresults op SLAPCONTROLIGNORED Paged Results State ps op o pagedresults state rs sr err parse paged cookie op rs if rs sr err LDAPSUCCESS send ldap result op rs goto done cursor ID ps ps cookie if cursor ps ps size 0 rs sr err LDAPSUCCESS rs sr text search abandoned by paged Result size 0 send ldap result op rs goto done id mdb idl first candidates cursor if id NOID Debug LDAPDEBUGTRACELDAPXSTRING mdb search no paged results candidates n 0 0 0 send paged response op rs lastid 0 rs sr err LDAPOTHER goto done if id ID ps ps cookie id mdb idl next candidates cursor nsubs ncand goto loop begin if nsubs ncand int rc if scopes 0 mid 1 cursor 1 for cscope 1 cscope scopes 0 mid cscope if scopes cscope mid base e id continue iscopes cursor scopes cscope mid iscopes 0 scopes 0 mid 1 else iscopes 0 0 wwctx mcd mcd isc id base e id isc numrdns 0 rc mdb dn2id walk op isc if rc id NOID else id isc id cscope 0 else id mdb idl first candidates cursor while id NOID int scopeok MDB val edata loop begin if op o abandon rs sr err SLAPDABANDON send ldap result op rs goto done if slapd shutdown rs sr err LDAPUNAVAILABLE send ldap disconnect op rs goto done if op ors tlimit SLAPNOLIMIT slap get time stoptime rs sr err LDAPTIMELIMITEXCEEDED rs sr ref rs sr v2ref send ldap result op rs rs sr err LDAPSUCCESS goto done if nsubs ncand unsigned i scopeok 0 if MDBIDLISRANGE candidates if id MDBIDLRANGEFIRST candidates id MDBIDLRANGELAST candidates scopeok 1 else i mdb idl search candidates id if i candidates 0 candidates i id scopeok 1 if scopeok goto scopeok goto loop continue scopeok 0 isc numrdns 0 switch op ors scope case LDAPSCOPEBASE if id base e id scopeok 1 break scopeok 1 break case LDAPSCOPEONELEVEL if id base e id break isc id id isc nscope 0 rs sr err mdb idscopes op isc if rs sr err MDBSUCCESS if isc nscope scopeok 1 else if rs sr err MDBNOTFOUND goto notfound break if scopeok Debug LDAPDEBUGTRACELDAPXSTRING mdb search ld scope not okay n long id 0 0 goto loop continue scopeok if id base e id e base else rs sr err mdb id2edata op mci id edata if rs sr err MDBNOTFOUND notfound if nsubs ncand goto loop continue if MDBIDLISRANGE candidates Debug LDAPDEBUGTRACELDAPXSTRING mdb search candidate ld not found n long id 0 0 else rs sr err mdb get nextid mci cursor if rs sr err MDBNOTFOUND break if rs sr err rs sr err LDAPOTHER rs sr text internal error in get nextid send ldap result op rs goto done cursor goto loop continue else if rs sr err rs sr err LDAPOTHER rs sr text internal error in mdb id2edata send ldap result op rs goto done rs sr err mdb entry decode op ltid edata id e if rs sr err rs sr err LDAPOTHER rs sr text internal error in mdb entry decode send ldap result op rs goto done e e id id e e name bv val NULL e e nname bv val NULL if is entry subentry e if op oq search rs scope LDAPSCOPEBASE if get subentries visibility op goto loop continue else if get subentries op get subentries visibility op goto loop continue else if get subentries visibility op goto loop continue if op ors deref LDAPDEREFSEARCHING if is entry alias e op ors deref LDAPDEREFFINDING e base goto loop continue if manage DS Ait is entry glue e goto loop continue if e base struct berval pdn pndn char d n int i if nsubs ncand isc scopes isc nscope mid base e id pdn base e name pndn base e nname else mdb id2name op ltid isc mc scopes isc nscope mid pdn pndn e e name bv len pdn bv len e e nname bv len pndn bv len for i 0 i isc numrdns i e e name bv len isc rdns i bv len 1 e e nname bv len isc nrdns i bv len 1 e e name bv val op o tmpalloc e e name bv len 1 op o tmpmemctx e e nname bv val op o tmpalloc e e nname bv len 1 op o tmpmemctx d e e name bv val n e e nname bv val if nsubs ncand for i isc numrdns 1 i 0 i memcpy d isc rdns i bv val isc rdns i bv len d isc rdns i bv len d memcpy n isc nrdns i bv val isc nrdns i bv len n isc nrdns i bv len n else for i 0 i isc numrdns i memcpy d isc rdns i bv val isc rdns i bv len d isc rdns i bv len d memcpy n isc nrdns i bv val isc nrdns i bv len n isc nrdns i bv len n if pdn bv len memcpy d pdn bv val pdn bv len 1 memcpy n pndn bv val pndn bv len 1 else d 0 n 0 e e name bv len e e nname bv len if pndn bv val base e nname bv val op o tmpfree pndn bv val op o tmpmemctx op o tmpfree pdn bv val op o tmpmemctx if manage DS Ait op oq search rs scope LDAPSCOPEBASE is entry referral e Ber Varray erefs get entry referrals op e rs sr ref referral rewrite erefs e e name NULL op oq search rs scope LDAPSCOPEONELEVELLDAPSCOPEBASELDAPSCOPESUBTREE rs sr entry e rs sr flags 0 send search reference op rs if e base mdb entry return op e rs sr entry NULL e NULL ber bvarray free rs sr ref ber bvarray free erefs rs sr ref NULL goto loop continue rs sr err test filter op e op oq search rs filter if rs sr err LDAPCOMPARETRUE if get pagedresults op SLAPCONTROLIGNORED if rs sr nentries Paged Results State op o pagedresults state ps size mdb entry return op e e NULL send paged response op rs lastid tentries goto done lastid id if e rs sr attrs op oq search rs attrs rs sr operational attrs NULL rs sr ctrls NULL rs sr entry e RSASSERT e e private NULL rs sr flags 0 rs sr err LDAPSUCCESS rs sr err send search entry op rs rs sr attrs NULL rs sr entry NULL if e base mdb entry return op e e NULL switch rs sr err case LDAPSUCCESS break default break case LDAPBUSY send ldap result op rs goto done case LDAPUNAVAILABLE case LDAPSIZELIMITEXCEEDED if rs sr err LDAPSIZELIMITEXCEEDED rs sr ref rs sr v2ref send ldap result op rs rs sr err LDAPSUCCESS else rs sr err LDAPOTHER goto done else Debug LDAPDEBUGTRACELDAPXSTRING mdb search ld does not match filter n long id 0 0 loop continue if moi opinfo wwctx flag mdb mi rtxn size wwctx nentries if wwctx nentries mdb mi rtxn size wwctx nentries 0 mdb rtxn snap op wwctx if wwctx flag rs sr err mdb waitfixup op wwctx mci mcd isc if rs sr err send ldap result op rs goto done if e NULL if e base mdb entry return op e RSASSERT rs sr entry NULL e NULL rs sr entry NULL if nsubs ncand int rc mdb dn2id walk op isc if rc id NOID while iscopes 0 cscope iscopes 0 cscope isc id iscopes cscope if base mdb entry return op base rs sr err mdb id2entry op mci isc id base if rs sr err mdb id2name op ltid isc mc isc id base e name base e nname isc numrdns 0 if isc oscope LDAPSCOPEONELEVEL isc oscope LDAPSCOPEBASE rc mdb dn2id walk op isc if rc id isc id break else id isc id else id mdb idl next candidates cursor static int select input picture Mpeg Enc Context s int i ret for i 1 i MAXPICTURECOUNT i s reordered input picture i 1 s reordered input picture i s reordered input picture MAXPICTURECOUNT 1 NULL if s reordered input picture 0 NULL s input picture 0 if s next picture ptr NULL s intra only s reordered input picture 0 s input picture 0 s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f coded picture number s coded picture number else int b frames if s avctx frame skip threshold s avctx frame skip factor if s picture in gop number s gop size skip check s s input picture 0 s next picture ptr av frame unref s input picture 0 f emms c ff vbv update s 0 goto no output pic if s flags CODECFLAGPAS S2 for i 0 i s max b frames 1 i int pict num s input picture 0 f display picture number i if pict num s rc context num entries break if s input picture i s rc context entry pict num 1 new pict type AVPICTURETYPEP break s input picture i f pict type s rc context entry pict num new pict type if s avctx b frame strategy 0 b frames s max b frames while b frames s input picture b frames b frames else if s avctx b frame strategy 1 for i 1 i s max b frames 1 i if s input picture i s input picture i b frame score 0 s input picture i b frame score get intra count s s input picture i f data 0 s input picture i 1 f data 0 s linesize 1 for i 0 i s max b frames 1 i if s input picture i NULL s input picture i b frame score 1 s mb num s avctx b sensitivity break b frames FFMAX 0 i 1 for i 0 i b frames 1 i s input picture i b frame score 0 else if s avctx b frame strategy 2 b frames estimate best b count s else av log s avctx AVLOGERROR illegal b frame strategy n b frames 0 emms c for i b frames 1 i 0 i int type s input picture i f pict type if type type AVPICTURETYPEB b frames i if s input picture b frames f pict type AVPICTURETYPEB b frames s max b frames av log s avctx AVLOGERROR warning too many b frames in a row n if s picture in gop number b frames s gop size if s mpv flags FFMPVFLAGSTRICTGOP s gop size s picture in gop number b frames s gop size s picture in gop number 1 else if s flags CODECFLAGCLOSEDGOP b frames 0 s input picture b frames f pict type AVPICTURETYPEI if s flags CODECFLAGCLOSEDGOP b frames s input picture b frames f pict type AVPICTURETYPEI b frames s reordered input picture 0 s input picture b frames if s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f pict type AVPICTURETYPEP s reordered input picture 0 f coded picture number s coded picture number for i 0 i b frames i s reordered input picture i 1 s input picture i s reordered input picture i 1 f pict type AVPICTURETYPEB s reordered input picture i 1 f coded picture number s coded picture number no output pic if s reordered input picture 0 s reordered input picture 0 reference s reordered input picture 0 f pict type AVPICTURETYPEB 3 0 ff mpeg unref picture s s new picture if ret ff mpeg ref picture s s new picture s reordered input picture 0 return ret if s reordered input picture 0 shared s avctx rc buffer size Picture pic int i ff find unused picture s 0 if i 0 return i pic s picture i pic reference s reordered input picture 0 reference if ff alloc picture s pic 0 0 return 1 copy picture attributes s pic f s reordered input picture 0 f av frame unref s reordered input picture 0 f s reordered input picture 0 shared 0 s current picture ptr pic else s current picture ptr s reordered input picture 0 for i 0 i 4 i s new picture f data i INPLACEOFFSET ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret s picture number s new picture f display picture number else ff mpeg unref picture s s new picture return 0 static void update state V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col BLOCKSIZE bsize int output enabled int i x idx y V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd struct macroblock plane const p x plane struct macroblockd plane const pd xd plane MODEINFO mi ctx mic MBMODEINFO const mbmi xd mi 0 src mi mbmi MODEINFO mi addr xd mi 0 const struct segmentation const seg cm seg const int mis cm mi stride const int mi width num 8x8 blocks wide lookup bsize const int mi height num 8x8 blocks high lookup bsize int max plane assert mi mbmi sb type bsize mi addr mi mi addr src mi mi addr if seg enabled output enabled if cpi oxcf aq mode COMPLEXITYAQ const uint8 t const map seg update map cpi segmentation map cm last frame seg map mi addr mbmi segment id vp9 get segment id cm map bsize mi row mi col if cpi oxcf aq mode CYCLICREFRESHAQ vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 max plane is inter block mbmi MAXMBPLANE 1 for i 0 i max plane i p i coeff ctx coeff pbuf i 1 p i qcoeff ctx qcoeff pbuf i 1 pd i dqcoeff ctx dqcoeff pbuf i 1 p i eobs ctx eobs pbuf i 1 for i max plane i MAXMBPLANE i p i coeff ctx coeff pbuf i 2 p i qcoeff ctx qcoeff pbuf i 2 pd i dqcoeff ctx dqcoeff pbuf i 2 p i eobs ctx eobs pbuf i 2 for y 0 y mi height y for x idx 0 x idx mi width x idx if xd mb to right edge 3 MISIZELO G2 mi width x idx xd mb to bottom edge 3 MISIZELO G2 mi height y xd mi x idx y mis src mi mi addr if cpi oxcf aq mode vp9 init plane quantizers cpi x if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 ctx tx rd diff ALLOW 16 X16 ctx tx rd diff ALLOW 8 X8 ctx tx rd diff ALLOW 32 X32 ctx tx rd diff ALLOW 16 X16 if is inter block mbmi mbmi sb type BLOCK 8 X8 mbmi mv 0 as int mi bmi 3 as mv 0 as int mbmi mv 1 as int mi bmi 3 as mv 1 as int x skip ctx skip vpx memcpy x zcoeff blk mbmi tx size ctx zcoeff blk sizeof uint8 t ctx num 4x4 blk if output enabled return if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP for i 0 i TXMODES i rd opt tx select diff i ctx tx rd diff i static const int kf mode index THRDCTHRVPREDTHRHPREDTHR D45 PREDTHR D135 PREDTHR D117 PREDTHR D153 PREDTHR D207 PREDTHR D63 PREDTHRTM cpi mode chosen counts kf mode index mbmi mode static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int field ret AV Frame pic avctx coded frame const uint8 t buf avpkt data const uint8 t buf end buf avpkt size if pic data 0 avctx release buffer avctx pic if avpkt size avctx width 2 avctx height 4 2 8 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if bytestream get le32 buf MKTAGFRW 1 av log avctx AVLOGERROR incorrect marker n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret pic pict type AVPICTURETYPEI pic key frame 1 pic interlaced frame 1 pic top field first 1 for field 0 field 2 field int i int field h avctx height field 1 int field size min field size avctx width 2 field h uint8 t dst pic data 0 if buf end buf 8 return AVERRORINVALIDDATA buf 4 field size bytestream get le32 buf if field size min field size av log avctx AVLOGERROR Field size i is too small required i n field size min field size return AVERRORINVALIDDATA if buf end buf field size av log avctx AVLOGERROR Packet is too small need i have i n field size int buf end buf return AVERRORINVALIDDATA if field dst pic linesize 0 for i 0 i field h i memcpy dst buf avctx width 2 buf avctx width 2 dst pic linesize 0 1 buf field size min field size got frame 1 AV Frame data pic return avpkt size static u16 transaction id pick void for u16 trans id trans id function if trans id 0xffff continue if request find from trans id trans id NULL return trans id static inline void ff mpeg4 set one direct mv Mpeg Enc Context s int mx int my int i int xy s block index i uint16 t time pp s pp time uint16 t time pb s pb time int p mx p my p mx s next picture f motion val 0 xy 0 if unsigned p mx tab bias tab size s mv 0 i 0 s direct scale mv 0 p mx tab bias mx s mv 1 i 0 mx s mv 0 i 0 p mx s direct scale mv 1 p mx tab bias else s mv 0 i 0 p mx time pb time pp mx s mv 1 i 0 mx s mv 0 i 0 p mx p mx time pb time pp time pp p my s next picture f motion val 0 xy 1 if unsigned p my tab bias tab size s mv 0 i 1 s direct scale mv 0 p my tab bias my s mv 1 i 1 my s mv 0 i 1 p my s direct scale mv 1 p my tab bias else s mv 0 i 1 p my time pb time pp my s mv 1 i 1 my s mv 0 i 1 p my p my time pb time pp time pp void vp9 cyclic refresh setup V P9 COMP const cpi V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc CYCLICREFRESH const cr cpi cyclic refresh struct segmentation const seg cm seg unsigned char const seg map cpi segmentation map const int apply cyclic refresh apply cyclic refresh bitrate cm rc if apply cyclic refresh cm frame type KEYFRAME cpi svc temporal layer id 0 vpx memset seg map 0 cm mi rows cm mi cols vp9 disable segmentation cm seg if cm frame type KEYFRAME cr sb index 0 return else int qindex delta 0 int i block count bl index sb rows sb cols sbs in frame int xmis ymis x y qindex2 const float rate ratio qdelta 2 0 const double q vp9 convert qindex to q cm base qindex vp9 clear system state cr max sbs perframe 10 cr max qdelta perc 50 cr min block size BLOCK 8 X8 cr time for refresh 1 cr thresh rate sb rc sb64 target rate 256 2 cr thresh dist sb 8 int q q if cpi sf use nonrd pick mode cr thresh rate sb rc sb64 target rate 256 3 cr thresh dist sb 4 int q q cr num seg blocks 0 vpx memset seg map 0 cm mi rows cm mi cols vp9 enable segmentation cm seg vp9 clearall segfeatures seg seg abs delta SEGMENTDELTADATA vp9 disable segfeature seg 0 SEGLVLALTQ vp9 enable segfeature seg 1 SEGLVLALTQ qindex delta vp9 compute qdelta by rate rc cm frame type cm base qindex rate ratio qdelta if qindex delta cr max qdelta perc cm base qindex 100 qindex delta cr max qdelta perc cm base qindex 100 qindex2 clamp cm base qindex cm y dc delta q qindex delta 0 MAXQ cr rdmult vp9 compute rd mult cpi qindex2 vp9 set segdata seg 1 SEGLVLALTQ qindex delta sb cols cm mi cols MIBLOCKSIZE 1 MIBLOCKSIZE sb rows cm mi rows MIBLOCKSIZE 1 MIBLOCKSIZE sbs in frame sb cols sb rows block count cr max sbs perframe sbs in frame 100 assert cr sb index sbs in frame i cr sb index do int sum map 0 int sb row index i sb cols int sb col index i sb row index sb cols int mi row sb row index MIBLOCKSIZE int mi col sb col index MIBLOCKSIZE assert mi row 0 mi row cm mi rows assert mi col 0 mi col cm mi cols bl index mi row cm mi cols mi col xmis MIN cm mi cols mi col num 8x8 blocks wide lookup BLOCK 64 X64 ymis MIN cm mi rows mi row num 8x8 blocks high lookup BLOCK 64 X64 for y 0 y ymis y for x 0 x xmis x const int bl index2 bl index y cm mi cols x if cr map bl index2 0 seg map bl index2 1 sum map else if cr map bl index2 0 cr map bl index2 if sum map 0 sum map xmis ymis const int new value sum map xmis ymis 2 for y 0 y ymis y for x 0 x xmis x seg map bl index y cm mi cols x new value i if i sbs in frame i 0 if sum map xmis ymis 2 block count while block count i cr sb index cr sb index i static guint32 dissect minipacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet proto item item ts tvb get ntohs tvb offset iax packet iax2 get packet data for minipacket pinfo scallno FALSE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add uint iax2 tree hf iax2 minits tvb offset 2 ts iax2 add ts fields pinfo iax2 tree iax packet guint16 ts else iax2 add ts fields pinfo iax2 tree iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini packet source call d timestamp ums scallno ts dissect payload tvb offset pinfo iax2 tree main tree ts FALSE iax packet iax packet first time FALSE return offset static int16 t wmv2 pred motion Wmv2 Context w int px int py Mpeg Enc Context const s w s int xy wrap diff type int16 t ABC mot val wrap s b8 stride xy s block index 0 mot val s current picture motion val 0 xy A s current picture motion val 0 xy 1 B s current picture motion val 0 xy wrap C s current picture motion val 0 xy 2 wrap if s mb x s first slice line s mspel w top left mv flag diff FFMAXFFABSA 0 B 0 FFABSA 1 B 1 else diff 0 if diff 8 type get bits1 s gb else type 2 if type 0 px A 0 py A 1 else if type 1 px B 0 py B 1 else if s first slice line px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val static int64 t rd pick intra4x4block V P9 COMP cpi MACROBLOCK x int ib PREDICTIONMODE best mode const int bmode costs ENTROPYCONTEXT a ENTROPYCONTEXT l int bestrate int bestratey int64 t bestdistortion BLOCKSIZE bsize int64 t rd thresh PREDICTIONMODE mode MACROBLOCKD const xd x e mbd int64 t best rd rd thresh struct macroblock plane p x plane 0 struct macroblockd plane pd xd plane 0 const int src stride p src stride const int dst stride pd dst stride const uint8 t src init p src buf raster block offset BLOCK 8 X8 ib src stride uint8 t dst init pd dst buf raster block offset BLOCK 8 X8 ib dst stride ENTROPYCONTEXT ta 2 tempa 2 ENTROPYCONTEXT tl 2 templ 2 const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize int idx idy uint8 t best dst 8 8 assert ib 4 vpx memcpy ta a sizeof ta vpx memcpy tl l sizeof tl xd mi 0 src mi mbmi tx size TX 4 X4 for mode DCPRED mode TMPRED mode int64 t this rd int ratey 0 int64 t distortion 0 int rate bmode costs mode if cpi sf intra y mode mask TX 4 X4 1 mode continue if cpi sf mode search skip flags FLAGSKIPINTRADIRMISMATCH if conditional skipintra mode best mode continue vpx memcpy tempa ta sizeof ta vpx memcpy templ tl sizeof tl for idy 0 idy num 4x4 blocks high idy for idx 0 idx num 4x4 blocks wide idx const int block ib idy 2 idx const uint8 t const src src init idx 4 idy 4 src stride uint8 t const dst dst init idx 4 idy 4 dst stride int16 t const src diff raster block offset int16 BLOCK 8 X8 block p src diff tran low t const coeff BLOCKOFFSET x plane 0 coeff block xd mi 0 src mi bmi block as mode mode vp9 predict intra block xd block 1 TX 4 X4 mode x skip encode src dst x skip encode src stride dst stride dst dst stride idx idy 0 vp9 subtract block 4 4 src diff 8 src src stride dst dst stride if xd lossless const scan order so vp9 default scan orders TX 4 X4 vp9 fwht4x4 src diff coeff 8 vp9 regular quantize b 4x4 x 0 block so scan so iscan ratey cost coeffs x 0 block tempa idx templ idy TX 4 X4 so scan so neighbors cpi sf use fast coef costing if RDCOST x rdmult x rddiv ratey distortion best rd goto next vp9 iwht4x4 add BLOCKOFFSET pd dqcoeff block dst dst stride p eobs block else int64 t unused const TXTYPE tx type get tx type 4x4 PLANETYPEY xd block const scan order so vp9 scan orders TX 4 X4 tx type vp9 fht4x4 src diff coeff 8 tx type vp9 regular quantize b 4x4 x 0 block so scan so iscan ratey cost coeffs x 0 block tempa idx templ idy TX 4 X4 so scan so neighbors cpi sf use fast coef costing distortion vp9 block error coeff BLOCKOFFSET pd dqcoeff block 16 unused 2 if RDCOST x rdmult x rddiv ratey distortion best rd goto next vp9 iht4x4 add tx type BLOCKOFFSET pd dqcoeff block dst dst stride p eobs block rate ratey this rd RDCOST x rdmult x rddiv rate distortion if this rd best rd bestrate rate bestratey ratey bestdistortion distortion best rd this rd best mode mode vpx memcpy a tempa sizeof tempa vpx memcpy l templ sizeof templ for idy 0 idy num 4x4 blocks high 4 idy vpx memcpy best dst idy 8 dst init idy dst stride num 4x4 blocks wide 4 next if best rd rd thresh x skip encode return best rd for idy 0 idy num 4x4 blocks high 4 idy vpx memcpy dst init idy dst stride best dst idy 8 num 4x4 blocks wide 4 return best rd extern int as mysql step start mysql conn t mysql conn struct step record step ptr int tasks 0 nodes 0 task dist 0 int rc SLURMSUCCESS char temp bit BUFSIZE char node list BUFFERSIZE char node inx NULL step name NULL time t start time submit time char query NULL if step ptr job ptr db index step ptr job ptr details step ptr job ptr details submit time step ptr job ptr resize time error as mysql step start Not inputing this job it has no submit time return SLURMERROR if step ptr job ptr resize time submit time start time step ptr job ptr resize time if step ptr start time submit time start time step ptr start time else start time step ptr start time submit time step ptr job ptr details submit time if check connection mysql conn SLURMSUCCESS return ESLURMDBCONNECTION if slurmdbd conf if step ptr job ptr details tasks step ptr job ptr details num tasks else tasks step ptr cpu count snprintf node list BUFFERSIZE s step ptr job ptr nodes nodes step ptr step layout node cnt task dist step ptr step layout task dist node inx step ptr network else if step ptr step id SLURMBATCHSCRIPT if step ptr step node bitmap node inx bit fmt temp bit sizeof temp bit step ptr step node bitmap snprintf node list BUFFERSIZE s step ptr gres nodes tasks 1 if step ptr tres alloc str xstrfmtcat step ptr tres alloc str s u u u u step ptr tres alloc str TRESCPU 1 TRESNODE 1 else char ionodes NULL temp nodes NULL if step ptr step node bitmap node inx bit fmt temp bit sizeof temp bit step ptr step node bitmap if step ptr step layout step ptr step layout task cnt if step ptr cpu count tasks step ptr cpu count else if tasks slurmdb find tres count in string step ptr tres alloc str TRESCPUINFINIT E64 if tasks slurmdb find tres count in string step ptr job ptr tres alloc str TRESCPUINFINIT E64 tasks step ptr job ptr total nodes nodes step ptr job ptr total nodes temp nodes step ptr job ptr nodes else tasks step ptr step layout task cnt temp nodes step ptr step layout node list select g select jobinfo get step ptr select jobinfo SELECTJOBDATAIONODES ionodes if ionodes snprintf node list BUFFERSIZE s s temp nodes ionodes xfree ionodes else snprintf node list BUFFERSIZE s temp nodes if step ptr job ptr db index if step ptr job ptr db index get db index mysql conn submit time step ptr job ptr job id step ptr job ptr assoc id if as mysql job start mysql conn step ptr job ptr SLURMERROR error couldn t add job u at step start step ptr job ptr job id return SLURMSUCCESS step name slurm add slash to quotes step ptr name query xstrdup printf insert into s s job db inx id step time start step name state tres alloc nodes alloc task cnt nodelist node inx task dist req cpufreq req cpufreq min req cpufreq gov values PR Iu64 d d s d s d d s s d u u u on duplicate key update nodes alloc d task cnt d time end 0 state d nodelist s node inx s task dist d req cpufreq u req cpufreq min u req cpufreq gov u tres alloc s mysql conn cluster name step table step ptr job ptr db index step ptr step id int start time step name JOBRUNNING step ptr tres alloc str nodes tasks node list node inx task dist step ptr cpu freq max step ptr cpu freq min step ptr cpu freq gov nodes tasks JOBRUNNING node list node inx task dist step ptr cpu freq max step ptr cpu freq min step ptr cpu freq gov step ptr tres alloc str if debug flags DEBUGFLAGDBSTEPDBDEBUG mysql conn conn query n s query rc mysql db query mysql conn query xfree query xfree step name return rc static void fts build parse content type struct fts mail build context ctx const struct message header line hdr struct rfc822 parser context parser string t content type if ctx content type NULL return rfc822 parser init parser hdr full value hdr full value len NULL rfc822 skip lwsp parser TBEGIN content type t str new 64 void rfc822 parse content type parser content type ctx content type str lcase i strdup str c content type TEND rfc822 parser deinit parser static void alloc mode context V P9 COMMON cm int num 4x4 blk PICKMODECONTEXT ctx const int num blk num 4x4 blk 4 4 num 4x4 blk const int num pix num blk 4 int i k ctx num 4x4 blk num blk CHECKMEMERROR cm ctx zcoeff blk vpx calloc num 4x4 blk sizeof uint8 t for i 0 i MAXMBPLANE i for k 0 k 3 k CHECKMEMERROR cm ctx coeff i k vpx memalign 16 num pix sizeof ctx coeff i k CHECKMEMERROR cm ctx qcoeff i k vpx memalign 16 num pix sizeof ctx qcoeff i k CHECKMEMERROR cm ctx dqcoeff i k vpx memalign 16 num pix sizeof ctx dqcoeff i k CHECKMEMERROR cm ctx eobs i k vpx memalign 16 num pix sizeof ctx eobs i k ctx coeff pbuf i k ctx coeff i k ctx qcoeff pbuf i k ctx qcoeff i k ctx dqcoeff pbuf i k ctx dqcoeff i k ctx eobs pbuf i k ctx eobs i k int64 t vp9 rd pick inter mode sub8x8 V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best yrd best rd so far static const int64 t best tx diff TXMODES 0 int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int ref index best ref index 0 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER tmp best filter SWITCHABLE int rate uv intra rate uv tokenonly int64 t dist uv int skip uv PREDICTIONMODE mode uv DCPRED const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int mv seg mvs 4 MAXREFFRAMES b mode info best bmodes 4 int best skip2 0 int ref frame skip mask 2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH vpx memset x zcoeff blk TX 4 X4 0 4 vp9 zero best mbmode for i 0 i 4 i int j for j 0 j MAXREFFRAMES j seg mvs i j as int INVALIDMV estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX rate uv intra INTMAX returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb else ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref index 0 ref index MAXREFS ref index int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int i int this skip2 0 int64 t total sse INTMAX int early term 0 ref frame vp9 ref order ref index ref frame 0 second ref frame vp9 ref order ref index ref frame 1 if ref index 2 cpi sf mode skip start MAXMODES if ref index 3 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 1 GOLDENFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 1 LASTFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 1 GOLDENFRAME 1 LASTFRAME break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if rd less than thresh best rd rd opt threshes segment id bsize ref index rd opt thresh freq fact bsize ref index continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if cpi sf mode search skip flags FLAGSKIPCOMPBESTINTRA best mbmode ref frame 0 INTRAFRAME continue if ref frame INTRAFRAME vp9 is scaled cm frame refs ref frame 1 sf continue if second ref frame INTRAFRAME vp9 is scaled cm frame refs second ref frame 1 sf continue if comp pred mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame continue else if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 continue mbmi tx size TX 4 X4 mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i if ref frame INTRAFRAME int rate if rd pick intra sub 8x8 y mode cpi x rate rate y distortion y best rd best rd continue rate2 rate rate2 intra cost penalty distortion2 distortion y if rate uv intra INTMAX choose intra uv mode cpi ctx bsize TX 4 X4 rate uv intra rate uv tokenonly dist uv skip uv mode uv rate2 rate uv intra rate uv rate uv tokenonly distortion2 dist uv distortion uv dist uv mbmi uv mode mode uv else int rate int64 t distortion int64 t this rd thresh int64 t tmp rd tmp best rd IN T64 MAX tmp best rdu IN T64 MAX int tmp best rate INTMAX tmp best ratey INTMAX int64 t tmp best distortion INTMAX tmp best sse uv sse int tmp best skippable 0 int switchable filter index int mv second ref comp pred mbmi ref mvs second ref frame 0 NULL b mode info tmp best bmodes 16 MBMODEINFO tmp best mbmode BESTSEGINFO bsi SWITCHABLEFILTERS int pred exists 0 int uv skippable this rd thresh ref frame LASTFRAME rd opt threshes segment id bsize THRLAST rd opt threshes segment id bsize THRALTR this rd thresh ref frame GOLDENFRAME rd opt threshes segment id bsize THRGOLD this rd thresh rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR tmp best filter EIGHTTAP if x source variance cpi sf disable filter search var thresh tmp best filter EIGHTTAP else if cpi sf adaptive pred interp filter 1 ctx pred interp filter SWITCHABLE tmp best filter ctx pred interp filter else if cpi sf adaptive pred interp filter 2 tmp best filter ctx pred interp filter SWITCHABLE ctx pred interp filter 0 else for switchable filter index 0 switchable filter index SWITCHABLEFILTERS switchable filter index int newbest rs int64 t rs rd mbmi interp filter switchable filter index tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi switchable filter index mi row mi col if tmp rd IN T64 MAX continue rs vp9 get switchable rate cpi rs rd RDCOST x rdmult x rddiv rs 0 rd opt filter cache switchable filter index tmp rd rd opt filter cache SWITCHABLEFILTERSMIN rd opt filter cache SWITCHABLEFILTERS tmp rd rs rd if cm interp filter SWITCHABLE tmp rd rs rd rd opt mask filter MAX rd opt mask filter tmp rd newbest tmp rd tmp best rd if newbest tmp best filter mbmi interp filter tmp best rd tmp rd if newbest cm interp filter SWITCHABLE mbmi interp filter cm interp filter cm interp filter SWITCHABLE tmp best rdu tmp rd tmp best rate rate tmp best ratey rate y tmp best distortion distortion tmp best sse total sse tmp best skippable skippable tmp best mbmode mbmi for i 0 i 4 i tmp best bmodes i xd mi 0 src mi bmi i x zcoeff blk TX 4 X4 i x plane 0 eobs i pred exists 1 if switchable filter index 0 cpi sf use rd breakout best rd IN T64 MAX if tmp best rdu 2 best rd tmp best filter mbmi interp filter tmp best rdu IN T64 MAX break if tmp best rdu IN T64 MAX pred exists continue mbmi interp filter cm interp filter SWITCHABLE tmp best filter cm interp filter if pred exists tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi 0 mi row mi col if tmp rd IN T64 MAX continue else total sse tmp best sse rate tmp best rate rate y tmp best ratey distortion tmp best distortion skippable tmp best skippable mbmi tmp best mbmode for i 0 i 4 i xd mi 0 src mi bmi i tmp best bmodes i rate2 rate distortion2 distortion if cm interp filter SWITCHABLE rate2 vp9 get switchable rate cpi if mode excluded mode excluded comp pred cm reference mode SINGLEREFERENCE cm reference mode COMPOUNDREFERENCE compmode cost vp9 cost bit comp mode p comp pred tmp best rdu best rd MINRDCOST x rdmult x rddiv rate2 distortion2 RDCOST x rdmult x rddiv 0 total sse if tmp best rdu 0 vp9 build inter predictors sbuv x e mbd mi row mi col BLOCK 8 X8 super block uvrd cpi x rate uv distortion uv uv skippable uv sse BLOCK 8 X8 tmp best rdu if rate uv INTMAX continue rate2 rate uv distortion2 distortion uv skippable skippable uv skippable total sse uv sse if cm reference mode REFERENCEMODESELECT rate2 compmode cost if second ref frame INTRAFRAME rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv rate y 0 rate uv 0 this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip if mode excluded int max plane MAXMBPLANE best ref index ref index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 returnrate rate2 returndistortion distortion2 best rd this rd best yrd best rd RDCOST x rdmult x rddiv rate uv distortion uv best mbmode mbmi best skip2 this skip2 if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk TX 4 X4 sizeof uint8 t ctx num 4x4 blk for i 0 i 4 i best bmodes i xd mi 0 src mi bmi i if cpi sf mode search skip flags FLAGEARLYTERMINATE ref index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if comp pred single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded disable skip ref frame INTRAFRAME cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter int64 t adj rd for i 0 i SWITCHABLEFILTERCONTEXTS i if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if early term break if x skip comp pred break if best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAME mbmi best mbmode rd pick intra sbuv mode cpi x ctx rate uv intra rate uv tokenonly dist uv skip uv BLOCK 8 X8 TX 4 X4 if best rd IN T64 MAX returnrate INTMAX returndistortion IN T64 MAX return best rd assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode update rd thresh fact cpi bsize best ref index mbmi best mbmode x skip best skip2 if is inter block best mbmode for i 0 i 4 i xd mi 0 src mi bmi i as mode best bmodes i as mode else for i 0 i 4 i vpx memcpy xd mi 0 src mi bmi i best bmodes i sizeof b mode info mbmi mv 0 as int xd mi 0 src mi bmi 3 as mv 0 as int mbmi mv 1 as int xd mi 0 src mi bmi 3 as mv 1 as int for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 else vp9 zero best filter diff store coding context x ctx best ref index best pred diff best tx diff best filter diff 0 return best rd static void choose tx size from rd V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t psse int64 t tx cache TXMODES int64 t ref best rd BLOCKSIZE bs const TXSIZE max tx size max txsize lookup bs V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi vp9 prob skip prob vp9 get skip prob cm xd int r TXSIZES 2 s TXSIZES int64 t d TXSIZES sse TXSIZES int64 t rd TXSIZES 2 IN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAX int n m int s0 s1 const TXSIZE max mode tx size tx mode to biggest tx size cm tx mode int64 t best rd IN T64 MAXTXSIZE best tx max tx size const vp9 prob tx probs get tx probs2 max tx size xd cm fc tx probs assert skip prob 0 s0 vp9 cost bit skip prob 0 s1 vp9 cost bit skip prob 1 for n max tx size n 0 n txfm rd in plane x r n 0 d n s n sse n ref best rd 0 bs n cpi sf use fast coef costing r n 1 r n 0 if r n 0 INTMAX for m 0 m n n int max tx size m if m n r n 1 vp9 cost zero tx probs m else r n 1 vp9 cost one tx probs m if d n IN T64 MAX rd n 0 rd n 1 IN T64 MAX else if s n rd n 0 rd n 1 RDCOST x rdmult x rddiv s1 d n else rd n 0 RDCOST x rdmult x rddiv r n 0 s0 d n rd n 1 RDCOST x rdmult x rddiv r n 1 s0 d n if cpi sf tx size search breakout rd n 1 IN T64 MAX n int max tx size rd n 1 rd n 1 1 s n 1 break if rd n 1 best rd best tx n best rd rd n 1 mbmi tx size cm tx mode TXMODESELECT best tx MIN max tx size max mode tx size distortion d mbmi tx size rate r mbmi tx size cm tx mode TXMODESELECT skip s mbmi tx size psse sse mbmi tx size tx cache ONLY 4 X4 rd TX 4 X4 0 tx cache ALLOW 8 X8 rd TX 8 X8 0 tx cache ALLOW 16 X16 rd MIN max tx size TX 16 X16 0 tx cache ALLOW 32 X32 rd MIN max tx size TX 32 X32 0 if max tx size TX 32 X32 best tx TX 32 X32 tx cache TXMODESELECT rd TX 32 X32 1 else if max tx size TX 16 X16 best tx TX 16 X16 tx cache TXMODESELECT rd TX 16 X16 1 else if rd TX 8 X8 1 rd TX 4 X4 1 tx cache TXMODESELECT rd TX 8 X8 1 else tx cache TXMODESELECT rd TX 4 X4 1 static void vc1 decode b mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i j int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 0 int val int first block 1 int dst idx off int fwd int dmv x 2 dmv y 2 pred flag 2 int bmvtype BMVTYPEBACKWARD int idx mbmode interpmvp mquant v pq s mb intra 0 idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 0 0 s current picture motion val 1 s block index 0 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 v mb type 0 s block index i s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if v fmb is raw fwd v forward mb plane mb pos get bits1 gb else fwd v forward mb plane mb pos if idx mbmode 5 dmv x 0 dmv x 1 dmv y 0 dmv y 1 0 pred flag 0 pred flag 1 0 if fwd bmvtype BMVTYPEFORWARD else bmvtype decode012 gb switch bmvtype case 0 bmvtype BMVTYPEBACKWARD break case 1 bmvtype BMVTYPEDIRECT break case 2 bmvtype BMVTYPEINTERPOLATED interpmvp get bits1 gb v bmvtype bmvtype if bmvtype BMVTYPEDIRECT idx mbmode 1 get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD if bmvtype BMVTYPEINTERPOLATED interpmvp get mvdata interlaced v dmv x 1 dmv y 1 pred flag 1 if bmvtype BMVTYPEDIRECT dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 0 0 vc1 pred b mv intfi v 0 dmv x dmv y 1 pred flag vc1 b mc v dmv x dmv y bmvtype BMVTYPEDIRECT bmvtype mb has coeffs idx mbmode 2 else if fwd bmvtype BMVTYPEFORWARD v bmvtype bmvtype v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 1 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD vc1 pred b mv intfi v i dmv x dmv y 0 pred flag vc1 mc 4mv luma v i bmvtype BMVTYPEBACKWARD else if i 4 vc1 mc 4mv chroma v bmvtype BMVTYPEBACKWARD mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAYNULL if v ttmbf ttmb 8 ttmb 1 first block 0 static void parse command line int argc const char argv App Input app input Svc Context svc ctx vpx codec enc cfg t enc cfg struct arg arg 0 char argv NULL char argi NULL char argj NULL vpx codec err t res int passes 0 int pass 0 const char fpf file name NULL unsigned int min bitrate 0 unsigned int max bitrate 0 svc ctx log level SVCLOGDEBUG svc ctx spatial layers default spatial layers svc ctx temporal layers default temporal layers res vpx codec enc config default vpx codec vp9 cx enc cfg 0 if res die Failed to get config s n vpx codec err to string res enc cfg g w default width enc cfg g h default height enc cfg g timebase num default timebase num enc cfg g timebase den default timebase den enc cfg rc target bitrate default bitrate enc cfg kf min dist default kf dist enc cfg kf max dist default kf dist enc cfg rc end usage VPXCQ app input frames to code default frames to code app input frames to skip default frames to skip argv argv dup argc 1 argv 1 for argi argj argv argj argi argi arg argv step arg argv step 1 if arg match arg frames arg argi app input frames to code arg parse uint arg else if arg match arg width arg argi enc cfg g w arg parse uint arg else if arg match arg height arg argi enc cfg g h arg parse uint arg else if arg match arg timebase arg argi enc cfg g timebase arg parse rational arg else if arg match arg bitrate arg argi enc cfg rc target bitrate arg parse uint arg else if arg match arg skip frames arg argi app input frames to skip arg parse uint arg else if arg match arg spatial layers arg argi svc ctx spatial layers arg parse uint arg else if arg match arg temporal layers arg argi svc ctx temporal layers arg parse uint arg else if arg match arg kf dist arg argi enc cfg kf min dist arg parse uint arg enc cfg kf max dist enc cfg kf min dist else if arg match arg scale factors arg argi vpx svc set scale factors svc ctx arg val else if arg match arg quantizers arg argi vpx svc set quantizers svc ctx arg val else if arg match arg passes arg argi passes arg parse uint arg if passes 1 passes 2 die Error Invalid number of passes d n passes else if arg match arg pass arg argi pass arg parse uint arg if pass 1 pass 2 die Error Invalid pass selected d n pass else if arg match arg fpf name arg argi fpf file name arg val else if arg match arg min q arg argi enc cfg rc min quantizer arg parse uint arg else if arg match arg max q arg argi enc cfg rc max quantizer arg parse uint arg else if arg match arg min bitrate arg argi min bitrate arg parse uint arg else if arg match arg max bitrate arg argi max bitrate arg parse uint arg else argj if passes 0 passes 1 if pass fprintf stderr pass is ignored since there s only one pass n enc cfg g pass VPXRCONEPASS else if pass 0 die pass must be specified when passes is 2 n if fpf file name NULL die fpf must be specified when passes is 2 n if pass 1 enc cfg g pass VPXRCFIRSTPASS if stats open file app input rc stats fpf file name 0 fatal Failed to open statistics store else enc cfg g pass VPXRCLASTPASS if stats open file app input rc stats fpf file name 1 fatal Failed to open statistics store enc cfg rc twopass stats in stats get app input rc stats app input passes passes app input pass pass if enc cfg rc target bitrate 0 if min bitrate 0 enc cfg rc 2pass vbr minsection pct min bitrate 100 enc cfg rc target bitrate if max bitrate 0 enc cfg rc 2pass vbr maxsection pct max bitrate 100 enc cfg rc target bitrate for argi argv argi argi if argi 0 0 strlen argi 0 1 die Error Unrecognized option s n argi if argv 0 NULL argv 1 0 usage exit app input input filename argv 0 app input output filename argv 1 free argv if enc cfg g w 16 enc cfg g w 2 enc cfg g h 16 enc cfg g h 2 die Invalid resolution d x d n enc cfg g w enc cfg g h printf Codec s nframes d skip d n layers d n width d height d n num d den d bitrate d n gop size d n vpx codec iface name vpx codec vp9 cx app input frames to code app input frames to skip svc ctx spatial layers enc cfg g w enc cfg g h enc cfg g timebase num enc cfg g timebase den enc cfg rc target bitrate enc cfg kf max dist static int flac decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size FLAC Context s avctx priv data int bytes read 0 int ret got frame ptr 0 if s max framesize 0 s max framesize ff flac get max frame size s max blocksize s max blocksize FLACMAXBLOCKSIZEFLACMAXCHANNELS 32 if buf size FLACMINFRAMESIZE return buf size if AVR B32 buf MKBETAG f L a C if s got streaminfo parse streaminfo s buf buf size av log s avctx AVLOGERROR invalid header n return 1 return get metadata size buf buf size init get bits s gb buf buf size 8 if decode frame s 0 av log s avctx AVLOGERROR decode frame failed n return 1 bytes read get bits count s gb 7 8 frame nb samples s blocksize if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret s dsp decorrelate s ch mode frame data s decoded s channels s blocksize s sample shift if bytes read buf size av log s avctx AVLOGERROR overread d n bytes read buf size return 1 if bytes read buf size av log s avctx AVLOGDEBUG underread d orig size d n buf size bytes read buf size got frame ptr 1 return bytes read static U Bool UCALLCONV enum Property Starts Range const void context U Char32 start U Char32 end uint32 t value void end void value const U Set Adder sa const U Set Adder context sa add sa set start return static int svq3 decode end AV Codec Context avctx SV Q3 Context s avctx priv data H264 Context h s h free picture avctx s cur pic free picture avctx s next pic free picture avctx s last pic av freep s cur pic av freep s next pic av freep s last pic av frame unref h cur pic f ff h264 free context h return 0 static int m authenticate struct Client client p struct Client source p int parc const char parv struct Client agent p NULL struct Client saslserv p NULL if Is Capable source p CLICAPSASL return 0 if strlen client p id 3 exit client client p client p client p Mixing client and server protocol return 0 if parv 1 strchr parv 1 exit client client p client p client p Malformed AUTHENTICATE return 0 saslserv p find named client Config File Entry sasl service if saslserv p NULL Is Service saslserv p sendto one source p form str ERRSASLABORTED me name Empty String source p name source p name return 0 if source p local Client sasl complete source p local Client sasl agent 0 source p local Client sasl complete 0 if strlen parv 1 400 sendto one source p form str ERRSASLTOOLONG me name Empty String source p name source p name return 0 if source p id strcpy source p id generate uid add to id hash source p id source p if source p local Client sasl agent agent p find id source p local Client sasl agent if agent p NULL sendto one saslserv p s ENCAP s SASL s s H s s me id saslserv p servptr name source p id saslserv p id source p host source p sockhost if strcmp parv 1 EXTERNAL source p certfp NULL sendto one saslserv p s ENCAP s SASL s s S s s me id saslserv p servptr name source p id saslserv p id parv 1 source p certfp else sendto one saslserv p s ENCAP s SASL s s S s me id saslserv p servptr name source p id saslserv p id parv 1 rb strlcpy source p local Client sasl agent saslserv p id IDLEN else sendto one agent p s ENCAP s SASL s s C s me id agent p servptr name source p id agent p id parv 1 source p local Client sasl out return 0 void ff MPV common end Mpeg Enc Context s int i if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i s slice context count 1 else free duplicate context s av freep s parse context buffer s parse context buffer size 0 av freep s bitstream buffer s allocated bitstream buffer size 0 av freep s avctx stats out av freep s ac stats av freep s q intra matrix av freep s q inter matrix av freep s q intra matrix16 av freep s q inter matrix16 av freep s input picture av freep s reordered input picture av freep s dct offset if s picture s avctx internal is copy for i 0 i s picture count i free picture s s picture i av freep s picture free context frame s if s avctx active thread type FFTHREADFRAME avcodec default free buffers s avctx s context initialized 0 s last picture ptr s next picture ptr s current picture ptr NULL s linesize s uvlinesize 0 static int64 t rd pick intra sby mode V P9 COMP cpi MACROBLOCK x int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize int64 t tx cache TXMODES int64 t best rd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPREDMACROBLOCKD const xd x e mbd MODEINFO const mic xd mi 0 int this rate this rate tokenonly s int64 t this distortion this rd TXSIZE best tx TX 4 X4 int i int bmode costs cpi mbmode cost if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i tx cache i IN T64 MAX for mode DCPRED mode TMPRED mode int64 t local tx cache TXMODESMODEINFO above mi xd mi xd mi stride MODEINFO left mi xd left available xd mi 1 NULL if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi 0 const PREDICTIONMODEL vp9 left block mode mic left mi 0 bmode costs cpi y mode costs AL mic mbmi mode mode super block yrd cpi x this rate tokenonly this distortion s NULL bsize local tx cache best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly bmode costs mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd best tx mic mbmi tx size rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if cpi sf tx size search method USEFULLRD this rd IN T64 MAX for i 0 i TXMODES local tx cache i IN T64 MAX i const int64 t adj rd this rd local tx cache i local tx cache cpi common tx mode if adj rd tx cache i tx cache i adj rd mic mbmi mode mode selected mic mbmi tx size best tx return best rd double histogram selectivity Variable Stat Data vardata Fmgr Info opproc Datum constval bool varonleft int min hist size int n skip int hist size double result Datum values int nvalues Assert n skip 0 Assert min hist size 2 n skip if Heap Tuple Is Valid vardata stats Tuple get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid NULL values nvalues NULLNULL hist size nvalues if nvalues min hist size int nmatch 0 int i for i n skip i nvalues n skip i if varonleft Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values i constval Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID constval values i nmatch result double nmatch double nvalues 2 n skip else result 1 free attstatsslot vardata atttype values nvalues NULL 0 else hist size 0 result 1 return result static int mv refs rt const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 int const motion 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col 1 const motion 1 for i MVREFNEIGHBOURS refmv count i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 if different ref found refmv count for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd return const motion static int tokenexec continue i ctx t i ctx p scanner state pstate bool save os ptr op osp int code make null osp pop 1 again check estack 1 code gs scan token i ctx p ref esp 1 pstate op osp switch code case 0 if r is proc esp 1 push 1 ref assign op esp 1 code 0 break case scan BOS esp code o push estack break case scan EOF code 0 break case scan Refill code gs scan handle refill i ctx p pstate save ztokenexec continue switch code case 0 goto again case o push estack return code break case scan Comment case scan DSC Comment return ztoken handle comment i ctx p pstate esp 1 code save true ztokenexec continue default gs scanner error object i ctx p pstate i ctx p error object break if save gs free object scanner state dynamic pstate mem pstate token continue return code static void dissect rtmpt common tvbuff t tvb packet info pinfo proto tree tree rtmpt conv t rconv int cdir guint32 seq guint32 lastackseq int offset 0 int remain int want guint8 header type int basic hlen int message hlen guint32 id guint32 ts 0 guint32 tsd 0 int body len guint8 cmd guint32 src int chunk size rtmpt frag t tf rtmpt id t ti rtmpt packet t tp tvbuff t pktbuf remain tvb reported length tvb if remain return RTMPTDEBUG Segment cdir d seq d d n cdir seq seq remain 1 if pinfo fd flags visited wmem stack t packets packets wmem stack new wmem packet scope wmem stack push packets 0 tp rtmpt packet t wmem tree lookup32 le rconv packets cdir seq remain 1 while tp tp lastseq seq wmem stack push packets tp tp rtmpt packet t wmem tree lookup32 le rconv packets cdir tp lastseq 1 while tp rtmpt packet t wmem stack pop packets NULL if tp resident pktbuf tvb new child real data tvb tp data p tp have tp have add new data source pinfo pktbuf Unchunked RTMP else pktbuf tvb new subset length tvb tp data offset tp have dissect rtmpt pktbuf pinfo tree rconv cdir tp return while remain 0 tf NULL ti NULL tp NULL if offset 0 tf rtmpt frag t wmem tree lookup32 le rconv frags cdir seq offset 1 if tf RTMPTDEBUG tf seq d lseq d h d l d n tf seq tf lastseq tf have tf len if tf have tf len seq offset tf seq seq offset tf lastseq tf len tf have tf NULL else if tf ishdr ti rtmpt id t wmem tree lookup32 rconv ids cdir tf saved id if ti tp rtmpt packet t wmem tree lookup32 le ti packets seq offset 1 if tp tp chunkwant goto unchunk tf NULL ti NULL tp NULL if tf want tf len tf have if remain want want remain tvb memcpy tvb tf saved d tf have offset want id tf saved d 0 header type id 6 3 basic hlen rtmpt basic header length id if header type 3 tf have basic hlen 3 tf have want basic hlen 3 if pntoh24 tf saved d basic hlen 0xffffff tf len 4 tf have want tf lastseq seq want 1 remain want offset want if tf have tf len return if tf id tvb get guint8 tvb offset if id RTMPTMAGIC seq offset RTMPTHANDSHAKEOFFSET 1 header type 4 basic hlen 1 message hlen 0 id lastackseq 1 RTMPTTYPEHANDSHAKE 1 RTMPTTYPEHANDSHAKE 2 else if seq offset RTMPTHANDSHAKEOFFSET 2 header type 4 basic hlen 0 message hlen 0 id RTMPTTYPEHANDSHAKE 3 else header type id 6 3 basic hlen rtmpt basic header length id message hlen rtmpt message header length id if header type 3 remain basic hlen 3 if tvb get ntoh24 tvb offset basic hlen 0xffffff message hlen 4 if remain basic hlen message hlen tf wmem new wmem file scope rtmpt frag t tf ishdr 1 tf seq seq offset tf lastseq tf seq remain 1 tf len basic hlen message hlen tvb memcpy tvb tf saved d offset remain tf have remain wmem tree insert32 rconv frags cdir seq offset tf return id id 0x3f if id 0 id tvb get guint8 tvb offset 1 64 else if id 1 id tvb get letohs tvb offset 1 64 else id tf saved d 0 header type id 6 3 basic hlen rtmpt basic header length id message hlen tf len basic hlen id id 0x3f if id 0 id tf saved d 1 64 else if id 1 id pletoh16 tf saved d 1 64 if id RTMPTIDMAX ti rtmpt id t wmem tree lookup32 rconv ids cdir id if ti tp rtmpt packet t wmem tree lookup32 le ti packets seq offset 1 if header type 0 src tf pntoh32 tf saved d basic hlen 7 tvb get ntohl tvb offset basic hlen 7 else if ti src ti src else src 0 if header type 2 cmd tf tf saved d basic hlen 6 tvb get guint8 tvb offset basic hlen 6 else if ti cmd ti cmd else cmd 0 if id RTMPTIDMAX if id RTMPTTYPEHANDSHAKE 1 chunk size body len 1536 else if id RTMPTTYPEHANDSHAKE 2 chunk size body len 3072 else chunk size body len 1536 else chunk size GPOINTERTOINT wmem tree lookup32 le rconv chunksize cdir seq offset 1 if chunk size chunk size RTMPTDEFAULTCHUNKSIZE if header type 2 body len tf pntoh24 tf saved d basic hlen 3 tvb get ntoh24 tvb offset basic hlen 3 else if ti body len ti len else body len chunk size if body len gint rtmpt max packet size return if ti tp header type 3 tp have tp want tp chunkhave tp chunkwant RTMPTDEBUG New packet cdir d seq d ti p tp p header type d header len d id d tph d tpw d len d cs d n cdir seq offset ti tp header type basic hlen message hlen id tp tp have 0 tp tp want 0 body len chunk size if ti ti wmem new wmem file scope rtmpt id t ti packets wmem tree new wmem file scope ti ts 0 ti tsd 0 wmem tree insert32 rconv ids cdir id ti if header type 0 ts tf pntoh24 tf saved d basic hlen tvb get ntoh24 tvb offset basic hlen if ts 0xffffff ts tf pntoh32 tf saved d basic hlen 11 tvb get ntohl tvb offset basic hlen 11 tsd ts ti ts else if header type 3 tsd tf pntoh24 tf saved d basic hlen tvb get ntoh24 tvb offset basic hlen if tsd 0xffffff ts tf pntoh32 tf saved d basic hlen message hlen 4 tvb get ntohl tvb offset basic hlen message hlen 4 tsd ti tsd else ts ti ts tsd else ts ti ts ti tsd tsd ti tsd tp wmem new wmem file scope rtmpt packet t tp seq tp lastseq tf tf seq seq offset tp have 0 tp want basic hlen message hlen body len tp chunkwant 0 tp chunkhave 0 tp bhlen basic hlen tp mhlen message hlen tp fmt header type tp id id tp ts ts tp len body len if id RTMPTIDMAX tp cmd id else tp cmd cmd 0x7f tp src src tp txid 0 tp isresponse FALSE tp otherframe 0 ti ts ts ti tsd tsd ti len body len ti cmd cmd ti src src wmem tree insert32 ti packets tp seq tp if tf body len chunk size tp want remain tp resident FALSE tp data offset offset tp lastseq seq offset tp want 1 tp have tp want wmem tree insert32 rconv packets cdir tp lastseq tp pktbuf tvb new subset length tvb tp data offset tp have dissect rtmpt pktbuf pinfo tree rconv cdir tp offset tp want remain tp want continue else tp resident TRUE tp data p guint8 wmem alloc wmem file scope tp bhlen tp mhlen tp len if tf tf ishdr memcpy tp data p tf saved d tf len else tvb memcpy tvb tp data p offset basic hlen message hlen offset basic hlen message hlen remain basic hlen message hlen tp lastseq seq offset 1 tp have basic hlen message hlen if tp have tp want wmem tree insert32 rconv packets cdir tp lastseq tp pktbuf tvb new child real data tvb tp data p tp have tp have add new data source pinfo pktbuf Unchunked RTMP dissect rtmpt pktbuf pinfo tree rconv cdir tp continue tp chunkwant chunk size if tp chunkwant tp want tp have tp chunkwant tp want tp have else RTMPTDEBUG Old packet cdir d seq d ti p tp p header len d id d tph d tpw d len d cs d n cdir seq offset ti tp basic hlen message hlen id tp tp have 0 tp tp want 0 body len chunk size tp chunkwant chunk size if tp chunkwant tp want tp have tp chunkwant tp want tp have offset basic hlen message hlen remain basic hlen message hlen tf NULL unchunk want tp chunkwant tp chunkhave if want remain want remain RTMPTDEBUG cw d ch d r d w d n tp chunkwant tp chunkhave remain want tvb memcpy tvb tp data p tp have offset want if tf tf have want tf lastseq seq offset want 1 tp lastseq seq offset want 1 tp have want tp chunkhave want offset want remain want if tp chunkhave tp chunkwant tp chunkhave 0 tp chunkwant 0 if tp have tp want wmem tree insert32 rconv packets cdir tp lastseq tp pktbuf tvb new child real data tvb tp data p tp have tp have add new data source pinfo pktbuf Unchunked RTMP dissect rtmpt pktbuf pinfo tree rconv cdir tp else if tp chunkhave tp chunkwant rtmpt frag t tf2 wmem new wmem file scope rtmpt frag t tf2 ishdr 0 tf2 seq seq offset want tf2 lastseq tf2 seq remain 1 want tf2 have tp chunkhave tf2 len tp chunkwant tf2 saved id tp id RTMPTDEBUG inserting tf d n seq offset want 1 wmem tree insert32 rconv frags cdir seq offset want 1 tf2 static int cmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cmv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int ret if buf end buf EAPREAMBLESIZE return AVERRORINVALIDDATA if AVR L32 buf MV Ih TAGAVR B32 buf MV Ih TAG cmv process header s buf EAPREAMBLESIZE buf end return buf size if av image check size s width s height 0 s avctx return 1 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 s palette AVPALETTESIZE buf EAPREAMBLESIZE if buf 0 1 cmv decode inter s frame buf 2 buf end frame key frame 0 frame pict type AVPICTURETYPEP else frame key frame 1 frame pict type AVPICTURETYPEI cmv decode intra s frame buf 2 buf end av frame unref s last2 frame av frame move ref s last2 frame s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size int ff wmv2 decode mb Mpeg Enc Context s int16 t block 6 64 Wmv2 Context const w Wmv2 Context s int cbp code i uint8 t coded val if w j type return 0 if s pict type AVPICTURETYPEP if ISSKIP s current picture mb type s mb y s mb stride s mb x s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 w hshift 0 return 0 code get vlc2 s gb ff mb non intra vlc w cbp table index table MBNONINTRAVLCBITS 3 if code 0 return 1 s mb intra code 0x40 6 cbp code 0x3f else s mb intra 1 code get vlc2 s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if code 0 av log s avctx AVLOGERRORII cbp illegal at d d n s mb x s mb y return 1 cbp 0 for i 0 i 6 i int val code 5 i 1 if i 4 int pred ff msmpeg4 coded block pred s i coded val val val pred coded val val cbp val 5 i if s mb intra int mx my wmv2 pred motion w mx my if cbp s dsp clear blocks s block 0 if s per mb rl table s rl table index decode012 s gb s rl chroma table index s rl table index if w abt flag w per mb abt w per block abt get bits1 s gb if w per block abt w abt type decode012 s gb else w per block abt 0 if wmv2 decode motion w mx my 0 return 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 mx s mv 0 0 1 my for i 0 i 6 i if wmv2 decode inter block w block i i cbp 5 i 1 0 av log s avctx AVLOGERROR nerror while decoding inter block d x d d n s mb x s mb y i return 1 else if s pict type AVPICTURETYPEP av dlog s avctx d d s inter intra pred cbp av dlog s avctx I at d d d 06 X n s mb x s mb y cbp 3 1 0 cbp 0x3 C 2 0 show bits s gb 24 s ac pred get bits1 s gb if s inter intra pred s h263 aic dir get vlc2 s gb ff inter intra vlc table INTERINTRAVLCBITS 1 av dlog s avctx d d d d s ac pred s h263 aic dir s mb x s mb y if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index s dsp clear blocks s block 0 for i 0 i 6 i if ff msmpeg4 decode block s block i i cbp 5 i 1 NULL 0 av log s avctx AVLOGERROR nerror while decoding intra block d x d d n s mb x s mb y i return 1 return 0 static int temporal filter find matching mb c V P9 COMP cpi uint8 t arf frame buf uint8 t frame ptr buf int stride MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const MVSPEEDFEATURES const mv sf cpi sf mv int step param int sadpb x sadperbit16 int bestsme INTMAX int distortion unsigned int sse int sad list 5 MV best ref mv1 0 0 MV best ref mv1 full MV ref mv x e mbd mi 0 src mi bmi 0 as mv 0 as mv struct buf 2d src x plane 0 src struct buf 2d pre xd plane 0 pre 0 best ref mv1 full col best ref mv1 col 3 best ref mv1 full row best ref mv1 row 3 x plane 0 src buf arf frame buf x plane 0 src stride stride xd plane 0 pre 0 buf frame ptr buf xd plane 0 pre 0 stride stride step param mv sf reduce first step size step param MIN step param MAXMVSEARCHSTEPS 2 vp9 hex search x best ref mv1 full step param sadpb 1 cond sad list cpi sad list cpi fn ptr BLOCK 16 X16 0 best ref mv1 ref mv bestsme cpi find fractional mv step x ref mv best ref mv1 cpi common allow high precision mv x errorperbit cpi fn ptr BLOCK 16 X16 0 mv sf subpel iters per step cond sad list cpi sad list NULLNULL distortion sse NULL 0 0 x plane 0 src src xd plane 0 pre 0 pre return bestsme static int bfi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Get Byte Context g int buf size avpkt size BFI Context bfi avctx priv data uint8 t dst bfi dst uint8 t src dst offset colour1 colour2 uint8 t frame end bfi dst avctx width avctx height uint32 t pal int i j ret height avctx height if bfi frame data 0 avctx release buffer avctx bfi frame bfi frame reference 1 if ret ff get buffer avctx bfi frame 0 av log avctx AVLOGERROR get buffer failed n return ret bytestream2 init g avpkt data buf size if avctx frame number bfi frame pict type AVPICTURETYPEI bfi frame key frame 1 if avctx extradata size 768 av log NULLAVLOGERROR Palette is too large n return AVERRORINVALIDDATA pal uint32 t bfi frame data 1 for i 0 i avctx extradata size 3 i int shift 16 pal 0 for j 0 j 3 j shift 8 pal avctx extradata i 3 j 2 avctx extradata i 3 j 4 shift pal bfi frame palette has changed 1 else bfi frame pict type AVPICTURETYPEP bfi frame key frame 0 bytestream2 skip g 4 while dst frame end static const uint8 t lentab 4 0 2 0 1 unsigned int byte bytestream2 get byte g av uninit offset unsigned int code byte 6 unsigned int length byte 0x C0 if bytestream2 get bytes left g av log avctx AVLOGERROR Input resolution larger than actual frame n return AVERRORINVALIDDATA if length 0 if code 1 length bytestream2 get byte g offset bytestream2 get le16 g else length bytestream2 get le16 g if code 2 length 0 break else if code 1 offset bytestream2 get byte g if dst length lentab code frame end break switch code case 0 if length bytestream2 get bytes left g av log avctx AVLOGERROR Frame larger than buffer n return AVERRORINVALIDDATA bytestream2 get buffer g dst length dst length break case 1 dst offset dst offset length 4 if dst offset bfi dst break while length dst dst offset break case 2 dst length break case 3 colour1 bytestream2 get byte g colour2 bytestream2 get byte g while length dst colour1 dst colour2 break src bfi dst dst bfi frame data 0 while height memcpy dst src avctx width src avctx width dst bfi frame linesize 0 got frame 1 AV Frame data bfi frame return buf size static int decode frame Wmall Decode Ctx s Get Bit Context gb s gb int more frames 0 len 0 i ret s frame nb samples s samples per frame if ret ff get buffer s avctx s frame 0 0 av log s avctx AVLOGERROR not enough space for the output samples n s packet loss 1 return ret for i 0 i s num channels i s samples 16 i int16 t s frame extended data i s samples 32 i int32 t s frame extended data i if s len prefix len get bits gb s log2 frame size if decode tilehdr s s packet loss 1 return 0 if s dynamic range compression s drc gain get bits gb 8 if get bits1 gb int av unused skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx start skip i n skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx end skip i n skip s parsed all subframes 0 for i 0 i s num channels i s channel i decoded samples 0 s channel i cur subframe 0 while s parsed all subframes if decode subframe s 0 s packet loss 1 return 0 av dlog s avctx Frame done n if s skip frame s skip frame 0 if s len prefix if len get bits count gb s frame offset 2 av log s avctx AVLOGERROR frame i would have to skip i bits n s frame num len get bits count gb s frame offset 1 s packet loss 1 return 0 skip bits long gb len get bits count gb s frame offset 1 more frames get bits1 gb s frame num return more frames static guint16 dissect mpa fpdu tvbuff t tvb packet info pinfo proto tree tree mpa state t state struct tcpinfo tcpinfo guint8 endpoint proto item mpa item NULL proto item mpa header item NULL proto tree mpa tree NULL proto tree mpa header tree NULL guint8 pad length guint16 ulpdu length exp ulpdu length guint32 offset total length guint32 num of m 0 if state minfo endpoint valid get first marker offset state tcpinfo endpoint 0 offset MPAMARKERLEN else offset 0 ulpdu length guint16 tvb get ntohs tvb offset if state minfo endpoint valid num of m number of markers state tcpinfo endpoint pad length fpdu pad length ulpdu length exp ulpdu length expected ulpdu length state tcpinfo endpoint if exp ulpdu length exp ulpdu length ulpdu length pad length return 0 mpa packetlist pinfo MPAFPDU mpa item proto tree add item tree proto iwarp mpa tvb 0 1 ENCNA mpa tree proto item add subtree mpa item ett mpa mpa header item proto tree add item mpa tree hf mpa fpdu tvb offset 1 ENCNA mpa header tree proto item add subtree mpa header item ett mpa proto tree add uint mpa header tree hf mpa ulpdu length tvb offset MPAULPDULENGTHLEN ulpdu length if state minfo endpoint valid num of m 0 total length fpdu total length tcpinfo if pad length 0 proto tree add item mpa header tree hf mpa pad tvb pad offset tcpinfo total length pad length pad length ENCNA dissect fpdu crc tvb mpa header tree state total length MPACRCLEN num of m MPAMARKERLEN ulpdu length pad length MPAULPDULENGTHLEN dissect fpdu markers tvb mpa tree state tcpinfo endpoint else offset MPAULPDULENGTHLEN ulpdu length if pad length 0 proto tree add item mpa header tree hf mpa pad tvb offset pad length ENCNA offset pad length dissect fpdu crc tvb mpa header tree state offset ulpdu length pad length MPAULPDULENGTHLEN return ulpdu length static int svq1 encode frame AV Codec Context avctx AV Packet pkt const AV Frame pict int got packet SV Q1 Context const s avctx priv data AV Frame const p s picture AV Frame temp int i ret if pkt data ret av new packet pkt s y block width s y block height MAXMBBYTES 3 FFMINBUFFERSIZE 0 av log avctx AVLOGERROR Error getting output packet n return ret if avctx pix fmt AVPIXFMTYU V410 P av log avctx AVLOGERROR unsupported pixel format n return 1 if s current picture data 0 ff get buffer avctx s current picture 0 ff get buffer avctx s last picture 0 s scratchbuf av malloc s current picture linesize 0 16 2 temp s current picture s current picture s last picture s last picture temp init put bits s pb pkt data pkt size p pict p pict type avctx gop size avctx frame number avctx gop size AVPICTURETYPEPAVPICTURETYPEI p key frame p pict type AVPICTURETYPEI svq1 write header s p pict type for i 0 i 3 i if svq1 encode plane s i s picture data i s last picture data i s current picture data i s frame width i 4 1 s frame height i 4 1 s picture linesize i s current picture linesize i 0 return 1 while put bits count s pb 31 put bits s pb 1 0 flush put bits s pb pkt size put bits count s pb 8 if p pict type AVPICTURETYPEI pkt flags AVPKTFLAGKEY got packet 1 return 0 static int vble decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VBLE Context ctx avctx priv data AV Frame pic avctx coded frame Get Bit Context gb const uint8 t src avpkt data int version int offset 0 int width uv avctx width 2 height uv avctx height 2 pic reference 0 if pic data 0 avctx release buffer avctx pic if ff get buffer avctx pic 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI version AVR L32 src if version 1 av log avctx AVLOGWARNING Unsupported VBLE Version d n version init get bits gb src 4 avpkt size 4 8 if vble unpack ctx gb 0 av log avctx AVLOGERROR Invalid Code n return AVERRORINVALIDDATA vble restore plane ctx 0 offset avctx width avctx height if ctx avctx flags CODECFLAGGRAY offset avctx width avctx height vble restore plane ctx 1 offset width uv height uv offset width uv height uv vble restore plane ctx 2 offset width uv height uv got frame 1 AV Frame data pic return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Eight Bps Context const c avctx priv data const unsigned char encoded buf unsigned char pixptr pixptr end unsigned int height avctx height unsigned int dlen p row const unsigned char lp dp unsigned char count unsigned int px inc unsigned int planes c planes unsigned char planemap c planemap int ret if c pic data 0 avctx release buffer avctx c pic c pic reference 0 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret dp encoded planes height 1 if planes 4 planes px inc planes avctx pix fmt AVPIXFMTRG B32 for p 0 p planes p lp encoded p height 1 for row 0 row height row pixptr c pic data 0 row c pic linesize 0 planemap p pixptr end pixptr c pic linesize 0 dlen av be2ne16 const unsigned short lp row 2 while dlen 0 if dp 1 buf buf size return AVERRORINVALIDDATA if count dp 127 count dlen count 1 if pixptr count px inc pixptr end break if dp count buf buf size return AVERRORINVALIDDATA while count pixptr dp pixptr px inc else count 257 count if pixptr count px inc pixptr end break while count pixptr dp pixptr px inc dp dlen 2 if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size void vp9 temporal filter V P9 COMP cpi int distance V P9 COMMON const cm cpi common RATECONTROL const rc cpi rc int frame int frames to blur int start frame int strength int frames to blur backward int frames to blur forward struct scale factors sf Y V12 BUFFERCONFIG frames MAXLAGBUFFERSNULL adjust arnr filter cpi distance rc gfu boost frames to blur strength frames to blur backward frames to blur 2 frames to blur forward frames to blur 1 2 start frame distance frames to blur forward for frame 0 frame frames to blur frame const int which buffer start frame frame struct lookahead entry buf vp9 lookahead peek cpi lookahead which buffer frames frames to blur 1 frame buf img if is two pass svc cpi int frame used 0 frame frames to blur frame if cm mi cols MISIZE frames frame y width cm mi rows MISIZE frames frame y height if vp9 realloc frame buffer cpi svc scaled frames frame used cm width cm height cm subsampling x cm subsampling y if CONFIGV P9 HIGHBITDEPTH cm use highbitdepth endif V P9 ENCBORDERINPIXELSNULLNULLNULL vpx internal error cm error VPXCODECMEMERROR Failed to reallocate alt ref buffer frames frame vp9 scale if required cm frames frame cpi svc scaled frames frame used frame used else temporal filter iterate c cpi frames frames to blur frames to blur backward strength sf static byte i alloc byte array gs memory t mem uint num elements uint elt size client name t cname gs ref memory t const imem gs ref memory t mem obj header t obj ulong lsize obj alloc obj imem lsize st bytes ALLOCDIRECT cname if debug6m A mem a d b s bytes lu u u 0x lx n alloc trace space imem client name string cname ulong num elements elt size num elements elt size ulong obj return byte obj void jpc qmfb split colgrp jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr JPCQMFBCOLGRPSIZE srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i JPCQMFBCOLGRPSIZE i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr JPCQMFBCOLGRPSIZE if buf splitbuf jas free buf static int tqi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size Tqi Context t avctx priv data Mpeg Enc Context s t s AV Frame frame data int ret s width AVR L16 buf 0 s height AVR L16 buf 2 tqi calculate qtable s buf 4 buf 8 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret av fast padded malloc t bitstream buf t bitstream buf size buf end buf if t bitstream buf return AVERRORENOMEM s dsp bswap buf t bitstream buf const uint32 t buf buf end buf 4 init get bits s gb t bitstream buf 8 buf end buf s last dc 0 s last dc 1 s last dc 2 0 for s mb y 0 s mb y avctx height 15 16 s mb y for s mb x 0 s mb x avctx width 15 16 s mb x if tqi decode mb s t block 0 break tqi idct put t frame t block got frame 1 return buf size static int cavs decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AVS Context h avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data uint32 t stc 1 int input size const uint8 t buf end const uint8 t buf ptr if buf size 0 if h low delay h DPB 0 f data 0 got frame 1 picture h DPB 0 f if h cur f data 0 avctx release buffer avctx h cur f FFSWAPAVS Frame h cur h DPB 0 return 0 buf ptr buf buf end buf buf size for buf ptr avpriv mpv find start code buf ptr buf end stc if stc 0x FFFFF E00 buf ptr buf end return FFMAX 0 buf ptr buf input size buf end buf ptr 8 switch stc case CAVSSTARTCODE init get bits h gb buf ptr input size decode seq header h break case PICISTARTCODE if h got keyframe if h DPB 0 f data 0 avctx release buffer avctx h DPB 0 f if h DPB 1 f data 0 avctx release buffer avctx h DPB 1 f h got keyframe 1 case PICPBSTARTCODE got frame 0 if h got keyframe break init get bits h gb buf ptr input size h stc stc if decode pic h break got frame 1 if h cur f pict type AVPICTURETYPEB if h DPB 1 f data 0 picture h DPB 1 f else got frame 0 else picture h cur f break case EXTSTARTCODE break case USERSTARTCODE break default if stc SLICEMAXSTARTCODE init get bits h gb buf ptr input size decode slice header h h gb break static void kq init struct event base base int i kq struct kqop kqueueop if evutil getenv EVENTNOKQUEUE return NULL if kqueueop calloc 1 sizeof struct kqop return NULL if kq kqueue 1 event warn kqueue free kqueueop return NULL kqueueop kq kq kqueueop pid getpid kqueueop changes malloc NEVENT sizeof struct kevent if kqueueop changes NULL free kqueueop return NULL kqueueop events malloc NEVENT sizeof struct kevent if kqueueop events NULL free kqueueop changes free kqueueop return NULL kqueueop nevents NEVENT for i 0 i NSIG i TAILQINIT kqueueop evsigevents i memset kqueueop changes 0 0 sizeof kqueueop changes 0 kqueueop changes 0 ident 1 kqueueop changes 0 filter EVFILTREAD kqueueop changes 0 flags EVADD if kevent kq kqueueop changes 1 kqueueop events NEVENTNULL 1 kqueueop events 0 ident 1 kqueueop events 0 flags EVERROR event warn s detected broken kqueue not using func free kqueueop changes free kqueueop events free kqueueop close kq return NULL return kqueueop vpx codec err t vpx svc init Svc Context svc ctx vpx codec ctx t codec ctx vpx codec iface t iface vpx codec enc cfg t enc cfg vpx codec err t res int i Svc Internal const si get svc internal svc ctx if svc ctx NULL codec ctx NULL iface NULL enc cfg NULL return VPXCODECINVALIDPARAM if si NULL return VPXCODECMEMERROR si codec ctx codec ctx si width enc cfg g w si height enc cfg g h if enc cfg kf max dist 2 svc log svc ctx SVCLOGERROR key frame distance too small d n enc cfg kf max dist return VPXCODECINVALIDPARAM si kf dist enc cfg kf max dist if svc ctx spatial layers 0 svc ctx spatial layers VPXSSDEFAULTLAYERS if svc ctx spatial layers 1 svc ctx spatial layers VPXSSMAXLAYERS svc log svc ctx SVCLOGERROR spatial layers invalid value d n svc ctx spatial layers return VPXCODECINVALIDPARAM res parse quantizer values svc ctx si quantizers if res VPXCODECOK return res res parse scale factors svc ctx si scale factors if res VPXCODECOK return res res parse options svc ctx si options if res VPXCODECOK return res if svc ctx spatial layers 1 svc ctx spatial layers 1 if svc ctx spatial layers VPXSSMAXLAYERS svc ctx spatial layers VPXSSMAXLAYERS if svc ctx temporal layers 1 svc ctx temporal layers 1 if svc ctx temporal layers VPXTSMAXLAYERS svc ctx temporal layers VPXTSMAXLAYERS si layers svc ctx spatial layers if si layers 1 float total 0 float alloc ratio VPXSSMAXLAYERS 0 assert si layers VPXSSMAXLAYERS for i 0 i si layers i int pos i VPXSSMAXLAYERS svc ctx spatial layers if pos VPXSSMAXLAYERS si scaling factor den pos 0 alloc ratio i float si scaling factor num pos 1 0 si scaling factor den pos alloc ratio i alloc ratio i total alloc ratio i for i 0 i si layers i if total 0 enc cfg ss target bitrate i unsigned int enc cfg rc target bitrate alloc ratio i total i si layers i enc cfg ss enable auto alt ref i si enable auto alt ref i int i for i 0 i svc ctx temporal layers i enc cfg ts target bitrate i enc cfg rc target bitrate svc ctx temporal layers enc cfg ts rate decimator i 1 svc ctx temporal layers 1 i static int sipr decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Sipr Context ctx avctx priv data AV Frame frame data const uint8 t buf avpkt data Sipr Parameters parm const Sipr Mode Param mode par modes ctx mode Get Bit Context gb float samples int subframe size ctx mode MODE 16k LSUBFR 16k SUBFRSIZE int i ret ctx avctx avctx if avpkt size mode par bits per frame 3 av log avctx AVLOGERROR Error processing packet packet size d too small n avpkt size return 1 frame nb samples mode par frames per packet subframe size mode par subframe count if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame data 0 init get bits gb buf mode par bits per frame for i 0 i mode par frames per packet i decode parameters parm gb mode par ctx decode frame ctx parm samples samples subframe size mode par subframe count got frame ptr 1 return mode par bits per frame 3 static void model rd for sb V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum int i int64 t rate sum 0 int64 t dist sum 0 const int ref xd mi 0 src mi mbmi ref frame 0 unsigned int sse unsigned int var 0 unsigned int sum sse 0 const int shift 8 int rate int64 t dist x pred sse ref 0 for i 0 i MAXMBPLANE i struct macroblock plane const p x plane i struct macroblockd plane const pd xd plane i const BLOCKSIZE bs get plane block size bsize pd const TXSIZE max tx size max txsize lookup bs const BLOCKSIZE unit size txsize to bsize max tx size int bw 1 b width log2 lookup bs b width log2 lookup unit size int bh 1 b height log2 lookup bs b width log2 lookup unit size int idx idy int lw b width log2 lookup unit size 2 int lh b height log2 lookup unit size 2 sum sse 0 for idy 0 idy bh idy for idx 0 idx bw idx uint8 t src p src buf idy p src stride lh idx lw uint8 t dst pd dst buf idy pd dst stride lh idx lh int block idx idy 1 idx var cpi fn ptr unit size vf src p src stride dst pd dst stride sse x bsse i 2 block idx sse sum sse sse if x select tx size if x bsse i 2 block idx p quant thred 0 shift x skip txfm i 2 block idx 1 else if var p quant thred 1 shift x skip txfm i 2 block idx 2 else x skip txfm i 2 block idx 0 if i 0 x pred sse ref sse if cpi oxcf speed 4 int64 t rate int64 t dist int64 t square error sse int quantizer pd dequant 1 3 if quantizer 120 rate square error 280 quantizer 8 else rate 0 dist square error quantizer 8 rate sum rate dist sum dist else vp9 model rd from var lapndz sum sse 1 num pels log2 lookup bs pd dequant 1 3 rate dist rate sum rate dist sum dist out rate sum int rate sum out dist sum dist sum 4 int64 t vp9 rd pick inter mode sub8x8 V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best yrd best rd so far static const int64 t best tx diff TXMODES 0 int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int ref index best ref index 0 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER tmp best filter SWITCHABLE int rate uv intra rate uv tokenonly int64 t dist uv int skip uv PREDICTIONMODE mode uv DCPRED const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int mv seg mvs 4 MAXREFFRAMES b mode info best bmodes 4 int best skip2 0 int ref frame skip mask 2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH vpx memset x zcoeff blk TX 4 X4 0 4 vp9 zero best mbmode for i 0 i 4 i int j for j 0 j MAXREFFRAMES j seg mvs i j as int INVALIDMV estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX rate uv intra INTMAX returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb else ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref index 0 ref index MAXREFS ref index int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int i int this skip2 0 int64 t total sse INTMAX int early term 0 ref frame vp9 ref order ref index ref frame 0 second ref frame vp9 ref order ref index ref frame 1 if ref index 2 cpi sf mode skip start MAXMODES if ref index 3 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 1 GOLDENFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 1 LASTFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 1 GOLDENFRAME 1 LASTFRAME break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if rd less than thresh best rd rd opt threshes segment id bsize ref index rd opt thresh freq fact bsize ref index continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if cpi sf mode search skip flags FLAGSKIPCOMPBESTINTRA best mbmode ref frame 0 INTRAFRAME continue if ref frame INTRAFRAME vp9 is scaled cm frame refs ref frame 1 sf continue if second ref frame INTRAFRAME vp9 is scaled cm frame refs second ref frame 1 sf continue if comp pred mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame continue else if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 continue mbmi tx size TX 4 X4 mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i if ref frame INTRAFRAME int rate if rd pick intra sub 8x8 y mode cpi x rate rate y distortion y best rd best rd continue rate2 rate rate2 intra cost penalty distortion2 distortion y if rate uv intra INTMAX choose intra uv mode cpi ctx bsize TX 4 X4 rate uv intra rate uv tokenonly dist uv skip uv mode uv rate2 rate uv intra rate uv rate uv tokenonly distortion2 dist uv distortion uv dist uv mbmi uv mode mode uv else int rate int64 t distortion int64 t this rd thresh int64 t tmp rd tmp best rd IN T64 MAX tmp best rdu IN T64 MAX int tmp best rate INTMAX tmp best ratey INTMAX int64 t tmp best distortion INTMAX tmp best sse uv sse int tmp best skippable 0 int switchable filter index int mv second ref comp pred mbmi ref mvs second ref frame 0 NULL b mode info tmp best bmodes 16 MBMODEINFO tmp best mbmode BESTSEGINFO bsi SWITCHABLEFILTERS int pred exists 0 int uv skippable this rd thresh ref frame LASTFRAME rd opt threshes segment id bsize THRLAST rd opt threshes segment id bsize THRALTR this rd thresh ref frame GOLDENFRAME rd opt threshes segment id bsize THRGOLD this rd thresh rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR tmp best filter EIGHTTAP if x source variance cpi sf disable filter search var thresh tmp best filter EIGHTTAP else if cpi sf adaptive pred interp filter 1 ctx pred interp filter SWITCHABLE tmp best filter ctx pred interp filter else if cpi sf adaptive pred interp filter 2 tmp best filter ctx pred interp filter SWITCHABLE ctx pred interp filter 0 else for switchable filter index 0 switchable filter index SWITCHABLEFILTERS switchable filter index int newbest rs int64 t rs rd mbmi interp filter switchable filter index tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi switchable filter index mi row mi col if tmp rd IN T64 MAX continue rs vp9 get switchable rate cpi rs rd RDCOST x rdmult x rddiv rs 0 rd opt filter cache switchable filter index tmp rd rd opt filter cache SWITCHABLEFILTERSMIN rd opt filter cache SWITCHABLEFILTERS tmp rd rs rd if cm interp filter SWITCHABLE tmp rd rs rd rd opt mask filter MAX rd opt mask filter tmp rd newbest tmp rd tmp best rd if newbest tmp best filter mbmi interp filter tmp best rd tmp rd if newbest cm interp filter SWITCHABLE mbmi interp filter cm interp filter cm interp filter SWITCHABLE tmp best rdu tmp rd tmp best rate rate tmp best ratey rate y tmp best distortion distortion tmp best sse total sse tmp best skippable skippable tmp best mbmode mbmi for i 0 i 4 i tmp best bmodes i xd mi 0 src mi bmi i x zcoeff blk TX 4 X4 i x plane 0 eobs i pred exists 1 if switchable filter index 0 cpi sf use rd breakout best rd IN T64 MAX if tmp best rdu 2 best rd tmp best filter mbmi interp filter tmp best rdu IN T64 MAX break if tmp best rdu IN T64 MAX pred exists continue mbmi interp filter cm interp filter SWITCHABLE tmp best filter cm interp filter if pred exists tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi 0 mi row mi col if tmp rd IN T64 MAX continue else total sse tmp best sse rate tmp best rate rate y tmp best ratey distortion tmp best distortion skippable tmp best skippable mbmi tmp best mbmode for i 0 i 4 i xd mi 0 src mi bmi i tmp best bmodes i rate2 rate distortion2 distortion if cm interp filter SWITCHABLE rate2 vp9 get switchable rate cpi if mode excluded mode excluded comp pred cm reference mode SINGLEREFERENCE cm reference mode COMPOUNDREFERENCE compmode cost vp9 cost bit comp mode p comp pred tmp best rdu best rd MINRDCOST x rdmult x rddiv rate2 distortion2 RDCOST x rdmult x rddiv 0 total sse if tmp best rdu 0 vp9 build inter predictors sbuv x e mbd mi row mi col BLOCK 8 X8 super block uvrd cpi x rate uv distortion uv uv skippable uv sse BLOCK 8 X8 tmp best rdu if rate uv INTMAX continue rate2 rate uv distortion2 distortion uv skippable skippable uv skippable total sse uv sse if cm reference mode REFERENCEMODESELECT rate2 compmode cost if second ref frame INTRAFRAME rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv rate y 0 rate uv 0 this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip if mode excluded int max plane MAXMBPLANE best ref index ref index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 returnrate rate2 returndistortion distortion2 best rd this rd best yrd best rd RDCOST x rdmult x rddiv rate uv distortion uv best mbmode mbmi best skip2 this skip2 if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk TX 4 X4 sizeof uint8 t ctx num 4x4 blk for i 0 i 4 i best bmodes i xd mi 0 src mi bmi i if cpi sf mode search skip flags FLAGEARLYTERMINATE ref index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if comp pred single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded disable skip ref frame INTRAFRAME cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter int64 t adj rd for i 0 i SWITCHABLEFILTERCONTEXTS i if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if early term break if x skip comp pred break if best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAME mbmi best mbmode rd pick intra sbuv mode cpi x ctx rate uv intra rate uv tokenonly dist uv skip uv BLOCK 8 X8 TX 4 X4 if best rd IN T64 MAX returnrate INTMAX returndistortion IN T64 MAX return best rd assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode update rd thresh fact cpi bsize best ref index mbmi best mbmode x skip best skip2 if is inter block best mbmode for i 0 i 4 i xd mi 0 src mi bmi i as mode best bmodes i as mode else for i 0 i 4 i vpx memcpy xd mi 0 src mi bmi i best bmodes i sizeof b mode info mbmi mv 0 as int xd mi 0 src mi bmi 3 as mv 0 as int mbmi mv 1 as int xd mi 0 src mi bmi 3 as mv 1 as int for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 else vp9 zero best filter diff store coding context x ctx best ref index best pred diff best tx diff best filter diff 0 return best rd static Asn1 Generic Decode Asn1 Der Octet String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 OCTETSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL memcpy a str const char d ptr length a str length 0 d ptr length a length d ptr buffer return a static void vc1 decode b mb V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i j int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 0 int index index1 int val sign int first block 1 int dst idx off int skipped direct int dmv x 2 dmv y 2 int bmvtype BMVTYPEBACKWARD mquant v pq s mb intra 0 if v dmb is raw direct get bits1 gb else direct v direct mb plane mb pos if v skip is raw skipped get bits1 gb else skipped v s mbskip table mb pos dmv x 0 dmv x 1 dmv y 0 dmv y 1 0 for i 0 i 6 i v mb type 0 s block index i 0 s dc val 0 s block index i 0 s current picture f qscale table mb pos 0 if direct if skipped GETMVDATA dmv x 0 dmv y 0 dmv x 1 dmv x 0 dmv y 1 dmv y 0 if skipped s mb intra bmvtype decode012 gb switch bmvtype case 0 bmvtype v bfraction BFRACTIONDEN 2 BMVTYPEBACKWARDBMVTYPEFORWARD break case 1 bmvtype v bfraction BFRACTIONDEN 2 BMVTYPEFORWARDBMVTYPEBACKWARD break case 2 bmvtype BMVTYPEINTERPOLATED dmv x 0 dmv y 0 0 for i 0 i 6 i v mb type 0 s block index i s mb intra if skipped if direct bmvtype BMVTYPEINTERPOLATED vc1 pred b mv v dmv x dmv y direct bmvtype vc1 b mc v dmv x dmv y direct bmvtype return if direct cbp get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 GETMQUANT s mb intra 0 s current picture f qscale table mb pos mquant if v ttmbf ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dmv x 0 dmv y 0 dmv x 1 dmv y 1 0 vc1 pred b mv v dmv x dmv y direct bmvtype vc1 b mc v dmv x dmv y direct bmvtype else if mb has coeffs s mb intra vc1 pred b mv v dmv x dmv y direct bmvtype vc1 b mc v dmv x dmv y direct bmvtype return if s mb intra mb has coeffs GETMQUANT s current picture f qscale table mb pos mquant s ac pred get bits1 gb cbp 0 vc1 pred b mv v dmv x dmv y direct bmvtype else if bmvtype BMVTYPEINTERPOLATEDGETMVDATA dmv x 0 dmv y 0 if mb has coeffs vc1 pred b mv v dmv x dmv y direct bmvtype vc1 b mc v dmv x dmv y direct bmvtype return vc1 pred b mv v dmv x dmv y direct bmvtype if s mb intra vc1 b mc v dmv x dmv y direct bmvtype if s mb intra s ac pred get bits1 gb cbp get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 GETMQUANT s current picture f qscale table mb pos mquant if v ttmbf s mb intra mb has coeffs ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize v mb type 0 s block index i s mb intra if s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else if val vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAYNULL if v ttmbf ttmb 8 ttmb 1 first block 0 void vp9 init quantizer V P9 COMP cpi V P9 COMMON const cm cpi common QUANTS const quants cpi quants int i q quant for q 0 q QINDEXRANGE q const int qzbin factor q 0 64 vp9 dc quant q 0 148 84 80 const int qrounding factor q 0 64 48 for i 0 i 2 i int qrounding factor fp i 0 48 42 if q 0 qrounding factor fp 64 quant i 0 vp9 dc quant q cm y dc delta q vp9 ac quant q 0 invert quant quants y quant q i quants y quant shift q i quant quants y quant fp q i 1 16 quant quants y round fp q i qrounding factor fp quant 7 quants y zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants y round q i qrounding factor quant 7 cm y dequant q i quant quant i 0 vp9 dc quant q cm uv dc delta q vp9 ac quant q cm uv ac delta q invert quant quants uv quant q i quants uv quant shift q i quant quants uv quant fp q i 1 16 quant quants uv round fp q i qrounding factor fp quant 7 quants uv zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants uv round q i qrounding factor quant 7 cm uv dequant q i quant for i 2 i 8 i quants y quant q i quants y quant q 1 quants y quant fp q i quants y quant fp q 1 quants y round fp q i quants y round fp q 1 quants y quant shift q i quants y quant shift q 1 quants y zbin q i quants y zbin q 1 quants y round q i quants y round q 1 cm y dequant q i cm y dequant q 1 quants uv quant q i quants uv quant q 1 quants uv quant fp q i quants uv quant fp q 1 quants uv round fp q i quants uv round fp q 1 quants uv quant shift q i quants uv quant shift q 1 quants uv zbin q i quants uv zbin q 1 quants uv round q i quants uv round q 1 cm uv dequant q i cm uv dequant q 1 guint16 de mid tvbuff t tvb proto tree tree packet info pinfo guint32 offset guint len gchar add string int string len guint8 oct guint32 curr offset guint32 value gboolean odd const gchar digit str proto item ti curr offset offset oct tvb get guint8 tvb curr offset switch oct 0x07 case 0 proto tree add item tree hf gsm a unused tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN if add string g snprintf add string string len No Identity Code curr offset if len 1 expert add info pinfo tree ei gsm a format not supported curr offset len 1 break case 3 case 1 odd oct 0x08 proto tree add item tree hf gsm a id dig 1 tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN if oct 0x07 3 digit str tvb bcd dig to wmem packet str tvb curr offset len curr offset offset NULLTRUE proto tree add string format tree hf gsm a imeisv tvb curr offset len curr offset offset digit str BCD Digits s digit str else digit str dissect e212 imsi tvb pinfo tree curr offset len curr offset offset TRUE if sccp assoc sccp assoc calling party sccp assoc calling party wmem strdup printf wmem file scope oct 0x07 3 IMEISV s IMSI s digit str if add string g snprintf add string string len s s oct 0x07 3 IMEISVIMSI digit str curr offset len curr offset offset if odd proto tree add item tree hf gsm a filler tvb curr offset 1 1 ENCNA break case 2 proto tree add uint format value tree hf gsm a identity digit1 tvb curr offset 1 oct c Dgt1 9 bcd out oct 0xf0 4 proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN curr offset if curr offset offset len return curr offset offset digit str tvb bcd dig to wmem packet str tvb curr offset len curr offset offset NULLFALSE proto tree add string format tree hf gsm a imei tvb curr offset len curr offset offset digit str BCD Digits s digit str if add string g snprintf add string string len IMEI s digit str curr offset len curr offset offset break case 4 proto tree add item tree hf gsm a unused tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN curr offset value tvb get ntohl tvb curr offset proto tree add uint tree hf gsm a tmsi tvb curr offset 4 value if add string g snprintf add string string len TMSIPTMSI 0x 04x value curr offset 4 break case 5 proto tree add bits item tree hf gsm a spare bits tvb curr offset 3 2 ENCBIGENDIAN proto tree add item tree hf gsm a mbs ses id ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a tmgi mcc mnc ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN curr offset proto tree add item tree hf gsm a mbs service id tvb curr offset 3 ENCBIGENDIAN curr offset 3 if oct 0x10 0x10 curr offset dissect e212 mcc mnc tvb pinfo tree curr offset E212 NONETRUE if oct 0x20 0x20 proto tree add item tree hf gsm a mbs session id tvb curr offset 1 ENCBIGENDIAN curr offset break default proto tree add item tree hf gsm a odd even ind tvb curr offset 1 ENCBIGENDIAN ti proto tree add item tree hf gsm a mobile identity type tvb curr offset 1 ENCBIGENDIAN expert add info format pinfo ti ei gsm a mobile identity type Unknown format u oct 0x07 if add string g snprintf add string string len Format Unknown curr offset len break EXTRANEOUSDATACHECK len curr offset offset pinfo ei gsm a extraneous data return curr offset offset static int mpeg field start Mpeg Enc Context s const uint8 t buf int buf size AV Codec Context avctx s avctx Mpeg1 Context s1 Mpeg1 Context s if s first field s picture structure PICTFRAME if ff MPV frame start s avctx 0 return 1 ff mpeg er frame start s s current picture ptr f repeat pict 0 if s repeat first field if s progressive sequence if s top field first s current picture ptr f repeat pict 4 else s current picture ptr f repeat pict 2 else if s progressive frame s current picture ptr f repeat pict 1 s current picture ptr f pan scan s1 pan scan if HAVETHREADS avctx active thread type FFTHREADFRAME ff thread finish setup avctx else int i if s current picture ptr av log s avctx AVLOGERROR first field missing n return 1 if s avctx hwaccel s avctx slice flags SLICEFLAGALLOWFIELD if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode first field n for i 0 i 4 i s current picture f data i s current picture ptr f data i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture ptr f linesize i if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 return 1 if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration if ff xvmc field start s avctx 0 return 1 return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt T M2 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size 3 AV Frame const p l pic int offset T M2 HEADERSIZE int i t ret uint8 t swbuf swbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if swbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n av free swbuf return ret l dsp bswap buf uint32 t swbuf const uint32 t buf buf size 2 if ret tm2 read header l swbuf 0 av free swbuf return ret for i 0 i T M2 NUMSTREAMS i if offset buf size av free swbuf return AVERRORINVALIDDATA t tm2 read stream l swbuf offset tm2 stream order i buf size offset if t 0 av free swbuf return t offset t p key frame tm2 decode blocks l p if p key frame p pict type AVPICTURETYPEI else p pict type AVPICTURETYPEP l cur l cur got frame 1 ret av frame ref data l pic av free swbuf return ret 0 ret buf size static int selinux setprocattr struct task struct p char name void value size t size struct task security struct tsec struct cred new u32 sid 0 ptsid int error char str value if current p return EACCES if strcmp name exec error current has perm p PROCESSSETEXEC else if strcmp name fscreate error current has perm p PROCESSSETFSCREATE else if strcmp name keycreate error current has perm p PROCESSSETKEYCREATE else if strcmp name sockcreate error current has perm p PROCESSSETSOCKCREATE else if strcmp name current error current has perm p PROCESSSETCURRENT else error EINVAL if error return error if size str 0 str 0 n if str size 1 n str size 1 0 size error security context to sid value size sid GFPKERNEL if error EINVAL strcmp name fscreate if capable CAPMACADMIN struct audit buffer ab size t audit size if str size 1 0 audit size size 1 else audit size size ab audit log start current audit context GFPATOMICAUDITSELINUXERR audit log format ab op fscreate invalid context audit log n untrustedstring ab value audit size audit log end ab return error error security context to sid force value size sid if error return error new prepare creds if new return ENOMEM tsec new security if strcmp name exec tsec exec sid sid else if strcmp name fscreate tsec create sid sid else if strcmp name keycreate error may create key sid p if error goto abort change tsec keycreate sid sid else if strcmp name sockcreate tsec sockcreate sid sid else if strcmp name current error EINVAL if sid 0 goto abort change error EPERM if current is single threaded error security bounded transition tsec sid sid if error goto abort change error avc has perm tsec sid sid SECCLASSPROCESSPROCESSDYNTRANSITIONNULL if error goto abort change ptsid ptrace parent sid p if ptsid 0 error avc has perm ptsid sid SECCLASSPROCESSPROCESSPTRACENULL if error goto abort change tsec sid sid else error EINVAL goto abort change commit creds new return size abort change abort creds new return error static int decode Mimic Context ctx int quality int num coeffs int is iframe int ret y x plane cur row 0 for plane 0 plane 3 plane const int is chroma plane const int qscale av clip 10000 quality is chroma 1000 2000 10000 2 const int stride ctx flipped ptrs ctx cur index linesize plane const uint8 t src ctx flipped ptrs ctx prev index data plane uint8 t dst ctx flipped ptrs ctx cur index data plane for y 0 y ctx num vblocks plane y for x 0 x ctx num hblocks plane x if is iframe get bits1 ctx gb is chroma if is chroma is iframe get bits1 ctx gb if ret vlc decode block ctx num coeffs qscale 0 av log ctx avctx AVLOGERROR Error decoding block n return ret ctx dsp idct put dst stride ctx dct block else unsigned int backref get bits ctx gb 4 int index ctx cur index backref 15 uint8 t p ctx flipped ptrs index data 0 if index ctx cur index p ff thread await progress ctx buf ptrs index cur row 0 p src ctx flipped ptrs ctx prev index data plane ctx dsp put pixels tab 1 0 dst p stride 8 else av log ctx avctx AVLOGERROR No such backreference Buggy sample n else ff thread await progress ctx buf ptrs ctx prev index cur row 0 ctx dsp put pixels tab 1 0 dst src stride 8 src 8 dst 8 src stride ctx num hblocks plane 3 dst stride ctx num hblocks plane 3 ff thread report progress ctx buf ptrs ctx cur index cur row 0 return 0 static void purple logout struct im connection ic struct purple data pd ic proto data if pd return while ic groupchats imcb chat free ic groupchats data if pd filetransfers purple transfer cancel all ic purple account set enabled pd account Bitl Bee FALSE purple connections g slist remove purple connections ic purple accounts remove pd account imcb chat list free ic g free pd chat list server g hash table destroy pd input requests g free pd static double ineq histogram selectivity Planner Info root Variable Stat Data vardata Fmgr Info opproc bool isgt Datum constval Oid consttype double hist selec Oid hist op Datum values int nvalues hist selec 1 0 if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opproc fn oid get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid hist op values nvalues NULLNULL if nvalues 1 double histfrac int lobound 0 int hibound nvalues bool have end false if nvalues 2 have end get actual variable range root vardata hist op values 0 values 1 while lobound hibound int probe lobound hibound 2 bool ltcmp if probe 0 nvalues 2 have end get actual variable range root vardata hist op values 0 NULL else if probe nvalues 1 nvalues 2 have end get actual variable range root vardata hist op NULL values probe ltcmp Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values probe constval if isgt ltcmp ltcmp if ltcmp lobound probe 1 else hibound probe if lobound 0 histfrac 0 0 else if lobound nvalues histfrac 1 0 else int i lobound double val high low double binfrac if convert to scalar constval consttype val values i 1 values i vardata vartype low high if high low binfrac 0 5 else if val low binfrac 0 0 else if val high binfrac 1 0 else binfrac val low high low if isnan binfrac binfrac 0 0 binfrac 1 0 binfrac 0 5 else binfrac 0 5 histfrac double i 1 binfrac histfrac double nvalues 1 hist selec isgt 1 0 histfrac histfrac if have end CLAMPPROBABILITY hist selec else if hist selec 0 0001 hist selec 0 0001 else if hist selec 0 9999 hist selec 0 9999 free attstatsslot vardata atttype values nvalues NULL 0 return hist selec int set wep key char string int bit 0 char p type char tok char s strlen string 1 u char tmp wkey 512 size t tmp wkey len char tmp 128 memset GBLWIFI wkey 0 sizeof GBLWIFI wkey GBLWIFI wkey len 0 strcpy s string p ec strtok s tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key bit atoi p if bit 0 SEMIFATALERROR Unsupported WEP key length tmp wkey len bit 8 WEPIVLEN if bit 64 bit 128 SEMIFATALERROR Unsupported WEP key length p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key type p p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key if type s if strescape char tmp wkey p int tmp wkey len SEMIFATALERROR Specified WEP key length does not match the given string else if type p if bit 64 make key 64 u char p tmp wkey else if bit 128 make key 128 u char p tmp wkey else SEMIFATALERROR Invalid parsing of the WEP key USERMSG Using WEP key s n str tohex tmp wkey tmp wkey len tmp sizeof tmp memcpy GBLWIFI wkey tmp wkey sizeof GBLWIFI wkey GBLWIFI wkey len tmp wkey len return static void dissect q931 pdu tvbuff t tvb packet info pinfo proto tree tree gboolean is over ip int offset 0 proto tree q931 tree NULL proto tree ie tree NULL proto item ti guint8 prot discr guint8 call ref len guint8 call ref 16 guint32 call ref val guint8 message type segmented message type guint8 info element guint16 info element len gboolean first frag more frags guint32 frag len fragment head fd head tvbuff t next tvb NULL q931 pi wmem new wmem packet scope q931 packet info reset q931 packet info q931 pi have valid q931 pi TRUE col set str pinfo cinfo COLPROTOCOLQ 931 prot discr tvb get guint8 tvb offset ti proto tree add item tree proto q931 tvb offset 1 ENCNA if tree q931 tree proto item add subtree ti ett q931 dissect q931 protocol discriminator tvb offset q931 tree offset 1 call ref len tvb get guint8 tvb offset 0x F if q931 tree NULL proto tree add uint q931 tree hf q931 call ref len tvb offset 1 call ref len offset 1 switch call ref len case 0 call ref val 0 break case 1 call ref val tvb get guint8 tvb offset break case 2 call ref val tvb get ntohs tvb offset break case 3 call ref val tvb get ntoh24 tvb offset break default call ref val tvb get ntohl tvb offset if call ref len 0 tvb memcpy tvb call ref offset call ref len if q931 tree NULL proto tree add boolean q931 tree hf q931 call ref flag tvb offset 1 call ref 0 0x80 0 call ref 0 0x7 F proto tree add bytes q931 tree hf q931 call ref tvb offset call ref len call ref else call ref 0 0x7 F memcpy q931 pi crv call ref call ref len sizeof q931 pi crv sizeof q931 pi crv call ref len offset call ref len message type tvb get guint8 tvb offset if have valid q931 pi q931 pi q931 pi message type message type col add str pinfo cinfo COLINFO get message name prot discr message type if prot discr NLPIDDMS proto tree add item q931 tree hf q931 maintenance message type tvb offset 1 ENCBIGENDIAN else proto tree add item q931 tree hf q931 message type tvb offset 1 ENCBIGENDIAN offset 1 if message type Q931 SEGMENT q931 reassembly tvb reported length remaining tvb offset 4 dissect q931 I Es tvb pinfo tree q931 tree is over ip offset 0 return info element tvb get guint8 tvb offset info element len tvb get guint8 tvb offset 1 if info element Q931 IESEGMENTEDMESSAGE info element len 2 dissect q931 I Es tvb pinfo tree q931 tree is over ip offset 0 return ie tree proto tree add subtree q931 tree tvb offset 1 1 info element len ett q931 ie info element NULL val to str info element q931 info element vals 0 Unknown information element 0x 02 X proto tree add uint format value ie tree hf q931 information element tvb offset 1 info element s val to str info element q931 info element vals 0 Unknown 0x 02 X proto tree add item ie tree hf q931 information element len tvb offset 1 1 ENCNA dissect q931 segmented message ie tvb pinfo offset 2 info element len ie tree ti first frag tvb get guint8 tvb offset 2 0x80 0 more frags tvb get guint8 tvb offset 2 0x7 F 0 segmented message type tvb get guint8 tvb offset 3 col append fstr pinfo cinfo COLINFO of s val to str ext segmented message type q931 message type vals ext Unknown message type 0x 02 X offset 1 1 info element len frag len tvb reported length remaining tvb offset if first frag fragment get q931 reassembly table pinfo call ref val NULL fragment end seq next q931 reassembly table pinfo call ref val NULL fd head fragment add seq next q931 reassembly table tvb offset pinfo call ref val NULL frag len more frags if fd head if pinfo num fd head reassembled in if fd head next NULL next tvb tvb new chain tvb fd head tvb data add new data source pinfo next tvb Reassembled Q 931 I Es if tree proto item frag tree item show fragment seq tree fd head q931 frag items q931 tree pinfo next tvb frag tree item else next tvb tvb new subset remaining tvb offset col add fstr pinfo cinfo COLINFO s reassembled val to str ext segmented message type q931 message type vals ext Unknown message type 0x 02 X else if tree proto tree add uint q931 tree hf q931 reassembled in tvb offset frag len fd head reassembled in if next tvb dissect q931 I Es next tvb pinfo tree q931 tree is over ip 0 0 static void s390 virtio register void s390 virtio bus register withprop s390 virtio serial s390 virtio bus register withprop s390 virtio blk s390 virtio bus register withprop s390 virtio net void ff h263 loop filter Mpeg Enc Context s int qp c const int linesize s linesize const int uvlinesize s uvlinesize const int xy s mb y s mb stride s mb x uint8 t dest y s dest 0 uint8 t dest cb s dest 1 uint8 t dest cr s dest 2 if ISSKIP s current picture mb type xy qp c s qscale s dsp h263 v loop filter dest y 8 linesize linesize qp c s dsp h263 v loop filter dest y 8 linesize 8 linesize qp c else qp c 0 if s mb y int qp dt qp tt qp tc if ISSKIP s current picture mb type xy s mb stride qp tt 0 else qp tt s current picture qscale table xy s mb stride if qp c qp tc qp c else qp tc qp tt if qp tc const int chroma qp s chroma qscale table qp tc s dsp h263 v loop filter dest y linesize qp tc s dsp h263 v loop filter dest y 8 linesize qp tc s dsp h263 v loop filter dest cb uvlinesize chroma qp s dsp h263 v loop filter dest cr uvlinesize chroma qp if qp tt s dsp h263 h loop filter dest y 8 linesize 8 linesize qp tt if s mb x if qp tt ISSKIP s current picture mb type xy 1 s mb stride qp dt qp tt else qp dt s current picture qscale table xy 1 s mb stride if qp dt const int chroma qp s chroma qscale table qp dt s dsp h263 h loop filter dest y 8 linesize linesize qp dt s dsp h263 h loop filter dest cb 8 uvlinesize uvlinesize chroma qp s dsp h263 h loop filter dest cr 8 uvlinesize uvlinesize chroma qp if qp c s dsp h263 h loop filter dest y 8 linesize qp c if s mb y 1 s mb height s dsp h263 h loop filter dest y 8 linesize 8 linesize qp c if s mb x int qp lc if qp c ISSKIP s current picture mb type xy 1 qp lc qp c else qp lc s current picture qscale table xy 1 if qp lc s dsp h263 h loop filter dest y linesize qp lc if s mb y 1 s mb height const int chroma qp s chroma qscale table qp lc s dsp h263 h loop filter dest y 8 linesize linesize qp lc s dsp h263 h loop filter dest cb uvlinesize chroma qp s dsp h263 h loop filter dest cr uvlinesize chroma qp static void inject user void size t len len strescape char injectbuf char injectbuf if wdg c1 flags WDGOBJFOCUSED user inject injectbuf len curr conn 1 else if wdg c2 flags WDGOBJFOCUSED user inject injectbuf len curr conn 2 void ff MPV common end Mpeg Enc Context s int i if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i s slice context count 1 else free duplicate context s av freep s parse context buffer s parse context buffer size 0 av freep s bitstream buffer s allocated bitstream buffer size 0 av freep s avctx stats out av freep s ac stats av freep s q intra matrix av freep s q inter matrix av freep s q intra matrix16 av freep s q inter matrix16 av freep s input picture av freep s reordered input picture av freep s dct offset if s picture s avctx internal is copy for i 0 i s picture count i free picture s s picture i av freep s picture free context frame s if s avctx active thread type FFTHREADFRAME avcodec default free buffers s avctx s context initialized 0 s last picture ptr s next picture ptr s current picture ptr NULL s linesize s uvlinesize 0 static ulong get sort uint count va list args va start args count ulong sort 0 DBUGASSERT count 4 while count char start str va arg args char uint chars 0 uint wild pos 0 if start str for str str if str wild prefix str 1 str else if str wild many str wild one wild pos uint str start 1 if wild pos 1 str wild many str 0 wild pos break chars 128 sort sort 8 wild pos min wild pos 127 chars va end args return sort static int roq encode init AV Codec Context avctx Roq Context enc avctx priv data av lfg init enc randctx 1 enc frames Since Keyframe 0 if avctx width 0xf avctx height 0xf av log avctx AVLOGERROR Dimensions must be divisible by 16 n return 1 if avctx width avctx width 1 avctx height avctx height 1 av log avctx AVLOGERROR Warning dimensions not power of two n enc width avctx width enc height avctx height enc frames Since Keyframe 0 enc first frame 1 enc last frame av frame alloc enc current frame av frame alloc if enc last frame enc current frame roq encode end avctx return AVERRORENOMEM enc tmp Data av malloc sizeof Roq Tempdata enc this motion4 av mallocz enc width enc height 16 sizeof motion vect enc last motion4 av malloc enc width enc height 16 sizeof motion vect enc this motion8 av mallocz enc width enc height 64 sizeof motion vect enc last motion8 av malloc enc width enc height 64 sizeof motion vect return 0 static void fill picture parameters struct dxva context ctx const H264 Context h DXVA Pic Params H264 pp const Picture current picture h cur pic ptr int i j memset pp 0 sizeof pp fill picture entry pp Curr Pic ff dxva2 get surface index ctx current picture h picture structure PICTBOTTOMFIELD pp Used For Reference Flags 0 pp Non Existing Frame Flags 0 for i 0 j 0 i FFARRAYELEMS pp Ref Frame List i const Picture r if j h short ref count r h short ref j else r NULL while r j h short ref count 16 r h long ref j h short ref count if r fill picture entry pp Ref Frame List i ff dxva2 get surface index ctx r r long ref 0 if r reference PICTTOPFIELD r field poc 0 INTMAX pp Field Order Cnt List i 0 r field poc 0 if r reference PICTBOTTOMFIELD r field poc 1 INTMAX pp Field Order Cnt List i 1 r field poc 1 pp Frame Num List i r long ref r pic id r frame num if r reference PICTTOPFIELD pp Used For Reference Flags 1 2 i 0 if r reference PICTBOTTOMFIELD pp Used For Reference Flags 1 2 i 1 else pp Ref Frame List i b Pic Entry 0xff pp Field Order Cnt List i 0 0 pp Field Order Cnt List i 1 0 pp Frame Num List i 0 pp w Frame Width In Mbs Minus1 h mb width 1 pp w Frame Height In Mbs Minus1 h mb height 1 pp num ref frames h sps ref frame count pp w Bit Fields h picture structure PICTFRAME 0 h sps mb aff h picture structure PICTFRAME 1 h sps residual color transform flag 2 0 3 h sps chroma format idc 4 h nal ref idc 0 6 h pps constrained intra pred 7 h pps weighted pred 8 h pps weighted bipred idc 9 1 11 h sps frame mbs only flag 12 h pps transform 8x8 mode 13 h sps level idc 31 14 1 15 pp bit depth luma minus8 h sps bit depth luma 8 pp bit depth chroma minus8 h sps bit depth chroma 8 if ctx workaround FFDXV A2 WORKAROUNDSCALINGLISTZIGZAG pp Reserved16 Bits 0 else pp Reserved16 Bits 3 pp Status Report Feedback Number 1 ctx report id pp Curr Field Order Cnt 0 0 if h picture structure PICTTOPFIELD current picture field poc 0 INTMAX pp Curr Field Order Cnt 0 current picture field poc 0 pp Curr Field Order Cnt 1 0 if h picture structure PICTBOTTOMFIELD current picture field poc 1 INTMAX pp Curr Field Order Cnt 1 current picture field poc 1 pp pic init qs minus26 h pps init qs 26 pp chroma qp index offset h pps chroma qp index offset 0 pp second chroma qp index offset h pps chroma qp index offset 1 pp Continuation Flag 1 pp pic init qp minus26 h pps init qp 26 pp num ref idx l0 active minus1 h pps ref count 0 1 pp num ref idx l1 active minus1 h pps ref count 1 1 pp Reserved8 Bits A 0 pp frame num h frame num pp log2 max frame num minus4 h sps log2 max frame num 4 pp pic order cnt type h sps poc type if h sps poc type 0 pp log2 max pic order cnt lsb minus4 h sps log2 max poc lsb 4 else if h sps poc type 1 pp delta pic order always zero flag h sps delta pic order always zero flag pp direct 8x8 inference flag h sps direct 8x8 inference flag pp entropy coding mode flag h pps cabac pp pic order present flag h pps pic order present pp num slice groups minus1 h pps slice group count 1 pp slice group map type h pps mb slice group map type pp deblocking filter control present flag h pps deblocking filter parameters present pp redundant pic cnt present flag h pps redundant pic cnt present pp Reserved8 Bits B 0 pp slice group change rate minus1 0 int ff h263 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg Enc Context s avctx priv data int ret AV Frame pict data s flags2 avctx flags2 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got frame 1 return 0 if s flags CODECFLAGTRUNCATED int next if CONFIGMPE G4 DECODER s codec id AVCODECIDMPE G4 next ff mpeg4 find frame end s parse context buf buf size else if CONFIG H263 DECODER s codec id AVCODECID H263 next ff h263 find frame end s parse context buf buf size else av log s avctx AVLOGERROR this codec does not support truncated bitstreams n return 1 if ff combine frame s parse context next const uint8 t buf buf size 0 return buf size retry if s bitstream buffer size s divx packed buf size 20 init get bits s gb s bitstream buffer s bitstream buffer size 8 else init get bits s gb buf buf size 8 s bitstream buffer size 0 if s context initialized if ff MPV common init s 0 return 1 if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 return i s current picture ptr s picture i if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode picture header s else if CONFIGMSMPE G4 DECODER s msmpeg4 version ret ff msmpeg4 decode picture header s else if CONFIGMPE G4 DECODER s h263 pred if s avctx extradata size s picture number 0 Get Bit Context gb init get bits gb s avctx extradata s avctx extradata size 8 ret ff mpeg4 decode picture header s gb ret ff mpeg4 decode picture header s s gb else if CONFIG H263 IDECODER s codec id AVCODECID H263 I ret ff intel h263 decode picture header s else if CONFIGFLVDECODER s h263 flv ret ff flv decode picture header s else ret ff h263 decode picture header s if ret FRAMESKIPPED return get consumed bytes s buf size if ret 0 av log s avctx AVLOGERROR header damaged n return 1 avctx has b frames s low delay if s xvid build 1 s divx version 1 s lavc build 1 if s stream codec tag AVR L32 XVID s codec tag AVR L32 XVID s codec tag AVR L32 XVIX s codec tag AVR L32 RM P4 s codec tag AVR L32 ZM P4 s codec tag AVR L32 SIPP s xvid build 0 if s xvid build 1 s divx version 1 s lavc build 1 if s codec tag AVR L32 DIVX s vo type 0 s vol control parameters 0 s divx version 400 if s xvid build 0 s divx version 0 s divx version s divx build 1 if s workaround bugs FFBUGAUTODETECT if s codec tag AVR L32 XVIX s workaround bugs FFBUGXVIDILACE if s codec tag AVR L32 UM P4 s workaround bugs FFBUGUM P4 if s divx version 500 s divx build 1814 s workaround bugs FFBUGQPELCHROMA if s divx version 502 s divx build 1814 s workaround bugs FFBUGQPELCHROM A2 if s xvid build 3 U s padding bug score 256 256 256 64 if s xvid build 1 U s workaround bugs FFBUGQPELCHROMA if s xvid build 12 U s workaround bugs FFBUGEDGE if s xvid build 32 U s workaround bugs FFBUGDCCLIP s dsp put no rnd postfix1 ff put no rnd postfix2 s dsp avg postfix1 ff avg postfix2 if s lavc build 4653 U s workaround bugs FFBUGSTDQPEL if s lavc build 4655 U s workaround bugs FFBUGDIRECTBLOCKSIZE if s lavc build 4670 U s workaround bugs FFBUGEDGE if s lavc build 4712 U s workaround bugs FFBUGDCCLIP if s divx version 0 s workaround bugs FFBUGDIRECTBLOCKSIZE if s divx version 501 s divx build 20020416 s padding bug score 256 256 256 64 if s divx version 500 U s workaround bugs FFBUGEDGE if s divx version 0 s workaround bugs FFBUGHPELCHROMA if s resync marker 0 s data partitioning 0 s divx version 1 s codec id AVCODECIDMPE G4 s vo type 0 s workaround bugs FFBUGNOPADDING if s lavc build 4609 U s workaround bugs FFBUGNOPADDING if s workaround bugs FFBUGSTDQPELSETQPELFUNC qpel pixels tab 0 5 qpel16 mc11 old c SETQPELFUNC qpel pixels tab 0 7 qpel16 mc31 old c SETQPELFUNC qpel pixels tab 0 9 qpel16 mc12 old c SETQPELFUNC qpel pixels tab 0 11 qpel16 mc32 old c SETQPELFUNC qpel pixels tab 0 13 qpel16 mc13 old c SETQPELFUNC qpel pixels tab 0 15 qpel16 mc33 old c SETQPELFUNC qpel pixels tab 1 5 qpel8 mc11 old c SETQPELFUNC qpel pixels tab 1 7 qpel8 mc31 old c SETQPELFUNC qpel pixels tab 1 9 qpel8 mc12 old c SETQPELFUNC qpel pixels tab 1 11 qpel8 mc32 old c SETQPELFUNC qpel pixels tab 1 13 qpel8 mc13 old c SETQPELFUNC qpel pixels tab 1 15 qpel8 mc33 old c if avctx debug FFDEBUGBUGS av log s avctx AVLOGDEBUG bugs X lavc build d xvid build d divx version d divx build d s n s workaround bugs s lavc build s xvid build s divx version s divx build s divx packed p avctx idct algo FFIDCTXVIDMMX ff dct common init s s picture number 0 Parse Context pc s parse context s parse context buffer 0 ff MPV common end s s parse context pc avcodec set dimensions avctx s width s height goto retry if s width avctx coded width s height avctx coded height s context reinit s context reinit 0 avcodec set dimensions avctx s width s height if ret ff MPV common frame size change s return ret if s codec id AVCODECID H263 s codec id AVCODECID H263 P s codec id AVCODECID H263 I s gob index ff h263 get gob height s s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable return get consumed bytes s buf size if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return get consumed bytes s buf size if s next p frame damaged if s pict type AVPICTURETYPEB return get consumed bytes s buf size else s next p frame damaged 0 if s no rounding s pict type AVPICTURETYPEB s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab else s me qpel put s dsp put no rnd qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if ff MPV frame start s avctx 0 return 1 if s divx packed ff thread finish setup avctx if CONFIGMPE G4 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau mpeg4 decode picture s s gb buffer s gb buffer end s gb buffer goto frame end if avctx hwaccel if avctx hwaccel start frame avctx s gb buffer s gb buffer end s gb buffer 0 return 1 ff mpeg er frame start s if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode secondary picture header s if ret 0 return ret if ret 1 goto intrax8 decoded s mb x 0 s mb y 0 ret decode slice s while s mb y s mb height if s msmpeg4 version if s slice height 0 s mb x 0 s mb y s slice height 0 get bits left s gb 0 break else int prev x s mb x prev y s mb y if ff h263 resync s 0 break if prev y s mb width prev x s mb y s mb width s mb x s er error occurred 1 if s msmpeg4 version 4 s h263 pred ff mpeg4 clean buffers s if decode slice s 0 ret AVERRORINVALIDDATA if s msmpeg4 version s msmpeg4 version 4 s pict type AVPICTURETYPEI if CONFIGMSMPE G4 DECODER ff msmpeg4 decode ext header s buf size 0 s er error status table s mb num 1 ERMBERROR assert s bitstream buffer size 0 frame end if s codec id AVCODECIDMPE G4 s divx packed int current pos get bits count s gb 3 int startcode found 0 if buf size current pos 5 int i for i current pos i buf size 3 i if buf i 0 buf i 1 0 buf i 2 1 buf i 3 0x B6 startcode found 1 break if s gb buffer s bitstream buffer buf size 7 s xvid build 0 startcode found 1 current pos 0 if startcode found av fast malloc s bitstream buffer s allocated bitstream buffer size buf size current pos FFINPUTBUFFERPADDINGSIZE if s bitstream buffer return AVERRORENOMEM memcpy s bitstream buffer buf current pos buf size current pos s bitstream buffer size buf size current pos intrax8 decoded ff er frame end s er if avctx hwaccel if avctx hwaccel end frame avctx 0 return 1 ff MPV frame end s assert s current picture f pict type s current picture ptr f pict type assert s current picture f pict type s pict type if s pict type AVPICTURETYPEB s low delay pict s current picture ptr f else if s last picture ptr NULL pict s last picture ptr f if s last picture ptr s low delay got frame 1 ff print debug info s pict static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Dxa Dec Context const c avctx priv data uint8 t outptr srcptr tmpptr unsigned long dsize int i j compr ret int stride int orig buf size buf size int pc 0 if buf 0 C buf 1 M buf 2 A buf 3 P int r g b buf 4 for i 0 i 256 i r buf g buf b buf c pal i r 16 g 8 b pc 1 buf size 768 4 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed pc outptr frame data 0 srcptr c decomp buf tmpptr c prev data 0 stride frame linesize 0 if buf 0 N buf 1 U buf 2 L buf 3 L compr 1 else compr buf 4 dsize c dsize if compr 4 compr 1 uncompress c decomp buf dsize buf 9 buf size 9 ZOK av log avctx AVLOGERROR Uncompress failed n return AVERRORUNKNOWN switch compr case 1 frame key frame 0 frame pict type AVPICTURETYPEP if c prev data 0 memcpy frame data 0 c prev data 0 frame linesize 0 avctx height else memset frame data 0 0 frame linesize 0 avctx height frame key frame 1 frame pict type AVPICTURETYPEI break case 2 case 3 case 4 case 5 frame key frame compr 1 frame pict type compr 1 AVPICTURETYPEPAVPICTURETYPEI for j 0 j avctx height j if compr 1 for i 0 i avctx width i outptr i srcptr i tmpptr i tmpptr stride else memcpy outptr srcptr avctx width outptr stride srcptr avctx width break case 12 case 13 frame key frame 0 frame pict type AVPICTURETYPEP decode 13 avctx c frame data 0 frame linesize 0 srcptr c prev data 0 break default av log avctx AVLOGERROR Unknown unsupported compression type d n buf 4 return AVERRORINVALIDDATA av frame unref c prev if ret av frame ref c prev frame 0 return ret got frame 1 return orig buf size int evbuffer expand struct evbuffer buf size t datlen size t need buf misalign buf off datlen if buf totallen need return 0 if buf misalign datlen evbuffer align buf else void newbuf size t length buf totallen if length 256 length 256 while length need length 1 if buf orig buffer buf buffer evbuffer align buf if newbuf realloc buf buffer length NULL return 1 buf orig buffer buf buffer newbuf buf totallen length return 0 vpx codec err t vpx svc encode Svc Context svc ctx vpx codec ctx t codec ctx struct vpx image rawimg vpx codec pts t pts int64 t duration int deadline vpx codec err t res vpx codec iter t iter const vpx codec cx pkt t cx pkt int layer for psnr 0 Svc Internal const si get svc internal svc ctx if svc ctx NULL codec ctx NULL si NULL return VPXCODECINVALIDPARAM svc log reset svc ctx si rc stats buf used 0 si layers svc ctx spatial layers if si encode frame count 0 si frame within gop 0 si is keyframe si frame within gop 0 if rawimg NULL svc log svc ctx SVCLOGDEBUG vpx svc encode layers d frame count d frame within gop d n si layers si encode frame count si frame within gop if rawimg NULL for si layer 0 si layer si layers si layer set svc parameters svc ctx codec ctx res vpx codec encode codec ctx rawimg pts uint32 t duration 0 deadline if res VPXCODECOK return res iter NULL while cx pkt vpx codec get cx data codec ctx iter switch cx pkt kind case VPXCODECCXFRAMEPKT fd list add si frame list fd create cx pkt data frame buf cx pkt data frame sz cx pkt data frame flags svc log svc ctx SVCLOGDEBUGSVC frame d kf d size d pts d n si frame received cx pkt data frame flags VPXFRAMEISKEY 1 0 int cx pkt data frame sz int cx pkt data frame pts si frame received layer for psnr 0 break case VPXCODECPSNRPKT int i svc log svc ctx SVCLOGDEBUGSVC frame d layer d PSNR Total YUV 2 3f 2 3f 2 3f 2 3f n si frame received layer for psnr cx pkt data psnr psnr 0 cx pkt data psnr psnr 1 cx pkt data psnr psnr 2 cx pkt data psnr psnr 3 svc log svc ctx SVCLOGDEBUGSVC frame d layer d SSE Total YUV 2 3f 2 3f 2 3f 2 3f n si frame received layer for psnr cx pkt data psnr sse 0 cx pkt data psnr sse 1 cx pkt data psnr sse 2 cx pkt data psnr sse 3 for i 0 i COMPONENTS i si psnr sum layer for psnr i cx pkt data psnr psnr i si sse sum layer for psnr i cx pkt data psnr sse i layer for psnr break case VPXCODECSTATSPKT size t new size si rc stats buf used cx pkt data twopass stats sz if new size si rc stats buf size char p char realloc si rc stats buf new size if p NULL svc log svc ctx SVCLOGERROR Error allocating stats buf n return VPXCODECMEMERROR si rc stats buf p si rc stats buf size new size memcpy si rc stats buf si rc stats buf used cx pkt data twopass stats buf cx pkt data twopass stats sz si rc stats buf used cx pkt data twopass stats sz break int i for i 0 i si layers i si bytes sum i cx pkt data layer sizes i break break void configure buffer updates V P9 COMP cpi TWOPASS const twopass cpi twopass cpi rc is src frame alt ref 0 switch twopass gf group update type twopass gf group index case KFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 1 break case LFUPDATE cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 break case GFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 0 break case OVERLAYUPDATE cpi refresh last frame 0 cpi refresh golden frame 1 cpi refresh alt ref frame 0 cpi rc is src frame alt ref 1 break case ARFUPDATE cpi refresh last frame 0 cpi refresh golden frame 0 cpi refresh alt ref frame 1 break default assert 0 break if is two pass svc cpi if cpi svc temporal layer id 0 cpi refresh last frame 0 cpi refresh golden frame 0 if cpi svc layer context cpi svc spatial layer id gold ref idx 0 cpi refresh golden frame 0 if cpi alt ref source NULL cpi refresh alt ref frame 0 static int tmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt TMV Context tmv avctx priv data const uint8 t src avpkt data uint8 t dst unsigned char cols avctx width 3 unsigned char rows avctx height 3 unsigned x y fg bg c int ret if tmv pic data 0 avctx release buffer avctx tmv pic if ret ff get buffer avctx tmv pic 0 av log avctx AVLOGERROR get buffer failed n return ret if avpkt size 2 char rows char cols av log avctx AVLOGERROR Input buffer too small truncated sample n got frame 0 return AVERRORINVALIDDATA tmv pic pict type AVPICTURETYPEI tmv pic key frame 1 dst tmv pic data 0 tmv pic palette has changed 1 memcpy tmv pic data 1 ff cga palette 16 4 for y 0 y char rows y for x 0 x char cols x c src bg src 4 fg src 0x F ff draw pc font dst x 8 tmv pic linesize 0 ff cga font 8 c fg bg dst tmv pic linesize 0 8 got frame 1 AV Frame data tmv pic return avpkt size static void vc1 mc 4mv luma V C1 Context v int n int dir Mpeg Enc Context s v s DSP Context dsp v s dsp uint8 t src Y int dxy mx my src x src y int off int fieldmv v fcm ILACEFRAME v blk mv type s block index n 0 int v edge pos s v edge pos v field mode if v field mode v ref field type dir 1 v cur field type 1 v s last picture f data 0 return mx s mv dir n 0 my s mv dir n 1 if dir if v field mode if v cur field type v ref field type dir v cur field type src Y s current picture f data 0 else src Y s last picture f data 0 else src Y s last picture f data 0 else src Y s next picture f data 0 if v field mode if v cur field type v ref field type dir my my 2 4 v cur field type if s pict type AVPICTURETYPEP n 3 v field mode int same count 0 opp count 0 k int chosen mv 2 4 2 f int tx ty for k 0 k 4 k f v mv f 0 s block index k v blocks off chosen mv f f opp count same count 0 s mv 0 k 0 chosen mv f f opp count same count 1 s mv 0 k 1 opp count f same count 1 f f opp count same count switch f opp count same count case 4 tx median4 chosen mv f 0 0 chosen mv f 1 0 chosen mv f 2 0 chosen mv f 3 0 ty median4 chosen mv f 0 1 chosen mv f 1 1 chosen mv f 2 1 chosen mv f 3 1 break case 3 tx mid pred chosen mv f 0 0 chosen mv f 1 0 chosen mv f 2 0 ty mid pred chosen mv f 0 1 chosen mv f 1 1 chosen mv f 2 1 break case 2 tx chosen mv f 0 0 chosen mv f 1 0 2 ty chosen mv f 0 1 chosen mv f 1 1 2 break s current picture f motion val 1 s block index 0 v blocks off 0 tx s current picture f motion val 1 s block index 0 v blocks off 1 ty for k 0 k 4 k v mv f 1 s block index k v blocks off f if v fcm ILACEFRAME int qx qy int width s avctx coded width int height s avctx coded height 1 qx s mb x 16 mx 2 qy s mb y 8 my 3 if qx 17 mx 4 qx 17 else if qx width mx 4 qx width if qy 18 my 8 qy 18 else if qy height 1 my 8 qy height 1 if v fcm ILACEFRAME fieldmv off n 1 s linesize 0 n 1 8 else off s linesize 4 n 2 n 1 8 if v field mode v cur field type off s current picture ptr f linesize 0 src x s mb x 16 n 1 8 mx 2 if fieldmv src y s mb y 16 n 2 4 my 2 else src y s mb y 16 n 1 1 0 my 2 if v profile PROFILEADVANCED src x av clip src x 16 s mb width 16 src y av clip src y 16 s mb height 16 else src x av clip src x 17 s avctx coded width if v fcm ILACEFRAME if src y 1 src y av clip src y 17 s avctx coded height 1 else src y av clip src y 18 s avctx coded height else src y av clip src y 18 s avctx coded height 1 src Y src y s linesize src x if v field mode v ref field type dir src Y s current picture ptr f linesize 0 if fieldmv src y 1 v edge pos if fieldmv src y 1 src y 4 src y if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 13 v edge pos 23 unsigned src x s mspel s h edge pos mx 3 8 s mspel 2 unsigned src y s mspel fieldmv v edge pos my 3 8 s mspel 2 fieldmv src Y s mspel 1 s linesize fieldmv s vdsp emulated edge mc s edge emu buffer src Y s linesize 9 s mspel 2 9 s mspel 2 fieldmv src x s mspel src y s mspel fieldmv s h edge pos v edge pos src Y s edge emu buffer if v rangeredfrm int i j uint8 t src src src Y for j 0 j 9 s mspel 2 j for i 0 i 9 s mspel 2 i src i src i 128 1 128 src s linesize fieldmv if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src src Y for j 0 j 9 s mspel 2 j for i 0 i 9 s mspel 2 i src i v luty src i src s linesize fieldmv src Y s mspel 1 s linesize fieldmv if s mspel dxy my 3 2 mx 3 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off src Y s linesize fieldmv v rnd else dxy my 2 mx 2 1 if v rnd dsp put pixels tab 1 dxy s dest 0 off src Y s linesize 8 else dsp put no rnd pixels tab 1 dxy s dest 0 off src Y s linesize 8 static int combined motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv int64 t best rd sofar MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 const int step param cpi sf mv fullpel search step param const int sadpb x sadperbit16 MV mvp full const int ref mbmi ref frame 0 const MV ref mv mbmi ref mvs ref 0 as mv int dis int rate mode const int tmp col min x mv col min const int tmp col max x mv col max const int tmp row min x mv row min const int tmp row max x mv row max int rv 0 int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref if cpi common show frame x pred mv sad ref 3 x pred mv sad LASTFRAME return rv if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv assert x mv best ref index ref 2 if x mv best ref index ref 2 mvp full mbmi ref mvs ref x mv best ref index ref as mv else mvp full x pred mv ref mvp full col 3 mvp full row 3 vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 0 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max mvp full row tmp mv as mv row 8 mvp full col tmp mv as mv col 8 rate mv vp9 mv bit cost mvp full ref mv x nmvjointcost x mvcost MVCOSTWEIGHT rate mode cpi inter mode cost mbmi mode context ref INTEROFFSETNEWMV rv RDCOST x rdmult x rddiv rate mv rate mode 0 best rd sofar if rv cpi find fractional mv step x tmp mv as mv ref mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return rv static uint64 t vmport ioport read void opaque hwaddr addr unsigned size VM Port State s opaque CPU X86 State env cpu single env unsigned char command uint32 t eax cpu synchronize state CPU x86 env get cpu env eax env regs REAX if eax VMPORTMAGIC return eax command env regs RECX if command VMPORTENTRIES return eax if s func command return s func command s opaque command addr enum Imap Auth Res imap auth gss struct Imap Data idata const char method gss buffer desc request buf send token gss buffer t sec token gss name t target name gss ctx id t context gss OID mech name char server conf flags gss qop t quality int cflags OM uint32 maj stat min stat char buf1 GSSBUFSIZE buf2 GSSBUFSIZE unsigned long buf size int rc if mutt bit isset idata capabilities AGSSAPI return IMAPAUTHUNAVAIL if mutt account getuser idata conn account 0 return IMAPAUTHFAILURE snprintf buf1 sizeof buf1 imap s idata conn account host request buf value buf1 request buf length strlen buf1 maj stat gss import name min stat request buf gss nt service name target name if maj stat GSSSCOMPLETE mutt debug 2 Couldn t get service name for s n buf1 return IMAPAUTHUNAVAIL else if Debug Level 2 gss display name min stat target name request buf mech name mutt debug 2 Using service name s n char request buf value gss release buffer min stat request buf sec token GSSCNOBUFFER context GSSCNOCONTEXT maj stat gss init sec context min stat GSSCNOCREDENTIAL context target name GSSCNOOIDGSSCMUTUALFLAGGSSCSEQUENCEFLAG 0 GSSCNOCHANNELBINDINGS sec token NULL send token unsigned int cflags NULL if maj stat GSSSCOMPLETE maj stat GSSSCONTINUENEEDED print gss error maj stat min stat mutt debug 1 Error acquiring credentials no TGT n gss release name min stat target name return IMAPAUTHUNAVAIL mutt message Authenticating GSSAPI imap cmd start idata AUTHENTICATEGSSAPI do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 2 Invalid response from server s n buf1 gss release name min stat target name goto bail mutt debug 2 Sending credentials n mutt b64 encode buf1 send token value send token length sizeof buf1 2 gss release buffer min stat send token mutt str strcat buf1 sizeof buf1 r n mutt socket send idata conn buf1 while maj stat GSSSCONTINUENEEDED do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 1 Error receiving server response n gss release name min stat target name goto bail request buf length mutt b64 decode buf2 idata buf 2 request buf value buf2 sec token request buf maj stat gss init sec context min stat GSSCNOCREDENTIAL context target name GSSCNOOIDGSSCMUTUALFLAGGSSCSEQUENCEFLAG 0 GSSCNOCHANNELBINDINGS sec token NULL send token unsigned int cflags NULL if maj stat GSSSCOMPLETE maj stat GSSSCONTINUENEEDED print gss error maj stat min stat mutt debug 1 Error exchanging credentials n gss release name min stat target name goto err abort cmd mutt b64 encode buf1 send token value send token length sizeof buf1 2 gss release buffer min stat send token mutt str strcat buf1 sizeof buf1 r n mutt socket send idata conn buf1 gss release name min stat target name do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 2 Error receiving server response n goto bail request buf length mutt b64 decode buf2 idata buf 2 request buf value buf2 maj stat gss unwrap min stat context request buf send token cflags quality if maj stat GSSSCOMPLETE print gss error maj stat min stat mutt debug 2 Couldn t unwrap security level data n gss release buffer min stat send token goto err abort cmd mutt debug 2 Credential exchange complete n server conf flags char send token value 0 if char send token value 0 GSSAUTHPNONE mutt debug 2 Server requires integrity or privacy n gss release buffer min stat send token goto err abort cmd char send token value 0 0 buf size ntohl long send token value gss release buffer min stat send token mutt debug 2 Unwrapped security level flags c c c n server conf flags GSSAUTHPNONEN server conf flags GSSAUTHPINTEGRITYI server conf flags GSSAUTHPPRIVACYP mutt debug 2 Maximum GSS token size is ld n buf size buf size htonl buf size memcpy buf1 buf size 4 buf1 0 GSSAUTHPNONE strncpy buf1 4 idata conn account user sizeof buf1 4 request buf value buf1 request buf length 4 strlen idata conn account user maj stat gss wrap min stat context 0 GSSCQOPDEFAULT request buf cflags send token if maj stat GSSSCOMPLETE mutt debug 2 Error creating login request n goto err abort cmd mutt b64 encode buf1 send token value send token length sizeof buf1 2 mutt debug 2 Requesting authorisation as s n idata conn account user mutt str strcat buf1 sizeof buf1 r n mutt socket send idata conn buf1 do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 Unexpected server continuation request n goto err abort cmd if imap code idata buf mutt debug 2 Releasing GSS credentials n maj stat gss delete sec context min stat context send token if maj stat GSSSCOMPLETE mutt debug 1 Error releasing credentials n gss release buffer min stat send token return IMAPAUTHSUCCESS else goto bail err abort cmd mutt socket send idata conn r n do rc imap cmd step idata while rc IMAPCMDCONTINUE bail mutt error GSSAPI authentication failed return int ff h264 decode ref pic list reordering H264 Context h int list index pic structure i print short term h print long term h for list 0 list h list count list for i 0 i h ref count list i COPYPICTURE h ref list list i h default ref list list i if get bits1 h gb int pred h curr pic num for index 0 index unsigned int reordering of pic nums idc get ue golomb 31 h gb unsigned int pic id int i Picture ref NULL if reordering of pic nums idc 3 break if index h ref count list av log h avctx AVLOGERROR reference count overflow n return 1 if reordering of pic nums idc 3 if reordering of pic nums idc 2 const unsigned int abs diff pic num get ue golomb h gb 1 int frame num if abs diff pic num h max pic num av log h avctx AVLOGERROR abs diff pic num overflow n return 1 if reordering of pic nums idc 0 pred abs diff pic num else pred abs diff pic num pred h max pic num 1 frame num pic num extract h pred pic structure for i h short ref count 1 i 0 i ref h short ref i assert ref reference assert ref long ref if ref frame num frame num ref reference pic structure break if i 0 ref pic id pred else int long idx pic id get ue golomb h gb long idx pic num extract h pic id pic structure if long idx 31 av log h avctx AVLOGERROR long term pic idx overflow n return 1 ref h long ref long idx assert ref ref reference if ref ref reference pic structure ref pic id pic id assert ref long ref i 0 else i 1 if i 0 av log h avctx AVLOGERROR reference picture missing during reorder n memset h ref list list index 0 sizeof Picture else for i index i 1 h ref count list i if ref long ref h ref list list i long ref ref pic id h ref list list i pic id break for i index i COPYPICTURE h ref list list i h ref list list i 1 COPYPICTURE h ref list list index ref if FIELDPICTURE pic as field h ref list list index pic structure else av log h avctx AVLOGERROR illegal reordering of pic nums idc n return 1 for list 0 list h list count list for index 0 index h ref count list index if h ref list list index f data 0 av log h avctx AVLOGERROR Missing reference picture n if h default ref list list 0 f data 0 COPYPICTURE h ref list list index h default ref list list 0 else return 1 return 0 int ff get qtpalette int codec id AVIO Context pb uint32 t palette int tmp bit depth color table id greyscale i avio seek pb 82 SEEKCUR tmp avio rb16 pb bit depth tmp 0x1 F greyscale tmp 0x20 color table id avio rb16 pb if greyscale codec id AVCODECIDCINEPAK return 0 if bit depth 1 bit depth 2 bit depth 4 bit depth 8 uint32 t color count color start color end uint32 t a r g b if greyscale bit depth 1 color table id int color index color dec color count 1 bit depth color index 255 color dec 256 color count 1 for i 0 i color count i r g b color index palette i 0x FFU 24 r 16 g 8 b color index color dec if color index 0 color index 0 else if color table id const uint8 t color table color count 1 bit depth if bit depth 1 color table ff qt default palette 2 else if bit depth 2 color table ff qt default palette 4 else if bit depth 4 color table ff qt default palette 16 else color table ff qt default palette 256 for i 0 i color count i r color table i 3 0 g color table i 3 1 b color table i 3 2 palette i 0x FFU 24 r 16 g 8 b else color start avio rb32 pb avio rb16 pb color end avio rb16 pb if color start 255 color end 255 for i color start i color end i a avio r8 pb avio r8 pb r avio r8 pb avio r8 pb g avio r8 pb avio r8 pb b avio r8 pb avio r8 pb palette i a 24 r 16 g 8 b return 1 return 0 static int libspeex decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt uint8 t buf avpkt data int buf size avpkt size Lib Speex Context s avctx priv data AV Frame frame data int16 t output int ret consumed 0 frame nb samples s frame size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret output int16 t frame data 0 if speex bits remaining s bits 5 speex bits peek unsigned s bits 5 0x1 F if buf buf size got frame ptr 0 return buf size speex bits read from s bits buf buf size consumed buf size ret speex decode int s dec state s bits output if ret 2 av log avctx AVLOGERROR Error decoding Speex frame n return AVERRORINVALIDDATA if avctx channels 2 speex decode stereo int output s frame size s stereo got frame ptr 1 return consumed static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Camtasia Context const c avctx priv data const unsigned char encoded buf int zret int ret len buf size if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN c zstream next in encoded c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZFINISH if zret ZOK zret ZSTREAMEND zret ZDATAERROR av log avctx AVLOGERROR Inflate error d n zret return AVERRORUNKNOWN if zret ZDATAERROR bytestream2 init c gb c decomp buf c decomp size c zstream avail out ff msrle decode avctx AV Picture c pic c bpp c gb if c avctx pix fmt AVPIXFMTPA L8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size Qdraw Context const a avctx priv data AV Frame const p a pic uint8 t outdata int colors int i ret uint32 t pal int r g b if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 outdata a pic data 0 if buf end buf 0x68 4 return AVERRORINVALIDDATA buf 0x68 colors AVR B32 buf buf 4 if colors 0 colors 256 av log avctx AVLOGERROR Error color count i 0x X n colors colors return AVERRORINVALIDDATA if buf end buf colors 1 8 return AVERRORINVALIDDATA pal uint32 t p data 1 for i 0 i colors i unsigned int idx idx AVR B16 buf buf 2 if idx 255 av log avctx AVLOGERROR Palette index out of range u n idx buf 6 continue r buf buf g buf buf b buf buf pal idx r 16 g 8 b p palette has changed 1 if buf end buf 18 return AVERRORINVALIDDATA buf 18 for i 0 i avctx height i int size left code pix const uint8 t next uint8 t out int tsize 0 out outdata size AVR B16 buf buf 2 if buf end buf size return AVERRORINVALIDDATA left size next buf size while left 0 code buf if code 0x80 pix buf if out 257 code outdata a pic linesize 0 break memset out pix 257 code out 257 code tsize 257 code left 2 else if out code outdata a pic linesize 0 break if buf end buf code 1 return AVERRORINVALIDDATA memcpy out buf code 1 out code 1 buf code 1 left 2 code tsize code 1 buf next outdata a pic linesize 0 got frame 1 AV Frame data a pic return buf size static void pk transaction authorize actions finished cb G Object source object G Async Result res struct Authorize Actions Data data const gchar action id NULL Pk Transaction Private priv data transaction priv g autoptr G Error error NULL g autoptr Polkit Authorization Result result NULL g assert data actions data actions len 0 action id g ptr array index data actions 0 result polkit authority check authorization finish priv authority res error if g cancellable is cancelled priv cancellable priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED The authentication was cancelled due to a timeout pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if result NULL g autofree gchar message NULL priv waiting for auth FALSE g warning failed to check for auth s error message pk transaction status changed emit data transaction PKSTATUSENUMFINISHED message g strdup printf Failed to check for authentication s error message pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED message pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if polkit authorization result get is authorized result if g strcmp0 action id org freedesktop packagekit package install 0 pk bitfield contain priv cached transaction flags PKTRANSACTIONFLAGENUMALLOWREINSTALL g debug allowing just reinstallation pk bitfield add priv cached transaction flags PKTRANSACTIONFLAGENUMJUSTREINSTALL else priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED Failed to obtain authentication pk transaction finished emit data transaction PKEXITENUMFAILED 0 syslog LOGAUTHLOGNOTICE uid i failed to obtain auth priv uid goto out if data actions len 1 priv waiting for auth FALSE pk transaction set state data transaction PKTRANSACTIONSTATEREADY syslog LOGAUTHLOGINFO uid i obtained auth for s priv uid action id else g ptr array remove index data actions 0 pk transaction authorize actions data transaction data role data actions out g ptr array unref data actions g free data void vp9 xform quant dc MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 vp9 fdct32x32 1 src diff coeff diff stride vp9 quantize dc 32x32 coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 16 X16 vp9 fdct16x16 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 8 X8 vp9 fdct8x8 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break default assert 0 break static int mp decode frame MPA Decode Context s OUTINT samples const uint8 t buf int buf size int i nb frames ch ret OUTINT samples ptr init get bits s gb buf HEADERSIZE buf size HEADERSIZE 8 if s error protection skip bits s gb 16 switch s layer case 1 s avctx frame size 384 nb frames mp decode layer1 s break case 2 s avctx frame size 1152 nb frames mp decode layer2 s break case 3 s avctx frame size s lsf 576 1152 default nb frames mp decode layer3 s if nb frames 0 return nb frames s last buf size 0 if s in gb buffer align get bits s gb i get bits left s gb 3 if i 0 i BACKSTEPSIZE memmove s last buf s gb buffer get bits count s gb 3 i s last buf size i else av log s avctx AVLOGERROR invalid old backstep d n i s gb s in gb s in gb buffer NULL align get bits s gb assert get bits count s gb 7 0 i get bits left s gb 3 if i 0 i BACKSTEPSIZE nb frames 0 if i 0 av log s avctx AVLOGERROR invalid new backstep d n i i FFMINBACKSTEPSIZE buf size HEADERSIZE assert i buf size HEADERSIZE i 0 memcpy s last buf s last buf size s gb buffer buf size HEADERSIZE i i s last buf size i if samples av assert0 s frame NULL s frame nb samples s avctx frame size if ret ff get buffer s avctx s frame 0 0 av log s avctx AVLOGERROR get buffer failed n return ret samples OUTINT s frame extended data for ch 0 ch s nb channels ch int sample stride if s avctx sample fmt OUTFMTP samples ptr samples ch sample stride 1 else samples ptr samples 0 ch sample stride s nb channels for i 0 i nb frames i RENAME ff mpa synth filter s mpadsp s synth buf ch s synth buf offset ch RENAME ff mpa synth window s dither state samples ptr sample stride s sb samples ch i samples ptr 32 sample stride return nb frames 32 sizeof OUTINT s nb channels static int atrac1 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size A T1 Ctx q avctx priv data int ch ret Get Bit Context gb if buf size 212 avctx channels av log avctx AVLOGERROR Not enough data to decode n return AVERRORINVALIDDATA frame nb samples A T1 SUSAMPLES if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for ch 0 ch avctx channels ch A T1 SU Ctx su q S Us ch init get bits gb buf 212 ch 212 8 ret at1 parse bsm gb su log2 block count if ret 0 return ret ret at1 unpack dequant gb su q spec if ret 0 return ret ret at1 imdct block su q if ret 0 return ret at1 subband synthesis q su float frame extended data ch got frame ptr 1 return avctx block align static int svq3 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data SV Q3 Context s avctx priv data H264 Context h s h int buf size avpkt size int ret m i if buf size 0 if s next pic f data 0 h low delay s last frame output ret av frame ref data s next pic f if ret 0 return ret s last frame output 1 got frame 1 return 0 init get bits h gb buf 8 buf size h mb x h mb y h mb xy 0 if svq3 decode slice header avctx return 1 h pict type h slice type if h pict type AVPICTURETYPEBFFSWAP Picture s next pic s last pic av frame unref s cur pic f s cur pic f pict type h pict type s cur pic f key frame h pict type AVPICTURETYPEI ret get buffer avctx s cur pic if ret 0 return ret h cur pic ptr s cur pic av frame unref h cur pic f h cur pic s cur pic ret av frame ref h cur pic f s cur pic f if ret 0 return ret for i 0 i 16 i h block offset i 4 scan8 i scan8 0 7 4 h linesize scan8 i scan8 0 3 h block offset 48 i 4 scan8 i scan8 0 7 8 h linesize scan8 i scan8 0 3 for i 0 i 16 i h block offset 16 i h block offset 32 i 4 scan8 i scan8 0 7 4 h uvlinesize scan8 i scan8 0 3 h block offset 48 16 i h block offset 48 32 i 4 scan8 i scan8 0 7 8 h uvlinesize scan8 i scan8 0 3 if h pict type AVPICTURETYPEI if s last pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s last pic if ret 0 return ret memset s last pic f data 0 0 avctx height s last pic f linesize 0 memset s last pic f data 1 0x80 avctx height 2 s last pic f linesize 1 memset s last pic f data 2 0x80 avctx height 2 s last pic f linesize 2 if h pict type AVPICTURETYPEB s next pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s next pic if ret 0 return ret memset s next pic f data 0 0 avctx height s next pic f linesize 0 memset s next pic f data 1 0x80 avctx height 2 s next pic f linesize 1 memset s next pic f data 2 0x80 avctx height 2 s next pic f linesize 2 if avctx debug FFDEBUGPICTINFO av log h avctx AVLOGDEBUG c hpel d tpel d aqp d qp d slice num 02 X n av get picture type char h pict type s halfpel flag s thirdpel flag s adaptive quant h qscale h slice num if avctx skip frame AVDISCARDNONREF h pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY h pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return 0 if s next p frame damaged if h pict type AVPICTURETYPEB return 0 else s next p frame damaged 0 if h pict type AVPICTURETYPEB h frame num offset h slice num h prev frame num if h frame num offset 0 h frame num offset 256 if h frame num offset 0 h frame num offset h prev frame num offset av log h avctx AVLOGERROR error in B frame picture id n return 1 else h prev frame num h frame num h frame num h slice num h prev frame num offset h frame num h prev frame num if h prev frame num offset 0 h prev frame num offset 256 for m 0 m 2 m int i for i 0 i 4 i int j for j 1 j 4 j h ref cache m scan8 0 8 i j 1 if i 3 h ref cache m scan8 0 8 i j PARTNOTAVAILABLE for h mb y 0 h mb y h mb height h mb y for h mb x 0 h mb x h mb width h mb x unsigned mb type h mb xy h mb x h mb y h mb stride if get bits count h gb 7 h gb size in bits get bits count h gb 7 0 show bits h gb get bits count h gb 7 0 skip bits h gb s next slice index get bits count h gb h gb size in bits 8 buf size if svq3 decode slice header avctx return 1 mb type svq3 get ue golomb h gb if h pict type AVPICTURETYPEI mb type 8 else if h pict type AVPICTURETYPEB mb type 4 mb type 4 if mb type 33 svq3 decode mb s mb type av log h avctx AVLOGERROR error while decoding MB d d n h mb x h mb y return 1 if mb type 0 ff h264 hl decode mb h if h pict type AVPICTURETYPEB h low delay h cur pic mb type h mb x h mb y h mb stride h pict type AVPICTURETYPEP mb type 8 mb type 1 1 ff draw horiz band avctx NULL s cur pic s last pic f data 0 s last pic NULL 16 h mb y 16 h picture structure 0 0 h low delay h mb height 16 h mb width 16 if h pict type AVPICTURETYPEB h low delay ret av frame ref data s cur pic f else if s last pic f data 0 ret av frame ref data s last pic f if ret 0 return ret if s last pic f data 0 h low delay got frame 1 if h pict type AVPICTURETYPEBFFSWAP Picture s cur pic s next pic else av frame unref s cur pic f return buf size static int get twopass worst quality const V P9 COMP cpi const FIRSTPASSSTATS stats int section target bandwidth const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf if section target bandwidth 0 return rc worst quality else const int num mbs cpi common M Bs const double section err stats coded error stats count const double err per mb section err num mbs const double speed term 1 0 0 04 oxcf speed const int target norm bits per mb uint64 t section target bandwidth BPERMBNORMBITS num mbs int q int is svc upper layer 0 if is two pass svc cpi cpi svc spatial layer id 0 is svc upper layer 1 for q rc best quality q rc worst quality q const double factor calc correction factor err per mb ERRDIVISOR is svc upper layer SVCFACTORPTLOWFACTORPTLOWFACTORPTHIGH q const int bits per mb vp9 rc bits per mb INTERFRAME q factor speed term if bits per mb target norm bits per mb break if cpi oxcf rc mode VPXCQ q MAX q oxcf cq level return q void ff h264 fill mbaff ref list H264 Context h int list i j for list 0 list 2 list for i 0 i h ref count list i Picture frame h ref list list i Picture field h ref list list 16 2 i field 0 frame for j 0 j 3 j field 0 f linesize j 1 field 0 f reference PICTTOPFIELD field 0 poc field 0 field poc 0 field 1 field 0 for j 0 j 3 j field 1 f data j frame f linesize j field 1 f reference PICTBOTTOMFIELD field 1 poc field 1 field poc 1 h luma weight 16 2 i list 0 h luma weight 16 2 i 1 list 0 h luma weight i list 0 h luma weight 16 2 i list 1 h luma weight 16 2 i 1 list 1 h luma weight i list 1 for j 0 j 2 j h chroma weight 16 2 i list j 0 h chroma weight 16 2 i 1 list j 0 h chroma weight i list j 0 h chroma weight 16 2 i list j 1 h chroma weight 16 2 i 1 list j 1 h chroma weight i list j 1 static int aura decode frame AV Codec Context avctx void data int got frame AV Packet pkt Aura Decode Context s avctx priv data uint8 t YUV uint8 t val int x y ret const uint8 t buf pkt data const int8 t delta table const int8 t buf 16 if pkt size 48 avctx height avctx width av log avctx AVLOGERROR got a buffer with d bytes when d were expected n pkt size 48 avctx height avctx width return AVERRORINVALIDDATA buf 48 if s frame data 0 avctx release buffer avctx s frame s frame buffer hints FFBUFFERHINTSVALID s frame reference 0 if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret Y s frame data 0 U s frame data 1 V s frame data 2 for y 0 y avctx height y val buf U 0 val 0x F0 Y 0 val 4 val buf V 0 val 0x F0 Y 1 Y 0 delta table val 0x FY 2 UV for x 1 x avctx width 1 x val buf U 0 U 1 delta table val 4 Y 0 Y 1 delta table val 0x F val buf V 0 V 1 delta table val 4 Y 1 Y 0 delta table val 0x FY 2 UVY s frame linesize 0 avctx width U s frame linesize 1 avctx width 1 V s frame linesize 2 avctx width 1 got frame 1 AV Frame data s frame return pkt size static void slurm rpc job will run slurm msg t msg DEFTIMERS int error code SLURMSUCCESS struct job record job ptr NULL job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint16 t port slurm addr t resp addr will run response msg t resp NULL char err msg NULL job submit user msg NULL if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED goto send reply STARTTIMER debug2 Processing RPCREQUESTJOBWILLRUN from uid d uid if is valid will run user job desc msg uid error code ESLURMUSERIDMISSING error Security violation JOBWILLRUNRPC from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTJOBWILLRUN lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if slurm get peer addr msg conn fd resp addr job desc msg resp host xmalloc 16 slurm get ip str resp addr port job desc msg resp host 16 dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job write lock if job desc msg job id NOVAL job desc msg pack job offset NOVAL error code job allocate job desc msg false true resp true uid job ptr err msg msg protocol version else error code job start data job desc msg resp unlock slurmctld job write lock ENDTIME R2 slurm rpc job will run else if errno error code errno else error code SLURMERROR send reply if error code debug2 slurm rpc job will run s slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else if resp slurm msg t response msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg address msg address response msg conn msg conn response msg msg type RESPONSEJOBWILLRUN response msg data resp resp job submit user msg job submit user msg job submit user msg NULL slurm send node msg msg conn fd response msg slurm free will run response msg resp debug2 slurm rpc job will run success s TIMESTR else debug2 slurm rpc job will run success s TIMESTR if job desc msg job id NOVAL slurm send rc msg msg SLURMSUCCESS xfree err msg xfree job submit user msg static int flic decode frame 15 16 BPPAV Codec Context avctx void data int got frame const uint8 t buf int buf size Flic Decode Context s avctx priv data Get Byte Context g2 int pixel ptr unsigned char palette idx1 unsigned int frame size int num chunks unsigned int chunk size int chunk type int i j ret int lines int compressed lines signed short line packets int y ptr int byte run int pixel skip int pixel countdown unsigned char pixels int pixel unsigned int pixel limit bytestream2 init g2 buf buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret pixels s frame data 0 pixel limit s avctx height s frame linesize 0 frame size bytestream2 get le32 g2 bytestream2 skip g2 2 num chunks bytestream2 get le16 g2 bytestream2 skip g2 8 frame size 16 while frame size 0 num chunks 0 chunk size bytestream2 get le32 g2 chunk type bytestream2 get le16 g2 switch chunk type case FLI 256 COLOR case FLICOLOR av dlog avctx Unexpected Palette chunk d in non palettized FLC n chunk type bytestream2 skip g2 chunk size 6 break case FLIDELTA case FLIDTALC y ptr 0 compressed lines bytestream2 get le16 g2 while compressed lines 0 line packets bytestream2 get le16 g2 if line packets 0 line packets line packets y ptr line packets s frame linesize 0 else compressed lines pixel ptr y ptr CHECKPIXELPTR 0 pixel countdown s avctx width for i 0 i line packets i pixel skip bytestream2 get byte g2 pixel ptr pixel skip 2 pixel countdown pixel skip byte run sign extend bytestream2 get byte g2 8 if byte run 0 byte run byte run pixel bytestream2 get le16 g2 CHECKPIXELPTR 2 byte run for j 0 j byte run j pixel countdown 2 signed short pixels pixel ptr pixel pixel ptr 2 else CHECKPIXELPTR 2 byte run for j 0 j byte run j pixel countdown signed short pixels pixel ptr bytestream2 get le16 g2 pixel ptr 2 y ptr s frame linesize 0 break case FLILC av log avctx AVLOGERROR Unexpected FLILC chunk in non paletised FLC n bytestream2 skip g2 chunk size 6 break case FLIBLACK memset pixels 0x0000 s frame linesize 0 s avctx height break case FLIBRUN y ptr 0 for lines 0 lines s avctx height lines pixel ptr y ptr bytestream2 skip g2 1 pixel countdown s avctx width 2 while pixel countdown 0 byte run sign extend bytestream2 get byte g2 8 if byte run 0 palette idx1 bytestream2 get byte g2 CHECKPIXELPTR byte run for j 0 j byte run j pixels pixel ptr palette idx1 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d linea d n pixel countdown lines else byte run byte run CHECKPIXELPTR byte run for j 0 j byte run j palette idx1 bytestream2 get byte g2 pixels pixel ptr palette idx1 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d at line d n pixel countdown lines pixel countdown s avctx width while pixel countdown 0 signed short pixels pixel ptr AVR L16 buf pixel ptr pixel ptr 2 break case FLIDTABRUN y ptr 0 for lines 0 lines s avctx height lines pixel ptr y ptr bytestream2 skip g2 1 pixel countdown s avctx width while pixel countdown 0 byte run sign extend bytestream2 get byte g2 8 if byte run 0 pixel bytestream2 get le16 g2 CHECKPIXELPTR 2 byte run for j 0 j byte run j signed short pixels pixel ptr pixel pixel ptr 2 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d n pixel countdown else byte run byte run CHECKPIXELPTR 2 byte run for j 0 j byte run j signed short pixels pixel ptr bytestream2 get le16 g2 pixel ptr 2 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d n pixel countdown y ptr s frame linesize 0 break case FLICOPY case FLIDTACOPY if chunk size 6 unsigned int s avctx width s avctx height 2 av log avctx AVLOGERROR In chunk FLICOPY source data d bytes bigger than image skipping chunk n chunk size 6 bytestream2 skip g2 chunk size 6 else for y ptr 0 y ptr s frame linesize 0 s avctx height y ptr s frame linesize 0 pixel countdown s avctx width pixel ptr 0 while pixel countdown 0 signed short pixels y ptr pixel ptr bytestream2 get le16 g2 pixel ptr 2 pixel countdown break case FLIMINI bytestream2 skip g2 chunk size 6 break default av log avctx AVLOGERROR Unrecognized chunk type d n chunk type break frame size chunk size num chunks if bytestream2 get bytes left g2 0 bytestream2 get bytes left g2 1 av log avctx AVLOGERROR Processed FLI chunk where chunk size d and final chunk ptr d n buf size bytestream2 tell g2 if ret av frame ref data s frame 0 return ret got frame 1 return buf size static void parse mb skip Wmv2 Context w int mb x mb y Mpeg Enc Context const s w s uint32 t const mb type s current picture ptr mb type w skip type get bits s gb 2 switch w skip type case SKIPTYPENONE for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEMPEG for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEROW for mb y 0 mb y s mb height mb y if get bits1 s gb for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPECOL for mb x 0 mb x s mb width mb x if get bits1 s gb for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break gcry error t gcry pk verify gcry sexp t s sig gcry sexp t s hash gcry sexp t s pkey gcry module t module key NULL module sig NULL gcry mpi t pkey NULL hash NULL sig NULL struct pk encoding ctx ctx gcry err code t rc REGISTERDEFAULTPUBKEYS rc sexp to key s pkey 0 GCRYPKUSAGESIGNNULL pkey module key NULL if rc goto leave rc sexp to sig s sig sig module sig if rc goto leave if module key mod id module sig mod id rc GPGERRCONFLICT goto leave init encoding ctx ctx PUBKEYOPVERIFY gcry pk get nbits s pkey rc sexp data to mpi s hash hash ctx if rc goto leave rc pubkey verify module key mod id hash sig pkey ctx leave if pkey release mpi array pkey gcry free pkey if sig release mpi array sig gcry free sig if hash mpi free hash if module key module sig ath mutex lock pubkeys registered lock if module key gcry module release module key if module sig gcry module release module sig ath mutex unlock pubkeys registered lock return gcry error rc static void choose partitioning V P9 COMP cpi const Tile Info const tile int mi row int mi col V P9 COMMON const cm cpi common MACROBLOCK x cpi mb MACROBLOCKD xd cpi mb e mbd int i j k v64x64 vt uint8 t s const uint8 t d int sp int dp int pixels wide 64 pixels high 64 int mv nearest mv near mv const Y V12 BUFFERCONFIG yv12 get ref frame buffer cpi LASTFRAME const struct scale factors const sf cm frame refs LASTFRAME 1 sf vp9 zero vt set offsets cpi tile mi row mi col BLOCK 64 X64 if xd mb to right edge 0 pixels wide xd mb to right edge 3 if xd mb to bottom edge 0 pixels high xd mb to bottom edge 3 s x plane 0 src buf sp x plane 0 src stride if cm frame type KEYFRAME vp9 setup pre planes xd 0 yv12 mi row mi col sf xd mi 0 mbmi ref frame 0 LASTFRAME xd mi 0 mbmi sb type BLOCK 64 X64 vp9 find best ref mvs xd cm allow high precision mv xd mi 0 mbmi ref mvs LASTFRAME nearest mv near mv xd mi 0 mbmi mv 0 nearest mv vp9 build inter predictors sby xd mi row mi col BLOCK 64 X64 d xd plane 0 dst buf dp xd plane 0 dst stride else d V P9 VAROFFS dp 0 for i 0 i 4 i const int x32 idx i 1 5 const int y32 idx i 1 5 for j 0 j 4 j const int x16 idx x32 idx j 1 4 const int y16 idx y32 idx j 1 4 v16x16 vst vt split i split j for k 0 k 4 k int x idx x16 idx k 1 3 int y idx y16 idx k 1 3 unsigned int sse 0 int sum 0 if x idx pixels wide y idx pixels high vp9 get8x8var s y idx sp x idx sp d y idx dp x idx dp sse sum fill variance sse sum 64 vst split k part variances none for i 0 i 4 i for j 0 j 4 j fill variance tree vt split i split j BLOCK 16 X16 fill variance tree vt split i BLOCK 32 X32 fill variance tree vt BLOCK 64 X64 if set vt partitioning cpi vt BLOCK 64 X64 mi row mi col for i 0 i 4 i const int x32 idx i 1 2 const int y32 idx i 1 2 if set vt partitioning cpi vt split i BLOCK 32 X32 mi row y32 idx mi col x32 idx for j 0 j 4 j const int x16 idx j 1 1 const int y16 idx j 1 1 set block size cpi mi row y32 idx y16 idx mi col x32 idx x16 idx BLOCK 16 X16 else for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 for k 0 k 4 k const int x8 idx k 1 const int y8 idx k 1 set block size cpi mi row y32 idx y16 idx y8 idx mi col x32 idx x16 idx x8 idx BLOCK 8 X8 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Video XL Context const a avctx priv data AV Frame const p a pic uint8 t YUV int i j ret int stride uint32 t val int y0 y1 y2 y3 0 c0 0 c1 0 if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 Y a pic data 0 U a pic data 1 V a pic data 2 stride avctx width 4 if buf size avctx width avctx height av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA for i 0 i avctx height i buf stride for j 0 j avctx width j 4 val AVR L32 buf buf 4 val val 16 0x FFFF val 0x FFFF 16 if j y0 val 0x1 F 2 else y0 y3 xl table val 0x1 F val 5 y1 y0 xl table val 0x1 F val 5 y2 y1 xl table val 0x1 F val 6 y3 y2 xl table val 0x1 F val 5 if j c0 val 0x1 F 2 else c0 xl table val 0x1 F val 5 if j c1 val 0x1 F 2 else c1 xl table val 0x1 FY j 0 y0 1 Y j 1 y1 1 Y j 2 y2 1 Y j 3 y3 1 U j 2 c0 1 V j 2 c1 1 buf avctx width 4 Y a pic linesize 0 U a pic linesize 1 V a pic linesize 2 got frame 1 AV Frame data a pic return buf size int ff h263 decode mb Mpeg Enc Context s int16 t block 6 64 int cbpc cbpy i cbp pred x pred y mx my dquant int16 t mot val const int xy s mb x s mb y s mb stride int cbpb 0 pb mv count 0 assert s h263 pred if s pict type AVPICTURETYPEP do if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped s obmc s loop filter goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc damaged at d d n s mb x s mb y return 1 while cbpc 20 s dsp clear blocks s block 0 dquant cbpc 8 s mb intra cbpc 4 0 if s mb intra goto intra if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s s mv dir MVDIRFORWARD if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 0 0 mx s mv 0 0 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 s mv type MVTYPE 8 X8 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my else if s pict type AVPICTURETYPEB int mb type const int stride s b8 stride int16 t mot val0 s current picture motion val 0 2 s mb x s mb y stride int16 t mot val1 s current picture motion val 1 2 s mb x s mb y stride mot val0 0 mot val0 2 mot val0 0 2 stride mot val0 2 2 stride mot val0 1 mot val0 3 mot val0 1 2 stride mot val0 3 2 stride mot val1 0 mot val1 2 mot val1 0 2 stride mot val1 2 2 stride mot val1 1 mot val1 3 mot val1 1 2 stride mot val1 3 2 stride 0 do mb type get vlc2 s gb h263 mbtype b vlc table H263 MBTYPEBVLCBITS 2 if mb type 0 av log s avctx AVLOGERROR b mb type damaged at d d n s mb x s mb y return 1 mb type h263 mb type b map mb type while mb type s mb intra ISINTRA mb type if HASCBP mb type s dsp clear blocks s block 0 cbpc get vlc2 s gb cbpc b vlc table CBPCBVLCBITS 1 if s mb intra dquant ISQUANT mb type goto intra cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERROR b cbpy damaged at d d n s mb x s mb y return 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 else cbp 0 assert s mb intra if ISQUANT mb type h263 decode dquant s if ISDIRECT mb type s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT mb type ff mpeg4 set direct mv s 0 0 else s mv dir 0 s mv type MVTYPE 16 X16 if USESLIST mb type 0 int16 t mot val ff h263 pred motion s 0 0 mx my s mv dir MVDIRFORWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 0 0 0 mx s mv 0 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my if USESLIST mb type 1 int16 t mot val ff h263 pred motion s 0 1 mx my s mv dir MVDIRBACKWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 1 0 0 mx s mv 1 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my s current picture mb type xy mb type else do cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERRORI cbpc damaged at d d n s mb x s mb y return 1 while cbpc 8 s dsp clear blocks s block 0 dquant cbpc 4 s mb intra 1 intra s current picture mb type xy MBTYPEINTRA if s h263 aic s ac pred get bits1 s gb if s ac pred s current picture mb type xy MBTYPEINTRAMBTYPEACPRED s h263 aic dir get bits1 s gb else s ac pred 0 if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy damaged at d d n s mb x s mb y return 1 cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s pb mv count s pb frame while pb mv count ff h263 decode motion s 0 1 ff h263 decode motion s 0 1 for i 0 i 6 i if h263 decode block s block i i cbp 32 0 return 1 cbp cbp if s pb frame h263 skip b part s cbpb 0 return 1 if s obmc s mb intra if s pict type AVPICTURETYPEP s mb x 1 s mb width s mb num left 1 preview obmc s end int v show bits s gb 16 if get bits left s gb 16 v 16 get bits left s gb if v 0 return SLICEEND return static int decode pic AVS Context h int skip count 1 enum cavs mb mb type skip bits h gb 16 if h stc PICPBSTARTCODE h cur f pict type get bits h gb 2 AVPICTURETYPEI if h cur f pict type AVPICTURETYPEB av log h avctx AVLOGERROR illegal picture type n return 1 if h DPB 0 f data 0 h DPB 1 f data 0 h cur f pict type AVPICTURETYPEB return 1 else h cur f pict type AVPICTURETYPEI if get bits1 h gb skip bits h gb 24 if h low delay show bits h gb 9 1 h stream revision 1 else if show bits h gb 11 3 h stream revision 1 if h stream revision 0 skip bits h gb 1 if h cur f data 0 h avctx release buffer h avctx h cur f ff get buffer h avctx h cur f if h edge emu buffer int alloc size FFALIGNFFABS h cur f linesize 0 32 32 h edge emu buffer av mallocz alloc size 2 24 if h edge emu buffer return AVERRORENOMEM ff cavs init pic h h cur poc get bits h gb 8 2 if h cur f pict type AVPICTURETYPEB h dist 0 h cur poc h DPB 0 poc 512 512 else h dist 0 h DPB 0 poc h cur poc 512 512 h dist 1 h cur poc h DPB 1 poc 512 512 h scale den 0 h dist 0 512 h dist 0 0 h scale den 1 h dist 1 512 h dist 1 0 if h cur f pict type AVPICTURETYPEB h sym factor h dist 0 h scale den 1 else h direct den 0 h dist 0 16384 h dist 0 0 h direct den 1 h dist 1 16384 h dist 1 0 if h low delay get ue golomb h gb h progressive get bits1 h gb h pic structure 1 if h progressive h pic structure get bits1 h gb if h pic structure h stc PICPBSTARTCODE skip bits1 h gb skip bits1 h gb skip bits1 h gb h qp fixed get bits1 h gb h qp get bits h gb 6 if h cur f pict type AVPICTURETYPEI if h progressive h pic structure skip bits1 h gb skip bits h gb 4 else if h cur f pict type AVPICTURETYPEB h pic structure 1 h ref flag get bits1 h gb skip bits h gb 4 h skip mode flag get bits1 h gb h loop filter disable get bits1 h gb if h loop filter disable get bits1 h gb h alpha offset get se golomb h gb h beta offset get se golomb h gb else h alpha offset h beta offset 0 if h cur f pict type AVPICTURETYPEI do check for slice h decode mb i h 0 while ff cavs next mb h else if h cur f pict type AVPICTURETYPEP do if check for slice h skip count 1 if h skip mode flag skip count 0 skip count get ue golomb h gb if h skip mode flag skip count decode mb p h PSKIP else mb type get ue golomb h gb PSKIP h skip mode flag if mb type P 8 X8 decode mb i h mb type P 8 X8 1 else decode mb p h mb type while ff cavs next mb h else do if check for slice h skip count 1 if h skip mode flag skip count 0 skip count get ue golomb h gb if h skip mode flag skip count decode mb b h BSKIP else mb type get ue golomb h gb BSKIP h skip mode flag if mb type B 8 X8 decode mb i h mb type B 8 X8 1 else decode mb b h mb type while ff cavs next mb h if h cur f pict type AVPICTURETYPEB if h DPB 1 f data 0 h avctx release buffer h avctx h DPB 1 f FFSWAPAVS Frame h cur h DPB 1 FFSWAPAVS Frame h DPB 0 h DPB 1 return 0 void ff estimate b frame motion Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me const int penalty factor c mb penalty factor int fmin bmin dmin fbmin bimin fimin int type 0 const int xy mb y s mb stride mb x init ref c s new picture f data s last picture f data s next picture f data 16 mb x 16 mb y 2 get limits s 16 mb x 16 mb y c skip 0 if s codec id AVCODECIDMPE G4 s next picture f mbskip table xy int score direct search s mb x mb y score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score s mb type mb y s mb stride mb x CANDIDATEMBTYPEDIREC T0 return if s codec id AVCODECIDMPE G4 dmin direct search s mb x mb y else dmin INTMAX c skip 0 fmin ff estimate motion b s mb x mb y s b forw mv table 0 s f code 3 penalty factor c skip 0 bmin ff estimate motion b s mb x mb y s b back mv table 2 s b code 2 penalty factor av dlog s d d s b forw mv table xy 0 s b forw mv table xy 1 c skip 0 fbmin bidir refine s mb x mb y penalty factor av dlog s d d d d n dmin fmin bmin fbmin if s flags CODECFLAGINTERLACEDME c skip 0 c current mv penalty c mv penalty s f code MAXMV fimin interlaced search s 0 s b field mv table 0 s b field select table 0 s b forw mv table xy 0 s b forw mv table xy 1 0 c current mv penalty c mv penalty s b code MAXMV bimin interlaced search s 2 s b field mv table 1 s b field select table 1 s b back mv table xy 0 s b back mv table xy 1 0 else fimin bimin INTMAX int score fmin type CANDIDATEMBTYPEFORWARD if dmin score score dmin type CANDIDATEMBTYPEDIRECT if bmin score score bmin type CANDIDATEMBTYPEBACKWARD if fbmin score score fbmin type CANDIDATEMBTYPEBIDIR if fimin score score fimin type CANDIDATEMBTYPEFORWARDI if bimin score score bimin type CANDIDATEMBTYPEBACKWARDI score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score if c avctx mb decision FFMBDECISIONSIMPLE type CANDIDATEMBTYPEFORWARDCANDIDATEMBTYPEBACKWARDCANDIDATEMBTYPEBIDIRCANDIDATEMBTYPEDIRECT if fimin INTMAX type CANDIDATEMBTYPEFORWARDI if bimin INTMAX type CANDIDATEMBTYPEBACKWARDI if fimin INTMAX bimin INTMAX type CANDIDATEMBTYPEBIDIRI if dmin 256 256 16 type CANDIDATEMBTYPEDIRECT if s codec id AVCODECIDMPE G4 type CANDIDATEMBTYPEDIRECT s flags CODECFLAGM V0 uint32 t s b direct mv table xy type CANDIDATEMBTYPEDIREC T0 s mb type mb y s mb stride mb x type void xcalloc size t num size t size void ptr malloc num size if ptr memset ptr 0 num size return ptr static int asf write packet AV Format Context s AV Packet pkt ASF Context asf s priv data AVIO Context pb s pb ASF Stream stream AV Codec Context codec uint32 t packet number int64 t pts int start sec int flags pkt flags int ret uint64 t offset avio tell pb codec s streams pkt stream index codec stream asf streams pkt stream index if codec codec type AVMEDIATYPEAUDIO flags AVPKTFLAGKEY pts pkt pts AVNOPTSVALUE pkt pts pkt dts av assert0 pts AVNOPTSVALUE if pts PREROLLTIME pts INTMAX 3 10000 LLASFINDEXEDINTERVALPREROLLTIME av log s AVLOGERROR input pts PR Id64 is invalid n pts return AVERROREINVAL pts 10000 asf duration FFMAX asf duration pts pkt duration 10000 packet number asf nb packets put frame s stream s streams pkt stream index pkt dts pkt data pkt size flags start sec int PREROLLTIME 10000 pts ASFINDEXEDINTERVAL 1 ASFINDEXEDINTERVAL if asf is streamed flags AVPKTFLAGKEY uint16 t packet count asf nb packets packet number ret update index s start sec packet number packet count offset if ret 0 return ret asf end sec start sec return 0 static int ws snd decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int in size out size ret int sample 128 uint8 t samples uint8 t samples end if buf size return 0 if buf size 4 av log avctx AVLOGERROR packet is too small n return AVERROREINVAL out size AVR L16 buf 0 in size AVR L16 buf 2 buf 4 if in size buf size av log avctx AVLOGERROR Frame data is larger than input buffer n return 1 frame nb samples out size if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples frame data 0 samples end samples out size if in size out size memcpy samples buf out size got frame ptr 1 return buf size while samples samples end buf avpkt data buf size int code smp size uint8 t count code buf 6 count buf 0x3 F buf switch code case 0 smp 4 count 1 break case 1 smp 2 count 1 break case 2 smp count 0x20 1 count 1 break default smp count 1 break if samples end samples smp break size code 2 count 0x20 code 3 0 count 1 if buf avpkt data size buf size break switch code case 0 for count count 0 count code buf sample code 0x3 2 sample av clip uint8 sample samples sample sample code 2 0x3 2 sample av clip uint8 sample samples sample sample code 4 0x3 2 sample av clip uint8 sample samples sample sample code 6 2 sample av clip uint8 sample samples sample break case 1 for count count 0 count code buf sample ws adpcm 4bit code 0x F sample av clip uint8 sample samples sample sample ws adpcm 4bit code 4 sample av clip uint8 sample samples sample break case 2 if count 0x20 int8 t t t count t 3 sample t 3 sample av clip uint8 sample samples sample else memcpy samples buf smp samples smp buf smp sample buf 1 break default memset samples sample smp samples smp frame nb samples samples frame data 0 got frame ptr 1 return buf size static Asn1 Generic Decode Asn1 Der Octet String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 OCTETSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL memcpy a str const char d ptr length a str length 0 d ptr length a length d ptr buffer return a static void parse content disposition const char content disposition const char filename r struct rfc822 parser context parser const char const results filename2 string t str filename r NULL if content disposition NULL return rfc822 parser init parser const unsigned char content disposition strlen content disposition NULL rfc822 skip lwsp parser str t str new 32 if rfc822 parse mime token parser str 0 rfc822 parser deinit parser return rfc2231 parse parser results filename2 NULL for results NULL results 2 if strcasecmp results 0 filename 0 filename r results 1 break if strcasecmp results 0 filename 0 filename2 results 1 if filename r NULL filename r filename2 rfc822 parser deinit parser static int estimate best b count Mpeg Enc Context s AV Codec codec avcodec find encoder s avctx codec id AV Codec Context c avcodec alloc context3 NULLAV Frame input FFMAXBFRAMES 2 const int scale s avctx brd scale int i j out size p lambda b lambda lambda2 int64 t best rd IN T64 MAX int best b count 1 assert scale 0 scale 3 p lambda s last lambda for AVPICTURETYPEP b lambda s last lambda for AVPICTURETYPEB if b lambda b lambda p lambda lambda2 b lambda b lambda 1 FFLAMBDASHIFT 2 FFLAMBDASHIFT c width s width scale c height s height scale c flags CODECFLAGQSCALECODECFLAGPSNRCODECFLAGINPUTPRESERVED c flags s avctx flags CODECFLAGQPEL c mb decision s avctx mb decision c me cmp s avctx me cmp c mb cmp s avctx mb cmp c me sub cmp s avctx me sub cmp c pix fmt AVPIXFMTYU V420 P c time base s avctx time base c max b frames s max b frames if avcodec open2 c codec NULL 0 return 1 for i 0 i s max b frames 2 i int ysize c width c height int csize c width 2 c height 2 Picture pre input pre input ptr i s input picture i 1 s next picture ptr avcodec get frame defaults input i input i data 0 av malloc ysize 2 csize input i data 1 input i data 0 ysize input i data 2 input i data 1 csize input i linesize 0 c width input i linesize 1 input i linesize 2 c width 2 if pre input ptr i s input picture i 1 pre input pre input ptr if pre input f type FFBUFFERTYPESHARED i pre input f data 0 INPLACEOFFSET pre input f data 1 INPLACEOFFSET pre input f data 2 INPLACEOFFSET s dsp shrink scale input i data 0 input i linesize 0 pre input f data 0 pre input f linesize 0 c width c height s dsp shrink scale input i data 1 input i linesize 1 pre input f data 1 pre input f linesize 1 c width 1 c height 1 s dsp shrink scale input i data 2 input i linesize 2 pre input f data 2 pre input f linesize 2 c width 1 c height 1 for j 0 j s max b frames 1 j int64 t rd 0 if s input picture j break c error 0 c error 1 c error 2 0 input 0 pict type AVPICTURETYPEI input 0 quality 1 FFQ P2 LAMBDA out size encode frame c input 0 for i 0 i s max b frames 1 i int is p i j 1 j i s max b frames input i 1 pict type is p AVPICTURETYPEPAVPICTURETYPEB input i 1 quality is p p lambda b lambda out size encode frame c input i 1 rd out size lambda2 FFLAMBDASHIFT 3 while out size out size encode frame c NULL rd out size lambda2 FFLAMBDASHIFT 3 rd c error 0 c error 1 c error 2 if rd best rd best rd rd best b count j avcodec close c av freep c for i 0 i s max b frames 2 i av freep input i data 0 return best b count static void set partition range V P9 COMMON cm MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize BLOCKSIZE min bs BLOCKSIZE max bs int mi width num 8x8 blocks wide lookup bsize int mi height num 8x8 blocks high lookup bsize int idx idy MODEINFO mi MODEINFO prev mi cm prev mi grid visible mi row cm mi stride mi col BLOCKSIZE bs min size max size min size BLOCK 64 X64 max size BLOCK 4 X4 if prev mi for idy 0 idy mi height idy for idx 0 idx mi width idx mi prev mi idy cm mi stride idx bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd left available for idy 0 idy mi height idy mi xd mi idy cm mi stride 1 bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd up available for idx 0 idx mi width idx mi xd mi idx cm mi stride bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if min size max size min size min partition size min size max size max partition size max size min bs min size max bs max size int64 t vp9 rd pick inter mode sb seg skip V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 mbmi unsigned char segment id mbmi segment id const int comp pred 0 int i int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best filter diff SWITCHABLEFILTERCONTEXTS unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER best filter SWITCHABLE int64 t this rd IN T64 MAX int rate2 0 const int64 t distortion2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i LASTFRAME i MAXREFFRAMES i x pred mv sad i INTMAX returnrate INTMAX assert vp9 segfeature active cm seg segment id SEGLVLSKIP mbmi mode ZEROMV mbmi uv mode DCPRED mbmi ref frame 0 LASTFRAME mbmi ref frame 1 NONE mbmi mv 0 as int 0 x skip 1 rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR best filter EIGHTTAP if cm interp filter SWITCHABLE x source variance cpi sf disable filter search var thresh int rs int best rs INTMAX for i 0 i SWITCHABLEFILTERS i mbmi interp filter i rs vp9 get switchable rate cpi if rs best rs best rs rs best filter mbmi interp filter if cm interp filter SWITCHABLE mbmi interp filter best filter rate2 vp9 get switchable rate cpi else mbmi interp filter cm interp filter if cm reference mode REFERENCEMODESELECT rate2 vp9 cost bit comp mode p comp pred rate2 ref costs single LASTFRAME this rd RDCOST x rdmult x rddiv rate2 distortion2 returnrate rate2 returndistortion distortion2 if this rd best rd so far return IN T64 MAX assert cm interp filter SWITCHABLE cm interp filter mbmi interp filter update rd thresh fact cpi bsize THRZEROMV vp9 zero best pred diff vp9 zero best filter diff vp9 zero best tx diff if x select tx size swap block ptr x ctx 1 0 0 MAXMBPLANE store coding context x ctx THRZEROMV best pred diff best tx diff best filter diff 0 return this rd static char create argv command struct rule rule struct process process struct iovec argv size t count i j stdin arg char req argv NULL const char program for count 0 argv count NULL count if rule sudo user NULL req argv xcalloc count 1 sizeof char else req argv xcalloc count 5 sizeof char if rule sudo user NULL req argv 0 xstrdup PATHSUDO req argv 1 xstrdup u req argv 2 xstrdup rule sudo user req argv 3 xstrdup req argv 4 xstrdup rule program j 5 else program strrchr rule program if program NULL program rule program else program req argv 0 xstrdup program j 1 if rule stdin arg 1 stdin arg count 1 else stdin arg size t rule stdin arg for i 1 i count i const char data argv i iov base size t length argv i iov len if i stdin arg process input evbuffer new if process input NULL die internal error cannot create input buffer if evbuffer add process input data length 0 die internal error cannot add data to input buffer continue if length 0 req argv j xstrdup else req argv j xstrndup data length j req argv j NULL return req argv double histogram selectivity Variable Stat Data vardata Fmgr Info opproc Datum constval bool varonleft int min hist size int n skip int hist size double result Datum values int nvalues Assert n skip 0 Assert min hist size 2 n skip if Heap Tuple Is Valid vardata stats Tuple get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid NULL values nvalues NULLNULL hist size nvalues if nvalues min hist size int nmatch 0 int i for i n skip i nvalues n skip i if varonleft Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values i constval Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID constval values i nmatch result double nmatch double nvalues 2 n skip else result 1 free attstatsslot vardata atttype values nvalues NULL 0 else hist size 0 result 1 return result static int libopenjpeg decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t buf avpkt data int buf size avpkt size Lib Open JPEG Context ctx avctx priv data AV Frame picture ctx image output data const AV Pix Fmt Descriptor desc opj dinfo t dec opj cio t stream opj image t image int width height ret 1 int pixel size 0 int ispacked 0 int i got frame 0 if AVR B32 buf 12 AVR B32 buf 4 J P2 SIGTYPEAVR B32 buf 8 J P2 SIGVALUE dec opj create decompress CODECJ P2 else if AVR B32 buf 4 AVR B32 jp2c buf 8 dec opj create decompress CODEC J2 K if dec av log avctx AVLOGERROR Error initializing decoder n return 1 opj set event mgr opj common ptr dec NULLNULL ctx dec params cp limit decoding LIMITTOMAINHEADER ctx dec params cp reduce ctx lowres ctx dec params cp layer ctx lowqual opj setup decoder dec ctx dec params stream opj cio open opj common ptr dec buf buf size if stream av log avctx AVLOGERROR Codestream could not be opened for reading n opj destroy decompress dec return 1 image opj decode with info dec stream NULL opj cio close stream if image av log avctx AVLOGERROR Error decoding codestream n opj destroy decompress dec return 1 width image x1 image x0 height image y1 image y0 if ctx lowres width width 1 ctx lowres 1 ctx lowres height height 1 ctx lowres 1 ctx lowres if av image check size width height 0 avctx 0 av log avctx AVLOGERROR dx d dimension invalid n width height goto done avcodec set dimensions avctx width height if avctx pix fmt AVPIXFMTNONE if libopenjpeg matches pix fmt image avctx pix fmt avctx pix fmt AVPIXFMTNONE if avctx pix fmt AVPIXFMTNONE avctx pix fmt libopenjpeg guess pix fmt image if avctx pix fmt AVPIXFMTNONE av log avctx AVLOGERROR Unable to determine pixel format n ret AVERRORINVALIDDATA goto done for i 0 i image numcomps i if image comps i prec avctx bits per raw sample avctx bits per raw sample image comps i prec if picture data 0 ff thread release buffer avctx picture if ff thread get buffer avctx picture 0 av log avctx AVLOGERROR ff thread get buffer failed n goto done ctx dec params cp limit decoding NOLIMITATION opj setup decoder dec ctx dec params stream opj cio open opj common ptr dec buf buf size if stream av log avctx AVLOGERROR Codestream could not be opened for reading n goto done opj image destroy image image opj decode with info dec stream NULL opj cio close stream if image av log avctx AVLOGERROR Error decoding codestream n goto done desc av pix fmt desc get avctx pix fmt pixel size desc comp 0 step minus1 1 ispacked libopenjpeg ispacked avctx pix fmt switch pixel size case 1 if ispacked libopenjpeg copy to packed8 picture image else libopenjpeg copyto8 picture image break case 2 if ispacked libopenjpeg copy to packed8 picture image else libopenjpeg copyto16 picture image break case 3 case 4 if ispacked libopenjpeg copy to packed8 picture image break case 6 case 8 if ispacked libopenjpeg copy to packed16 picture image break default av log avctx AVLOGERROR unsupported pixel size d n pixel size goto done output ctx image got frame 1 ret buf size done opj image destroy image opj destroy decompress dec return ret static int pcm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t src avpkt data int buf size avpkt size PCM Decode s avctx priv data AV Frame frame data int sample size c n ret samples per block uint8 t samples int32 t dst int32 t sample size av get bits per sample avctx codec id 8 samples per block 1 if AVCODECIDPCMDVD avctx codec id if avctx bits per coded sample 20 avctx bits per coded sample 24 av log avctx AVLOGERRORPCMDVD unsupported sample depth n return AVERROREINVAL samples per block 2 sample size avctx bits per coded sample 2 8 else if avctx codec id AVCODECIDPCMLXF samples per block 2 sample size 5 if sample size 0 av log avctx AVLOGERROR Invalid sample size n return AVERROREINVAL n avctx channels sample size if n buf size n if buf size n av log avctx AVLOGERROR invalid PCM packet n return 1 else buf size buf size n n buf size sample size frame nb samples n samples per block avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples frame data 0 switch avctx codec id case AVCODECIDPCM U32 LEDECODE 32 le32 src samples n 0 0x80000000 break case AVCODECIDPCM U32 BEDECODE 32 be32 src samples n 0 0x80000000 break case AVCODECIDPCM S24 LEDECODE 32 le24 src samples n 8 0 break case AVCODECIDPCM S24 BEDECODE 32 be24 src samples n 8 0 break case AVCODECIDPCM U24 LEDECODE 32 le24 src samples n 8 0x800000 break case AVCODECIDPCM U24 BEDECODE 32 be24 src samples n 8 0x800000 break case AVCODECIDPCM S24 DAUD for n 0 n uint32 t v bytestream get be24 src v 4 AVW N16 A samples ff reverse v 8 0xff ff reverse v 0xff 8 samples 2 break case AVCODECIDPCM S16 LEPLANAR int av unused n2 n avctx channels for c 0 c avctx channels c samples frame extended data c DECODE 16 le16 src samples n2 0 0 else memcpy samples src n 2 src n 2 break case AVCODECIDPCM U16 LEDECODE 16 le16 src samples n 0 0x8000 break case AVCODECIDPCM U16 BEDECODE 16 be16 src samples n 0 0x8000 break case AVCODECIDPCM S8 for n 0 n samples src 128 break case AVCODECIDPCM S32 LE case AVCODECIDPCM F32 LEDECODE 32 le32 src samples n 0 0 break case AVCODECIDPCM S16 LEDECODE 16 le16 src samples n 0 0 break case AVCODECIDPCM F64 BE case AVCODECIDPCM F32 BE case AVCODECIDPCM S32 BE case AVCODECIDPCM S16 BE else case AVCODECIDPCM F64 BEDECODE 64 be64 src samples n 0 0 break case AVCODECIDPCM F32 BE case AVCODECIDPCM S32 BEDECODE 32 be32 src samples n 0 0 break case AVCODECIDPCM S16 BEDECODE 16 be16 src samples n 0 0 break case AVCODECIDPCM F64 LE case AVCODECIDPCM F32 LE case AVCODECIDPCM S32 LE case AVCODECIDPCM S16 LE endif case AVCODECIDPCM U8 memcpy samples src n sample size break case AVCODECIDPCMZORK for n 0 n int v src if v 128 v 128 v samples v break case AVCODECIDPCMALAW case AVCODECIDPCMMULAW for n 0 n AVW N16 A samples s table src samples 2 break case AVCODECIDPCMDVD const uint8 t src8 dst int32 t int32 t frame data 0 n avctx channels switch avctx bits per coded sample case 20 while n c avctx channels src8 src 4 c while c dst int32 t bytestream get be16 src 16 src8 0xf0 8 dst int32 t bytestream get be16 src 16 src8 0x0f 12 src src8 break case 24 while n c avctx channels src8 src 4 c while c dst int32 t bytestream get be16 src 16 src8 8 dst int32 t bytestream get be16 src 16 src8 8 src src8 break break case AVCODECIDPCMLXF int i n avctx channels for c 0 c avctx channels c dst int32 t int32 t frame extended data c for i 0 i n i dst int32 t src 2 28 src 1 20 src 0 12 src 2 0x0 F 8 src 1 dst int32 t src 4 24 src 3 16 src 2 0x F0 8 src 4 4 src 3 4 src 5 break default return 1 got frame ptr 1 return buf size int ff generate sliding window mmcos H264 Context h int first slice MMCO mmco temp MAXMMCOCOUNT mmco first slice h mmco mmco temp int mmco index 0 i assert h long ref count h short ref count h sps ref frame count if h short ref count h long ref count h short ref count h sps ref frame count FIELDPICTURE h first field h cur pic ptr f reference mmco 0 opcode MMCOSHOR T2 UNUSED mmco 0 short pic num h short ref h short ref count 1 frame num mmco index 1 if FIELDPICTURE mmco 0 short pic num 2 mmco 1 opcode MMCOSHOR T2 UNUSED mmco 1 short pic num mmco 0 short pic num 1 mmco index 2 if first slice h mmco index mmco index else if first slice mmco index 0 mmco index h mmco index i check opcodes h mmco mmco temp mmco index av log h avctx AVLOGERROR Inconsistent MMCO state between slices d d d n mmco index h mmco index i return AVERRORINVALIDDATA return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t ctable 128 Qpeg Context const a avctx priv data AV Frame const p a pic uint8 t outdata int delta ret const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if avpkt size 0x86 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA bytestream2 init a buffer avpkt data avpkt size if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR reget buffer failed n return ret outdata a pic data 0 bytestream2 skip a buffer 4 bytestream2 get buffer a buffer ctable 128 bytestream2 skip a buffer 1 delta bytestream2 get byte a buffer if delta 0x10 qpeg decode intra a outdata a pic linesize 0 avctx width avctx height else qpeg decode inter a outdata a pic linesize 0 avctx width avctx height delta ctable a refdata if pal a pic palette has changed 1 memcpy a pal pal AVPALETTESIZE memcpy a pic data 1 a pal AVPALETTESIZE if ret av frame ref data a pic 0 return ret got frame 1 return avpkt size static int mpeg4 decode mb Mpeg Enc Context s int16 t block 6 64 int cbpc cbpy i cbp pred x pred y mx my dquant int16 t mot val static int8 t quant tab 4 1 2 1 2 const int xy s mb x s mb y s mb stride assert s h263 pred if s pict type AVPICTURETYPEP s pict type AVPICTURETYPES do if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s current picture f mb type xy MBTYPESKIPMBTYPEGMCMBTYPE 16x16 MBTYPE L0 s mcsel 1 s mv 0 0 0 get amv s 0 s mv 0 0 1 get amv s 1 s mb skipped 0 else s current picture f mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mcsel 0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc damaged at d d n s mb x s mb y return 1 while cbpc 20 s dsp clear blocks s block 0 dquant cbpc 8 s mb intra cbpc 4 0 if s mb intra goto intra if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE cbpc 16 0 s mcsel get bits1 s gb else s mcsel 0 cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 0x0 F cbp cbpc 3 cbpy 2 if dquant ff set qscale s s qscale quant tab get bits s gb 2 if s progressive sequence cbp s workaround bugs FFBUGXVIDILACE s interlaced dct get bits1 s gb s mv dir MVDIRFORWARD if cbpc 16 0 if s mcsel s current picture f mb type xy MBTYPEGMCMBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 mx get amv s 0 my get amv s 1 s mv 0 0 0 mx s mv 0 0 1 my else if s progressive sequence get bits1 s gb s current picture f mb type xy MBTYPE 16x8 MBTYPE L0 MBTYPEINTERLACED s mv type MVTYPEFIELD s field select 0 0 get bits1 s gb s field select 0 1 get bits1 s gb ff h263 pred motion s 0 0 pred x pred y for i 0 i 2 i mx ff h263 decode motion s pred x s f code if mx 0xffff return 1 my ff h263 decode motion s pred y 2 s f code if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my else s current picture f mb type xy MBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 ff h263 pred motion s 0 0 pred x pred y mx ff h263 decode motion s pred x s f code if mx 0xffff return 1 my ff h263 decode motion s pred y s f code if my 0xffff return 1 s mv 0 0 0 mx s mv 0 0 1 my else s current picture f mb type xy MBTYPE 8x8 MBTYPE L0 s mv type MVTYPE 8 X8 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y mx ff h263 decode motion s pred x s f code if mx 0xffff return 1 my ff h263 decode motion s pred y s f code if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my mot val 0 mx mot val 1 my else if s pict type AVPICTURETYPEB int modb1 int modb2 int mb type s mb intra 0 s mcsel 0 if s mb x 0 for i 0 i 2 i s last mv i 0 0 s last mv i 0 1 s last mv i 1 0 s last mv i 1 1 0 ff thread await progress s next picture ptr f s mb y 0 s mb skipped s next picture f mbskip table s mb y s mb stride s mb x if s mb skipped for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mv 1 0 0 0 s mv 1 0 1 0 s current picture f mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 goto end modb1 get bits1 s gb if modb1 mb type MBTYPEDIREC T2 MBTYPESKIPMBTYPE L0 L1 cbp 0 else modb2 get bits1 s gb mb type get vlc2 s gb mb type b vlc table MBTYPEBVLCBITS 1 if mb type 0 av log s avctx AVLOGERROR illegal MB type n return 1 mb type mb type b map mb type if modb2 cbp 0 else s dsp clear blocks s block 0 cbp get bits s gb 6 if ISDIRECT mb type cbp if get bits1 s gb ff set qscale s s qscale get bits1 s gb 4 2 if s progressive sequence if cbp s interlaced dct get bits1 s gb if ISDIRECT mb type get bits1 s gb mb type MBTYPE 16x8 MBTYPEINTERLACED mb type MBTYPE 16x16 if USESLIST mb type 0 s field select 0 0 get bits1 s gb s field select 0 1 get bits1 s gb if USESLIST mb type 1 s field select 1 0 get bits1 s gb s field select 1 1 get bits1 s gb s mv dir 0 if mb type MBTYPEDIREC T2 MBTYPEINTERLACED 0 s mv type MVTYPE 16 X16 if USESLIST mb type 0 s mv dir MVDIRFORWARD mx ff h263 decode motion s s last mv 0 0 0 s f code my ff h263 decode motion s s last mv 0 0 1 s f code s last mv 0 1 0 s last mv 0 0 0 s mv 0 0 0 mx s last mv 0 1 1 s last mv 0 0 1 s mv 0 0 1 my if USESLIST mb type 1 s mv dir MVDIRBACKWARD mx ff h263 decode motion s s last mv 1 0 0 s b code my ff h263 decode motion s s last mv 1 0 1 s b code s last mv 1 1 0 s last mv 1 0 0 s mv 1 0 0 mx s last mv 1 1 1 s last mv 1 0 1 s mv 1 0 1 my else if ISDIRECT mb type s mv type MVTYPEFIELD if USESLIST mb type 0 s mv dir MVDIRFORWARD for i 0 i 2 i mx ff h263 decode motion s s last mv 0 i 0 s f code my ff h263 decode motion s s last mv 0 i 1 2 s f code s last mv 0 i 0 s mv 0 i 0 mx s last mv 0 i 1 s mv 0 i 1 my 2 if USESLIST mb type 1 s mv dir MVDIRBACKWARD for i 0 i 2 i mx ff h263 decode motion s s last mv 1 i 0 s b code my ff h263 decode motion s s last mv 1 i 1 2 s b code s last mv 1 i 0 s mv 1 i 0 mx s last mv 1 i 1 s mv 1 i 1 my 2 if ISDIRECT mb type if ISSKIP mb type mx my 0 else mx ff h263 decode motion s 0 1 my ff h263 decode motion s 0 1 s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT mb type ff mpeg4 set direct mv s mx my s current picture f mb type xy mb type else do cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERRORI cbpc damaged at d d n s mb x s mb y return 1 while cbpc 8 dquant cbpc 4 s mb intra 1 intra s ac pred get bits1 s gb if s ac pred s current picture f mb type xy MBTYPEINTRAMBTYPEACPRED else s current picture f mb type xy MBTYPEINTRA cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy damaged at d d n s mb x s mb y return 1 cbp cbpc 3 cbpy 2 s use intra dc vlc s qscale s intra dc threshold if dquant ff set qscale s s qscale quant tab get bits s gb 2 if s progressive sequence s interlaced dct get bits1 s gb s dsp clear blocks s block 0 for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 1 0 0 return 1 cbp cbp goto end for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 0 0 0 return 1 cbp cbp end if s codec id AVCODECIDMPE G4 if mpeg4 is resync s const int delta s mb x 1 s mb width 2 1 if s pict type AVPICTURETYPEB s next picture f mbskip table xy delta ff thread await progress s next picture ptr f s mb x delta s mb width FFMIN s mb y 1 s mb height 1 s mb y 0 if s pict type AVPICTURETYPEB s next picture f mbskip table xy delta return SLICEOK return SLICEEND return int ff mpeg4 decode video packet header Mpeg Enc Context s int mb num bits av log2 s mb num 1 1 int header extension 0 mb num len if get bits count s gb s gb size in bits 20 return 1 for len 0 len 32 len if get bits1 s gb break if len ff mpeg4 get video packet prefix length s av log s avctx AVLOGERROR marker does not match f code n return 1 if s shape RECTSHAPE header extension get bits1 s gb mb num get bits s gb mb num bits if mb num s mb num av log s avctx AVLOGERROR illegal mb num in video packet d d n mb num s mb num return 1 if s pict type AVPICTURETYPEB int mb x 0 mb y 0 while s next picture f mbskip table s mb index2xy mb num if mb x ff thread await progress s next picture ptr f mb y 0 mb num if mb x s mb width mb x 0 if mb num s mb num return 1 s mb x mb num s mb width s mb y mb num s mb width if s shape BINONLYSHAPE int qscale get bits s gb s quant precision if qscale s chroma qscale s qscale qscale if s shape RECTSHAPE header extension get bits1 s gb if header extension int time incr 0 while get bits1 s gb 0 time incr check marker s gb before time increment in video packed header skip bits s gb s time increment bits check marker s gb before vop coding type in video packed header skip bits s gb 2 if s shape BINONLYSHAPE skip bits s gb 3 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE mpeg4 decode sprite trajectory s s gb av log s avctx AVLOGERROR untested n if s pict type AVPICTURETYPEI int f code get bits s gb 3 if f code 0 av log s avctx AVLOGERROR Error video packet header damaged f code 0 n if s pict type AVPICTURETYPEB int b code get bits s gb 3 if b code 0 av log s avctx AVLOGERROR Error video packet header damaged b code 0 n return 0 static int decode tag AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Nelly Moser Decode Context s avctx priv data int blocks i ret float samples flt blocks buf size NELLYBLOCKLEN if blocks 0 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if buf size NELLYBLOCKLEN av log avctx AVLOGWARNING Leftover bytes d n buf size NELLYBLOCKLEN frame nb samples NELLYSAMPLES blocks if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples flt float frame data 0 for i 0 i blocks i nelly decode block s buf samples flt samples flt NELLYSAMPLES buf NELLYBLOCKLEN got frame ptr 1 return buf size static int slirp smb Slirp State s const char exported dir struct in addr vserver addr char smb conf 128 char smb cmdline 128 struct passwd passwd FILE f passwd getpwuid geteuid if passwd error report failed to retrieve user name return 1 if access CONFIGSMBDCOMMANDFOK error report could not find s please install it CONFIGSMBDCOMMAND return 1 if access exported dir ROKXOK error report error accessing shared directory s s exported dir strerror errno return 1 snprintf s smb dir sizeof s smb dir tmp qemu smb XXXXXX if mkdtemp s smb dir error report could not create samba server dir s s smb dir s smb dir 0 0 return 1 snprintf smb conf sizeof smb conf s s s smb dir smb conf f fopen smb conf w if f slirp smb cleanup s error report could not create samba server configuration file s smb conf return 1 fprintf f global n private dir s n interfaces 127 0 0 1 n bind interfaces only yes n pid directory s n lock directory s n state directory s n cache directory s n ncalrpc dir scalrpc n log file s log smbd n smb passwd file s smbpasswd n security user n map to guest Bad User n load printers no n printing bsd n disable spoolss yes n usershare max shares 0 n qemu n path s n read only no n guest ok yes n force user s n s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir exported dir passwd pw name fclose f snprintf smb cmdline sizeof smb cmdline s l s s s CONFIGSMBDCOMMAND s smb dir smb conf if slirp add exec s slirp 0 smb cmdline vserver addr 139 0 slirp add exec s slirp 0 smb cmdline vserver addr 445 0 slirp smb cleanup s error report conflicting invalid smbserver address return 1 return 0 int16 t ff h263 pred motion Mpeg Enc Context s int block int dir int px int py int wrap int16 t ABC mot val 2 static const int off 4 2 1 1 1 wrap s b8 stride mot val s current picture motion val dir s block index block A mot val 1 if s first slice line block 3 if block 0 if s mb x s resync mb x px py 0 else if s mb x 1 s resync mb x s h263 pred C mot val off block wrap if s mb x 0 px C 0 py C 1 else px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else if block 1 if s mb x 1 s resync mb x s h263 pred C mot val off block wrap px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else B mot val wrap C mot val off block wrap if s mb x s resync mb x A 0 A 1 0 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else B mot val wrap C mot val off block wrap px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val void vp9 loop filter frame mt Y V12 BUFFERCONFIG frame V P9 Decoder pbi V P9 COMMON cm int frame filter level int y only V P9 Lf Sync const lf sync pbi lf row sync const V P9 Worker Interface const winterface vp9 get worker interface const int sb rows mi cols aligned to sb cm mi rows MIBLOCKSIZELO G2 const int tile cols 1 cm log2 tile cols const int num workers MIN pbi max threads 1 tile cols int i if frame filter level return if lf sync sync range cm last height cm height vp9 loop filter dealloc lf sync vp9 loop filter alloc lf sync cm sb rows cm width vp9 loop filter frame init cm frame filter level vpx memset lf sync cur sb col 1 sizeof lf sync cur sb col sb rows for i 0 i num workers i V P9 Worker const worker pbi tile workers i Tile Worker Data const tile data Tile Worker Data worker data1 LF Worker Data const lf data tile data lfdata worker hook V P9 Worker Hook loop filter row worker lf data frame buffer frame lf data cm cm vp9 copy lf data planes pbi mb plane lf data start i lf data stop sb rows lf data y only y only lf data lf sync lf sync lf data num lf workers num workers if i num workers 1 winterface execute worker else winterface launch worker for i 0 i num workers i winterface sync pbi tile workers i static void update state V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col BLOCKSIZE bsize int output enabled int i x idx y V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd struct macroblock plane const p x plane struct macroblockd plane const pd xd plane MODEINFO mi ctx mic MBMODEINFO const mbmi xd mi 0 src mi mbmi MODEINFO mi addr xd mi 0 const struct segmentation const seg cm seg const int mis cm mi stride const int mi width num 8x8 blocks wide lookup bsize const int mi height num 8x8 blocks high lookup bsize int max plane assert mi mbmi sb type bsize mi addr mi mi addr src mi mi addr if seg enabled output enabled if cpi oxcf aq mode COMPLEXITYAQ const uint8 t const map seg update map cpi segmentation map cm last frame seg map mi addr mbmi segment id vp9 get segment id cm map bsize mi row mi col if cpi oxcf aq mode CYCLICREFRESHAQ vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 max plane is inter block mbmi MAXMBPLANE 1 for i 0 i max plane i p i coeff ctx coeff pbuf i 1 p i qcoeff ctx qcoeff pbuf i 1 pd i dqcoeff ctx dqcoeff pbuf i 1 p i eobs ctx eobs pbuf i 1 for i max plane i MAXMBPLANE i p i coeff ctx coeff pbuf i 2 p i qcoeff ctx qcoeff pbuf i 2 pd i dqcoeff ctx dqcoeff pbuf i 2 p i eobs ctx eobs pbuf i 2 for y 0 y mi height y for x idx 0 x idx mi width x idx if xd mb to right edge 3 MISIZELO G2 mi width x idx xd mb to bottom edge 3 MISIZELO G2 mi height y xd mi x idx y mis src mi mi addr if cpi oxcf aq mode vp9 init plane quantizers cpi x if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 ctx tx rd diff ALLOW 16 X16 ctx tx rd diff ALLOW 8 X8 ctx tx rd diff ALLOW 32 X32 ctx tx rd diff ALLOW 16 X16 if is inter block mbmi mbmi sb type BLOCK 8 X8 mbmi mv 0 as int mi bmi 3 as mv 0 as int mbmi mv 1 as int mi bmi 3 as mv 1 as int x skip ctx skip vpx memcpy x zcoeff blk mbmi tx size ctx zcoeff blk sizeof uint8 t ctx num 4x4 blk if output enabled return if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP for i 0 i TXMODES i rd opt tx select diff i ctx tx rd diff i static const int kf mode index THRDCTHRVPREDTHRHPREDTHR D45 PREDTHR D135 PREDTHR D117 PREDTHR D153 PREDTHR D207 PREDTHR D63 PREDTHRTM cpi mode chosen counts kf mode index mbmi mode static Asn1 Generic Decode Asn1 Der Set const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node Asn1 Generic child d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SET node data NULL c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL seq index 0 el max size max size d ptr buffer child Decode Asn1 Der Generic d ptr el max size depth seq index errcode node data child return Asn1 Generic node void vp9 idct32x32 1024 add sse2 const int16 t input uint8 t dest int stride const m128i rounding mm set1 epi32 DCTCONSTROUNDING const m128i final rounding mm set1 epi16 1 5 const m128i zero mm setzero si128 const m128i stg1 0 pair set epi16 cospi 31 64 cospi 1 64 const m128i stg1 1 pair set epi16 cospi 1 64 cospi 31 64 const m128i stg1 2 pair set epi16 cospi 15 64 cospi 17 64 const m128i stg1 3 pair set epi16 cospi 17 64 cospi 15 64 const m128i stg1 4 pair set epi16 cospi 23 64 cospi 9 64 const m128i stg1 5 pair set epi16 cospi 9 64 cospi 23 64 const m128i stg1 6 pair set epi16 cospi 7 64 cospi 25 64 const m128i stg1 7 pair set epi16 cospi 25 64 cospi 7 64 const m128i stg1 8 pair set epi16 cospi 27 64 cospi 5 64 const m128i stg1 9 pair set epi16 cospi 5 64 cospi 27 64 const m128i stg1 10 pair set epi16 cospi 11 64 cospi 21 64 const m128i stg1 11 pair set epi16 cospi 21 64 cospi 11 64 const m128i stg1 12 pair set epi16 cospi 19 64 cospi 13 64 const m128i stg1 13 pair set epi16 cospi 13 64 cospi 19 64 const m128i stg1 14 pair set epi16 cospi 3 64 cospi 29 64 const m128i stg1 15 pair set epi16 cospi 29 64 cospi 3 64 const m128i stg2 0 pair set epi16 cospi 30 64 cospi 2 64 const m128i stg2 1 pair set epi16 cospi 2 64 cospi 30 64 const m128i stg2 2 pair set epi16 cospi 14 64 cospi 18 64 const m128i stg2 3 pair set epi16 cospi 18 64 cospi 14 64 const m128i stg2 4 pair set epi16 cospi 22 64 cospi 10 64 const m128i stg2 5 pair set epi16 cospi 10 64 cospi 22 64 const m128i stg2 6 pair set epi16 cospi 6 64 cospi 26 64 const m128i stg2 7 pair set epi16 cospi 26 64 cospi 6 64 const m128i stg3 0 pair set epi16 cospi 28 64 cospi 4 64 const m128i stg3 1 pair set epi16 cospi 4 64 cospi 28 64 const m128i stg3 2 pair set epi16 cospi 12 64 cospi 20 64 const m128i stg3 3 pair set epi16 cospi 20 64 cospi 12 64 const m128i stg3 4 pair set epi16 cospi 4 64 cospi 28 64 const m128i stg3 5 pair set epi16 cospi 28 64 cospi 4 64 const m128i stg3 6 pair set epi16 cospi 28 64 cospi 4 64 const m128i stg3 8 pair set epi16 cospi 20 64 cospi 12 64 const m128i stg3 9 pair set epi16 cospi 12 64 cospi 20 64 const m128i stg3 10 pair set epi16 cospi 12 64 cospi 20 64 const m128i stg4 0 pair set epi16 cospi 16 64 cospi 16 64 const m128i stg4 1 pair set epi16 cospi 16 64 cospi 16 64 const m128i stg4 2 pair set epi16 cospi 24 64 cospi 8 64 const m128i stg4 3 pair set epi16 cospi 8 64 cospi 24 64 const m128i stg4 4 pair set epi16 cospi 8 64 cospi 24 64 const m128i stg4 5 pair set epi16 cospi 24 64 cospi 8 64 const m128i stg4 6 pair set epi16 cospi 24 64 cospi 8 64 const m128i stg6 0 pair set epi16 cospi 16 64 cospi 16 64 m128i in 32 col 128 zero idx 16 m128i stp1 0 stp1 1 stp1 2 stp1 3 stp1 4 stp1 5 stp1 6 stp1 7 stp1 8 stp1 9 stp1 10 stp1 11 stp1 12 stp1 13 stp1 14 stp1 15 stp1 16 stp1 17 stp1 18 stp1 19 stp1 20 stp1 21 stp1 22 stp1 23 stp1 24 stp1 25 stp1 26 stp1 27 stp1 28 stp1 29 stp1 30 stp1 31 m128i stp2 0 stp2 1 stp2 2 stp2 3 stp2 4 stp2 5 stp2 6 stp2 7 stp2 8 stp2 9 stp2 10 stp2 11 stp2 12 stp2 13 stp2 14 stp2 15 stp2 16 stp2 17 stp2 18 stp2 19 stp2 20 stp2 21 stp2 22 stp2 23 stp2 24 stp2 25 stp2 26 stp2 27 stp2 28 stp2 29 stp2 30 stp2 31 m128i tmp0 tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 int i j i32 for i 0 i 4 i i32 i 5 LOADDQCOEFF in 0 input LOADDQCOEFF in 8 input LOADDQCOEFF in 16 input LOADDQCOEFF in 24 input LOADDQCOEFF in 1 input LOADDQCOEFF in 9 input LOADDQCOEFF in 17 input LOADDQCOEFF in 25 input LOADDQCOEFF in 2 input LOADDQCOEFF in 10 input LOADDQCOEFF in 18 input LOADDQCOEFF in 26 input LOADDQCOEFF in 3 input LOADDQCOEFF in 11 input LOADDQCOEFF in 19 input LOADDQCOEFF in 27 input LOADDQCOEFF in 4 input LOADDQCOEFF in 12 input LOADDQCOEFF in 20 input LOADDQCOEFF in 28 input LOADDQCOEFF in 5 input LOADDQCOEFF in 13 input LOADDQCOEFF in 21 input LOADDQCOEFF in 29 input LOADDQCOEFF in 6 input LOADDQCOEFF in 14 input LOADDQCOEFF in 22 input LOADDQCOEFF in 30 input LOADDQCOEFF in 7 input LOADDQCOEFF in 15 input LOADDQCOEFF in 23 input LOADDQCOEFF in 31 input zero idx 0 mm or si128 in 0 in 1 zero idx 1 mm or si128 in 2 in 3 zero idx 2 mm or si128 in 4 in 5 zero idx 3 mm or si128 in 6 in 7 zero idx 4 mm or si128 in 8 in 9 zero idx 5 mm or si128 in 10 in 11 zero idx 6 mm or si128 in 12 in 13 zero idx 7 mm or si128 in 14 in 15 zero idx 8 mm or si128 in 16 in 17 zero idx 9 mm or si128 in 18 in 19 zero idx 10 mm or si128 in 20 in 21 zero idx 11 mm or si128 in 22 in 23 zero idx 12 mm or si128 in 24 in 25 zero idx 13 mm or si128 in 26 in 27 zero idx 14 mm or si128 in 28 in 29 zero idx 15 mm or si128 in 30 in 31 zero idx 0 mm or si128 zero idx 0 zero idx 1 zero idx 1 mm or si128 zero idx 2 zero idx 3 zero idx 2 mm or si128 zero idx 4 zero idx 5 zero idx 3 mm or si128 zero idx 6 zero idx 7 zero idx 4 mm or si128 zero idx 8 zero idx 9 zero idx 5 mm or si128 zero idx 10 zero idx 11 zero idx 6 mm or si128 zero idx 12 zero idx 13 zero idx 7 mm or si128 zero idx 14 zero idx 15 zero idx 8 mm or si128 zero idx 0 zero idx 1 zero idx 9 mm or si128 zero idx 2 zero idx 3 zero idx 10 mm or si128 zero idx 4 zero idx 5 zero idx 11 mm or si128 zero idx 6 zero idx 7 zero idx 12 mm or si128 zero idx 8 zero idx 9 zero idx 13 mm or si128 zero idx 10 zero idx 11 zero idx 14 mm or si128 zero idx 12 zero idx 13 if mm movemask epi8 mm cmpeq epi32 zero idx 14 zero 0x FFFF col i32 0 mm setzero si128 col i32 1 mm setzero si128 col i32 2 mm setzero si128 col i32 3 mm setzero si128 col i32 4 mm setzero si128 col i32 5 mm setzero si128 col i32 6 mm setzero si128 col i32 7 mm setzero si128 col i32 8 mm setzero si128 col i32 9 mm setzero si128 col i32 10 mm setzero si128 col i32 11 mm setzero si128 col i32 12 mm setzero si128 col i32 13 mm setzero si128 col i32 14 mm setzero si128 col i32 15 mm setzero si128 col i32 16 mm setzero si128 col i32 17 mm setzero si128 col i32 18 mm setzero si128 col i32 19 mm setzero si128 col i32 20 mm setzero si128 col i32 21 mm setzero si128 col i32 22 mm setzero si128 col i32 23 mm setzero si128 col i32 24 mm setzero si128 col i32 25 mm setzero si128 col i32 26 mm setzero si128 col i32 27 mm setzero si128 col i32 28 mm setzero si128 col i32 29 mm setzero si128 col i32 30 mm setzero si128 col i32 31 mm setzero si128 continue array transpose 8x8 in in array transpose 8x8 in 8 in 8 array transpose 8x8 in 16 in 16 array transpose 8x8 in 24 in 24 IDC T32 col i32 0 mm add epi16 stp1 0 stp1 31 col i32 1 mm add epi16 stp1 1 stp1 30 col i32 2 mm add epi16 stp1 2 stp1 29 col i32 3 mm add epi16 stp1 3 stp1 28 col i32 4 mm add epi16 stp1 4 stp1 27 col i32 5 mm add epi16 stp1 5 stp1 26 col i32 6 mm add epi16 stp1 6 stp1 25 col i32 7 mm add epi16 stp1 7 stp1 24 col i32 8 mm add epi16 stp1 8 stp1 23 col i32 9 mm add epi16 stp1 9 stp1 22 col i32 10 mm add epi16 stp1 10 stp1 21 col i32 11 mm add epi16 stp1 11 stp1 20 col i32 12 mm add epi16 stp1 12 stp1 19 col i32 13 mm add epi16 stp1 13 stp1 18 col i32 14 mm add epi16 stp1 14 stp1 17 col i32 15 mm add epi16 stp1 15 stp1 16 col i32 16 mm sub epi16 stp1 15 stp1 16 col i32 17 mm sub epi16 stp1 14 stp1 17 col i32 18 mm sub epi16 stp1 13 stp1 18 col i32 19 mm sub epi16 stp1 12 stp1 19 col i32 20 mm sub epi16 stp1 11 stp1 20 col i32 21 mm sub epi16 stp1 10 stp1 21 col i32 22 mm sub epi16 stp1 9 stp1 22 col i32 23 mm sub epi16 stp1 8 stp1 23 col i32 24 mm sub epi16 stp1 7 stp1 24 col i32 25 mm sub epi16 stp1 6 stp1 25 col i32 26 mm sub epi16 stp1 5 stp1 26 col i32 27 mm sub epi16 stp1 4 stp1 27 col i32 28 mm sub epi16 stp1 3 stp1 28 col i32 29 mm sub epi16 stp1 2 stp1 29 col i32 30 mm sub epi16 stp1 1 stp1 30 col i32 31 mm sub epi16 stp1 0 stp1 31 for i 0 i 4 i j i 3 array transpose 8x8 col j in array transpose 8x8 col j 32 in 8 array transpose 8x8 col j 64 in 16 array transpose 8x8 col j 96 in 24 IDC T32 in 0 mm add epi16 stp1 0 stp1 31 in 1 mm add epi16 stp1 1 stp1 30 in 2 mm add epi16 stp1 2 stp1 29 in 3 mm add epi16 stp1 3 stp1 28 in 4 mm add epi16 stp1 4 stp1 27 in 5 mm add epi16 stp1 5 stp1 26 in 6 mm add epi16 stp1 6 stp1 25 in 7 mm add epi16 stp1 7 stp1 24 in 8 mm add epi16 stp1 8 stp1 23 in 9 mm add epi16 stp1 9 stp1 22 in 10 mm add epi16 stp1 10 stp1 21 in 11 mm add epi16 stp1 11 stp1 20 in 12 mm add epi16 stp1 12 stp1 19 in 13 mm add epi16 stp1 13 stp1 18 in 14 mm add epi16 stp1 14 stp1 17 in 15 mm add epi16 stp1 15 stp1 16 in 16 mm sub epi16 stp1 15 stp1 16 in 17 mm sub epi16 stp1 14 stp1 17 in 18 mm sub epi16 stp1 13 stp1 18 in 19 mm sub epi16 stp1 12 stp1 19 in 20 mm sub epi16 stp1 11 stp1 20 in 21 mm sub epi16 stp1 10 stp1 21 in 22 mm sub epi16 stp1 9 stp1 22 in 23 mm sub epi16 stp1 8 stp1 23 in 24 mm sub epi16 stp1 7 stp1 24 in 25 mm sub epi16 stp1 6 stp1 25 in 26 mm sub epi16 stp1 5 stp1 26 in 27 mm sub epi16 stp1 4 stp1 27 in 28 mm sub epi16 stp1 3 stp1 28 in 29 mm sub epi16 stp1 2 stp1 29 in 30 mm sub epi16 stp1 1 stp1 30 in 31 mm sub epi16 stp1 0 stp1 31 in 0 mm adds epi16 in 0 final rounding in 1 mm adds epi16 in 1 final rounding in 2 mm adds epi16 in 2 final rounding in 3 mm adds epi16 in 3 final rounding in 4 mm adds epi16 in 4 final rounding in 5 mm adds epi16 in 5 final rounding in 6 mm adds epi16 in 6 final rounding in 7 mm adds epi16 in 7 final rounding in 8 mm adds epi16 in 8 final rounding in 9 mm adds epi16 in 9 final rounding in 10 mm adds epi16 in 10 final rounding in 11 mm adds epi16 in 11 final rounding in 12 mm adds epi16 in 12 final rounding in 13 mm adds epi16 in 13 final rounding in 14 mm adds epi16 in 14 final rounding in 15 mm adds epi16 in 15 final rounding in 16 mm adds epi16 in 16 final rounding in 17 mm adds epi16 in 17 final rounding in 18 mm adds epi16 in 18 final rounding in 19 mm adds epi16 in 19 final rounding in 20 mm adds epi16 in 20 final rounding in 21 mm adds epi16 in 21 final rounding in 22 mm adds epi16 in 22 final rounding in 23 mm adds epi16 in 23 final rounding in 24 mm adds epi16 in 24 final rounding in 25 mm adds epi16 in 25 final rounding in 26 mm adds epi16 in 26 final rounding in 27 mm adds epi16 in 27 final rounding in 28 mm adds epi16 in 28 final rounding in 29 mm adds epi16 in 29 final rounding in 30 mm adds epi16 in 30 final rounding in 31 mm adds epi16 in 31 final rounding in 0 mm srai epi16 in 0 6 in 1 mm srai epi16 in 1 6 in 2 mm srai epi16 in 2 6 in 3 mm srai epi16 in 3 6 in 4 mm srai epi16 in 4 6 in 5 mm srai epi16 in 5 6 in 6 mm srai epi16 in 6 6 in 7 mm srai epi16 in 7 6 in 8 mm srai epi16 in 8 6 in 9 mm srai epi16 in 9 6 in 10 mm srai epi16 in 10 6 in 11 mm srai epi16 in 11 6 in 12 mm srai epi16 in 12 6 in 13 mm srai epi16 in 13 6 in 14 mm srai epi16 in 14 6 in 15 mm srai epi16 in 15 6 in 16 mm srai epi16 in 16 6 in 17 mm srai epi16 in 17 6 in 18 mm srai epi16 in 18 6 in 19 mm srai epi16 in 19 6 in 20 mm srai epi16 in 20 6 in 21 mm srai epi16 in 21 6 in 22 mm srai epi16 in 22 6 in 23 mm srai epi16 in 23 6 in 24 mm srai epi16 in 24 6 in 25 mm srai epi16 in 25 6 in 26 mm srai epi16 in 26 6 in 27 mm srai epi16 in 27 6 in 28 mm srai epi16 in 28 6 in 29 mm srai epi16 in 29 6 in 30 mm srai epi16 in 30 6 in 31 mm srai epi16 in 31 6 RECONANDSTORE dest in 0 RECONANDSTORE dest in 1 RECONANDSTORE dest in 2 RECONANDSTORE dest in 3 RECONANDSTORE dest in 4 RECONANDSTORE dest in 5 RECONANDSTORE dest in 6 RECONANDSTORE dest in 7 RECONANDSTORE dest in 8 RECONANDSTORE dest in 9 RECONANDSTORE dest in 10 RECONANDSTORE dest in 11 RECONANDSTORE dest in 12 RECONANDSTORE dest in 13 RECONANDSTORE dest in 14 RECONANDSTORE dest in 15 RECONANDSTORE dest in 16 RECONANDSTORE dest in 17 RECONANDSTORE dest in 18 RECONANDSTORE dest in 19 RECONANDSTORE dest in 20 RECONANDSTORE dest in 21 RECONANDSTORE dest in 22 RECONANDSTORE dest in 23 RECONANDSTORE dest in 24 RECONANDSTORE dest in 25 RECONANDSTORE dest in 26 RECONANDSTORE dest in 27 RECONANDSTORE dest in 28 RECONANDSTORE dest in 29 RECONANDSTORE dest in 30 RECONANDSTORE dest in 31 dest 8 stride 32 static int tscc2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size TSC C2 Context c avctx priv data Get Byte Context gb uint32 t frame type size int i val len pos 0 int num mb c mb width c mb height int ret bytestream2 init gb buf buf size frame type bytestream2 get byte gb if frame type 1 av log avctx AVLOGERROR Incorrect frame type d n frame type return AVERRORINVALIDDATA c pic reference 3 c pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx c pic 0 av log avctx AVLOGERROR reget buffer failed n return ret if frame type 0 got frame 1 AV Frame data c pic return buf size if bytestream2 get bytes left gb 4 av log avctx AVLOGERROR Frame is too short n return AVERRORINVALIDDATA c quant 0 bytestream2 get byte gb c quant 1 bytestream2 get byte gb if c quant 0 2 c quant 0 NUMVLCSETS 1 c quant 1 2 c quant 1 NUMVLCSETS 1 av log avctx AVLOGERROR Invalid quantisers d d n c quant 0 c quant 1 return AVERRORINVALIDDATA for i 0 i 3 i c q 0 i tscc2 quants c quant 0 2 i c q 1 i tscc2 quants c quant 1 2 i bytestream2 skip gb 1 size bytestream2 get le32 gb if size bytestream2 get bytes left gb av log avctx AVLOGERROR Slice properties chunk is too large n return AVERRORINVALIDDATA for i 0 i size i val bytestream2 get byte gb len val 0x3 F val 6 if pos len num mb av log avctx AVLOGERROR Too many slice properties n return AVERRORINVALIDDATA memset c slice quants pos val len pos len if pos num mb av log avctx AVLOGERROR Too few slice properties d d n pos num mb return AVERRORINVALIDDATA for i 0 i c mb height i size bytestream2 peek byte gb if size 1 size bytestream2 get byte gb 1 else size bytestream2 get le32 gb 1 if size int skip row 1 j off i c mb width for j 0 j c mb width j if c slice quants off j 1 c slice quants off j 2 skip row 0 break if skip row av log avctx AVLOGERROR Non skip row with zero size n return AVERRORINVALIDDATA if bytestream2 get bytes left gb size av log avctx AVLOGERROR Invalid slice size d d n size bytestream2 get bytes left gb return AVERRORINVALIDDATA ret tscc2 decode slice c i buf bytestream2 tell gb size if ret av log avctx AVLOGERROR Error decoding slice d n i return ret bytestream2 skip gb size got frame 1 AV Frame data c pic return buf size static int get twopass worst quality const V P9 COMP cpi const FIRSTPASSSTATS stats int section target bandwidth const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf if section target bandwidth 0 return rc worst quality else const int num mbs cpi common M Bs const double section err stats coded error stats count const double err per mb section err num mbs const double speed term 1 0 0 04 oxcf speed const int target norm bits per mb uint64 t section target bandwidth BPERMBNORMBITS num mbs int q int is svc upper layer 0 if is two pass svc cpi cpi svc spatial layer id 0 is svc upper layer 1 for q rc best quality q rc worst quality q const double factor calc correction factor err per mb ERRDIVISOR is svc upper layer SVCFACTORPTLOWFACTORPTLOWFACTORPTHIGH q const int bits per mb vp9 rc bits per mb INTERFRAME q factor speed term if bits per mb target norm bits per mb break if cpi oxcf rc mode VPXCQ q MAX q oxcf cq level return q static void model rd for sb y V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum unsigned int var y unsigned int sse y unsigned int sse int rate int64 t dist struct macroblock plane const p x plane 0 struct macroblockd plane const pd xd plane 0 const uint32 t dc quant pd dequant 0 const uint32 t ac quant pd dequant 1 unsigned int var cpi fn ptr bsize vf p src buf p src stride pd dst buf pd dst stride sse var y var sse y sse if sse dc quant dc quant 6 x skip txfm 0 1 else if var ac quant ac quant 6 x skip txfm 0 2 else x skip txfm 0 0 if cpi common tx mode TXMODESELECT if sse var 2 xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode else xd mi 0 src mi mbmi tx size TX 8 X8 else xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode vp9 model rd from var lapndz sse var 1 num pels log2 lookup bsize dc quant 3 rate dist out rate sum rate 1 out dist sum dist 3 vp9 model rd from var lapndz var 1 num pels log2 lookup bsize ac quant 3 rate dist out rate sum rate out dist sum dist 4 void ff h264 filter mb H264 Context h int mb x int mb y uint8 t img y uint8 t img cb uint8 t img cr unsigned int linesize unsigned int uvlinesize const int mb xy mb x mb y h mb stride const int mb type h cur pic f mb type mb xy const int mvy limit ISINTERLACED mb type 2 4 int first vertical edge done 0 av unused int dir int chroma CONFIGGRAY h flags CODECFLAGGRAY int qp bd offset 6 h sps bit depth luma 8 int a h slice alpha c0 offset qp bd offset int b h slice beta offset qp bd offset if FRAMEMBAFFISINTERLACED mb type h left type LTOP h left type LTOPDECLAREALIGNED 8 int16 t b S 8 int qp 2 int bqp 2 int rqp 2 int mb qp mbn0 qp mbn1 qp int i first vertical edge done 1 if ISINTRA mb type AVW N64 A b S 0 0x0004000400040004 ULLAVW N64 A b S 4 0x0004000400040004 ULL else static const uint8 t offset 2 2 8 3 4 0 3 4 0 3 4 0 3 4 0 3 4 1 3 4 1 3 4 1 3 4 1 3 4 2 3 4 2 3 4 2 3 4 2 3 4 3 3 4 3 3 4 3 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 const uint8 t off offset MBFIELD mb y 1 for i 0 i 8 i int j MBFIELD i 2 i 1 int mbn xy h left mb xy LEFT j int mbn type h left type LEFT j if ISINTRA mbn type b S i 4 else b S i 1 h non zero count cache 12 8 i 1 h pps cabac IS 8x8 DCT mbn type h cbp table mbn xy MBFIELD i 2 mb y 1 8 2 12 h non zero count mbn xy off i mb qp h cur pic f qscale table mb xy mbn0 qp h cur pic f qscale table h left mb xy 0 mbn1 qp h cur pic f qscale table h left mb xy 1 qp 0 mb qp mbn0 qp 1 1 bqp 0 get chroma qp h 0 mb qp get chroma qp h 0 mbn0 qp 1 1 rqp 0 get chroma qp h 1 mb qp get chroma qp h 1 mbn0 qp 1 1 qp 1 mb qp mbn1 qp 1 1 bqp 1 get chroma qp h 0 mb qp get chroma qp h 0 mbn1 qp 1 1 rqp 1 get chroma qp h 1 mb qp get chroma qp h 1 mbn1 qp 1 1 tprintf h avctx filter mb d d MBAFFQ Py d d Q Pb d d Q Pr d d ls d uvls d mb x mb y qp 0 qp 1 bqp 0 bqp 1 rqp 0 rqp 1 linesize uvlinesize int i for i 0 i 8 i tprintf h avctx b S d d i b S i tprintf h avctx n if MBFIELD filter mb mbaff edgev h img y linesize b S 1 qp 0 a b 1 filter mb mbaff edgev h img y 8 linesize linesize b S 4 1 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgev h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgev h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgev h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else if CHROM A422 filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 4 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 4 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgev h img y 2 linesize b S 2 qp 0 a b 1 filter mb mbaff edgev h img y linesize 2 linesize b S 1 2 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgev h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgev h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgev h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 else filter mb mbaff edgecv h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgecv h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgecv h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgecv h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 dir 2 dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit dir 0 first vertical edge done a b chroma dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit 0 a b chroma 1 static int libgsm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt int i ret Lib GSM Decode Context s avctx priv data AV Frame frame data uint8 t buf avpkt data int buf size avpkt size int16 t samples if buf size avctx block align av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA frame nb samples avctx frame size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 for i 0 i avctx frame size GSMFRAMESIZE i if ret gsm decode s state buf samples 0 return 1 buf GSMBLOCKSIZE samples GSMFRAMESIZE got frame ptr 1 return avctx block align static VALUE ossl cipher set key VALUE self VALUE key EVPCIPHERCTX ctx int key len String Value key Get Cipher self ctx key len EVPCIPHERCTX key length ctx if RSTRINGLEN key key len ossl raise rb e Arg Error key must be d bytes key len if EVP Cipher Init ex ctx NULLNULL unsigned char RSTRINGPTR key NULL 1 1 ossl raise e Cipher Error NULL rb ivar set self id key set Qtrue return key static void evhttp make header request struct evhttp connection evcon struct evhttp request req const char method evhttp remove header req output headers Proxy Connection method evhttp method req type evbuffer add printf evcon output buffer s s HTTP d d r n method req uri req major req minor if req type EVHTTPREQPOST evhttp find header req output headers Content Length NULL char size 22 evutil snprintf size sizeof size ld long EVBUFFERLENGTH req output buffer evhttp add header req output headers Content Length size static int msrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Msrle Context s avctx priv data int istride FFALIGN avctx width avctx bits per coded sample 32 8 int ret s buf buf s size buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE if avctx height istride avpkt size int linesize avctx width avctx bits per coded sample 8 uint8 t ptr s frame data 0 uint8 t buf avpkt data avctx height 1 istride int i j for i 0 i avctx height i if avctx bits per coded sample 4 for j 0 j avctx width 1 j 2 ptr j 0 buf j 1 4 ptr j 1 buf j 1 0x F if avctx width 1 ptr j 0 buf j 1 4 else memcpy ptr buf linesize buf istride ptr s frame linesize 0 else bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame avctx bits per coded sample s gb if ret av frame ref data s frame 0 return ret got frame 1 return buf size static void dump Databases P Gconn conn P Gresult res int i if server version 70100 res execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 else res execute Query conn SELECT datname FROM pg database ORDERBY 1 for i 0 i P Qntuples res i int ret char dbname P Qgetvalue res i 0 PQ Exp Buffer Data connectbuf if verbose fprintf stderr s dumping database s n progname dbname init PQ Exp Buffer connectbuf append Psql Meta Connect connectbuf dbname fprintf OPF s n connectbuf data term PQ Exp Buffer connectbuf fprintf OPFSET default transaction read only off n n if filename fclose OPF ret run Pg Dump dbname if ret 0 fprintf stderr s pg dump failed on database s exiting n progname dbname exit nicely 1 if filename OPF fopen filename PGBINARYA if OPF fprintf stderr s could not re open the output file s s n progname filename strerror errno exit nicely 1 P Qclear res void jpc qmfb split col jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZE jpc fix t buf splitbuf register jpc fix t srcptr register jpc fix t dstptr register int n register int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr srcptr dstptr srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr srcptr dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr srcptr dstptr stride srcptr if buf splitbuf jas free buf static double eqjoinsel inner Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL Form pg statistic stats2 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid get opcode operator if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple stats2 Form pg statistic GETSTRUCT vardata2 stats Tuple if statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double nullfrac2 stats2 stanullfrac double matchprodfreq matchfreq1 matchfreq2 unmatchfreq1 unmatchfreq2 otherfreq1 otherfreq2 totalsel1 totalsel2 int i nmatches fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 nvalues2 sizeof bool matchprodfreq 0 0 nmatches 0 for i 0 i nvalues1 i int j for j 0 j nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true matchprodfreq numbers1 i numbers2 j nmatches break CLAMPPROBABILITY matchprodfreq matchfreq1 unmatchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i else unmatchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 CLAMPPROBABILITY unmatchfreq1 matchfreq2 unmatchfreq2 0 0 for i 0 i nvalues2 i if hasmatch2 i matchfreq2 numbers2 i else unmatchfreq2 numbers2 i CLAMPPROBABILITY matchfreq2 CLAMPPROBABILITY unmatchfreq2 pfree hasmatch1 pfree hasmatch2 otherfreq1 1 0 nullfrac1 matchfreq1 unmatchfreq1 otherfreq2 1 0 nullfrac2 matchfreq2 unmatchfreq2 CLAMPPROBABILITY otherfreq1 CLAMPPROBABILITY otherfreq2 totalsel1 matchprodfreq if nd2 nvalues2 totalsel1 unmatchfreq1 otherfreq2 nd2 nvalues2 if nd2 nmatches totalsel1 otherfreq1 otherfreq2 unmatchfreq2 nd2 nmatches totalsel2 matchprodfreq if nd1 nvalues1 totalsel2 unmatchfreq2 otherfreq1 nd1 nvalues1 if nd1 nmatches totalsel2 otherfreq2 otherfreq1 unmatchfreq1 nd1 nmatches selec totalsel1 totalsel2 totalsel1 totalsel2 else double nullfrac1 stats1 stats1 stanullfrac 0 0 double nullfrac2 stats2 stats2 stanullfrac 0 0 selec 1 0 nullfrac1 1 0 nullfrac2 if nd1 nd2 selec nd1 else selec nd2 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec int zrestore i ctx t i ctx p os ptr op osp alloc save t asave bool last vm save t vmsave int code restore check operand op asave idmemory if code 0 return code if debug2m u imemory u vmrestore 0x lx id lu n ulong alloc save client data asave ulong op value saveid if IVALIDATEBEFORERESTORE ivalidate clean spaces i ctx p osp int code if code restore check stack i ctx p o stack asave false 0 code restore check stack i ctx p e stack asave true 0 code restore check stack i ctx p d stack asave false 0 osp return code restore fix stack i ctx p o stack asave false restore fix stack i ctx p e stack asave true restore fix stack i ctx p d stack asave false do vmsave alloc save client data alloc save current idmemory gs grestoreall for restore igs vmsave gsave vmsave gsave 0 code alloc restore step in idmemory asave if code 0 return code last code while last uint space icurrent space ialloc set space idmemory avm local ifree object vmsave zrestore ialloc set space idmemory space dict set top if IVALIDATEAFTERRESTORE ivalidate clean spaces i ctx p i ctx p Lock File Permissions false return 0 int encode msg struct sip msg msg char payload int len int i j k u request unsigned short int h struct hdr field hf struct msg start ms struct sip uri miuri char myerror NULL ptrdiff t diff if len MAXENCODEDMSGMAXMESSAGELEN return 1 if parse headers msg HDREOHF 0 0 myerror in parse headers goto error memset payload 0 len ms msg first line if ms type SIPREQUEST request 1 else if ms type SIPREPLY request 0 else myerror message is neither request nor response goto error if request for h 0 h 32 j 0x01 h h if j ms u request method value break else h unsigned short ms u reply statuscode if h 32 myerror unknown message type n goto error h htons h memcpy payload h 2 h htons unsigned short int msg len memcpy payload MSGLENIDX h 2 if 0 diff get body msg msg buf myerror body starts before the message uh goto error else h htons unsigned short int diff memcpy payload CONTENTIDX h 2 payload METHODCODEIDX unsigned char request ms u request method s msg buf ms u reply status s msg buf payload METHODCODEIDX 1 unsigned char request ms u request method len ms u reply status len payload URIREASONIDX unsigned char request ms u request uri s msg buf ms u reply reason s msg buf payload URIREASONIDX 1 unsigned char request ms u request uri len ms u reply reason len payload VERSIONIDX unsigned char request ms u request version s msg buf ms u reply version s msg buf if request if parse uri ms u request uri s ms u request uri len miuri 0 LMERR s n ms u request uri len ms u request uri s myerror while parsing the RURI goto error if 0 j encode uri2 msg buf ms u request method s msg buf ms len ms u request uri miuri unsigned char payload REQUESTURIIDX 1 myerror ENCODEMSGERROR while encoding the RURI goto error payload REQUESTURIIDX unsigned char j k REQUESTURIIDX 1 j else k REQUESTURIIDX u k k for i 0 hf msg headers hf hf hf next i i j k 3 i for i 0 hf msg headers hf hf hf next k 3 payload k unsigned char hf type 0x FF h htons j memcpy payload k 1 h 2 if 0 i encode header msg hf unsigned char payload j MAXENCODEDMSGMAXMESSAGELEN j LMERR encoding header s n hf name len hf name s goto error k 3 continue j unsigned short int i payload u unsigned char k u 1 3 j htons j memcpy payload k 1 j 2 k 3 j ntohs j if len j msg len 1 LMERR not enough space to encode sip message n return 1 memcpy payload j msg buf msg len LMDBG msglen d msg starts at d n msg len j j htons j memcpy payload MSGSTARTIDX j 2 return GETPAYSIZE payload error LMERR s n myerror return 1 int jbig2 text region Jbig2 Ctx ctx Jbig2 Segment segment const byte segment data int offset 0 Jbig2 Region Segment Info region info Jbig2 Text Region Params params Jbig2 Image image NULL Jbig2 Symbol Dict dicts NULL int n dicts 0 uint16 t flags 0 uint16 t huffman flags 0 Jbig2 Arith Cx GR stats NULL int code 0 Jbig2 Word Stream ws NULL Jbig2 Arith State as NULL int table index 0 const Jbig2 Huffman Params huffman params NULL if segment data length 17 goto too short jbig2 get region segment info region info segment data offset 17 flags jbig2 get uint16 segment data offset offset 2 jbig2 error ctx JBI G2 SEVERITYDEBUG segment number text region header flags 0x 04x flags memset params 0 sizeof Jbig2 Text Region Params params SBHUFF flags 0x0001 params SBREFINE flags 0x0002 params LOGSBSTRIPS flags 0x000c 2 params SBSTRIPS 1 params LOGSBSTRIPS params REFCORNER Jbig2 Ref Corner flags 0x0030 4 params TRANSPOSED flags 0x0040 params SBCOMBOP Jbig2 Compose Op flags 0x0180 7 params SBDEFPIXEL flags 0x0200 params SBDSOFFSET flags 0x7 C00 10 if params SBDSOFFSET 0x0f params SBDSOFFSET 0x20 params SBRTEMPLATE flags 0x8000 if params SBDSOFFSET jbig2 error ctx JBI G2 SEVERITYDEBUG segment number text region has SBDSOFFSET d params SBDSOFFSET if params SBHUFF huffman flags jbig2 get uint16 segment data offset offset 2 if huffman flags 0x8000 jbig2 error ctx JBI G2 SEVERITYWARNING segment number reserved bit 15 of text region huffman flags is not zero else if params SBREFINE params SBRTEMPLATE params sbrat 0 segment data offset params sbrat 1 segment data offset 1 params sbrat 2 segment data offset 2 params sbrat 3 segment data offset 3 offset 4 params SBNUMINSTANCES jbig2 get uint32 segment data offset offset 4 if params SBHUFF switch huffman flags 0x0003 case 0 params SBHUFFFS jbig2 build huffman table ctx jbig2 huffman params F break case 1 params SBHUFFFS jbig2 build huffman table ctx jbig2 huffman params G break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom FS huffman table not found d table index goto cleanup1 params SBHUFFFS jbig2 build huffman table ctx huffman params table index break case 2 default code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region specified invalid FS huffman table goto cleanup1 break if params SBHUFFFSNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified FS huffman table goto cleanup1 switch huffman flags 0x000c 2 case 0 params SBHUFFDS jbig2 build huffman table ctx jbig2 huffman params H break case 1 params SBHUFFDS jbig2 build huffman table ctx jbig2 huffman params I break case 2 params SBHUFFDS jbig2 build huffman table ctx jbig2 huffman params J break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom DS huffman table not found d table index goto cleanup1 params SBHUFFDS jbig2 build huffman table ctx huffman params table index break if params SBHUFFDSNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified DS huffman table goto cleanup1 switch huffman flags 0x0030 4 case 0 params SBHUFFDT jbig2 build huffman table ctx jbig2 huffman params K break case 1 params SBHUFFDT jbig2 build huffman table ctx jbig2 huffman params L break case 2 params SBHUFFDT jbig2 build huffman table ctx jbig2 huffman params M break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom DT huffman table not found d table index goto cleanup1 params SBHUFFDT jbig2 build huffman table ctx huffman params table index break if params SBHUFFDTNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified DT huffman table goto cleanup1 switch huffman flags 0x00c0 6 case 0 params SBHUFFRDW jbig2 build huffman table ctx jbig2 huffman params N break case 1 params SBHUFFRDW jbig2 build huffman table ctx jbig2 huffman params O break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom RDW huffman table not found d table index goto cleanup1 params SBHUFFRDW jbig2 build huffman table ctx huffman params table index break case 2 default code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region specified invalid RDW huffman table goto cleanup1 break if params SBHUFFRDWNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified RDW huffman table goto cleanup1 switch huffman flags 0x0300 8 case 0 params SBHUFFRDH jbig2 build huffman table ctx jbig2 huffman params N break case 1 params SBHUFFRDH jbig2 build huffman table ctx jbig2 huffman params O break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom RDH huffman table not found d table index goto cleanup1 params SBHUFFRDH jbig2 build huffman table ctx huffman params table index break case 2 default code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region specified invalid RDH huffman table goto cleanup1 break if params SBHUFFRDHNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified RDH huffman table goto cleanup1 switch huffman flags 0x0c00 10 case 0 params SBHUFFRDX jbig2 build huffman table ctx jbig2 huffman params N break case 1 params SBHUFFRDX jbig2 build huffman table ctx jbig2 huffman params O break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom RDX huffman table not found d table index goto cleanup1 params SBHUFFRDX jbig2 build huffman table ctx huffman params table index break case 2 default code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region specified invalid RDX huffman table goto cleanup1 break if params SBHUFFRDXNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified RDX huffman table goto cleanup1 switch huffman flags 0x3000 12 case 0 params SBHUFFRDY jbig2 build huffman table ctx jbig2 huffman params N break case 1 params SBHUFFRDY jbig2 build huffman table ctx jbig2 huffman params O break case 3 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom RDY huffman table not found d table index goto cleanup1 params SBHUFFRDY jbig2 build huffman table ctx huffman params table index break case 2 default code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region specified invalid RDY huffman table goto cleanup1 break if params SBHUFFRDYNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified RDY huffman table goto cleanup1 switch huffman flags 0x4000 14 case 0 params SBHUFFRSIZE jbig2 build huffman table ctx jbig2 huffman params A break case 1 huffman params jbig2 find table ctx segment table index if huffman params NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number Custom RSIZE huffman table not found d table index goto cleanup1 params SBHUFFRSIZE jbig2 build huffman table ctx huffman params table index break if params SBHUFFRSIZENULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate text region specified RSIZE huffman table goto cleanup1 if huffman flags 0x8000 jbig2 error ctx JBI G2 SEVERITYWARNING segment number text region huffman flags bit 15 is set contrary to spec jbig2 error ctx JBI G2 SEVERITYINFO segment number text region d x d d d d symbols region info width region info height region info x region info y params SBNUMINSTANCES n dicts jbig2 sd count referred ctx segment if n dicts 0 dicts jbig2 sd list referred ctx segment else code jbig2 error ctx JBI G2 SEVERITYFATAL segment number text region refers to no symbol dictionaries goto cleanup1 if dicts NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number unable to retrive symbol dictionaries previous parsing error goto cleanup1 else int index if dicts 0 NULL code jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to find first referenced symbol dictionary goto cleanup1 for index 1 index n dicts index if dicts index NULL jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to find all referenced symbol dictionaries n dicts index int stats size params SBRTEMPLATE 1 10 1 13 GR stats jbig2 new ctx Jbig2 Arith Cx stats size if GR stats NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number could not allocate GR stats goto cleanup1 memset GR stats 0 stats size image jbig2 image new ctx region info width region info height if image NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number couldn t allocate text region image goto cleanup2 ws jbig2 word stream buf new ctx segment data offset segment data length offset if ws NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number couldn t allocate ws in text region image goto cleanup2 as jbig2 arith new ctx ws if as NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number couldn t allocate as in text region image goto cleanup2 if params SBHUFF int SBSYMCODELEN index int SBNUMSYMS 0 for index 0 index n dicts index SBNUMSYMS dicts index n symbols params IADT jbig2 arith int ctx new ctx params IAFS jbig2 arith int ctx new ctx params IADS jbig2 arith int ctx new ctx params IAIT jbig2 arith int ctx new ctx if params IADTNULL params IAFSNULL params IADSNULL params IAITNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number couldn t allocate text region image data goto cleanup3 for SBSYMCODELEN 0 1 SBSYMCODELENSBNUMSYMSSBSYMCODELEN params IAID jbig2 arith iaid ctx new ctx SBSYMCODELEN params IARI jbig2 arith int ctx new ctx params IARDW jbig2 arith int ctx new ctx params IARDH jbig2 arith int ctx new ctx params IARDX jbig2 arith int ctx new ctx params IARDY jbig2 arith int ctx new ctx if params IAIDNULL params IARINULL params IARDWNULL params IARDHNULL params IARDXNULL params IARDYNULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number couldn t allocate text region image data goto cleanup4 code jbig2 decode text region ctx segment params const Jbig2 Symbol Dict const dicts n dicts image segment data offset segment data length offset GR stats as ws if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to decode text region image data goto cleanup4 if segment flags 63 4 segment result jbig2 image clone ctx image else jbig2 error ctx JBI G2 SEVERITYDEBUG segment number composing dx d decoded text region onto page at d d region info width region info height region info x region info y jbig2 page add result ctx ctx pages ctx current page image region info x region info y region info op cleanup4 if params SBHUFF jbig2 arith iaid ctx free ctx params IAID jbig2 arith int ctx free ctx params IARI jbig2 arith int ctx free ctx params IARDW jbig2 arith int ctx free ctx params IARDH jbig2 arith int ctx free ctx params IARDX jbig2 arith int ctx free ctx params IARDY cleanup3 if params SBHUFF jbig2 arith int ctx free ctx params IADT jbig2 arith int ctx free ctx params IAFS jbig2 arith int ctx free ctx params IADS jbig2 arith int ctx free ctx params IAIT jbig2 free ctx allocator as jbig2 word stream buf free ctx ws cleanup2 jbig2 free ctx allocator GR stats jbig2 image release ctx image cleanup1 if params SBHUFF jbig2 release huffman table ctx params SBHUFFFS jbig2 release huffman table ctx params SBHUFFDS jbig2 release huffman table ctx params SBHUFFDT jbig2 release huffman table ctx params SBHUFFRDX jbig2 release huffman table ctx params SBHUFFRDY jbig2 release huffman table ctx params SBHUFFRDW jbig2 release huffman table ctx params SBHUFFRDH jbig2 release huffman table ctx params SBHUFFRSIZE jbig2 free ctx allocator dicts return code too short return jbig2 error ctx JBI G2 SEVERITYFATAL segment number Segment too short static int seqvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size int ret Seq Video Context seq avctx priv data if ret ff reget buffer avctx seq frame 0 av log seq avctx AVLOGERROR tiertexseqvideo reget buffer failed n return ret if seqvideo decode seq buf buf size return AVERRORINVALIDDATA if ret av frame ref data seq frame 0 return ret got frame 1 return buf size WORKSTATE ossl statem server pre work SSL s WORKSTATE wst OSSLSTATEM st s statem switch st hand state case TLSSTSWHELLOREQ s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s break case DTLSSTSWHELLOVERIFYREQUEST s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s st use timer 0 break case TLSSTSWSRVRHELLO if SSLISDTLS s st use timer 1 break case TLSSTSWSRVRDONE ifndef OPENSSLNOSCTP if SSLISDTLS s BIO dgram is sctp SSL get wbio s return dtls wait for dry s case TLSSTSWSESSIONTICKET if SSLISDTLS s st use timer 0 break case TLSSTSWCHANGE s session cipher s s3 tmp new cipher if s method ssl3 enc setup key block s ossl statem set error s return WORKERROR if SSLISDTLS s st use timer 0 return WORKFINISHEDCONTINUE case TLSSTOK return tls finish handshake s wst default break return int jbig2 end of stripe Jbig2 Ctx ctx Jbig2 Segment segment const uint8 t segment data Jbig2 Page page ctx pages ctx current page int end row end row jbig2 get int32 segment data if end row page end row jbig2 error ctx JBI G2 SEVERITYWARNING segment number end of stripe segment with non positive end row advance new end row d vs current end row d end row page end row else jbig2 error ctx JBI G2 SEVERITYINFO segment number end of stripe advancing end row to d end row page end row end row return 0 static int mpeg4 decode partition a Mpeg Enc Context s int mb num static const int8 t quant tab 4 1 2 1 2 mb num 0 s first slice line 1 for s mb y s mb height s mb y ff init block index s for s mb x s mb width s mb x const int xy s mb x s mb y s mb stride int cbpc int dir 0 mb num ff update block index s if s mb x s resync mb x s mb y s resync mb y 1 s first slice line 0 if s pict type AVPICTURETYPEI int i do if show bits long s gb 19 DCMARKER return mb num 1 cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc corrupted at d d n s mb x s mb y return 1 while cbpc 8 s cbp table xy cbpc 3 s current picture f mb type xy MBTYPEINTRA s mb intra 1 if cbpc 4 ff set qscale s s qscale quant tab get bits s gb 2 s current picture f qscale table xy s qscale s mbintra table xy 1 for i 0 i 6 i int dc pred dir int dc mpeg4 decode dc s i dc pred dir if dc 0 av log s avctx AVLOGERRORDC corrupted at d d n s mb x s mb y return 1 dir 1 if dc pred dir dir 1 s pred dir table xy dir else int mx my pred x pred y bits int16 t const mot val s current picture f motion val 0 s block index 0 const int stride s b8 stride 2 try again bits show bits s gb 17 if bits MOTIONMARKER return mb num 1 skip bits1 s gb if bits 0x10000 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s current picture f mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPEGMCMBTYPE L0 mx get amv s 0 my get amv s 1 else s current picture f mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 mx my 0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my if s mbintra table xy ff clean intra table entries s continue cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc corrupted at d d n s mb x s mb y return 1 if cbpc 20 goto try again s cbp table xy cbpc 8 3 s mb intra cbpc 4 0 if s mb intra s current picture f mb type xy MBTYPEINTRA s mbintra table xy 1 mot val 0 mot val 2 mot val 0 stride mot val 2 stride 0 mot val 1 mot val 3 mot val 1 stride mot val 3 stride 0 else if s mbintra table xy ff clean intra table entries s if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE cbpc 16 0 s mcsel get bits1 s gb else s mcsel 0 if cbpc 16 0 ff h263 pred motion s 0 0 pred x pred y if s mcsel mx ff h263 decode motion s pred x s f code if mx 0xffff return 1 my ff h263 decode motion s pred y s f code if my 0xffff return 1 s current picture f mb type xy MBTYPE 16x16 MBTYPE L0 else mx get amv s 0 my get amv s 1 s current picture f mb type xy MBTYPE 16x16 MBTYPEGMCMBTYPE L0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my else int i s current picture f mb type xy MBTYPE 8x8 MBTYPE L0 for i 0 i 4 i int16 t mot val ff h263 pred motion s i 0 pred x pred y mx ff h263 decode motion s pred x s f code if mx 0xffff return 1 my ff h263 decode motion s pred y s f code if my 0xffff return 1 mot val 0 mx mot val 1 my s mb x 0 return mb num int vp8 denoiser allocate V P8 DENOISER denoiser int width int height int num mb rows int num mb cols int mode int i assert denoiser denoiser num mb cols num mb cols for i 0 i MAXREFFRAMES i denoiser yv12 running avg i flags 0 if vp8 yv12 alloc frame buffer denoiser yv12 running avg i width height V P8 BORDERINPIXELS 0 vp8 denoiser free denoiser return 1 vpx memset denoiser yv12 running avg i buffer alloc 0 denoiser yv12 running avg i frame size denoiser yv12 mc running avg flags 0 if vp8 yv12 alloc frame buffer denoiser yv12 mc running avg width height V P8 BORDERINPIXELS 0 vp8 denoiser free denoiser return 1 vpx memset denoiser yv12 mc running avg buffer alloc 0 denoiser yv12 mc running avg frame size if vp8 yv12 alloc frame buffer denoiser yv12 last source width height V P8 BORDERINPIXELS 0 vp8 denoiser free denoiser return 1 vpx memset denoiser yv12 last source buffer alloc 0 denoiser yv12 last source frame size denoiser denoise state vpx calloc num mb rows num mb cols 1 vpx memset denoiser denoise state 0 num mb rows num mb cols vp8 denoiser set parameters denoiser mode denoiser nmse source diff 0 denoiser nmse source diff count 0 denoiser qp avg 0 denoiser qp threshold up 80 denoiser qp threshold down 128 denoiser bitrate threshold 200000 denoiser threshold aggressive mode 35 if width height 640 480 denoiser bitrate threshold 500000 denoiser threshold aggressive mode 100 else if width height 960 540 denoiser bitrate threshold 800000 denoiser threshold aggressive mode 150 else if width height 1280 720 denoiser bitrate threshold 2000000 denoiser threshold aggressive mode 1400 return 0 static void fill picture parameters struct dxva context ctx const H264 Context h DXVA Pic Params H264 pp const Picture current picture h cur pic ptr int i j memset pp 0 sizeof pp fill picture entry pp Curr Pic ff dxva2 get surface index ctx current picture h picture structure PICTBOTTOMFIELD pp Used For Reference Flags 0 pp Non Existing Frame Flags 0 for i 0 j 0 i FFARRAYELEMS pp Ref Frame List i const Picture r if j h short ref count r h short ref j else r NULL while r j h short ref count 16 r h long ref j h short ref count if r fill picture entry pp Ref Frame List i ff dxva2 get surface index ctx r r long ref 0 if r reference PICTTOPFIELD r field poc 0 INTMAX pp Field Order Cnt List i 0 r field poc 0 if r reference PICTBOTTOMFIELD r field poc 1 INTMAX pp Field Order Cnt List i 1 r field poc 1 pp Frame Num List i r long ref r pic id r frame num if r reference PICTTOPFIELD pp Used For Reference Flags 1 2 i 0 if r reference PICTBOTTOMFIELD pp Used For Reference Flags 1 2 i 1 else pp Ref Frame List i b Pic Entry 0xff pp Field Order Cnt List i 0 0 pp Field Order Cnt List i 1 0 pp Frame Num List i 0 pp w Frame Width In Mbs Minus1 h mb width 1 pp w Frame Height In Mbs Minus1 h mb height 1 pp num ref frames h sps ref frame count pp w Bit Fields h picture structure PICTFRAME 0 h sps mb aff h picture structure PICTFRAME 1 h sps residual color transform flag 2 0 3 h sps chroma format idc 4 h nal ref idc 0 6 h pps constrained intra pred 7 h pps weighted pred 8 h pps weighted bipred idc 9 1 11 h sps frame mbs only flag 12 h pps transform 8x8 mode 13 h sps level idc 31 14 1 15 pp bit depth luma minus8 h sps bit depth luma 8 pp bit depth chroma minus8 h sps bit depth chroma 8 if ctx workaround FFDXV A2 WORKAROUNDSCALINGLISTZIGZAG pp Reserved16 Bits 0 else pp Reserved16 Bits 3 pp Status Report Feedback Number 1 ctx report id pp Curr Field Order Cnt 0 0 if h picture structure PICTTOPFIELD current picture field poc 0 INTMAX pp Curr Field Order Cnt 0 current picture field poc 0 pp Curr Field Order Cnt 1 0 if h picture structure PICTBOTTOMFIELD current picture field poc 1 INTMAX pp Curr Field Order Cnt 1 current picture field poc 1 pp pic init qs minus26 h pps init qs 26 pp chroma qp index offset h pps chroma qp index offset 0 pp second chroma qp index offset h pps chroma qp index offset 1 pp Continuation Flag 1 pp pic init qp minus26 h pps init qp 26 pp num ref idx l0 active minus1 h pps ref count 0 1 pp num ref idx l1 active minus1 h pps ref count 1 1 pp Reserved8 Bits A 0 pp frame num h frame num pp log2 max frame num minus4 h sps log2 max frame num 4 pp pic order cnt type h sps poc type if h sps poc type 0 pp log2 max pic order cnt lsb minus4 h sps log2 max poc lsb 4 else if h sps poc type 1 pp delta pic order always zero flag h sps delta pic order always zero flag pp direct 8x8 inference flag h sps direct 8x8 inference flag pp entropy coding mode flag h pps cabac pp pic order present flag h pps pic order present pp num slice groups minus1 h pps slice group count 1 pp slice group map type h pps mb slice group map type pp deblocking filter control present flag h pps deblocking filter parameters present pp redundant pic cnt present flag h pps redundant pic cnt present pp Reserved8 Bits B 0 pp slice group change rate minus1 0 void ff clean h263 qscales Mpeg Enc Context s int i int8 t const qscale table s current picture f qscale table ff init qscale tab s for i 1 i s mb num i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 for i s mb num 2 i 0 i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 if s codec id AVCODECID H263 P for i 1 i s mb num i int mb xy s mb index2xy i if qscale table mb xy qscale table s mb index2xy i 1 s mb type mb xy CANDIDATEMBTYPEINTE R4 V s mb type mb xy int jbig2 page add result Jbig2 Ctx ctx Jbig2 Page page Jbig2 Image image int x int y Jbig2 Compose Op op if page image NULL jbig2 error ctx JBI G2 SEVERITYWARNING 1 page info possibly missing no image defined return 0 if page striped uint32 t new height y image height page end row if page image height new height jbig2 error ctx JBI G2 SEVERITYDEBUG 1 growing page buffer to d rows to accomodate new stripe new height jbig2 image resize ctx page image page image width new height jbig2 image compose ctx page image image x y page end row op return 0 static void encode breakout test V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col MVREFERENCEFRAME ref frame PREDICTIONMODE this mode unsigned int var y unsigned int sse y struct buf 2d yv12 mb MAXMBPLANE int rate int64 t dist MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi const BLOCKSIZE uv size get plane block size bsize xd plane 1 unsigned int var var y sse sse y unsigned int thresh ac unsigned int thresh dc if x encode breakout 0 const unsigned int max thresh 36000 const unsigned int min thresh MIN unsigned int x encode breakout 4 max thresh thresh ac xd plane 0 dequant 1 xd plane 0 dequant 1 9 thresh ac clamp thresh ac min thresh max thresh thresh ac b width log2 bsize b height log2 bsize thresh dc xd plane 0 dequant 0 xd plane 0 dequant 0 6 else thresh ac 0 thresh dc 0 if var thresh ac sse var thresh dc unsigned int sse u sse v unsigned int var u var v if x encode breakout 0 xd plane 1 pre 0 yv12 mb ref frame 1 xd plane 2 pre 0 yv12 mb ref frame 2 vp9 build inter predictors sbuv xd mi row mi col bsize var u cpi fn ptr uv size vf x plane 1 src buf x plane 1 src stride xd plane 1 dst buf xd plane 1 dst stride sse u if var u 4 thresh ac sse u var u thresh dc var v cpi fn ptr uv size vf x plane 2 src buf x plane 2 src stride xd plane 2 dst buf xd plane 2 dst stride sse v if var v 4 thresh ac sse v var v thresh dc x skip 1 rate cpi inter mode cost mbmi mode context ref frame INTEROFFSET this mode dist sse 4 static int select input picture Mpeg Enc Context s int i ret for i 1 i MAXPICTURECOUNT i s reordered input picture i 1 s reordered input picture i s reordered input picture MAXPICTURECOUNT 1 NULL if s reordered input picture 0 NULL s input picture 0 if s next picture ptr NULL s intra only s reordered input picture 0 s input picture 0 s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f coded picture number s coded picture number else int b frames if s avctx frame skip threshold s avctx frame skip factor if s picture in gop number s gop size skip check s s input picture 0 s next picture ptr av frame unref s input picture 0 f emms c ff vbv update s 0 goto no output pic if s flags CODECFLAGPAS S2 for i 0 i s max b frames 1 i int pict num s input picture 0 f display picture number i if pict num s rc context num entries break if s input picture i s rc context entry pict num 1 new pict type AVPICTURETYPEP break s input picture i f pict type s rc context entry pict num new pict type if s avctx b frame strategy 0 b frames s max b frames while b frames s input picture b frames b frames else if s avctx b frame strategy 1 for i 1 i s max b frames 1 i if s input picture i s input picture i b frame score 0 s input picture i b frame score get intra count s s input picture i f data 0 s input picture i 1 f data 0 s linesize 1 for i 0 i s max b frames 1 i if s input picture i NULL s input picture i b frame score 1 s mb num s avctx b sensitivity break b frames FFMAX 0 i 1 for i 0 i b frames 1 i s input picture i b frame score 0 else if s avctx b frame strategy 2 b frames estimate best b count s else av log s avctx AVLOGERROR illegal b frame strategy n b frames 0 emms c for i b frames 1 i 0 i int type s input picture i f pict type if type type AVPICTURETYPEB b frames i if s input picture b frames f pict type AVPICTURETYPEB b frames s max b frames av log s avctx AVLOGERROR warning too many b frames in a row n if s picture in gop number b frames s gop size if s mpv flags FFMPVFLAGSTRICTGOP s gop size s picture in gop number b frames s gop size s picture in gop number 1 else if s flags CODECFLAGCLOSEDGOP b frames 0 s input picture b frames f pict type AVPICTURETYPEI if s flags CODECFLAGCLOSEDGOP b frames s input picture b frames f pict type AVPICTURETYPEI b frames s reordered input picture 0 s input picture b frames if s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f pict type AVPICTURETYPEP s reordered input picture 0 f coded picture number s coded picture number for i 0 i b frames i s reordered input picture i 1 s input picture i s reordered input picture i 1 f pict type AVPICTURETYPEB s reordered input picture i 1 f coded picture number s coded picture number no output pic if s reordered input picture 0 s reordered input picture 0 reference s reordered input picture 0 f pict type AVPICTURETYPEB 3 0 ff mpeg unref picture s s new picture if ret ff mpeg ref picture s s new picture s reordered input picture 0 return ret if s reordered input picture 0 shared s avctx rc buffer size Picture pic int i ff find unused picture s 0 if i 0 return i pic s picture i pic reference s reordered input picture 0 reference if ff alloc picture s pic 0 0 return 1 copy picture attributes s pic f s reordered input picture 0 f av frame unref s reordered input picture 0 f s reordered input picture 0 shared 0 s current picture ptr pic else s current picture ptr s reordered input picture 0 for i 0 i 4 i s new picture f data i INPLACEOFFSET ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret s picture number s new picture f display picture number else ff mpeg unref picture s s new picture return 0 void init directory config directory config dcfg if dcfg NULL return if dcfg is enabled NOTSET dcfg is enabled 0 if dcfg reqbody access NOTSET dcfg reqbody access 0 if dcfg reqintercept oe NOTSET dcfg reqintercept oe 0 if dcfg reqbody buffering NOTSET dcfg reqbody buffering REQUESTBODYFORCEBUFOFF if dcfg reqbody inmemory limit NOTSET dcfg reqbody inmemory limit REQUESTBODYDEFAULTINMEMORYLIMIT if dcfg reqbody limit NOTSET dcfg reqbody limit REQUESTBODYDEFAULTLIMIT if dcfg reqbody no files limit NOTSET dcfg reqbody no files limit REQUESTBODYNOFILESDEFAULTLIMIT if dcfg resbody access NOTSET dcfg resbody access 0 if dcfg of limit NOTSET dcfg of limit RESPONSEBODYDEFAULTLIMIT if dcfg if limit action NOTSET dcfg if limit action REQUESTBODYLIMITACTIONREJECT if dcfg of limit action NOTSET dcfg of limit action RESPONSEBODYLIMITACTIONREJECT if dcfg of mime types NOTSETP dcfg of mime types apr table make dcfg mp 3 if dcfg of mime types cleared 1 apr table setn dcfg of mime types text plain 1 apr table setn dcfg of mime types text html 1 if dcfg debuglog fd NOTSETP dcfg debuglog fd NULL if dcfg debuglog name NOTSETP dcfg debuglog name NULL if dcfg debuglog level NOTSET dcfg debuglog level 0 if dcfg cookie format NOTSET dcfg cookie format 0 if dcfg argument separator NOTSET dcfg argument separator if dcfg cookiev0 separator NOTSETP dcfg cookiev0 separator NULL if dcfg rule inheritance NOTSET dcfg rule inheritance 1 if dcfg auditlog flag NOTSET dcfg auditlog flag 0 if dcfg auditlog type NOTSET dcfg auditlog type AUDITLOGSERIAL if dcfg max rule time NOTSET dcfg max rule time 0 if dcfg auditlog dirperms NOTSET dcfg auditlog dirperms CREATEMODEDIR if dcfg auditlog fileperms NOTSET dcfg auditlog fileperms CREATEMODE if dcfg auditlog fd NOTSETP dcfg auditlog fd NULL if dcfg auditlog2 fd NOTSETP dcfg auditlog2 fd NULL if dcfg auditlog name NOTSETP dcfg auditlog name NULL if dcfg auditlog2 name NOTSETP dcfg auditlog2 name NULL if dcfg auditlog storage dir NOTSETP dcfg auditlog storage dir NULL if dcfg auditlog parts NOTSETP dcfg auditlog parts ABCFHZ if dcfg auditlog relevant regex NOTSETP dcfg auditlog relevant regex NULL if dcfg tmp dir NOTSETP dcfg tmp dir guess tmp dir dcfg mp if dcfg upload dir NOTSETP dcfg upload dir NULL if dcfg upload keep files NOTSET dcfg upload keep files KEEPFILESOFF if dcfg upload validates files NOTSET dcfg upload validates files 0 if dcfg upload filemode NOTSET dcfg upload filemode 0600 if dcfg upload file limit NOTSET dcfg upload file limit 100 if dcfg data dir NOTSETP dcfg data dir NULL if dcfg webappid NOTSETP dcfg webappid default if dcfg sensor id NOTSETP dcfg sensor id default if dcfg http Blkey NOTSETP dcfg http Blkey NULL if dcfg content injection enabled NOTSET dcfg content injection enabled 0 if dcfg stream inbody inspection NOTSET dcfg stream inbody inspection 0 if dcfg stream outbody inspection NOTSET dcfg stream outbody inspection 0 if dcfg geo NOTSETP dcfg geo NULL if dcfg gsb NOTSETP dcfg gsb NULL if dcfg u map NOTSETP dcfg u map NULL if dcfg cache trans NOTSET dcfg cache trans MODSECCACHEDISABLED if dcfg cache trans incremental NOTSET dcfg cache trans incremental 0 if dcfg cache trans min apr size t NOTSET dcfg cache trans min 32 if dcfg cache trans max apr size t NOTSET dcfg cache trans max 1024 if dcfg cache trans maxitems apr size t NOTSET dcfg cache trans maxitems 512 if dcfg request encoding NOTSETP dcfg request encoding NULL if dcfg disable backend compression NOTSET dcfg disable backend compression 0 if dcfg col timeout NOTSET dcfg col timeout 3600 if dcfg crypto key NOTSETP dcfg crypto key getkey dcfg mp if dcfg crypto key len NOTSET dcfg crypto key len strlen dcfg crypto key if dcfg crypto key add NOTSET dcfg crypto key add HASHKEYONLY if dcfg crypto param name NOTSETP dcfg crypto param name crypt if dcfg hash is enabled NOTSET dcfg hash is enabled HASHDISABLED if dcfg hash enforcement NOTSET dcfg hash enforcement HASHDISABLED if dcfg crypto hash href rx NOTSET dcfg crypto hash href rx 0 if dcfg crypto hash faction rx NOTSET dcfg crypto hash faction rx 0 if dcfg crypto hash location rx NOTSET dcfg crypto hash location rx 0 if dcfg crypto hash iframesrc rx NOTSET dcfg crypto hash iframesrc rx 0 if dcfg crypto hash framesrc rx NOTSET dcfg crypto hash framesrc rx 0 if dcfg crypto hash href pm NOTSET dcfg crypto hash href pm 0 if dcfg crypto hash faction pm NOTSET dcfg crypto hash faction pm 0 if dcfg crypto hash location pm NOTSET dcfg crypto hash location pm 0 if dcfg crypto hash iframesrc pm NOTSET dcfg crypto hash iframesrc pm 0 if dcfg crypto hash framesrc pm NOTSET dcfg crypto hash framesrc pm 0 if dcfg xml external entity NOTSET dcfg xml external entity 0 static Asn1 Generic Decode Asn1 Der Printable String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 PRINTSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL strlcpy a str const char d ptr length 1 a str length 0 d ptr length a length d ptr buffer return a static vpx fixed buf t pass0 vpx image t raw FILE infile const Vpx Interface encoder const vpx codec enc cfg t cfg vpx codec ctx t codec int frame count 0 vpx fixed buf t stats NULL 0 if vpx codec enc init codec encoder codec interface cfg 0 die codec codec Failed to initialize encoder while vpx img read raw infile frame count get frame stats codec raw frame count 1 0 VPXDLGOODQUALITY stats while get frame stats codec NULL frame count 1 0 VPXDLGOODQUALITY stats printf Pass 0 complete Processed d frames n frame count if vpx codec destroy codec die codec codec Failed to destroy codec return stats static int vc1 decode p mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int val int first block 1 int dst idx off int pred flag int block cbp 0 pat block tt 0 int idx mbmode 0 mquant v pq idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 v mb type 0 s block index i 1 dst idx i 2 val cbp 5 i 1 v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if idx mbmode 5 dmv x dmv y pred flag 0 if idx mbmode 1 get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v 0 dmv x dmv y 1 v range x v range y v mb type 0 pred flag 0 vc1 mc 1mv v 0 mb has coeffs idx mbmode 2 else v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x dmv y pred flag 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v i dmv x dmv y 0 v range x v range y v mb type 0 pred flag 0 vc1 mc 4mv luma v i 0 else if i 4 vc1 mc 4mv chroma v 0 mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 if s mb x s mb width 1 memmove v is intra base v is intra sizeof v is intra base 0 s mb stride return 0 static void pred spatial direct motion H264 Context const h int mb type int b8 stride 2 int b4 stride h b stride int mb xy h mb xy mb y h mb y int mb type col 2 const int16 t l1mv0 2 l1mv1 2 const int8 t l1ref0 l1ref1 const int is b8x8 IS 8 X8 mb type unsigned int sub mb type MBTYPE L0 L1 int i8 i4 int ref 2 int mv 2 int list assert h ref list 1 0 reference 3 await reference mb row h h ref list 1 0 h mb y ISINTERLACED mb type list 2 list int left ref h ref cache list scan8 0 1 int top ref h ref cache list scan8 0 8 int refc h ref cache list scan8 0 8 4 const int16 t C h mv cache list scan8 0 8 4 if refc PARTNOTAVAILABLE refc h ref cache list scan8 0 8 1 C h mv cache list scan8 0 8 1 ref list FFMI N3 unsigned left ref unsigned top ref unsigned refc if ref list 0 const int16 t const A h mv cache list scan8 0 1 const int16 t const B h mv cache list scan8 0 8 int match count left ref ref list top ref ref list refc ref list if match count 1 mv list pack16to32 mid pred A 0 B 0 C 0 mid pred A 1 B 1 C 1 else assert match count 1 if left ref ref list mv list AVR N32 AA else if top ref ref list mv list AVR N32 AB else mv list AVR N32 AC else int mask MBTYPE L0 2 list mv list 0 ref list 1 if is b8x8 mb type mask sub mb type mask if ref 0 0 ref 1 0 ref 0 ref 1 0 if is b8x8 mb type MBTYPE L0 L1 sub mb type MBTYPE L0 L1 if is b8x8 mv 0 mv 1 fill rectangle h ref cache 0 scan8 0 4 4 8 uint8 t ref 0 1 fill rectangle h ref cache 1 scan8 0 4 4 8 uint8 t ref 1 1 fill rectangle h mv cache 0 scan8 0 4 4 8 0 4 fill rectangle h mv cache 1 scan8 0 4 4 8 0 4 mb type mb type MBTYPE 8x8 MBTYPE 16x8 MBTYPE 8x16 MBTYPE P1 L0 MBTYPE P1 L1 MBTYPE 16x16 MBTYPEDIREC T2 return if ISINTERLACED h ref list 1 0 mb type mb xy if ISINTERLACED mb type mb y h mb y 1 h col parity mb xy h mb x h mb y 1 h col parity h mb stride b8 stride 0 else mb y h col fieldoff mb xy h mb stride h col fieldoff goto single col else if ISINTERLACED mb type mb y h mb y 1 mb xy h mb x h mb y 1 h mb stride mb type col 0 h ref list 1 0 mb type mb xy mb type col 1 h ref list 1 0 mb type mb xy h mb stride b8 stride 2 4 h mb stride b4 stride 6 if ISINTERLACED mb type col 0 ISINTERLACED mb type col 1 mb type col 0 MBTYPEINTERLACED mb type col 1 MBTYPEINTERLACED sub mb type MBTYPE 16x16 MBTYPEDIREC T2 if mb type col 0 MBTYPE 16x16 ORINTRA mb type col 1 MBTYPE 16x16 ORINTRA is b8x8 mb type MBTYPE 16x8 MBTYPEDIREC T2 else mb type MBTYPE 8x8 else single col mb type col 0 mb type col 1 h ref list 1 0 mb type mb xy sub mb type MBTYPE 16x16 MBTYPEDIREC T2 if is b8x8 mb type col 0 MBTYPE 16x16 ORINTRA mb type MBTYPE 16x16 MBTYPEDIREC T2 else if is b8x8 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 mb type MBTYPEDIREC T2 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 else if h sps direct 8x8 inference flag sub mb type MBTYPE 8x8 MBTYPE 16x16 mb type MBTYPE 8x8 await reference mb row h h ref list 1 0 mb y l1mv0 h ref list 1 0 motion val 0 h mb2b xy mb xy l1mv1 h ref list 1 0 motion val 1 h mb2b xy mb xy l1ref0 h ref list 1 0 ref index 0 4 mb xy l1ref1 h ref list 1 0 ref index 1 4 mb xy if b8 stride if h mb y 1 l1ref0 2 l1ref1 2 l1mv0 2 b4 stride l1mv1 2 b4 stride if ISINTERLACED mb type ISINTERLACED mb type col 0 int n 0 for i8 0 i8 4 i8 int x8 i8 1 int y8 i8 1 int xy8 x8 y8 b8 stride int xy4 3 x8 y8 b4 stride int a b if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 0 scan8 i8 4 2 2 8 uint8 t ref 0 1 fill rectangle h ref cache 1 scan8 i8 4 2 2 8 uint8 t ref 1 1 if ISINTRA mb type col y8 h ref list 1 0 long ref l1ref0 xy8 0 FFABS l1mv0 xy4 0 1 FFABS l1mv0 xy4 1 1 l1ref0 xy8 0 l1ref1 xy8 0 FFABS l1mv1 xy4 0 1 FFABS l1mv1 xy4 1 1 a b 0 if ref 0 0 a mv 0 if ref 1 0 b mv 1 n else a mv 0 b mv 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 a 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 b 4 if is b8x8 n 3 mb type mb type MBTYPE 8x8 MBTYPE 16x8 MBTYPE 8x16 MBTYPE P1 L0 MBTYPE P1 L1 MBTYPE 16x16 MBTYPEDIREC T2 else if IS 16 X16 mb type int a b fill rectangle h ref cache 0 scan8 0 4 4 8 uint8 t ref 0 1 fill rectangle h ref cache 1 scan8 0 4 4 8 uint8 t ref 1 1 if ISINTRA mb type col 0 h ref list 1 0 long ref l1ref0 0 0 FFABS l1mv0 0 0 1 FFABS l1mv0 0 1 1 l1ref0 0 0 l1ref1 0 0 FFABS l1mv1 0 0 1 FFABS l1mv1 0 1 1 h x264 build 33 U a b 0 if ref 0 0 a mv 0 if ref 1 0 b mv 1 else a mv 0 b mv 1 fill rectangle h mv cache 0 scan8 0 4 4 8 a 4 fill rectangle h mv cache 1 scan8 0 4 4 8 b 4 else int n 0 for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h mv cache 0 scan8 i8 4 2 2 8 mv 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 mv 1 4 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 uint8 t ref 0 1 fill rectangle h ref cache 1 scan8 i8 4 2 2 8 uint8 t ref 1 1 assert b8 stride 2 if ISINTRA mb type col 0 h ref list 1 0 long ref l1ref0 i8 0 l1ref0 i8 0 l1ref1 i8 0 h x264 build 33 U const int16 t l1mv 2 l1ref0 i8 0 l1mv0 l1mv1 if ISSUB 8 X8 sub mb type const int16 t mv col l1mv x8 3 y8 3 b4 stride if FFABS mv col 0 1 FFABS mv col 1 1 if ref 0 0 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 if ref 1 0 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 n 4 else int m 0 for i4 0 i4 4 i4 const int16 t mv col l1mv x8 2 i4 1 y8 2 i4 1 b4 stride if FFABS mv col 0 1 FFABS mv col 1 1 if ref 0 0 AVZER O32 h mv cache 0 scan8 i8 4 i4 if ref 1 0 AVZER O32 h mv cache 1 scan8 i8 4 i4 m if m 3 h sub mb type i8 MBTYPE 16x16 MBTYPE 8x8 n m if is b8x8 n 15 mb type mb type MBTYPE 8x8 MBTYPE 16x8 MBTYPE 8x16 MBTYPE P1 L0 MBTYPE P1 L1 MBTYPE 16x16 MBTYPEDIREC T2 int64 t vp9 rd pick inter mode sb V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg struct macroblockd plane const pd xd plane PREDICTIONMODE this mode MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i k int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE int mv single newmv MAXREFFRAMES 0 INTERPFILTER single inter filter MBMODECOUNTMAXREFFRAMES int single skippable MBMODECOUNTMAXREFFRAMES static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best tx rd TXMODES int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int best mode skippable 0 int midx best mode index 1 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p int64 t best intra rd IN T64 MAX unsigned int best pred sse UINTMAXPREDICTIONMODE best intra mode DCPRED int rate uv intra TXSIZES rate uv tokenonly TXSIZES int64 t dist uv TXSIZES int skip uv TXSIZESPREDICTIONMODE mode uv TXSIZES const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int best skip2 0 uint8 t ref frame skip mask 2 0 uint16 t mode skip mask MAXREFFRAMES 0 int mode skip start cpi sf mode skip start 1 const int const rd threshes rd opt threshes segment id bsize const int const rd thresh freq fact rd opt thresh freq fact bsize int mode threshold MAXMODES int mode map rd opt mode map bsize const int mode search skip flags cpi sf mode search skip flags vp9 zero best mbmode x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i TXMODES i best tx rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX for i 0 i TXSIZES i rate uv intra i INTMAX for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i 0 i MBMODECOUNT i for k 0 k MAXREFFRAMES k single inter filter i k SWITCHABLE single skippable i k 0 returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame x pred mv sad ref frame INTMAX if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK else if cpi sf reference masking for i LASTFRAME i ALTREFFRAME i if x pred mv sad ref frame 2 x pred mv sad i mode skip mask ref frame INTERNEARESTNEARZERO break if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 ref frame skip mask 0 1 LASTFRAME 1 GOLDENFRAME ref frame skip mask 1 SECONDREFFRAMEMASK mode skip mask ALTREFFRAMEINTERNEARESTNEARZERO if frame mv NEARMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARMV if frame mv NEARESTMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARESTMV if cpi rc is src frame alt ref if cpi sf alt ref search fp mode skip mask ALTREFFRAME 0 ref frame skip mask 0 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK if bsize cpi sf max intra bsize ref frame skip mask 0 1 INTRAFRAME ref frame skip mask 1 1 INTRAFRAME mode skip mask INTRAFRAME cpi sf intra y mode mask max txsize lookup bsize for i 0 i MAXMODES i mode threshold i int64 t rd threshes i rd thresh freq fact i 5 midx cpi sf schedule mode search mode skip start 0 while midx 4 uint8 t end pos 0 for i 5 i midx i if mode threshold mode map i 1 mode threshold mode map i uint8 t tmp mode map i mode map i mode map i 1 mode map i 1 tmp end pos i midx end pos for midx 0 midx MAXMODES midx int mode index mode map midx int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int64 t tx cache TXMODES int this skip2 0 int64 t total sse IN T64 MAX int early term 0 this mode vp9 mode order mode index mode ref frame vp9 mode order mode index ref frame 0 second ref frame vp9 mode order mode index ref frame 1 if midx mode skip start best mode index 0 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 LASTFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 GOLDENFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 ALTREFMODEMASK break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if mode skip mask ref frame 1 this mode continue if best mode skippable cpi sf schedule mode search mode threshold mode index 1 if best rd mode threshold mode index continue if cpi sf motion field mode search const int mi width MIN num 8x8 blocks wide lookup bsize tile mi col end mi col const int mi height MIN num 8x8 blocks high lookup bsize tile mi row end mi row const int bsl mi width log2 bsize int cb partition search ctrl mi row mi col bsl get chessboard index cm current video frame 0x1 MBMODEINFO ref mbmi int const motion 1 int skip ref frame cb partition search ctrl MVREFERENCEFRAME rf NONE int mv ref mv ref mv as int INVALIDMV if mi row 1 tile mi row start ref mv xd mi xd mi stride src mi mbmi mv 0 rf xd mi xd mi stride src mi mbmi ref frame 0 for i 0 i mi width i ref mbmi xd mi xd mi stride i src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if mi col 1 tile mi col start if ref mv as int INVALIDMV ref mv xd mi 1 src mi mbmi mv 0 if rf NONE rf xd mi 1 src mi mbmi ref frame 0 for i 0 i mi height i ref mbmi xd mi i xd mi stride 1 src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if skip ref frame this mode NEARESTMV this mode NEWMV if rf INTRAFRAME if ref frame rf continue if const motion if this mode NEARMV this mode ZEROMV continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if mode search skip flags FLAGSKIPCOMPBESTINTRA best mode index 0 best mbmode ref frame 0 INTRAFRAME continue mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if ref frame INTRAFRAME if cpi sf adaptive mode search if x source variance num pels log2 lookup bsize best pred sse continue if this mode DCPRED const unsigned int skip intra var thresh 64 if mode search skip flags FLAGSKIPINTRALOWVAR x source variance skip intra var thresh continue if mode search skip flags FLAGSKIPINTRABESTINTER this mode D45 PRED this mode TMPRED if best mode index 0 best mbmode ref frame 0 INTRAFRAME continue if mode search skip flags FLAGSKIPINTRADIRMISMATCH if conditional skipintra this mode best intra mode continue else const MVREFERENCEFRAME ref frames 2 ref frame second ref frame if check best zero mv cpi mbmi mode context frame mv this mode ref frames continue mbmi mode this mode mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter mbmi mv 0 as int mbmi mv 1 as int 0 x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i for i 0 i TXMODES i tx cache i IN T64 MAX if ref frame INTRAFRAMETXSIZE uv tx super block yrd cpi x rate y distortion y skippable NULL bsize tx cache best rd if rate y INTMAX continue uv tx get uv tx size impl mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y if rate uv intra uv tx INTMAX choose intra uv mode cpi ctx bsize uv tx rate uv intra uv tx rate uv tokenonly uv tx dist uv uv tx skip uv uv tx mode uv uv tx rate uv rate uv tokenonly uv tx distortion uv dist uv uv tx skippable skippable skip uv uv tx mbmi uv mode mode uv uv tx rate2 rate y cpi mbmode cost mbmi mode rate uv intra uv tx if this mode DCPRED this mode TMPRED rate2 intra cost penalty distortion2 distortion y distortion uv else this rd handle inter mode cpi x bsize tx cache rate2 distortion2 skippable rate y distortion y rate uv distortion uv disable skip frame mv mi row mi col single newmv single inter filter single skippable total sse best rd if this rd IN T64 MAX continue compmode cost vp9 cost bit comp mode p comp pred if cm reference mode REFERENCEMODESELECT rate2 compmode cost if comp pred rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if skippable rate2 rate y rate uv rate2 vp9 cost bit vp9 get skip prob cm xd 1 else if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if ref frame INTRAFRAME if this rd best intra rd best intra rd this rd best intra mode mbmi mode if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip int max plane MAXMBPLANE if mode excluded best mode index mode index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 else best pred sse x pred sse ref frame returnrate rate2 returndistortion distortion2 best rd this rd best mbmode mbmi best skip2 this skip2 best mode skippable skippable if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk mbmi tx size sizeof uint8 t ctx num 4x4 blk if mode search skip flags FLAGEARLYTERMINATE mode index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred if single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter for i 0 i SWITCHABLEFILTERCONTEXTS i int64 t adj rd if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 tx cache ALLOW 16 X16 tx cache ALLOW 8 X8 tx cache ALLOW 32 X32 tx cache ALLOW 16 X16 if mode excluded this rd IN T64 MAX for i 0 i TXMODES tx cache i IN T64 MAX i int64 t adj rd IN T64 MAX adj rd this rd tx cache i tx cache cm tx mode if adj rd best tx rd i best tx rd i adj rd if early term break if x skip comp pred break if best mbmode mode NEWMV const MVREFERENCEFRAME refs 2 best mbmode ref frame 0 best mbmode ref frame 1 int comp pred mode refs 1 INTRAFRAME if frame mv NEARESTMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARESTMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARESTMV else if frame mv NEARMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARMV else if best mbmode mv 0 as int 0 comp pred mode best mbmode mv 1 as int 0 comp pred mode best mbmode mode ZEROMV if best mode index 0 best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAMETXSIZE uv tx size mbmi best mbmode uv tx size get uv tx size mbmi xd plane 1 rd pick intra sbuv mode cpi x ctx rate uv intra uv tx size rate uv tokenonly uv tx size dist uv uv tx size skip uv uv tx size bsize BLOCK 8 X8 BLOCK 8 X8 bsize uv tx size assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode if cpi rc is src frame alt ref update rd thresh fact cpi bsize best mode index mbmi best mbmode x skip best skip2 for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 for i 0 i TXMODES i if best tx rd i IN T64 MAX best tx diff i 0 else best tx diff i best rd best tx rd i else vp9 zero best filter diff vp9 zero best tx diff x skip best mode skippable store coding context x ctx best mode index best pred diff best tx diff best filter diff best mode skippable return best rd static int cllc decode frame AV Codec Context avctx void data int got picture ptr AV Packet avpkt CLLC Context ctx avctx priv data AV Frame pic data uint8 t src avpkt data uint32 t info tag info offset int data size Get Bit Context gb int coding type ret info offset 0 info tag AVR L32 src if info tag MKTAGINFO info offset AVR L32 src 4 if info offset UIN T32 MAX 8 info offset 8 avpkt size av log avctx AVLOGERROR Invalid INFO header offset 0x 08 X is too large n info offset return AVERRORINVALIDDATA info offset 8 src info offset av log avctx AVLOGDEBUG Skipping INFO chunk n data size avpkt size info offset 1 av fast padded malloc ctx swapped buf ctx swapped buf size data size if ctx swapped buf av log avctx AVLOGERROR Could not allocate swapped buffer n return AVERRORENOMEM ctx dsp bswap16 buf uint16 t ctx swapped buf uint16 t src data size 2 init get bits gb ctx swapped buf data size 8 coding type AVR L32 src 8 0x FF av log avctx AVLOGDEBUG Frame coding type d n coding type switch coding type case 1 case 2 avctx pix fmt AVPIXFMTRG B24 avctx bits per raw sample 8 ret ff get buffer avctx pic 0 if ret 0 av log avctx AVLOGERROR Could not allocate buffer n return ret ret decode rgb24 frame ctx gb pic if ret 0 return ret break case 3 avctx pix fmt AVPIXFMTARGB avctx bits per raw sample 8 ret ff get buffer avctx pic 0 if ret 0 av log avctx AVLOGERROR Could not allocate buffer n return ret ret decode argb frame ctx gb pic if ret 0 return ret break default av log avctx AVLOGERROR Unknown coding type d n coding type return AVERRORINVALIDDATA pic key frame 1 pic pict type AVPICTURETYPEI got picture ptr 1 return avpkt size static int truemotion1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int ret buf size avpkt size True Motion1 Context s avctx priv data s buf buf s size buf size if ret truemotion1 decode header s 0 return ret s frame reference 1 s frame buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx s frame 0 av log s avctx AVLOGERROR get buffer failed n return ret if compression types s compression algorithm ALGORG B24 H truemotion1 decode 24bit s else if compression types s compression algorithm ALGONOP truemotion1 decode 16bit s got frame 1 AV Frame data s frame return buf size static gboolean logcat dump text wtap dumper wdh const struct wtap pkthdr phdr const guint8 pd int err gchar buf gint length gchar priority const struct logger entry log entry struct logger entry pd const struct logger entry v2 log entry v2 struct logger entry v2 pd gint payload length const gchar tag gint32 pid gint32 tid gint32 seconds gint32 milliseconds const gchar msg begin gint msg pre skip gchar log gchar log part gchar log next const union wtap pseudo header pseudo header phdr pseudo header const struct dumper t dumper const struct dumper t wdh priv if phdr rec type RECTYPEPACKET err WTAPERRRECTYPEUNSUPPORTED return FALSE payload length GIN T32 FROMLE log entry len pid GIN T32 FROMLE log entry pid tid GIN T32 FROMLE log entry tid seconds GIN T32 FROMLE log entry sec milliseconds GIN T32 FROMLE log entry nsec 1000000 if pseudo header logcat version 1 priority get priority log entry msg 0 tag log entry msg 1 msg pre skip 1 strlen tag 1 msg begin log entry msg msg pre skip else if pseudo header logcat version 2 priority get priority log entry v2 msg 0 tag log entry v2 msg 1 msg pre skip 1 strlen tag 1 msg begin log entry v2 msg msg pre skip else err WTAPERRUNSUPPORTED return FALSE log g strndup msg begin payload length msg pre skip log next log do log part log next if dumper type DUMPLONG log next NULL else log next strchr log part n if log next NULL log next 0 log next if log next 0 log next NULL buf logcat log dumper seconds milliseconds pid tid priority tag log part if buf g free log return FALSE length guint32 strlen buf if wtap dump file write wdh buf length err g free log return FALSE wdh bytes dumped length while log next NULL g free log return int main int argc char argv struct event signal int event init event set signal int SIGINTEVSIGNALEVPERSIST signal cb signal int event add signal int NULL event dispatch return 0 static void write header FILE sql file char db name if opt xml fputs xml version 1 0 n sql file fputs mysqldump sql file fputs xmlns xsi http fputs n sql file check io sql file else if opt compact print comment sql file 0 My SQL dump s Distrib s for s s n n DUMPVERSIONMYSQLSERVERVERSIONSYSTEMTYPEMACHINETYPE print comment sql file 0 Host s Database s n current host current host localhost db name db name print comment sql file 0 n print comment sql file 0 Server version t s n mysql get server info mysql connection if opt set charset fprintf sql file n n n n n default charset if opt tz utc fprintf sql file n fprintf sql file n if path if opt no create info fprintf md result file n fprintf md result file n fprintf sql file n n path NOAUTOVALUEONZERO compatible mode normal str 0 0 compatible mode normal str check io sql file static int skip check Mpeg Enc Context s Picture p Picture ref int x y plane int score 0 int64 t score64 0 for plane 0 plane 3 plane const int stride p f linesize plane const int bw plane 1 2 for y 0 y s mb height bw y for x 0 x s mb width bw x int off p f type FFBUFFERTYPESHARED 0 16 uint8 t dptr p f data plane 8 x y stride off uint8 t rptr ref f data plane 8 x y stride int v s dsp frame skip cmp 1 s dptr rptr stride 8 switch s avctx frame skip exp case 0 score FFMAX score v break case 1 score FFABS v break case 2 score v v break case 3 score64 FFABS v v int64 t v break case 4 score64 v v int64 t v v break if score score64 score if score64 s avctx frame skip threshold return 1 if score64 s avctx frame skip factor int64 t s lambda 8 return 1 return 0 void traverse commit list struct rev info revs show commit fn show commit show object fn show object void data int i struct commit commit struct strbuf base strbuf init base PATHMAX while commit get revision revs NULL if commit tree add pending tree revs commit tree show commit commit data for i 0 i revs pending nr i struct object array entry pending revs pending objects i struct object obj pending item const char name pending name const char path pending path if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN show object obj NULL name data continue if path path if obj type OBJTREE process tree revs struct tree obj show object NULL base path data continue if obj type OBJBLOB process blob revs struct blob obj show object NULL path data continue die unknown pending object s s oid to hex obj oid name object array clear revs pending strbuf release base int evbuffer add struct evbuffer buf const void data size t datlen size t used buf misalign buf off size t oldoff buf off if buf totallen used datlen if evbuffer expand buf datlen 1 return 1 memcpy buf buffer buf off data datlen buf off datlen if datlen buf cb NULL buf cb buf oldoff buf off buf cbarg return 0 Archive Handle Clone Archive Archive Handle AH Archive Handle clone clone Archive Handle pg malloc sizeof Archive Handle memcpy clone AH sizeof Archive Handle memset clone sqlparse 0 sizeof clone sqlparse clone connection NULL clone conn Cancel NULL clone curr User NULL clone curr Schema NULL clone curr Tablespace NULL clone curr With Oids 1 if clone saved Password clone saved Password pg strdup clone saved Password clone public n errors 0 if AH mode arch Mode Read Restore Options ropt AH public ropt Assert AH connection NULL Connect Database Archive clone ropt dbname ropt pghost ropt pgport ropt username ropt prompt Password do Set Fixed Output State clone else PQ Exp Buffer Data connstr char pghost char pgport char username Assert AH connection NULL init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr P Qdb AH connection pghost P Qhost AH connection pgport P Qport AH connection username P Quser AH connection Connect Database Archive clone connstr data pghost pgport username TRINO term PQ Exp Buffer connstr clone Clone Ptr clone Assert clone connection NULL return clone static int xwd decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame p avctx coded frame const uint8 t buf avpkt data int i ret buf size avpkt size uint32 t version header size vclass ncolors uint32 t xoffset be bpp lsize rsize uint32 t pixformat pixdepth bunit bitorder bpad uint32 t rgb 3 uint8 t ptr Get Byte Context gb if buf size XWDHEADERSIZE return AVERRORINVALIDDATA bytestream2 init gb buf buf size header size bytestream2 get be32u gb version bytestream2 get be32u gb if version XWDVERSION av log avctx AVLOGERROR unsupported version n return AVERRORINVALIDDATA if buf size header size header size XWDHEADERSIZE av log avctx AVLOGERROR invalid header size n return AVERRORINVALIDDATA pixformat bytestream2 get be32u gb pixdepth bytestream2 get be32u gb avctx width bytestream2 get be32u gb avctx height bytestream2 get be32u gb xoffset bytestream2 get be32u gb be bytestream2 get be32u gb bunit bytestream2 get be32u gb bitorder bytestream2 get be32u gb bpad bytestream2 get be32u gb bpp bytestream2 get be32u gb lsize bytestream2 get be32u gb vclass bytestream2 get be32u gb rgb 0 bytestream2 get be32u gb rgb 1 bytestream2 get be32u gb rgb 2 bytestream2 get be32u gb bytestream2 skipu gb 8 ncolors bytestream2 get be32u gb bytestream2 skipu gb header size XWDHEADERSIZE 20 av log avctx AVLOGDEBUG pixformat d pixdepth d bunit d bitorder d bpad d n pixformat pixdepth bunit bitorder bpad av log avctx AVLOGDEBUG vclass d ncolors d bpp d be d lsize d xoffset d n vclass ncolors bpp be lsize xoffset av log avctx AVLOGDEBUG red 0x green 0x blue 0x n rgb 0 rgb 1 rgb 2 if pixformat XWDZPIXMAP av log avctx AVLOGERROR invalid pixmap format n return AVERRORINVALIDDATA if pixdepth 0 pixdepth 32 av log avctx AVLOGERROR invalid pixmap depth n return AVERRORINVALIDDATA if xoffset av log ask for sample avctx unsupported xoffset d n xoffset return AVERRORPATCHWELCOME if be 1 av log avctx AVLOGERROR invalid byte order n return AVERRORINVALIDDATA if bitorder 1 av log avctx AVLOGERROR invalid bitmap bit order n return AVERRORINVALIDDATA if bunit 8 bunit 16 bunit 32 av log avctx AVLOGERROR invalid bitmap unit n return AVERRORINVALIDDATA if bpad 8 bpad 16 bpad 32 av log avctx AVLOGERROR invalid bitmap scan line pad n return AVERRORINVALIDDATA if bpp 0 bpp 32 av log avctx AVLOGERROR invalid bits per pixel n return AVERRORINVALIDDATA if ncolors 256 av log avctx AVLOGERROR invalid number of entries in colormap n return AVERRORINVALIDDATA if ret av image check size avctx width avctx height 0 NULL 0 return ret rsize FFALIGN avctx width bpp bpad 8 if lsize rsize av log avctx AVLOGERROR invalid bytes per scan line n return AVERRORINVALIDDATA if bytestream2 get bytes left gb ncolors XWDCMAPSIZE avctx height lsize av log avctx AVLOGERROR input buffer too small n return AVERRORINVALIDDATA if pixformat XWDZPIXMAP av log avctx AVLOGERROR pixmap format d unsupported n pixformat return AVERRORPATCHWELCOME avctx pix fmt AVPIXFMTNONE switch vclass case XWDSTATICGRAY case XWDGRAYSCALE if bpp 1 return AVERRORINVALIDDATA if pixdepth 1 avctx pix fmt AVPIXFMTMONOWHITE break case XWDSTATICCOLOR case XWDPSEUDOCOLOR if bpp 8 avctx pix fmt AVPIXFMTPA L8 break case XWDTRUECOLOR case XWDDIRECTCOLOR if bpp 16 bpp 24 bpp 32 return AVERRORINVALIDDATA if bpp 16 pixdepth 15 if rgb 0 0x7 C00 rgb 1 0x3 E0 rgb 2 0x1 F avctx pix fmt be AVPIXFMTRG B555 BEAVPIXFMTRG B555 LE else if rgb 0 0x1 F rgb 1 0x3 E0 rgb 2 0x7 C00 avctx pix fmt be AVPIXFMTBG R555 BEAVPIXFMTBG R555 LE else if bpp 16 pixdepth 16 if rgb 0 0x F800 rgb 1 0x7 E0 rgb 2 0x1 F avctx pix fmt be AVPIXFMTRG B565 BEAVPIXFMTRG B565 LE else if rgb 0 0x1 F rgb 1 0x7 E0 rgb 2 0x F800 avctx pix fmt be AVPIXFMTBG R565 BEAVPIXFMTBG R565 LE else if bpp 24 if rgb 0 0x F F0000 rgb 1 0x F F00 rgb 2 0x FF avctx pix fmt be AVPIXFMTRG B24 AVPIXFMTBG R24 else if rgb 0 0x FF rgb 1 0x F F00 rgb 2 0x F F0000 avctx pix fmt be AVPIXFMTBG R24 AVPIXFMTRG B24 else if bpp 32 if rgb 0 0x F F0000 rgb 1 0x F F00 rgb 2 0x FF avctx pix fmt be AVPIXFMTARGBAVPIXFMTBGRA else if rgb 0 0x FF rgb 1 0x F F00 rgb 2 0x F F0000 avctx pix fmt be AVPIXFMTABGRAVPIXFMTRGBA bytestream2 skipu gb ncolors XWDCMAPSIZE break default av log avctx AVLOGERROR invalid visual class n return AVERRORINVALIDDATA if avctx pix fmt AVPIXFMTNONE av log ask for sample avctx unknown file bpp d pixdepth d vclass d n bpp pixdepth vclass return AVERRORPATCHWELCOME if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p key frame 1 p pict type AVPICTURETYPEI if avctx pix fmt AVPIXFMTPA L8 uint32 t dst uint32 t p data 1 uint8 t red green blue for i 0 i ncolors i bytestream2 skipu gb 4 red bytestream2 get byteu gb bytestream2 skipu gb 1 green bytestream2 get byteu gb bytestream2 skipu gb 1 blue bytestream2 get byteu gb bytestream2 skipu gb 3 dst i red 16 green 8 blue ptr p data 0 for i 0 i avctx height i bytestream2 get bufferu gb ptr rsize bytestream2 skipu gb lsize rsize ptr p linesize 0 got frame 1 AV Frame data p return buf size static void single motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv MACROBLOCKD xd x e mbd const V P9 COMMON cm cpi common MBMODEINFO mbmi xd mi 0 mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 int bestsme INTMAX int step param int sadpb x sadperbit16 MV mvp full int ref mbmi ref frame 0 MV ref mv mbmi ref mvs ref 0 as mv int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref MV pred mv 3 pred mv 0 mbmi ref mvs ref 0 as mv pred mv 1 mbmi ref mvs ref 1 as mv pred mv 2 x pred mv ref if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv if cpi sf mv auto mv step size cm show frame step param vp9 init search range x max mv context ref cpi mv step param 2 else step param cpi mv step param if cpi sf adaptive motion search bsize BLOCK 64 X64 int boffset 2 b width log2 BLOCK 64 X64 MIN b height log2 bsize b width log2 bsize step param MAX step param boffset if cpi sf adaptive motion search int bwl b width log2 bsize int bhl b height log2 bsize int i int tlevel x pred mv sad ref bwl bhl 4 if tlevel 5 step param 2 for i LASTFRAME i ALTREFFRAME cm show frame i if x pred mv sad ref 3 x pred mv sad i x pred mv ref row 0 x pred mv ref col 0 tmp mv as int INVALIDMV if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return mvp full pred mv x mv best ref index ref mvp full col 3 mvp full row 3 bestsme vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis cpi find fractional mv step x tmp mv as mv ref mv cm allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 rate mv vp9 mv bit cost tmp mv as mv ref mv x nmvjointcost x mvcost MVCOSTWEIGHT if cpi sf adaptive motion search x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i int vp9 find best sub pixel tree pruned const MACROBLOCK x MV bestmv const MV ref mv int allow hp int error per bit const vp9 variance fn ptr t vfp int forced stop int iters per step int sad list int mvjcost int mvcost 2 int distortion unsigned int sse1 const uint8 t second pred int w int h SETUPSUBPELSEARCH if sad list sad list 0 INTMAX sad list 1 INTMAX sad list 2 INTMAX sad list 3 INTMAX sad list 4 INTMAX unsigned int left right up down diag whichdir sad list 1 sad list 3 0 1 sad list 2 sad list 4 0 2 switch whichdir case 0 CHECKBETTER left tr tc hstep CHECKBETTER up tr hstep tc CHECKBETTER diag tr hstep tc hstep break case 1 CHECKBETTER right tr tc hstep CHECKBETTER up tr hstep tc CHECKBETTER diag tr hstep tc hstep break case 2 CHECKBETTER left tr tc hstep CHECKBETTER down tr hstep tc CHECKBETTER diag tr hstep tc hstep break case 3 CHECKBETTER right tr tc hstep CHECKBETTER down tr hstep tc CHECKBETTER diag tr hstep tc hstep break else FIRSTLEVELCHECKS if halfiters 1 SECONDLEVELCHECKS tr br tc bc if forced stop 2 hstep 1 FIRSTLEVELCHECKS if quarteriters 1 SECONDLEVELCHECKS tr br tc bc if allow hp vp9 use mv hp ref mv forced stop 0 hstep 1 FIRSTLEVELCHECKS if eighthiters 1 SECONDLEVELCHECKS tr br tc bc void tr void tc bestmv row br bestmv col bc if abs bestmv col ref mv col MAXFULLPELVAL 3 abs bestmv row ref mv row MAXFULLPELVAL 3 return INTMAX return besterr void safeputs netdissect options ndo const u char s const u int maxlen u int idx 0 while idx maxlen s safeputchar ndo s idx s static inline int vc1 pred dc Mpeg Enc Context s int overlap int pq int n int a avail int c avail int16 t dc val ptr int dir ptr int a b c wrap pred int16 t dc val int mb pos s mb x s mb y s mb stride int q1 q2 0 int dqscale index wrap s block wrap n dc val s dc val 0 s block index n c dc val 1 b dc val 1 wrap a dc val wrap q1 s current picture qscale table mb pos dqscale index s y dc scale table q1 1 if dqscale index 0 return 0 if c avail n 1 n 3 q2 s current picture qscale table mb pos 1 if q2 q2 q1 c c s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail n 2 n 3 q2 s current picture qscale table mb pos s mb stride if q2 q2 q1 a a s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail n 3 int off mb pos if n 1 off if n 2 off s mb stride q2 s current picture qscale table off if q2 q2 q1 b b s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail if abs a b abs b c pred c dir ptr 1 else pred a dir ptr 0 else if a avail pred a dir ptr 0 else if c avail pred c dir ptr 1 else pred 0 dir ptr 1 dc val ptr dc val 0 return pred static void nvic writel nvic state s uint32 t offset uint32 t value uint32 t oldval switch offset case 0x10 oldval s systick control s systick control 0xfffffff8 s systick control value 7 if oldval value SYSTICKENABLE int64 t now qemu get clock ns vm clock if value SYSTICKENABLE if s systick tick s systick tick now qemu mod timer s systick timer s systick tick else systick reload s 1 else qemu del timer s systick timer s systick tick now if s systick tick 0 s systick tick 0 else if oldval value SYSTICKCLKSOURCE systick reload s 1 break case 0x14 s systick reload value break case 0x18 systick reload s 1 s systick control SYSTICKCOUNTFLAG break case 0xd04 if value 1 31 armv7m nvic set pending s ARM V7 MEXCPNMI if value 1 28 armv7m nvic set pending s ARM V7 MEXCPPENDSV else if value 1 27 s gic irq state ARM V7 MEXCPPENDSV pending 0 gic update s gic if value 1 26 armv7m nvic set pending s ARM V7 MEXCPSYSTICK else if value 1 25 s gic irq state ARM V7 MEXCPSYSTICK pending 0 gic update s gic break case 0xd08 cpu single env v7m vecbase value 0xffffff80 break case 0xd0c if value 16 0x05fa if value 2 qemu log mask LOGUNIMPVECTCLRACTIVE unimplemented n if value 5 qemu log mask LOGUNIMPAIRCR system reset unimplemented n break case 0xd10 case 0xd14 qemu log mask LOGUNIMPNVICSCR and CCR unimplemented n break case 0xd24 s gic irq state ARM V7 MEXCPMEM enabled value 1 16 0 s gic irq state ARM V7 MEXCPBUS enabled value 1 17 0 s gic irq state ARM V7 MEXCPUSAGE enabled value 1 18 0 break case 0xd28 case 0xd2c case 0xd30 case 0xd34 case 0xd38 case 0xd3c qemu log mask LOGUNIMPNVIC fault status registers unimplemented n break case 0xf00 if value 0x1ff s num irq gic set pending private s gic 0 value 0x1ff break default qemu log mask LOGGUESTERRORNVIC Bad write offset 0x x n offset static int64 t encode inter mb segment V P9 COMP cpi MACROBLOCK x int64 t best yrd int i int labelyrate int64 t distortion int64 t sse ENTROPYCONTEXT ta ENTROPYCONTEXT tl int mi row int mi col int k MACROBLOCKD xd x e mbd struct macroblockd plane const pd xd plane 0 struct macroblock plane const p x plane 0 MODEINFO const mi xd mi 0 src mi const BLOCKSIZE plane bsize get plane block size mi mbmi sb type pd const int width 4 num 4x4 blocks wide lookup plane bsize const int height 4 num 4x4 blocks high lookup plane bsize int idx idy const uint8 t const src p src buf raster block offset BLOCK 8 X8 i p src stride uint8 t const dst pd dst buf raster block offset BLOCK 8 X8 i pd dst stride int64 t thisdistortion 0 thissse 0 int thisrate 0 ref const scan order so vp9 default scan orders TX 4 X4 const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter for ref 0 ref 1 is compound ref const uint8 t pre pd pre ref buf raster block offset BLOCK 8 X8 i pd pre ref stride vp9 build inter predictor pre pd pre ref stride dst pd dst stride mi bmi i as mv ref as mv xd block refs ref sf width height ref kernel MVPRECISION Q3 mi col MISIZE 4 i 2 mi row MISIZE 4 i 2 vp9 subtract block height width raster block offset int16 BLOCK 8 X8 i p src diff 8 src p src stride dst pd dst stride k i for idy 0 idy height 4 idy for idx 0 idx width 4 idx int64 t ssz rd rd1 rd2 tran low t coeff k idy 2 idx coeff BLOCKOFFSET p coeff k x fwd txm4x4 raster block offset int16 BLOCK 8 X8 k p src diff coeff 8 vp9 regular quantize b 4x4 x 0 k so scan so iscan thisdistortion vp9 block error coeff BLOCKOFFSET pd dqcoeff k 16 ssz thissse ssz thisrate cost coeffs x 0 k ta k 1 tl k 1 TX 4 X4 so scan so neighbors cpi sf use fast coef costing rd1 RDCOST x rdmult x rddiv thisrate thisdistortion 2 rd2 RDCOST x rdmult x rddiv 0 thissse 2 rd MIN rd1 rd2 if rd best yrd return IN T64 MAX distortion thisdistortion 2 labelyrate thisrate sse thissse 2 return RDCOST x rdmult x rddiv labelyrate distortion int set wep key char string int bit 0 char p type char tok char s strlen string 1 u char tmp wkey 512 size t tmp wkey len char tmp 128 memset GBLWIFI wkey 0 sizeof GBLWIFI wkey GBLWIFI wkey len 0 strcpy s string p ec strtok s tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key bit atoi p if bit 0 SEMIFATALERROR Unsupported WEP key length tmp wkey len bit 8 WEPIVLEN if bit 64 bit 128 SEMIFATALERROR Unsupported WEP key length p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key type p p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key if type s if strescape char tmp wkey p int tmp wkey len SEMIFATALERROR Specified WEP key length does not match the given string else if type p if bit 64 make key 64 u char p tmp wkey else if bit 128 make key 128 u char p tmp wkey else SEMIFATALERROR Invalid parsing of the WEP key USERMSG Using WEP key s n str tohex tmp wkey tmp wkey len tmp sizeof tmp memcpy GBLWIFI wkey tmp wkey sizeof GBLWIFI wkey GBLWIFI wkey len tmp wkey len return static uint32 t nvic readl nvic state s uint32 t offset uint32 t val int irq switch offset case 4 return s num irq 32 1 case 0x10 val s systick control s systick control SYSTICKCOUNTFLAG return val case 0x14 return s systick reload case 0x18 int64 t t if s systick control SYSTICKENABLE 0 return 0 t qemu get clock ns vm clock if t s systick tick return 0 val s systick tick t 1 systick scale s 1 if val s systick reload val 0 return val case 0x1c return 10000 case 0xd00 return cpu single env cp15 c0 cpuid case 0xd04 val s gic running irq 0 if val 1023 val 0 else if val 32 val 16 if s gic running irq 0 1023 s gic last active s gic running irq 0 0 1023 val 1 11 if s gic current pending 0 1023 val s gic current pending 0 12 for irq 32 irq s num irq irq if s gic irq state irq pending val 1 22 break if s gic irq state ARM V7 MEXCPSYSTICK pending val 1 26 if s gic irq state ARM V7 MEXCPPENDSV pending val 1 28 if s gic irq state ARM V7 MEXCPNMI pending val 1 31 return val case 0xd08 return cpu single env v7m vecbase case 0xd0c return 0xfa05000 case 0xd10 return 0 case 0xd14 return 0 case 0xd24 val 0 if s gic irq state ARM V7 MEXCPMEM active val 1 0 if s gic irq state ARM V7 MEXCPBUS active val 1 1 if s gic irq state ARM V7 MEXCPUSAGE active val 1 3 if s gic irq state ARM V7 MEXCPSVC active val 1 7 if s gic irq state ARM V7 MEXCPDEBUG active val 1 8 if s gic irq state ARM V7 MEXCPPENDSV active val 1 10 if s gic irq state ARM V7 MEXCPSYSTICK active val 1 11 if s gic irq state ARM V7 MEXCPUSAGE pending val 1 12 if s gic irq state ARM V7 MEXCPMEM pending val 1 13 if s gic irq state ARM V7 MEXCPBUS pending val 1 14 if s gic irq state ARM V7 MEXCPSVC pending val 1 15 if s gic irq state ARM V7 MEXCPMEM enabled val 1 16 if s gic irq state ARM V7 MEXCPBUS enabled val 1 17 if s gic irq state ARM V7 MEXCPUSAGE enabled val 1 18 return val case 0xd28 qemu log mask LOGUNIMP Configurable Fault Status unimplemented n return 0 case 0xd2c case 0xd30 case 0xd34 case 0xd38 case 0xd3c qemu log mask LOGUNIMP Fault status registers unimplemented n return 0 case 0xd40 return 0x00000030 case 0xd44 return 0x00000200 case 0xd48 return 0x00100000 case 0xd4c return 0x00000000 case 0xd50 return 0x00000030 case 0xd54 return 0x00000000 case 0xd58 return 0x00000000 case 0xd5c return 0x00000000 case 0xd60 return 0x01141110 case 0xd64 return 0x02111000 case 0xd68 return 0x21112231 case 0xd6c return 0x01111110 case 0xd70 return 0x01310102 default qemu log mask LOGGUESTERRORNVIC Bad read offset 0x x n offset return 0 void bn mul comba8 BNULONG r BNULONG a BNULONG b BNULONG t1 t2 BNULONG c1 c2 c3 c1 0 c2 0 c3 0 mul add c a 0 b 0 c1 c2 c3 r 0 c1 c1 0 mul add c a 0 b 1 c2 c3 c1 mul add c a 1 b 0 c2 c3 c1 r 1 c2 c2 0 mul add c a 2 b 0 c3 c1 c2 mul add c a 1 b 1 c3 c1 c2 mul add c a 0 b 2 c3 c1 c2 r 2 c3 c3 0 mul add c a 0 b 3 c1 c2 c3 mul add c a 1 b 2 c1 c2 c3 mul add c a 2 b 1 c1 c2 c3 mul add c a 3 b 0 c1 c2 c3 r 3 c1 c1 0 mul add c a 4 b 0 c2 c3 c1 mul add c a 3 b 1 c2 c3 c1 mul add c a 2 b 2 c2 c3 c1 mul add c a 1 b 3 c2 c3 c1 mul add c a 0 b 4 c2 c3 c1 r 4 c2 c2 0 mul add c a 0 b 5 c3 c1 c2 mul add c a 1 b 4 c3 c1 c2 mul add c a 2 b 3 c3 c1 c2 mul add c a 3 b 2 c3 c1 c2 mul add c a 4 b 1 c3 c1 c2 mul add c a 5 b 0 c3 c1 c2 r 5 c3 c3 0 mul add c a 6 b 0 c1 c2 c3 mul add c a 5 b 1 c1 c2 c3 mul add c a 4 b 2 c1 c2 c3 mul add c a 3 b 3 c1 c2 c3 mul add c a 2 b 4 c1 c2 c3 mul add c a 1 b 5 c1 c2 c3 mul add c a 0 b 6 c1 c2 c3 r 6 c1 c1 0 mul add c a 0 b 7 c2 c3 c1 mul add c a 1 b 6 c2 c3 c1 mul add c a 2 b 5 c2 c3 c1 mul add c a 3 b 4 c2 c3 c1 mul add c a 4 b 3 c2 c3 c1 mul add c a 5 b 2 c2 c3 c1 mul add c a 6 b 1 c2 c3 c1 mul add c a 7 b 0 c2 c3 c1 r 7 c2 c2 0 mul add c a 7 b 1 c3 c1 c2 mul add c a 6 b 2 c3 c1 c2 mul add c a 5 b 3 c3 c1 c2 mul add c a 4 b 4 c3 c1 c2 mul add c a 3 b 5 c3 c1 c2 mul add c a 2 b 6 c3 c1 c2 mul add c a 1 b 7 c3 c1 c2 r 8 c3 c3 0 mul add c a 2 b 7 c1 c2 c3 mul add c a 3 b 6 c1 c2 c3 mul add c a 4 b 5 c1 c2 c3 mul add c a 5 b 4 c1 c2 c3 mul add c a 6 b 3 c1 c2 c3 mul add c a 7 b 2 c1 c2 c3 r 9 c1 c1 0 mul add c a 7 b 3 c2 c3 c1 mul add c a 6 b 4 c2 c3 c1 mul add c a 5 b 5 c2 c3 c1 mul add c a 4 b 6 c2 c3 c1 mul add c a 3 b 7 c2 c3 c1 r 10 c2 c2 0 mul add c a 4 b 7 c3 c1 c2 mul add c a 5 b 6 c3 c1 c2 mul add c a 6 b 5 c3 c1 c2 mul add c a 7 b 4 c3 c1 c2 r 11 c3 c3 0 mul add c a 7 b 5 c1 c2 c3 mul add c a 6 b 6 c1 c2 c3 mul add c a 5 b 7 c1 c2 c3 r 12 c1 c1 0 mul add c a 6 b 7 c2 c3 c1 mul add c a 7 b 6 c2 c3 c1 r 13 c2 c2 0 mul add c a 7 b 7 c3 c1 c2 r 14 c3 r 15 c1 int ff mpeg4 decode video packet header Mpeg Enc Context s int mb num bits av log2 s mb num 1 1 int header extension 0 mb num len if get bits count s gb s gb size in bits 20 return 1 for len 0 len 32 len if get bits1 s gb break if len ff mpeg4 get video packet prefix length s av log s avctx AVLOGERROR marker does not match f code n return 1 if s shape RECTSHAPE header extension get bits1 s gb mb num get bits s gb mb num bits if mb num s mb num av log s avctx AVLOGERROR illegal mb num in video packet d d n mb num s mb num return 1 if s pict type AVPICTURETYPEB int mb x 0 mb y 0 while s next picture f mbskip table s mb index2xy mb num if mb x ff thread await progress s next picture ptr f mb y 0 mb num if mb x s mb width mb x 0 if mb num s mb num return 1 s mb x mb num s mb width s mb y mb num s mb width if s shape BINONLYSHAPE int qscale get bits s gb s quant precision if qscale s chroma qscale s qscale qscale if s shape RECTSHAPE header extension get bits1 s gb if header extension int time incr 0 while get bits1 s gb 0 time incr check marker s gb before time increment in video packed header skip bits s gb s time increment bits check marker s gb before vop coding type in video packed header skip bits s gb 2 if s shape BINONLYSHAPE skip bits s gb 3 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE mpeg4 decode sprite trajectory s s gb av log s avctx AVLOGERROR untested n if s pict type AVPICTURETYPEI int f code get bits s gb 3 if f code 0 av log s avctx AVLOGERROR Error video packet header damaged f code 0 n if s pict type AVPICTURETYPEB int b code get bits s gb 3 if b code 0 av log s avctx AVLOGERROR Error video packet header damaged b code 0 n return 0 static int ra288 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float out int i ret R A288 Context ractx avctx priv data Get Bit Context gb if buf size avctx block align av log avctx AVLOGERROR Error Input buffer is too small d d n buf size avctx block align return AVERRORINVALIDDATA frame nb samples R A288 BLOCKSIZER A288 BLOCKSPERFRAME if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out float frame data 0 init get bits gb buf avctx block align 8 for i 0 i R A288 BLOCKSPERFRAME i float gain amptable get bits gb 3 int cb coef get bits gb 6 i 1 decode ractx gain cb coef memcpy out ractx sp hist 70 36 R A288 BLOCKSIZE sizeof out out R A288 BLOCKSIZE if i 7 3 backward filter ractx ractx sp hist ractx sp rec syn window ractx sp lpc syn bw tab 36 40 35 70 backward filter ractx ractx gain hist ractx gain rec gain window ractx gain lpc gain bw tab 10 8 20 28 got frame ptr 1 return avctx block align static int twin decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Twin Context tctx avctx priv data Get Bit Context gb const Mode Tab mtab tctx mtab float out NULL enum Frame Type ftype int window type ret static const enum Frame Type wtype to ftype table FTLONGFTLONGFTSHORTFTLONGFTMEDIUMFTLONGFTLONGFTMEDIUMFTMEDIUM if buf size 8 avctx bit rate mtab size avctx sample rate 8 av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size return AVERROREINVAL if tctx discarded packets 2 frame nb samples mtab size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret out float frame extended data init get bits gb buf buf size 8 skip bits gb get bits gb 8 window type get bits gb WINDOWTYPEBITS if window type 8 av log avctx AVLOGERROR Invalid window type broken sample n return 1 ftype wtype to ftype table window type read and decode spectrum tctx gb tctx spectrum ftype imdct output tctx ftype window type out FFSWAP float tctx curr frame tctx prev frame if tctx discarded packets 2 tctx discarded packets got frame ptr 0 return buf size got frame ptr 1 return buf size int vp8 denoiser filter c unsigned char mc running avg y int mc avg y stride unsigned char running avg y int avg y stride unsigned char sig int sig stride unsigned int motion magnitude int increase denoising unsigned char running avg y start running avg y unsigned char sig start sig int sum diff thresh int r c int sum diff 0 int adj val 3 3 4 6 int shift inc1 0 int shift inc2 1 if motion magnitude MOTIONMAGNITUDETHRESHOLD if increase denoising shift inc1 1 shift inc2 2 adj val 0 shift inc2 adj val 1 shift inc2 adj val 2 shift inc2 for r 0 r 16 r for c 0 c 16 c int diff 0 int adjustment 0 int absdiff 0 diff mc running avg y c sig c absdiff abs diff if absdiff 3 shift inc1 running avg y c mc running avg y c sum diff diff else if absdiff 4 absdiff 7 adjustment adj val 0 else if absdiff 8 absdiff 15 adjustment adj val 1 else adjustment adj val 2 if diff 0 if sig c adjustment 255 running avg y c 255 else running avg y c sig c adjustment sum diff adjustment else if sig c adjustment 0 running avg y c 0 else running avg y c sig c adjustment sum diff adjustment sig sig stride mc running avg y mc avg y stride running avg y avg y stride sum diff thresh SUMDIFFTHRESHOLD if increase denoising sum diff thresh SUMDIFFTHRESHOLDHIGH if abs sum diff sum diff thresh int delta abs sum diff sum diff thresh 8 1 if delta 4 sig sig stride 16 mc running avg y mc avg y stride 16 running avg y avg y stride 16 for r 0 r 16 r for c 0 c 16 c int diff mc running avg y c sig c int adjustment abs diff if adjustment delta adjustment delta if diff 0 if running avg y c adjustment 0 running avg y c 0 else running avg y c running avg y c adjustment sum diff adjustment else if diff 0 if running avg y c adjustment 255 running avg y c 255 else running avg y c running avg y c adjustment sum diff adjustment sig sig stride mc running avg y mc avg y stride running avg y avg y stride if abs sum diff sum diff thresh return COPYBLOCK else return COPYBLOCK vp8 copy mem16x16 running avg y start avg y stride sig start sig stride return static int aes ccm ctrl EVPCIPHERCTX c int type int arg void ptr EVPAESCCMCTX cctx EVPCDATAEVPAESCCMCTX c switch type case EVPCTRLINIT cctx key set 0 cctx iv set 0 cctx L 8 cctx M 12 cctx tag set 0 cctx len set 0 cctx tls aad len 1 return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx tls aad len arg uint16 t len EVPCIPHERCTX buf noconst c arg 2 8 EVPCIPHERCTX buf noconst c arg 1 if len EVPCCMTLSEXPLICITIVLEN return 0 len EVPCCMTLSEXPLICITIVLEN if EVPCIPHERCTX encrypting c if len cctx M return 0 len cctx MEVPCIPHERCTX buf noconst c arg 2 len 8 EVPCIPHERCTX buf noconst c arg 1 len 0xff return cctx M case EVPCTRLCCMSETIVFIXED if arg EVPCCMTLSFIXEDIVLEN return 0 memcpy EVPCIPHERCTX iv noconst c ptr arg return 1 case EVPCTRLAEADSETIVLEN arg 15 arg case EVPCTRLCCMSETL if arg 2 arg 8 return 0 cctx L arg return 1 case EVPCTRLAEADSETTAG if arg 1 arg 4 arg 16 return 0 if EVPCIPHERCTX encrypting c ptr return 0 if ptr cctx tag set 1 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx M arg return 1 case EVPCTRLAEADGETTAG if EVPCIPHERCTX encrypting c cctx tag set return 0 if CRYPTO ccm128 tag cctx ccm ptr size t arg return 0 cctx tag set 0 cctx iv set 0 cctx len set 0 return 1 case EVPCTRLCOPYEVPCIPHERCTX out ptr EVPAESCCMCTX cctx out EVPCDATAEVPAESCCMCTX out if cctx ccm key if cctx ccm key cctx ks return 0 cctx out ccm key cctx out ks return 1 default return 1 static struct evhttp http setup short pport struct event base base int i struct evhttp myhttp short port 1 myhttp evhttp new base for i 0 i 50 i if evhttp bind socket myhttp 127 0 0 1 8080 i 1 port 8080 i break if port 1 event errx 1 Could not start web server evhttp set cb myhttp test http basic cb NULL evhttp set cb myhttp chunked http chunked cb NULL evhttp set cb myhttp postit http post cb NULL evhttp set cb myhttp largedelay http large delay cb NULL evhttp set cb myhttp badrequest http badreq cb NULL evhttp set cb myhttp http dispatcher cb NULL pport port return myhttp static inline void vc1 pred b mv V C1 Context v int dmv x 2 int dmv y 2 int direct int mvtype Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int r x r y const uint8 t is intra v mb type 0 r x v range x r y v range y dmv x 0 1 s quarter sample dmv y 0 1 s quarter sample dmv x 1 1 s quarter sample dmv y 1 1 s quarter sample wrap s b8 stride xy s block index 0 if s mb intra s current picture f motion val 0 xy v blocks off 0 s current picture f motion val 0 xy v blocks off 1 s current picture f motion val 1 xy v blocks off 0 s current picture f motion val 1 xy v blocks off 1 0 return if v field mode s mv 0 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 1 s quarter sample s mv 0 0 0 av clip s mv 0 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 0 0 1 av clip s mv 0 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 s mv 1 0 0 av clip s mv 1 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 1 0 1 av clip s mv 1 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 if direct s current picture f motion val 0 xy v blocks off 0 s mv 0 0 0 s current picture f motion val 0 xy v blocks off 1 s mv 0 0 1 s current picture f motion val 1 xy v blocks off 0 s mv 1 0 0 s current picture f motion val 1 xy v blocks off 1 s mv 1 0 1 return if mvtype BMVTYPEFORWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 0 xy 2 A s current picture f motion val 0 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 0 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 0 0 0 px dmv x 0 r x r x 1 1 r x s mv 0 0 1 py dmv y 0 r y r y 1 1 r y if mvtype BMVTYPEBACKWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 1 xy 2 A s current picture f motion val 1 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 1 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 1 0 0 px dmv x 1 r x r x 1 1 r x s mv 1 0 1 py dmv y 1 r y r y 1 1 r y s current picture f motion val 0 xy 0 s mv 0 0 0 s current picture f motion val 0 xy 1 s mv 0 0 1 s current picture f motion val 1 xy 0 s mv 1 0 0 s current picture f motion val 1 xy 1 s mv 1 0 1 int64 t vp9 rd pick inter mode sb seg skip V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 mbmi unsigned char segment id mbmi segment id const int comp pred 0 int i int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best filter diff SWITCHABLEFILTERCONTEXTS unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER best filter SWITCHABLE int64 t this rd IN T64 MAX int rate2 0 const int64 t distortion2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i LASTFRAME i MAXREFFRAMES i x pred mv sad i INTMAX returnrate INTMAX assert vp9 segfeature active cm seg segment id SEGLVLSKIP mbmi mode ZEROMV mbmi uv mode DCPRED mbmi ref frame 0 LASTFRAME mbmi ref frame 1 NONE mbmi mv 0 as int 0 x skip 1 rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR best filter EIGHTTAP if cm interp filter SWITCHABLE x source variance cpi sf disable filter search var thresh int rs int best rs INTMAX for i 0 i SWITCHABLEFILTERS i mbmi interp filter i rs vp9 get switchable rate cpi if rs best rs best rs rs best filter mbmi interp filter if cm interp filter SWITCHABLE mbmi interp filter best filter rate2 vp9 get switchable rate cpi else mbmi interp filter cm interp filter if cm reference mode REFERENCEMODESELECT rate2 vp9 cost bit comp mode p comp pred rate2 ref costs single LASTFRAME this rd RDCOST x rdmult x rddiv rate2 distortion2 returnrate rate2 returndistortion distortion2 if this rd best rd so far return IN T64 MAX assert cm interp filter SWITCHABLE cm interp filter mbmi interp filter update rd thresh fact cpi bsize THRZEROMV vp9 zero best pred diff vp9 zero best filter diff vp9 zero best tx diff if x select tx size swap block ptr x ctx 1 0 0 MAXMBPLANE store coding context x ctx THRZEROMV best pred diff best tx diff best filter diff 0 return this rd static int tmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt TMV Context tmv avctx priv data const uint8 t src avpkt data uint8 t dst unsigned char cols avctx width 3 unsigned char rows avctx height 3 unsigned x y fg bg c int ret if tmv pic data 0 avctx release buffer avctx tmv pic if ret ff get buffer avctx tmv pic 0 av log avctx AVLOGERROR get buffer failed n return ret if avpkt size 2 char rows char cols av log avctx AVLOGERROR Input buffer too small truncated sample n got frame 0 return AVERRORINVALIDDATA tmv pic pict type AVPICTURETYPEI tmv pic key frame 1 dst tmv pic data 0 tmv pic palette has changed 1 memcpy tmv pic data 1 ff cga palette 16 4 for y 0 y char rows y for x 0 x char cols x c src bg src 4 fg src 0x F ff draw pc font dst x 8 tmv pic linesize 0 ff cga font 8 c fg bg dst tmv pic linesize 0 8 got frame 1 AV Frame data tmv pic return avpkt size int Get Certificate Failure JNI Env env const Java Param Ref jclass obj const Java Param Ref jobject java web contents enum Certificate Failure NONE 0 CERTIFICATEFAILUNSPECIFIED 1 CERTIFICATEFAILUNTRUSTED 2 CERTIFICATEFAILREVOKED 3 CERTIFICATEFAILNOTYETVALID 4 CERTIFICATEFAILEXPIRED 5 CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS 6 content Web Contents web contents content Web Contents From Java Web Contents java web contents content Navigation Entry entry web contents Get Controller Get Visible Entry if entry return NONE const content SSL Status ssl entry Get SSL switch ssl security style case content SECURITYSTYLEWARNING case content SECURITYSTYLEUNKNOWN case content SECURITYSTYLEUNAUTHENTICATED return NONE case content SECURITYSTYLEAUTHENTICATIONBROKEN case content SECURITYSTYLEAUTHENTICATED if net Is Cert Status Error ssl cert status if ssl cert status net CERTSTATUSAUTHORITYINVALID return CERTIFICATEFAILUNTRUSTED if ssl cert status net CERTSTATUSREVOKED return CERTIFICATEFAILREVOKED if ssl cert status net CERTSTATUSDATEINVALID return CERTIFICATEFAILEXPIRED if ssl cert status net CERTSTATUSUNABLETOCHECKREVOCATION return CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS return CERTIFICATEFAILUNSPECIFIED if ssl content status content SSL Status DISPLAYEDINSECURECONTENT return CERTIFICATEFAILUNSPECIFIED return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size Qdraw Context const a avctx priv data AV Frame const p a pic uint8 t outdata int colors int i ret uint32 t pal int r g b if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 outdata a pic data 0 if buf end buf 0x68 4 return AVERRORINVALIDDATA buf 0x68 colors AVR B32 buf buf 4 if colors 0 colors 256 av log avctx AVLOGERROR Error color count i 0x X n colors colors return AVERRORINVALIDDATA if buf end buf colors 1 8 return AVERRORINVALIDDATA pal uint32 t p data 1 for i 0 i colors i unsigned int idx idx AVR B16 buf buf 2 if idx 255 av log avctx AVLOGERROR Palette index out of range u n idx buf 6 continue r buf buf g buf buf b buf buf pal idx r 16 g 8 b p palette has changed 1 if buf end buf 18 return AVERRORINVALIDDATA buf 18 for i 0 i avctx height i int size left code pix const uint8 t next uint8 t out int tsize 0 out outdata size AVR B16 buf buf 2 if buf end buf size return AVERRORINVALIDDATA left size next buf size while left 0 code buf if code 0x80 pix buf if out 257 code outdata a pic linesize 0 break memset out pix 257 code out 257 code tsize 257 code left 2 else if out code outdata a pic linesize 0 break if buf end buf code 1 return AVERRORINVALIDDATA memcpy out buf code 1 out code 1 buf code 1 left 2 code tsize code 1 buf next outdata a pic linesize 0 got frame 1 AV Frame data a pic return buf size extern List as mysql modify job mysql conn t mysql conn uint32 t uid slurmdb job modify cond t job cond slurmdb job rec t job List ret list NULL int rc SLURMSUCCESS char object NULL char vals NULL query NULL cond char NULL time t now time NULL char user name NULLMYSQLRES result NULLMYSQLROW row if job cond job error we need something to change return NULL else if job cond job id NOVAL errno SLURMNOCHANGEINDATA error Job ID was not specified for job modification n return NULL else if job cond cluster errno SLURMNOCHANGEINDATA error Cluster was not specified for job modification n return NULL else if check connection mysql conn SLURMSUCCESS return NULL if job derived ec NOVAL xstrfmtcat vals derived ec u job derived ec if job derived es char derived es slurm add slash to quotes job derived es xstrfmtcat vals derived es s derived es xfree derived es if vals errno SLURMNOCHANGEINDATA error No change specified for job modification return NULL query xstrdup printf select job db inx id job time submit id user from s s where deleted 0 id job u order by time submit desc limit 1 job cond cluster job table job cond job id if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query if result mysql db query ret mysql conn query 0 xfree vals xfree query return NULL if row mysql fetch row result char tmp char 25 time t time submit atol row 2 if uid atoi row 3 is user min admin level mysql conn uid SLURMDBADMINOPERATOR errno ESLURMACCESSDENIED xfree vals xfree query mysql free result result return NULL slurm make time str time submit tmp char sizeof tmp char xstrfmtcat cond char job db inx s row 0 object xstrdup printf s submitted at s row 1 tmp char ret list list create slurm destroy char list append ret list object mysql free result result else errno ESLURMINVALIDJOBID if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn as mysql modify job Job not found n s query xfree vals xfree query mysql free result result return NULL xfree query user name uid to string uid t uid rc modify common mysql conn DBDMODIFYJOB now user name job table cond char vals job cond cluster xfree user name xfree cond char xfree vals if rc SLURMERROR error Couldn t modify job FREENULLLIST ret list ret list NULL return ret list void ff mpeg flush AV Codec Context avctx int i Mpeg Enc Context s avctx priv data if s NULL s picture NULL return for i 0 i s picture count i if s picture i f data 0 s picture i f type FFBUFFERTYPEINTERNAL s picture i f type FFBUFFERTYPEUSER free frame buffer s s picture i s current picture ptr s last picture ptr s next picture ptr NULL s mb x s mb y 0 s parse context state 1 s parse context frame start found 0 s parse context overread 0 s parse context overread index 0 s parse context index 0 s parse context last index 0 s bitstream buffer size 0 s pp time 0 static int pefromupx const char src uint32 t ssize char dst uint32 t dsize uint32 t ep uint32 t upx0 uint32 t upx1 uint32 t magic uint32 t dend char imports sections NULL pehdr NULL newbuf unsigned int sectcnt 0 upd 1 uint32 t realstuffsz 0 valign 0 uint32 t foffset 0xd0 0xf8 if dst NULL src NULL return 0 while valign magic sectcnt if ep upx1 valign ssize 5 src ep upx1 valign 2 x8d src ep upx1 valign 1 xbe break if valign ep upx1 0x80 ssize 8 const char pt src ep upx1 0x80 cli dbgmsg UPX bad magic scanning for imports n while pt cli memstr pt ssize pt src 8 x8d xbe 2 if pt 6 x8b pt 7 x07 valign pt src 2 ep upx1 break pt if valign CLIISCONTAINED src ssize src ep upx1 valign 4 imports dst cli readint32 src ep upx1 valign realstuffsz imports dst if realstuffsz dsize cli dbgmsg UPX wrong realstuff size n else pehdr imports while CLIISCONTAINED dst dsize pehdr 8 cli readint32 pehdr pehdr 8 while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr pehdr pehdr pehdr 4 if sections checkpe dst dsize pehdr valign sectcnt pehdr NULL if pehdr dend 0xf8 0x28 cli dbgmsg UPX no luck scanning for PE n pehdr dst dend 0xf8 0x28 while pehdr dst if sections checkpe dst dsize pehdr valign sectcnt break pehdr if realstuffsz pehdr dst pehdr NULL if pehdr uint32 t rebsz PESALIGN dend 0x1000 cli dbgmsg UPX no luck brutally crafing a reasonable PE n if newbuf char cli calloc rebsz 0x200 sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 FAKEPE 0x120 memcpy newbuf 0x200 dst dend memcpy dst newbuf dend 0x200 free newbuf cli writeint32 dst 0xd0 0x50 rebsz 0x1000 cli writeint32 dst 0xd0 0x100 rebsz cli writeint32 dst 0xd0 0x108 rebsz dsize rebsz 0x200 cli dbgmsg UPXPE structure added to uncompressed data n return 1 if sections sectcnt 0 foffset PESALIGN foffset 0x28 sectcnt valign for upd 0 upd sectcnt upd uint32 t vsize PESALIGN uint32 t cli readint32 sections 8 valign uint32 t urva PEALIGN uint32 t cli readint32 sections 12 valign if CLIISCONTAINED upx0 realstuffsz urva vsize cli dbgmsg UPX Sect d out of bounds giving up rebuild n upd return 0 cli writeint32 sections 8 vsize cli writeint32 sections 12 urva cli writeint32 sections 16 vsize cli writeint32 sections 20 foffset if foffset vsize foffset return 0 foffset vsize sections 0x28 cli writeint32 pehdr 8 0x4d414c43 cli writeint32 pehdr 0x3c valign if newbuf char cli calloc foffset sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 pehdr 0xf8 0x28 sectcnt sections pehdr 0xf8 for upd 0 upd sectcnt upd uint32 t offset1 offset2 offset3 offset1 uint32 t cli readint32 sections 20 offset2 uint32 t cli readint32 sections 16 if offset1 foffset offset2 foffset offset1 offset2 foffset free newbuf return 1 offset3 uint32 t cli readint32 sections 12 if offset3 upx0 dsize free newbuf return 1 memcpy newbuf offset1 dst offset3 upx0 offset2 sections 0x28 if foffset dsize 8192 cli dbgmsg UPX wrong raw size giving up rebuild n free newbuf return 0 memcpy dst newbuf foffset dsize foffset free newbuf cli dbgmsg UPXPE structure rebuilt from compressed file n return 1 static void test rfc822 parse quoted string void const struct const char input output int ret tests 1 0 foo foo 0 foo 1 1 0 0 foo foo foo foo 0 struct rfc822 parser context parser string t str t str new 64 unsigned int i 0 test begin rfc822 parse quoted string for i 0 i NELEMENTS tests i rfc822 parser init parser const void tests i input strlen tests i input NULL test assert idx rfc822 parse quoted string parser str tests i ret i test assert idx tests i ret 0 strcmp tests i output str c str 0 i rfc822 parser deinit parser str truncate str 0 test end static void free picture AV Codec Context avctx Picture pic int i for i 0 i 2 i av buffer unref pic motion val buf i av buffer unref pic ref index buf i av buffer unref pic mb type buf av frame unref pic f static int dissect pbb tlvblock tvbuff t tvb packet info pinfo proto tree tree guint offset guint maxoffset gint8 addr Count guint tlv Cat guint16 tlvblock Length guint tlvblock End proto tree tlvblock tree NULL proto tree tlv tree NULL proto tree tlv flags tree NULL proto tree tlv Value tree NULL proto item tlv Block item NULL proto item tlv item NULL proto item tlv Flags item NULL proto item tlv Value item NULL proto item ti NULL int tlv Count 0 int hf packetbb tlv type 0 const value string tlv type vals NULL if maxoffset offset 2 proto tree add expert format tree pinfo ei packetbb error tvb offset maxoffset offset Not enough octets for minimal tlvblock return maxoffset tlvblock Length tvb get ntohs tvb offset tlvblock End offset 2 tlvblock Length if maxoffset tlvblock End proto tree add expert format tree pinfo ei packetbb error tvb offset maxoffset offset Not enough octets for tlvblock return maxoffset tlv Block item proto tree add item tree hf packetbb tlvblock tvb offset tlvblock End offset ENCNA tlvblock tree proto item add subtree tlv Block item ett packetbb tlvblock proto tree add item tlvblock tree hf packetbb tlvblock length tvb offset 2 ENCBIGENDIAN offset 2 while offset tlvblock End guint tlv Start tlv Length guint8 tlv Type tlv Flags tlv Ext Type index Start index End guint16 length 0 tlv Start offset tlv Type tvb get guint8 tvb offset tlv Flags tvb get guint8 tvb offset index Start 0 index End addr Count addr Count 1 0 tlv Ext Type 0 if tlv Flags TLVHASTYPEEXT 0 tlv Ext Type tvb get guint8 tvb offset if tlv Flags TLVHASSINGLEINDEX 0 index Start index End tvb get guint8 tvb offset else if tlv Flags TLVHASMULTIINDEX 0 index Start tvb get guint8 tvb offset index End tvb get guint8 tvb offset if tlv Flags TLVHASVALUE 0 if tlv Flags TLVHASEXTLEN 0 length tvb get ntohs tvb offset else length tvb get guint8 tvb offset tlv Length offset tlv Start length offset tlv Start tlv item proto tree add item tlv Block item hf packetbb tlv tvb tlv Start tlv Length ENCNA tlv tree proto item add subtree tlv item ett packetbb tlv tlv Type if tlv Cat TLVCATPACKET hf packetbb tlv type hf packetbb pkttlv type tlv type vals pkttlv type vals else if tlv Cat TLVCATMESSAGE hf packetbb tlv type hf packetbb msgtlv type tlv type vals msgtlv type vals else hf packetbb tlv type hf packetbb addrtlv type tlv type vals addrtlv type vals if tlv Flags TLVHASTYPEEXT 0 proto item append text tlv item s val to str const tlv Type tlv type vals Unknown type else proto item append text tlv item s d val to str const tlv Type tlv type vals Unknown type tlv Ext Type proto tree add item tlv tree hf packetbb tlv type tvb offset 1 ENCBIGENDIAN tlv Flags item proto tree add item tlv tree hf packetbb tlv flags tvb offset 1 ENCBIGENDIAN tlv flags tree proto item add subtree tlv Flags item ett packetbb tlv flags proto tree add item tlv flags tree hf packetbb tlv flags hastypext tvb offset 1 ENCBIGENDIAN proto tree add item tlv flags tree hf packetbb tlv flags hassingleindex tvb offset 1 ENCBIGENDIAN proto tree add item tlv flags tree hf packetbb tlv flags hasmultiindex tvb offset 1 ENCBIGENDIAN proto tree add item tlv flags tree hf packetbb tlv flags hasvalue tvb offset 1 ENCBIGENDIAN proto tree add item tlv flags tree hf packetbb tlv flags hasextlen tvb offset 1 ENCBIGENDIAN proto tree add item tlv flags tree hf packetbb tlv flags hasmultivalue tvb offset 1 ENCBIGENDIAN offset if tlv Flags TLVHASTYPEEXT 0 proto tree add item tlv tree hf packetbb tlv typeext tvb offset 1 ENCBIGENDIAN if addr Count 0 if tlv Flags TLVHASSINGLEINDEX 0 proto tree add uint tlv tree hf packetbb tlv indexstart tvb offset 1 index Start ti proto tree add uint tlv tree hf packetbb tlv indexend tvb offset 0 index End proto item append text ti implicit else if tlv Flags TLVHASMULTIINDEX 0 proto tree add uint tlv tree hf packetbb tlv indexstart tvb offset 1 index Start proto tree add uint tlv tree hf packetbb tlv indexend tvb offset 1 index End else ti proto tree add uint tlv tree hf packetbb tlv indexstart tvb offset 0 index Start proto item append text ti implicit ti proto tree add uint tlv tree hf packetbb tlv indexend tvb offset 0 index End proto item append text ti implicit if tlv Flags TLVHASVALUE 0 if tlv Flags TLVHASEXTLEN 0 proto tree add uint tlv tree hf packetbb tlv length tvb offset 2 length offset 2 else proto tree add uint tlv tree hf packetbb tlv length tvb offset 1 length else ti proto tree add uint tlv tree hf packetbb tlv length tvb offset 0 0 proto item append text ti implicit if length 0 tlv Value item proto tree add item tlv tree hf packetbb tlv value tvb offset length ENCNA if tlv Flags TLVHASMULTIVALUE 0 offset length else int i guint8 c index End index Start 1 tlv Value tree proto item add subtree tlv Value item ett packetbb tlv value for i index Start i index End i proto tree add item tlv Value tree hf packetbb tlv multivalue tvb offset length c ENCNA offset length c tlv Count proto item append text tlv Block item d TL Vs tlv Count return offset int ff MPV frame start Mpeg Enc Context s AV Codec Context avctx int i ret Picture pic s mb skipped 0 if s out format FMT H264 s codec id AVCODECIDSV Q3 if s pict type AVPICTURETYPEB s last picture ptr s last picture ptr s next picture ptr s last picture ptr f data 0 ff mpeg unref picture s s last picture ptr if s encoding for i 0 i MAXPICTURECOUNT i if s picture i s last picture ptr s picture i s next picture ptr s picture i reference s picture i needs realloc if avctx active thread type FFTHREADFRAME av log avctx AVLOGERROR releasing zombie picture n ff mpeg unref picture s s picture i if s encoding ff release unused pictures s 1 if s current picture ptr s current picture ptr f data 0 NULL pic s current picture ptr else i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i pic s picture i pic reference 0 if s droppable if s codec id AVCODECID H264 pic reference s picture structure else if s pict type AVPICTURETYPEB pic reference 3 pic f coded picture number s coded picture number if ff alloc picture s pic 0 0 return 1 s current picture ptr pic s current picture ptr f top field first s top field first if s codec id AVCODECIDMPE G1 VIDEO s codec id AVCODECIDMPE G2 VIDEO if s picture structure PICTFRAME s current picture ptr f top field first s picture structure PICTTOPFIELD s first field s current picture ptr f interlaced frame s progressive frame s progressive sequence s current picture ptr field picture s picture structure PICTFRAME s current picture ptr f pict type s pict type s current picture ptr f key frame s pict type AVPICTURETYPEI ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret if s codec id AVCODECID H264 s pict type AVPICTURETYPEB s last picture ptr s next picture ptr if s droppable s next picture ptr s current picture ptr av dlog s avctx L p N p C p L p N p C p type d drop d n s last picture ptr s next picture ptr s current picture ptr s last picture ptr s last picture ptr f data 0 NULL s next picture ptr s next picture ptr f data 0 NULL s current picture ptr s current picture ptr f data 0 NULL s pict type s droppable if s codec id AVCODECID H264 if s last picture ptr NULL s last picture ptr f data 0 NULL s pict type AVPICTURETYPEI s picture structure PICTFRAME int h chroma shift v chroma shift av pix fmt get chroma sub sample s avctx pix fmt h chroma shift v chroma shift if s pict type AVPICTURETYPEI av log avctx AVLOGERROR warning first frame is no keyframe n else if s picture structure PICTFRAME av log avctx AVLOGINFO allocate dummy last picture for field based first keyframe n i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s last picture ptr s picture i if ff alloc picture s s last picture ptr 0 0 s last picture ptr NULL return 1 memset s last picture ptr f data 0 0 avctx height s last picture ptr f linesize 0 memset s last picture ptr f data 1 0x80 avctx height v chroma shift s last picture ptr f linesize 1 memset s last picture ptr f data 2 0x80 avctx height v chroma shift s last picture ptr f linesize 2 ff thread report progress s last picture ptr tf INTMAX 0 ff thread report progress s last picture ptr tf INTMAX 1 if s next picture ptr NULL s next picture ptr f data 0 NULL s pict type AVPICTURETYPEB i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s next picture ptr s picture i if ff alloc picture s s next picture ptr 0 0 s next picture ptr NULL return 1 ff thread report progress s next picture ptr tf INTMAX 0 ff thread report progress s next picture ptr tf INTMAX 1 if s codec id AVCODECID H264 if s last picture ptr ff mpeg unref picture s s last picture if s last picture ptr f data 0 ret ff mpeg ref picture s s last picture s last picture ptr 0 return ret if s next picture ptr ff mpeg unref picture s s next picture if s next picture ptr f data 0 ret ff mpeg ref picture s s next picture s next picture ptr 0 return ret assert s pict type AVPICTURETYPEI s last picture ptr s last picture ptr f data 0 if s picture structure PICTFRAME s out format FMT H264 int i for i 0 i 4 i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture f linesize i s current picture f linesize i 2 s last picture f linesize i 2 s next picture f linesize i 2 s err recognition avctx err recognition if s mpeg quant s codec id AVCODECIDMPE G2 VIDEO s dct unquantize intra s dct unquantize mpeg2 intra s dct unquantize inter s dct unquantize mpeg2 inter else if s out format FMT H263 s out format FMT H261 s dct unquantize intra s dct unquantize h263 intra s dct unquantize inter s dct unquantize h263 inter else s dct unquantize intra s dct unquantize mpeg1 intra s dct unquantize inter s dct unquantize mpeg1 inter if s dct error sum assert s avctx noise reduction s encoding update noise reduction s if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration return ff xvmc field start s avctx return 0 static int rc pick q and bounds one pass cbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc int active best quality int active worst quality calc active worst quality one pass cbr cpi int q int rtc minq ASSIGNMINQTABLE cm bit depth rtc minq if frame is intra only cm active best quality rc best quality if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else if cm current video frame 0 double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi use svc cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality active best quality get gf active quality rc q cm bit depth else if cm current video frame 1 if rc avg frame qindex INTERFRAME active worst quality active best quality rtc minq rc avg frame qindex INTERFRAME else active best quality rtc minq active worst quality else if rc avg frame qindex KEYFRAME active worst quality active best quality rtc minq rc avg frame qindex KEYFRAME else active best quality rtc minq active worst quality active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index gcry error t gcry mpi print enum gcry mpi format format unsigned char buffer size t buflen size t nwritten struct gcry mpi a unsigned int nbits mpi get nbits a size t len size t dummy nwritten int negative if nwritten nwritten dummy nwritten if a sign gcry mpi cmp ui a 0 negative 1 else negative 0 len buflen nwritten 0 if format GCRYMPIFMTSTD unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if extra s 0 memcpy s tmp n extra gcry free tmp nwritten n return 0 else if format GCRYMPIFMTUSG unsigned int n nbits 7 8 if buffer n len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy buffer tmp n gcry free tmp nwritten n return 0 else if format GCRYMPIFMTPGP unsigned int n nbits 7 8 if negative return gcry error GPGERRINVARG if buffer n 2 len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp unsigned char s buffer s 0 nbits 8 s 1 nbits tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy s 2 tmp n gcry free tmp nwritten n 2 return 0 else if format GCRYMPIFMTSSH unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n 4 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer s n 24 s n 16 s n 8 s n if extra s 0 memcpy s tmp n extra gcry free tmp nwritten 4 n return 0 else if format GCRYMPIFMTHEX unsigned char tmp int i int extra 0 unsigned int n 0 tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 extra 2 if buffer 2 n extra negative 1 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if negative s if extra s 0 s 0 for i 0 i n i unsigned int c tmp i s c 4 10 0 c 4 A c 4 10 c 15 s c 10 0 c A c 10 s 0 nwritten s buffer else nwritten 2 n extra negative 1 gcry free tmp return 0 else return gcry error static int ar parse gnu filename table struct archive read a struct ar ar char p size t size ar struct ar a format data size ar strtab size for p ar strtab p ar strtab size 1 p if p p 0 if p n goto bad string table p 0 if p ar strtab size p n p goto bad string table ar strtab size 1 0 return ARCHIVEOK bad string table archive set error a archive EINVAL Invalid string table free ar strtab ar strtab NULL return static void rv30 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int loc lim cur lim left lim 0 top lim 0 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if mb x left lim rv30 loop filt lim s current picture ptr f qscale table mb pos 1 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize 4 mb x for i mb x i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if i r deblock coefs mb pos 1 1 ij 3 loc lim left lim else if i r deblock coefs mb pos 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter Y 1 s linesize loc lim for k 0 k 2 k int cur cbp left cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if mb x left cbp r cbp chroma mb pos 1 k 4 0x F for j 0 j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize 4 mb x for i mb x i 2 i C 4 int ij i j 1 loc lim 0 if cur cbp 1 ij loc lim cur lim else if i left cbp 1 ij 1 loc lim left lim else if i cur cbp 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter C 1 s uvlinesize loc lim mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if row top lim rv30 loop filt lim s current picture ptr f qscale table mb pos s mb stride for j 4 row j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if j r deblock coefs mb pos s mb stride 1 ij 12 loc lim top lim else if j r deblock coefs mb pos 1 ij 4 loc lim cur lim if loc lim rv30 weak loop filter Y s linesize 1 loc lim for k 0 k 2 k int cur cbp top cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if row top cbp r cbp chroma mb pos s mb stride k 4 0x F for j 4 row j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize for i 0 i 2 i C 4 int ij i j 1 loc lim 0 if r cbp chroma mb pos 1 ij loc lim cur lim else if j top cbp 1 ij 2 loc lim top lim else if j cur cbp 1 ij 2 loc lim cur lim if loc lim rv30 weak loop filter C s uvlinesize 1 loc lim void vp9 dec build inter predictors sb MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane 0 plane MAXMBPLANE plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x dec build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else dec build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y void ff h264 filter mb H264 Context h int mb x int mb y uint8 t img y uint8 t img cb uint8 t img cr unsigned int linesize unsigned int uvlinesize const int mb xy mb x mb y h mb stride const int mb type h cur pic f mb type mb xy const int mvy limit ISINTERLACED mb type 2 4 int first vertical edge done 0 av unused int dir int chroma CONFIGGRAY h flags CODECFLAGGRAY int qp bd offset 6 h sps bit depth luma 8 int a h slice alpha c0 offset qp bd offset int b h slice beta offset qp bd offset if FRAMEMBAFFISINTERLACED mb type h left type LTOP h left type LTOPDECLAREALIGNED 8 int16 t b S 8 int qp 2 int bqp 2 int rqp 2 int mb qp mbn0 qp mbn1 qp int i first vertical edge done 1 if ISINTRA mb type AVW N64 A b S 0 0x0004000400040004 ULLAVW N64 A b S 4 0x0004000400040004 ULL else static const uint8 t offset 2 2 8 3 4 0 3 4 0 3 4 0 3 4 0 3 4 1 3 4 1 3 4 1 3 4 1 3 4 2 3 4 2 3 4 2 3 4 2 3 4 3 3 4 3 3 4 3 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 const uint8 t off offset MBFIELD mb y 1 for i 0 i 8 i int j MBFIELD i 2 i 1 int mbn xy h left mb xy LEFT j int mbn type h left type LEFT j if ISINTRA mbn type b S i 4 else b S i 1 h non zero count cache 12 8 i 1 h pps cabac IS 8x8 DCT mbn type h cbp table mbn xy MBFIELD i 2 mb y 1 8 2 12 h non zero count mbn xy off i mb qp h cur pic f qscale table mb xy mbn0 qp h cur pic f qscale table h left mb xy 0 mbn1 qp h cur pic f qscale table h left mb xy 1 qp 0 mb qp mbn0 qp 1 1 bqp 0 get chroma qp h 0 mb qp get chroma qp h 0 mbn0 qp 1 1 rqp 0 get chroma qp h 1 mb qp get chroma qp h 1 mbn0 qp 1 1 qp 1 mb qp mbn1 qp 1 1 bqp 1 get chroma qp h 0 mb qp get chroma qp h 0 mbn1 qp 1 1 rqp 1 get chroma qp h 1 mb qp get chroma qp h 1 mbn1 qp 1 1 tprintf h avctx filter mb d d MBAFFQ Py d d Q Pb d d Q Pr d d ls d uvls d mb x mb y qp 0 qp 1 bqp 0 bqp 1 rqp 0 rqp 1 linesize uvlinesize int i for i 0 i 8 i tprintf h avctx b S d d i b S i tprintf h avctx n if MBFIELD filter mb mbaff edgev h img y linesize b S 1 qp 0 a b 1 filter mb mbaff edgev h img y 8 linesize linesize b S 4 1 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgev h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgev h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgev h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else if CHROM A422 filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 4 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 4 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgev h img y 2 linesize b S 2 qp 0 a b 1 filter mb mbaff edgev h img y linesize 2 linesize b S 1 2 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgev h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgev h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgev h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 else filter mb mbaff edgecv h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgecv h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgecv h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgecv h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 dir 2 dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit dir 0 first vertical edge done a b chroma dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit 0 a b chroma 1 static uint32 t vmport cmd ram size void opaque uint32 t addr X86 CPU cpu X86 CPU current cpu cpu env regs REBX 0x1177 return ram size static void define gf group V P9 COMP cpi FIRSTPASSSTATS this frame RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf TWOPASS const twopass cpi twopass FIRSTPASSSTATS next frame const FIRSTPASSSTATS const start pos twopass stats in int i double boost score 0 0 double old boost score 0 0 double gf group err 0 0 double gf first frame err 0 0 double mod frame err 0 0 double mv ratio accumulator 0 0 double decay accumulator 1 0 double zero motion accumulator 1 0 double loop decay rate 1 00 double last loop decay rate 1 00 double this frame mv in out 0 0 double mv in out accumulator 0 0 double abs mv in out accumulator 0 0 double mv ratio accumulator thresh unsigned int allow alt ref is altref enabled cpi int f boost 0 int b boost 0 int flash detected int active max gf interval int64 t gf group bits double gf group error left int gf arf bits if cpi common frame type KEYFRAME vp9 zero twopass gf group vp9 clear system state vp9 zero next frame mod frame err calculate modified err twopass oxcf this frame gf first frame err mod frame err if cpi common frame type KEYFRAME rc source alt ref active gf group err gf first frame err mv ratio accumulator thresh cpi common width cpi common height 10 0 if cpi multi arf allowed active max gf interval rc max gf interval else active max gf interval int vp9 convert qindex to q rc last q INTERFRAME 5 if active max gf interval rc max gf interval active max gf interval rc max gf interval i 0 while i rc static scene max gf interval i rc frames to key i mod frame err calculate modified err twopass oxcf this frame gf group err mod frame err if EOF input stats twopass next frame break flash detected detect flash twopass 0 accumulate frame motion stats next frame this frame mv in out mv in out accumulator abs mv in out accumulator mv ratio accumulator if flash detected last loop decay rate loop decay rate loop decay rate get prediction decay rate cpi common next frame decay accumulator decay accumulator loop decay rate zero motion accumulator MIN zero motion accumulator get zero motion factor next frame if detect transition to still twopass i 5 loop decay rate last loop decay rate allow alt ref 0 break boost score decay accumulator calc frame boost twopass next frame this frame mv in out if i active max gf interval zero motion accumulator 0 995 i MINGFINTERVAL boost score 125 0 next frame pcnt inter 0 75 flash detected mv ratio accumulator mv ratio accumulator thresh abs mv in out accumulator 3 0 mv in out accumulator 2 0 boost score old boost score IIFACTOR boost score old boost score break this frame next frame old boost score boost score twopass gf zeromotion pct int zero motion accumulator 1000 0 if rc frames to key i MINGFINTERVAL while i rc frames to key rc next key frame forced i if EOF input stats twopass this frame break if i rc frames to key mod frame err calculate modified err twopass oxcf this frame gf group err mod frame err if cpi common frame type KEYFRAME rc source alt ref active rc baseline gf interval i 1 else rc baseline gf interval i if is two pass svc cpi cpi svc number temporal layers 1 int count 1 cpi svc number temporal layers 1 1 int new gf interval rc baseline gf interval count count int j for j 0 j new gf interval rc baseline gf interval j if EOF input stats twopass this frame break gf group err calculate modified err twopass oxcf this frame rc baseline gf interval new gf interval rc frames till gf update due rc baseline gf interval if allow alt ref i cpi oxcf lag in frames i MINGFINTERVAL rc next key frame forced i rc frames to key MINGFINTERVAL rc gfu boost calc arf boost cpi 0 i 1 i 1 f boost b boost rc source alt ref pending 1 cpi multi arf enabled cpi multi arf allowed rc baseline gf interval 6 zero motion accumulator 0 995 1 0 else rc gfu boost int boost score rc source alt ref pending 0 reset fpf position twopass start pos gf group bits calculate total gf group bits cpi gf group err int q rc last q INTERFRAME int boost rc gfu boost gfboost qadjust q 100 boost clamp boost 125 rc baseline gf interval 1 200 gf arf bits calculate boost bits rc baseline gf interval boost gf group bits twopass kf group error left int64 t gf group err if rc source alt ref pending gf group error left gf group err mod frame err else if cpi common frame type KEYFRAME gf group error left gf group err gf first frame err else gf group error left gf group err allocate gf group bits cpi gf group bits gf group error left gf arf bits reset fpf position twopass start pos if cpi common frame type KEYFRAME twopass section intra rating calculate section intra ratio start pos twopass stats in end rc baseline gf interval static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt T M2 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size 3 AV Frame const p l pic int offset T M2 HEADERSIZE int i t ret uint8 t swbuf swbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if swbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n av free swbuf return ret l dsp bswap buf uint32 t swbuf const uint32 t buf buf size 2 if ret tm2 read header l swbuf 0 av free swbuf return ret for i 0 i T M2 NUMSTREAMS i if offset buf size av free swbuf return AVERRORINVALIDDATA t tm2 read stream l swbuf offset tm2 stream order i buf size offset if t 0 av free swbuf return t offset t p key frame tm2 decode blocks l p if p key frame p pict type AVPICTURETYPEI else p pict type AVPICTURETYPEP l cur l cur got frame 1 ret av frame ref data l pic av free swbuf return ret 0 ret buf size void vp9 append sub8x8 mvs for idx V P9 COMMON cm MACROBLOCKD xd const Tile Info const tile int block int ref int mi row int mi col int mv nearest int mv near int mv mv list MAXMVREFCANDIDATESMODEINFO const mi xd mi 0 b mode info bmi mi bmi int n assert MAXMVREFCANDIDATES 2 find mv refs idx cm xd tile mi mi mbmi ref frame ref mv list block mi row mi col near as int 0 switch block case 0 nearest as int mv list 0 as int near as int mv list 1 as int break case 1 case 2 nearest as int bmi 0 as mv ref as int for n 0 n MAXMVREFCANDIDATES n if nearest as int mv list n as int near as int mv list n as int break break case 3 int mv candidates 2 MAXMVREFCANDIDATES candidates 0 bmi 1 as mv ref candidates 1 bmi 0 as mv ref candidates 2 mv list 0 candidates 3 mv list 1 nearest as int bmi 2 as mv ref as int for n 0 n 2 MAXMVREFCANDIDATES n if nearest as int candidates n as int near as int candidates n as int break break default assert Invalid block index static Selectivity calc arraycontsel Variable Stat Data vardata Datum constval Oid elemtype Oid operator Selectivity selec Type Cache Entry typentry Fmgr Info cmpfunc Array Type array typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid return DEFAULTSEL operator cmpfunc typentry cmp proc finfo array Datum Get Array Type P constval if Heap Tuple Is Valid vardata stats Tuple Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if operator OIDARRAYCONTAINEDOP get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 selec mcelem array selec array typentry values nvalues numbers nnumbers hist nhist operator cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc selec 1 0 stats stanullfrac else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc if Pointer Get Datum array constval pfree array return selec static void evsignal cb int fd short what void arg static char signals 1 if n 1 int err EVUTILSOCKETERROR if error is eagain err event err 1 s read func static int flic decode frame 8 BPPAV Codec Context avctx void data int got frame const uint8 t buf int buf size Flic Decode Context s avctx priv data Get Byte Context g2 int stream ptr after color chunk int pixel ptr int palette ptr unsigned char palette idx1 unsigned char palette idx2 unsigned int frame size int num chunks unsigned int chunk size int chunk type int i j ret int color packets int color changes int color shift unsigned char r g b int lines int compressed lines int starting line signed short line packets int y ptr int byte run int pixel skip int pixel countdown unsigned char pixels unsigned int pixel limit bytestream2 init g2 buf buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret pixels s frame data 0 pixel limit s avctx height s frame linesize 0 frame size bytestream2 get le32 g2 bytestream2 skip g2 2 num chunks bytestream2 get le16 g2 bytestream2 skip g2 8 frame size 16 while frame size 0 num chunks 0 chunk size bytestream2 get le32 g2 chunk type bytestream2 get le16 g2 switch chunk type case FLI 256 COLOR case FLICOLOR stream ptr after color chunk bytestream2 tell g2 chunk size 6 if chunk type FLI 256 COLOR s fli type FLCMAGICCARPETSYNTHETICTYPECODE color shift 0 else color shift 2 color packets bytestream2 get le16 g2 palette ptr 0 for i 0 i color packets i palette ptr bytestream2 get byte g2 color changes bytestream2 get byte g2 if color changes 0 color changes 256 for j 0 j color changes j unsigned int entry if unsigned palette ptr 256 palette ptr 0 r bytestream2 get byte g2 color shift g bytestream2 get byte g2 color shift b bytestream2 get byte g2 color shift entry r 16 g 8 b if s palette palette ptr entry s new palette 1 s palette palette ptr entry if stream ptr after color chunk bytestream2 tell g2 0 bytestream2 skip g2 stream ptr after color chunk bytestream2 tell g2 break case FLIDELTA y ptr 0 compressed lines bytestream2 get le16 g2 while compressed lines 0 line packets bytestream2 get le16 g2 if line packets 0x C000 0x C000 line packets line packets y ptr line packets s frame linesize 0 else if line packets 0x C000 0x4000 av log avctx AVLOGERROR Undefined opcode x in DELTAFLI n line packets else if line packets 0x C000 0x8000 pixel ptr y ptr s frame linesize 0 1 CHECKPIXELPTR 0 pixels pixel ptr line packets 0xff else compressed lines pixel ptr y ptr CHECKPIXELPTR 0 pixel countdown s avctx width for i 0 i line packets i pixel skip bytestream2 get byte g2 pixel ptr pixel skip pixel countdown pixel skip byte run sign extend bytestream2 get byte g2 8 if byte run 0 byte run byte run palette idx1 bytestream2 get byte g2 palette idx2 bytestream2 get byte g2 CHECKPIXELPTR byte run 2 for j 0 j byte run j pixel countdown 2 pixels pixel ptr palette idx1 pixels pixel ptr palette idx2 else CHECKPIXELPTR byte run 2 for j 0 j byte run 2 j pixel countdown pixels pixel ptr bytestream2 get byte g2 y ptr s frame linesize 0 break case FLILC starting line bytestream2 get le16 g2 y ptr 0 y ptr starting line s frame linesize 0 compressed lines bytestream2 get le16 g2 while compressed lines 0 pixel ptr y ptr CHECKPIXELPTR 0 pixel countdown s avctx width line packets bytestream2 get byte g2 if line packets 0 for i 0 i line packets i pixel skip bytestream2 get byte g2 pixel ptr pixel skip pixel countdown pixel skip byte run sign extend bytestream2 get byte g2 8 if byte run 0 CHECKPIXELPTR byte run for j 0 j byte run j pixel countdown pixels pixel ptr bytestream2 get byte g2 else if byte run 0 byte run byte run palette idx1 bytestream2 get byte g2 CHECKPIXELPTR byte run for j 0 j byte run j pixel countdown pixels pixel ptr palette idx1 y ptr s frame linesize 0 compressed lines break case FLIBLACK memset pixels 0 s frame linesize 0 s avctx height break case FLIBRUN y ptr 0 for lines 0 lines s avctx height lines pixel ptr y ptr bytestream2 skip g2 1 pixel countdown s avctx width while pixel countdown 0 byte run sign extend bytestream2 get byte g2 8 if byte run av log avctx AVLOGERROR Invalid byte run value n return AVERRORINVALIDDATA if byte run 0 palette idx1 bytestream2 get byte g2 CHECKPIXELPTR byte run for j 0 j byte run j pixels pixel ptr palette idx1 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d at line d n pixel countdown lines else byte run byte run CHECKPIXELPTR byte run for j 0 j byte run j pixels pixel ptr bytestream2 get byte g2 pixel countdown if pixel countdown 0 av log avctx AVLOGERROR pixel countdown 0 d at line d n pixel countdown lines y ptr s frame linesize 0 break case FLICOPY if chunk size 6 s avctx width s avctx height av log avctx AVLOGERROR In chunk FLICOPY source data d bytes bigger than image skipping chunk n chunk size 6 bytestream2 skip g2 chunk size 6 else for y ptr 0 y ptr s frame linesize 0 s avctx height y ptr s frame linesize 0 bytestream2 get buffer g2 pixels y ptr s avctx width break case FLIMINI bytestream2 skip g2 chunk size 6 break default av log avctx AVLOGERROR Unrecognized chunk type d n chunk type break frame size chunk size num chunks if bytestream2 get bytes left g2 0 bytestream2 get bytes left g2 1 av log avctx AVLOGERROR Processed FLI chunk where chunk size d and final chunk ptr d n buf size buf size bytestream2 get bytes left g2 memcpy s frame data 1 s palette AVPALETTESIZE if s new palette s frame palette has changed 1 s new palette 0 if ret av frame ref data s frame 0 return ret got frame 1 return buf size static int qtrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Qtrle Context s avctx priv data int header start line int height row ptr int has palette 0 int ret bytestream2 init s g avpkt data avpkt size if ret ff reget buffer avctx s frame 0 av log s avctx AVLOGERROR reget buffer failed n return ret if avpkt size 8 goto done bytestream2 seek s g 4 SEEKSET header bytestream2 get be16 s g if header 0x0008 if avpkt size 14 goto done start line bytestream2 get be16 s g bytestream2 skip s g 2 height bytestream2 get be16 s g bytestream2 skip s g 2 else start line 0 height s avctx height row ptr s frame linesize 0 start line switch avctx bits per coded sample case 1 case 33 qtrle decode 1bpp s row ptr height break case 2 case 34 qtrle decode 2n4bpp s row ptr height 2 has palette 1 break case 4 case 36 qtrle decode 2n4bpp s row ptr height 4 has palette 1 break case 8 case 40 qtrle decode 8bpp s row ptr height has palette 1 break case 16 qtrle decode 16bpp s row ptr height break case 24 qtrle decode 24bpp s row ptr height break case 32 qtrle decode 32bpp s row ptr height break default av log s avctx AVLOGERROR Unsupported colorspace d bits sample n avctx bits per coded sample break if has palette const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE done if ret av frame ref data s frame 0 return ret got frame 1 return avpkt size void ff estimate b frame motion Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me const int penalty factor c mb penalty factor int fmin bmin dmin fbmin bimin fimin int type 0 const int xy mb y s mb stride mb x init ref c s new picture f data s last picture f data s next picture f data 16 mb x 16 mb y 2 get limits s 16 mb x 16 mb y c skip 0 if s codec id AVCODECIDMPE G4 s next picture f mbskip table xy int score direct search s mb x mb y score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score s mb type mb y s mb stride mb x CANDIDATEMBTYPEDIREC T0 return if s codec id AVCODECIDMPE G4 dmin direct search s mb x mb y else dmin INTMAX c skip 0 fmin ff estimate motion b s mb x mb y s b forw mv table 0 s f code 3 penalty factor c skip 0 bmin ff estimate motion b s mb x mb y s b back mv table 2 s b code 2 penalty factor av dlog s d d s b forw mv table xy 0 s b forw mv table xy 1 c skip 0 fbmin bidir refine s mb x mb y penalty factor av dlog s d d d d n dmin fmin bmin fbmin if s flags CODECFLAGINTERLACEDME c skip 0 c current mv penalty c mv penalty s f code MAXMV fimin interlaced search s 0 s b field mv table 0 s b field select table 0 s b forw mv table xy 0 s b forw mv table xy 1 0 c current mv penalty c mv penalty s b code MAXMV bimin interlaced search s 2 s b field mv table 1 s b field select table 1 s b back mv table xy 0 s b back mv table xy 1 0 else fimin bimin INTMAX int score fmin type CANDIDATEMBTYPEFORWARD if dmin score score dmin type CANDIDATEMBTYPEDIRECT if bmin score score bmin type CANDIDATEMBTYPEBACKWARD if fbmin score score fbmin type CANDIDATEMBTYPEBIDIR if fimin score score fimin type CANDIDATEMBTYPEFORWARDI if bimin score score bimin type CANDIDATEMBTYPEBACKWARDI score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score if c avctx mb decision FFMBDECISIONSIMPLE type CANDIDATEMBTYPEFORWARDCANDIDATEMBTYPEBACKWARDCANDIDATEMBTYPEBIDIRCANDIDATEMBTYPEDIRECT if fimin INTMAX type CANDIDATEMBTYPEFORWARDI if bimin INTMAX type CANDIDATEMBTYPEBACKWARDI if fimin INTMAX bimin INTMAX type CANDIDATEMBTYPEBIDIRI if dmin 256 256 16 type CANDIDATEMBTYPEDIRECT if s codec id AVCODECIDMPE G4 type CANDIDATEMBTYPEDIRECT s flags CODECFLAGM V0 uint32 t s b direct mv table xy type CANDIDATEMBTYPEDIREC T0 s mb type mb y s mb stride mb x type void vp9 rc postencode update V P9 COMP cpi uint64 t bytes used const V P9 COMMON const cm cpi common const V P9 Encoder Config const oxcf cpi oxcf RATECONTROL const rc cpi rc const int qindex cm base qindex rc projected frame size int bytes used 3 vp9 rc update rate correction factors cpi cpi sf recode loop ALLOWRECODEKFARFGF oxcf rc mode VPXCBR 2 0 if cm frame type KEYFRAME rc last q KEYFRAME qindex rc avg frame qindex KEYFRAMEROUNDPOWEROFTWO 3 rc avg frame qindex KEYFRAME qindex 2 else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame cpi use svc oxcf rc mode VPXCBR rc last q INTERFRAME qindex rc avg frame qindex INTERFRAMEROUNDPOWEROFTWO 3 rc avg frame qindex INTERFRAME qindex 2 rc ni frames rc tot q vp9 convert qindex to q qindex cm bit depth rc avg q rc tot q rc ni frames rc ni tot qi qindex rc ni av qi rc ni tot qi rc ni frames if qindex rc last boosted qindex cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame rc is src frame alt ref rc last boosted qindex qindex if cm frame type KEYFRAME rc last kf qindex qindex update buffer level cpi rc projected frame size if cm frame type KEYFRAME rc rolling target bits ROUNDPOWEROFTWO rc rolling target bits 3 rc this frame target 2 rc rolling actual bits ROUNDPOWEROFTWO rc rolling actual bits 3 rc projected frame size 2 rc long rolling target bits ROUNDPOWEROFTWO rc long rolling target bits 31 rc this frame target 5 rc long rolling actual bits ROUNDPOWEROFTWO rc long rolling actual bits 31 rc projected frame size 5 rc total actual bits rc projected frame size rc total target bits cm show frame rc avg frame bandwidth 0 rc total target vs actual rc total actual bits rc total target bits if is altref enabled cpi cpi refresh alt ref frame cm frame type KEYFRAME update alt ref frame stats cpi else update golden frame stats cpi if cm frame type KEYFRAME rc frames since key 0 if cm show frame rc frames since key rc frames to key void vp9 set rd speed thresholds V P9 COMP cpi int i RDOPT const rd cpi rd SPEEDFEATURES const sf cpi sf for i 0 i MAXMODES i rd thresh mult i cpi oxcf mode BEST 500 0 rd thresh mult THRNEARESTMV 0 rd thresh mult THRNEARESTG 0 rd thresh mult THRNEARESTA 0 rd thresh mult THRDC 1000 rd thresh mult THRNEWMV 1000 rd thresh mult THRNEWA 1000 rd thresh mult THRNEWG 1000 rd thresh mult THRNEWMV sf elevate newmv thresh rd thresh mult THRNEARMV 1000 rd thresh mult THRNEARA 1000 rd thresh mult THRCOMPNEARESTLA 1000 rd thresh mult THRCOMPNEARESTGA 1000 rd thresh mult THRTM 1000 rd thresh mult THRCOMPNEARLA 1500 rd thresh mult THRCOMPNEWLA 2000 rd thresh mult THRNEARG 1000 rd thresh mult THRCOMPNEARGA 1500 rd thresh mult THRCOMPNEWGA 2000 rd thresh mult THRZEROMV 2000 rd thresh mult THRZEROG 2000 rd thresh mult THRZEROA 2000 rd thresh mult THRCOMPZEROLA 2500 rd thresh mult THRCOMPZEROGA 2500 rd thresh mult THRHPRED 2000 rd thresh mult THRVPRED 2000 rd thresh mult THR D45 PRED 2500 rd thresh mult THR D135 PRED 2500 rd thresh mult THR D117 PRED 2500 rd thresh mult THR D153 PRED 2500 rd thresh mult THR D207 PRED 2500 rd thresh mult THR D63 PRED 2500 if cpi ref frame flags V P9 LASTFLAG rd thresh mult THRNEWMVINTMAX rd thresh mult THRNEARESTMVINTMAX rd thresh mult THRZEROMVINTMAX rd thresh mult THRNEARMVINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult THRNEARESTGINTMAX rd thresh mult THRZEROGINTMAX rd thresh mult THRNEARGINTMAX rd thresh mult THRNEWGINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult THRNEARESTAINTMAX rd thresh mult THRZEROAINTMAX rd thresh mult THRNEARAINTMAX rd thresh mult THRNEWAINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROLAINTMAX rd thresh mult THRCOMPNEARESTLAINTMAX rd thresh mult THRCOMPNEARLAINTMAX rd thresh mult THRCOMPNEWLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROGAINTMAX rd thresh mult THRCOMPNEARESTGAINTMAX rd thresh mult THRCOMPNEARGAINTMAX rd thresh mult static int decode tag AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Nelly Moser Decode Context s avctx priv data int blocks i ret float samples flt blocks buf size NELLYBLOCKLEN if blocks 0 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if buf size NELLYBLOCKLEN av log avctx AVLOGWARNING Leftover bytes d n buf size NELLYBLOCKLEN frame nb samples NELLYSAMPLES blocks if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples flt float frame data 0 for i 0 i blocks i nelly decode block s buf samples flt samples flt NELLYSAMPLES buf NELLYBLOCKLEN got frame ptr 1 return buf size static void joint motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mv frame mv int mi row int mi col int mv single newmv MAXREFFRAMES int rate mv const int pw 4 num 4x4 blocks wide lookup bsize const int ph 4 num 4x4 blocks high lookup bsize MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi const int refs 2 mbmi ref frame 0 mbmi ref frame 1 0 0 mbmi ref frame 1 int mv ref mv 2 int ite ref uint8 t second pred vpx memalign 16 pw ph sizeof uint8 t const Interp Kernel kernel vp9 get interp kernel mbmi interp filter struct buf 2d backup yv12 2 MAXMBPLANE struct buf 2d scaled first yv12 xd plane 0 pre 0 int last besterr 2 INTMAXINTMAX const Y V12 BUFFERCONFIG const scaled ref frame 2 vp9 get scaled ref frame cpi mbmi ref frame 0 vp9 get scaled ref frame cpi mbmi ref frame 1 for ref 0 ref 2 ref ref mv ref mbmi ref mvs refs ref 0 if scaled ref frame ref int i for i 0 i MAXMBPLANE i backup yv12 ref i xd plane i pre ref vp9 setup pre planes xd ref scaled ref frame ref mi row mi col NULL frame mv refs ref as int single newmv refs ref as int for ite 0 ite 4 ite struct buf 2d ref yv12 2 int bestsme INTMAX int sadpb x sadperbit16 MV tmp mv int search range 3 int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int id ite 2 ref yv12 0 xd plane 0 pre 0 ref yv12 1 xd plane 0 pre 1 vp9 build inter predictor ref yv12 id buf ref yv12 id stride second pred pw frame mv refs id as mv xd block refs id sf pw ph 0 kernel MVPRECISION Q3 mi col MISIZE mi row MISIZE if id xd plane 0 pre 0 ref yv12 id vp9 set mv search range x ref mv id as mv tmp mv frame mv refs id as mv tmp mv col 3 tmp mv row 3 bestsme vp9 refining search 8p c x tmp mv sadpb search range cpi fn ptr bsize ref mv id as mv second pred if bestsme INTMAX bestsme vp9 get mvpred av var x tmp mv ref mv id as mv second pred cpi fn ptr bsize 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis unsigned int sse bestsme cpi find fractional mv step x tmp mv ref mv id as mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize 0 cpi sf mv subpel iters per step NULL x nmvjointcost x mvcost dis sse second pred pw ph if id xd plane 0 pre 0 scaled first yv12 if bestsme last besterr id frame mv refs id as mv tmp mv last besterr id bestsme else break rate mv 0 for ref 0 ref 2 ref if scaled ref frame ref int i for i 0 i MAXMBPLANE i xd plane i pre ref backup yv12 ref i rate mv vp9 mv bit cost frame mv refs ref as mv mbmi ref mvs refs ref 0 as mv x nmvjointcost x mvcost MVCOSTWEIGHT vpx free second pred void vp9 init me luts int i for i 0 i QINDEXRANGE i const double q vp9 convert qindex to q i sad per bit16lut i int 0 0418 q 2 4107 sad per bit4lut i int 0 063 q 2 742 static void add range fz context ctx pdf cmap cmap unsigned int low unsigned int high unsigned int out int check for overlap int many int current cmap splay tree if low high fz warn ctx range limits out of range in cmap s cmap cmap name return tree cmap tree if cmap tlen unsigned int move cmap ttop unsigned int gt EMPTY unsigned int lt EMPTY if check for overlap do current move if low tree current low tree current low high tree current out high 1 tree current low tree current low high 1 if tree current low tree current high move delete node cmap current current EMPTY continue else if low tree current high tree current high high tree current high low 1 assert tree current low tree current high else if tree current low low high tree current high int new high tree current high tree current high low 1 add range ctx cmap high 1 new high tree current out high 1 tree current low 0 many if tree current low high move tree current left gt current else move tree current right lt current while move EMPTY else do current move if tree current low high move tree current left gt current else move tree current right lt current while move EMPTY if many if lt EMPTY tree lt many tree lt high low 1 tree lt out tree lt low out low tree lt high high if gt EMPTY tree gt many tree gt low high 1 tree gt out tree gt low out low tree lt high tree gt high delete node cmap gt goto exit if gt EMPTY tree gt many tree gt low high 1 tree gt out tree gt low out low tree gt low low tree gt out out goto exit else current EMPTY if cmap tlen cmap tcap int new cap cmap tcap cmap tcap 2 256 tree cmap tree fz resize array ctx cmap tree new cap sizeof cmap tree cmap tcap new cap tree cmap tlen low low tree cmap tlen high high tree cmap tlen out out tree cmap tlen parent current tree cmap tlen left EMPTY tree cmap tlen right EMPTY tree cmap tlen many many cmap tlen if current EMPTY cmap ttop 0 else if tree current low high tree current left cmap tlen 1 else assert tree current high low tree current right cmap tlen 1 move to root tree cmap tlen 1 cmap ttop cmap tlen 1 exit static guint32 dissect minivideopacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet gboolean rtp marker proto item item ts tvb get ntohs tvb offset rtp marker ts 0x8000 TRUEFALSE ts 0x8000 iax packet iax2 get packet data for minipacket pinfo scallno TRUE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add item iax2 tree hf iax2 minividts tvb offset 2 ENCBIGENDIAN iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts proto tree add item iax2 tree hf iax2 minividmarker tvb offset 2 ENCBIGENDIAN else iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini video packet source call d timestamp ums s scallno ts rtp marker Mark dissect payload tvb offset pinfo iax2 tree main tree ts TRUE iax packet iax packet first time FALSE return offset static Asn1 Generic Decode Asn1 Der Set const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node Asn1 Generic child d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SET node data NULL c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL seq index 0 el max size max size d ptr buffer child Decode Asn1 Der Generic d ptr el max size depth seq index errcode node data child return Asn1 Generic node static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size C93 Decoder Context const c93 avctx priv data AV Frame const newpic c93 pictures c93 currentpic AV Frame const oldpic c93 pictures c93 currentpic 1 AV Frame picture data Get Byte Context gb uint8 t out int stride ret i x y b bt 0 c93 currentpic 1 newpic reference 1 newpic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLEFFBUFFERHINTSREADABLE if ret avctx reget buffer avctx newpic 0 av log avctx AVLOGERROR reget buffer failed n return ret stride newpic linesize 0 bytestream2 init gb buf buf size b bytestream2 get byte gb if b C93 FIRSTFRAME newpic pict type AVPICTURETYPEI newpic key frame 1 else newpic pict type AVPICTURETYPEP newpic key frame 0 for y 0 y HEIGHT y 8 out newpic data 0 y stride for x 0 x WIDTH x 8 uint8 t copy from oldpic data 0 unsigned int offset j uint8 t cols 4 grps 4 C93 Block Type block type if bt bt bytestream2 get byte gb block type bt 0x0 F switch block type case C93 8 X8 FROMPREV offset bytestream2 get le16 gb if ret copy block avctx out copy from offset 8 stride 0 return ret break case C93 4 X4 FROMCURR copy from newpic data 0 case C93 4 X4 FROMPREV for j 0 j 8 j 4 for i 0 i 8 i 4 offset bytestream2 get le16 gb if ret copy block avctx out j stride i copy from offset 4 stride 0 return ret break case C93 8 X8 2 COLOR bytestream2 get buffer gb cols 2 for i 0 i 8 i draw n color out i stride stride 8 1 1 cols NULL bytestream2 get byte gb break case C93 4 X4 2 COLOR case C93 4 X4 4 COLOR case C93 4 X4 4 COLORGRP for j 0 j 8 j 4 for i 0 i 8 i 4 if block type C93 4 X4 2 COLOR bytestream2 get buffer gb cols 2 draw n color out i j stride stride 4 4 1 cols NULL bytestream2 get le16 gb else if block type C93 4 X4 4 COLOR bytestream2 get buffer gb cols 4 draw n color out i j stride stride 4 4 2 cols NULL bytestream2 get le32 gb else bytestream2 get buffer gb grps 4 draw n color out i j stride stride 4 4 1 cols grps bytestream2 get le16 gb break case C93 NOOP break case C93 8 X8 INTRA for j 0 j 8 j bytestream2 get buffer gb out j stride 8 break default av log avctx AVLOGERROR unexpected type x at dx d n block type x y return AVERRORINVALIDDATA bt 4 out 8 if b C93 HASPALETTE uint32 t palette uint32 t newpic data 1 for i 0 i 256 i palette i bytestream2 get be24 gb newpic palette has changed 1 else if oldpic data 1 memcpy newpic data 1 oldpic data 1 256 4 picture newpic got frame 1 return buf size void ff MPV frame end Mpeg Enc Context s int i if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s else if s er error count s encoding s avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU s unrestricted mv s current picture f reference s intra only s flags CODECFLAGEMUEDGE const AV Pix Fmt Descriptor desc av pix fmt desc get s avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h s dsp draw edges s current picture f data 0 s linesize s h edge pos s v edge pos EDGEWIDTHEDGEWIDTHEDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 1 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 2 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM emms c s last pict type s pict type s last lambda for s pict type s current picture ptr f quality if s pict type AVPICTURETYPEB s last non b pict type s pict type i MAXPICTURECOUNT i if s picture i f data 0 s current picture f data 0 s picture i s current picture break assert i MAXPICTURECOUNT for i 0 i s picture count i if s picture i f data 0 s picture i f reference free frame buffer s s picture i static int evhttp parse response line struct evhttp request req char line char protocol char number char readable protocol strsep line if line NULL return 1 number strsep line if line NULL return 1 readable line if strcmp protocol HTTP 1 0 0 req major 1 req minor 0 else if strcmp protocol HTTP 1 1 0 req major 1 req minor 1 else event debug s bad protocol s func protocol return 1 req response code atoi number if evhttp valid response code req response code event debug s bad response code s func number return 1 if req response code line strdup readable NULL event err 1 s strdup func return 0 int64 t vp9 rd pick inter mode sub8x8 V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best yrd best rd so far static const int64 t best tx diff TXMODES 0 int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int ref index best ref index 0 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER tmp best filter SWITCHABLE int rate uv intra rate uv tokenonly int64 t dist uv int skip uv PREDICTIONMODE mode uv DCPRED const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int mv seg mvs 4 MAXREFFRAMES b mode info best bmodes 4 int best skip2 0 int ref frame skip mask 2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH vpx memset x zcoeff blk TX 4 X4 0 4 vp9 zero best mbmode for i 0 i 4 i int j for j 0 j MAXREFFRAMES j seg mvs i j as int INVALIDMV estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX rate uv intra INTMAX returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb else ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref index 0 ref index MAXREFS ref index int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int i int this skip2 0 int64 t total sse INTMAX int early term 0 ref frame vp9 ref order ref index ref frame 0 second ref frame vp9 ref order ref index ref frame 1 if ref index 2 cpi sf mode skip start MAXMODES if ref index 3 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 1 GOLDENFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 1 LASTFRAME 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 1 GOLDENFRAME 1 LASTFRAME break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if rd less than thresh best rd rd opt threshes segment id bsize ref index rd opt thresh freq fact bsize ref index continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if cpi sf mode search skip flags FLAGSKIPCOMPBESTINTRA best mbmode ref frame 0 INTRAFRAME continue if ref frame INTRAFRAME vp9 is scaled cm frame refs ref frame 1 sf continue if second ref frame INTRAFRAME vp9 is scaled cm frame refs second ref frame 1 sf continue if comp pred mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame continue else if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 continue mbmi tx size TX 4 X4 mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i if ref frame INTRAFRAME int rate if rd pick intra sub 8x8 y mode cpi x rate rate y distortion y best rd best rd continue rate2 rate rate2 intra cost penalty distortion2 distortion y if rate uv intra INTMAX choose intra uv mode cpi ctx bsize TX 4 X4 rate uv intra rate uv tokenonly dist uv skip uv mode uv rate2 rate uv intra rate uv rate uv tokenonly distortion2 dist uv distortion uv dist uv mbmi uv mode mode uv else int rate int64 t distortion int64 t this rd thresh int64 t tmp rd tmp best rd IN T64 MAX tmp best rdu IN T64 MAX int tmp best rate INTMAX tmp best ratey INTMAX int64 t tmp best distortion INTMAX tmp best sse uv sse int tmp best skippable 0 int switchable filter index int mv second ref comp pred mbmi ref mvs second ref frame 0 NULL b mode info tmp best bmodes 16 MBMODEINFO tmp best mbmode BESTSEGINFO bsi SWITCHABLEFILTERS int pred exists 0 int uv skippable this rd thresh ref frame LASTFRAME rd opt threshes segment id bsize THRLAST rd opt threshes segment id bsize THRALTR this rd thresh ref frame GOLDENFRAME rd opt threshes segment id bsize THRGOLD this rd thresh rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR tmp best filter EIGHTTAP if x source variance cpi sf disable filter search var thresh tmp best filter EIGHTTAP else if cpi sf adaptive pred interp filter 1 ctx pred interp filter SWITCHABLE tmp best filter ctx pred interp filter else if cpi sf adaptive pred interp filter 2 tmp best filter ctx pred interp filter SWITCHABLE ctx pred interp filter 0 else for switchable filter index 0 switchable filter index SWITCHABLEFILTERS switchable filter index int newbest rs int64 t rs rd mbmi interp filter switchable filter index tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi switchable filter index mi row mi col if tmp rd IN T64 MAX continue rs vp9 get switchable rate cpi rs rd RDCOST x rdmult x rddiv rs 0 rd opt filter cache switchable filter index tmp rd rd opt filter cache SWITCHABLEFILTERSMIN rd opt filter cache SWITCHABLEFILTERS tmp rd rs rd if cm interp filter SWITCHABLE tmp rd rs rd rd opt mask filter MAX rd opt mask filter tmp rd newbest tmp rd tmp best rd if newbest tmp best filter mbmi interp filter tmp best rd tmp rd if newbest cm interp filter SWITCHABLE mbmi interp filter cm interp filter cm interp filter SWITCHABLE tmp best rdu tmp rd tmp best rate rate tmp best ratey rate y tmp best distortion distortion tmp best sse total sse tmp best skippable skippable tmp best mbmode mbmi for i 0 i 4 i tmp best bmodes i xd mi 0 src mi bmi i x zcoeff blk TX 4 X4 i x plane 0 eobs i pred exists 1 if switchable filter index 0 cpi sf use rd breakout best rd IN T64 MAX if tmp best rdu 2 best rd tmp best filter mbmi interp filter tmp best rdu IN T64 MAX break if tmp best rdu IN T64 MAX pred exists continue mbmi interp filter cm interp filter SWITCHABLE tmp best filter cm interp filter if pred exists tmp rd rd pick best sub8x8 mode cpi x tile mbmi ref mvs ref frame 0 second ref best yrd rate rate y distortion skippable total sse int this rd thresh seg mvs bsi 0 mi row mi col if tmp rd IN T64 MAX continue else total sse tmp best sse rate tmp best rate rate y tmp best ratey distortion tmp best distortion skippable tmp best skippable mbmi tmp best mbmode for i 0 i 4 i xd mi 0 src mi bmi i tmp best bmodes i rate2 rate distortion2 distortion if cm interp filter SWITCHABLE rate2 vp9 get switchable rate cpi if mode excluded mode excluded comp pred cm reference mode SINGLEREFERENCE cm reference mode COMPOUNDREFERENCE compmode cost vp9 cost bit comp mode p comp pred tmp best rdu best rd MINRDCOST x rdmult x rddiv rate2 distortion2 RDCOST x rdmult x rddiv 0 total sse if tmp best rdu 0 vp9 build inter predictors sbuv x e mbd mi row mi col BLOCK 8 X8 super block uvrd cpi x rate uv distortion uv uv skippable uv sse BLOCK 8 X8 tmp best rdu if rate uv INTMAX continue rate2 rate uv distortion2 distortion uv skippable skippable uv skippable total sse uv sse if cm reference mode REFERENCEMODESELECT rate2 compmode cost if second ref frame INTRAFRAME rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv rate y 0 rate uv 0 this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip if mode excluded int max plane MAXMBPLANE best ref index ref index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 returnrate rate2 returndistortion distortion2 best rd this rd best yrd best rd RDCOST x rdmult x rddiv rate uv distortion uv best mbmode mbmi best skip2 this skip2 if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk TX 4 X4 sizeof uint8 t ctx num 4x4 blk for i 0 i 4 i best bmodes i xd mi 0 src mi bmi i if cpi sf mode search skip flags FLAGEARLYTERMINATE ref index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if comp pred single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded disable skip ref frame INTRAFRAME cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter int64 t adj rd for i 0 i SWITCHABLEFILTERCONTEXTS i if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if early term break if x skip comp pred break if best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAME mbmi best mbmode rd pick intra sbuv mode cpi x ctx rate uv intra rate uv tokenonly dist uv skip uv BLOCK 8 X8 TX 4 X4 if best rd IN T64 MAX returnrate INTMAX returndistortion IN T64 MAX return best rd assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode update rd thresh fact cpi bsize best ref index mbmi best mbmode x skip best skip2 if is inter block best mbmode for i 0 i 4 i xd mi 0 src mi bmi i as mode best bmodes i as mode else for i 0 i 4 i vpx memcpy xd mi 0 src mi bmi i best bmodes i sizeof b mode info mbmi mv 0 as int xd mi 0 src mi bmi 3 as mv 0 as int mbmi mv 1 as int xd mi 0 src mi bmi 3 as mv 1 as int for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 else vp9 zero best filter diff store coding context x ctx best ref index best pred diff best tx diff best filter diff 0 return best rd static int authenticate nss 2 3 struct crypto instance instance unsigned char buf int buf len if hash to nss instance crypto hash type unsigned char tmp hash hash len instance crypto hash type int datalen buf len hash len instance crypto hash type if buf len hash len instance crypto hash type log printf instance log level security Received message is too short ignoring return 1 if calculate nss hash instance buf datalen tmp hash 0 return 1 if memcmp tmp hash buf datalen hash len instance crypto hash type 0 log printf instance log level error Digest does not match return 1 buf len datalen return 0 static int slirp smb Slirp State s const char exported dir struct in addr vserver addr char smb conf 128 char smb cmdline 128 struct passwd passwd FILE f passwd getpwuid geteuid if passwd error report failed to retrieve user name return 1 if access CONFIGSMBDCOMMANDFOK error report could not find s please install it CONFIGSMBDCOMMAND return 1 if access exported dir ROKXOK error report error accessing shared directory s s exported dir strerror errno return 1 snprintf s smb dir sizeof s smb dir tmp qemu smb XXXXXX if mkdtemp s smb dir error report could not create samba server dir s s smb dir s smb dir 0 0 return 1 snprintf smb conf sizeof smb conf s s s smb dir smb conf f fopen smb conf w if f slirp smb cleanup s error report could not create samba server configuration file s smb conf return 1 fprintf f global n private dir s n interfaces 127 0 0 1 n bind interfaces only yes n pid directory s n lock directory s n state directory s n cache directory s n ncalrpc dir scalrpc n log file s log smbd n smb passwd file s smbpasswd n security user n map to guest Bad User n load printers no n printing bsd n disable spoolss yes n usershare max shares 0 n qemu n path s n read only no n guest ok yes n force user s n s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir s smb dir exported dir passwd pw name fclose f snprintf smb cmdline sizeof smb cmdline s l s s s CONFIGSMBDCOMMAND s smb dir smb conf if slirp add exec s slirp 0 smb cmdline vserver addr 139 0 slirp add exec s slirp 0 smb cmdline vserver addr 445 0 slirp smb cleanup s error report conflicting invalid smbserver address return 1 return 0 static int selinux setprocattr struct task struct p char name void value size t size struct task security struct tsec struct cred new u32 sid 0 ptsid int error char str value if current p return EACCES if strcmp name exec error current has perm p PROCESSSETEXEC else if strcmp name fscreate error current has perm p PROCESSSETFSCREATE else if strcmp name keycreate error current has perm p PROCESSSETKEYCREATE else if strcmp name sockcreate error current has perm p PROCESSSETSOCKCREATE else if strcmp name current error current has perm p PROCESSSETCURRENT else error EINVAL if error return error if size str 0 str 0 n if str size 1 n str size 1 0 size error security context to sid value size sid GFPKERNEL if error EINVAL strcmp name fscreate if capable CAPMACADMIN struct audit buffer ab size t audit size if str size 1 0 audit size size 1 else audit size size ab audit log start current audit context GFPATOMICAUDITSELINUXERR audit log format ab op fscreate invalid context audit log n untrustedstring ab value audit size audit log end ab return error error security context to sid force value size sid if error return error new prepare creds if new return ENOMEM tsec new security if strcmp name exec tsec exec sid sid else if strcmp name fscreate tsec create sid sid else if strcmp name keycreate error may create key sid p if error goto abort change tsec keycreate sid sid else if strcmp name sockcreate tsec sockcreate sid sid else if strcmp name current error EINVAL if sid 0 goto abort change error EPERM if current is single threaded error security bounded transition tsec sid sid if error goto abort change error avc has perm tsec sid sid SECCLASSPROCESSPROCESSDYNTRANSITIONNULL if error goto abort change ptsid ptrace parent sid p if ptsid 0 error avc has perm ptsid sid SECCLASSPROCESSPROCESSPTRACENULL if error goto abort change tsec sid sid else error EINVAL goto abort change commit creds new return size abort change abort creds new return error static int sipr decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Sipr Context ctx avctx priv data AV Frame frame data const uint8 t buf avpkt data Sipr Parameters parm const Sipr Mode Param mode par modes ctx mode Get Bit Context gb float samples int subframe size ctx mode MODE 16k LSUBFR 16k SUBFRSIZE int i ret ctx avctx avctx if avpkt size mode par bits per frame 3 av log avctx AVLOGERROR Error processing packet packet size d too small n avpkt size return 1 frame nb samples mode par frames per packet subframe size mode par subframe count if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame data 0 init get bits gb buf mode par bits per frame for i 0 i mode par frames per packet i decode parameters parm gb mode par ctx decode frame ctx parm samples samples subframe size mode par subframe count got frame ptr 1 return mode par bits per frame 3 static int temporal filter find matching mb c V P9 COMP cpi uint8 t arf frame buf uint8 t frame ptr buf int stride MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const MVSPEEDFEATURES const mv sf cpi sf mv int step param int sadpb x sadperbit16 int bestsme INTMAX int distortion unsigned int sse int sad list 5 MV best ref mv1 0 0 MV best ref mv1 full MV ref mv x e mbd mi 0 src mi bmi 0 as mv 0 as mv struct buf 2d src x plane 0 src struct buf 2d pre xd plane 0 pre 0 best ref mv1 full col best ref mv1 col 3 best ref mv1 full row best ref mv1 row 3 x plane 0 src buf arf frame buf x plane 0 src stride stride xd plane 0 pre 0 buf frame ptr buf xd plane 0 pre 0 stride stride step param mv sf reduce first step size step param MIN step param MAXMVSEARCHSTEPS 2 vp9 hex search x best ref mv1 full step param sadpb 1 cond sad list cpi sad list cpi fn ptr BLOCK 16 X16 0 best ref mv1 ref mv bestsme cpi find fractional mv step x ref mv best ref mv1 cpi common allow high precision mv x errorperbit cpi fn ptr BLOCK 16 X16 0 mv sf subpel iters per step cond sad list cpi sad list NULLNULL distortion sse NULL 0 0 x plane 0 src src xd plane 0 pre 0 pre return bestsme static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VB Dec Context const c avctx priv data AV Frame frame data uint8 t outptr srcptr int i j ret int flags uint32 t size int offset 0 bytestream2 init c stream avpkt data avpkt size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret flags bytestream2 get le16 c stream if flags VBHASGMC i int16 t bytestream2 get le16 c stream j int16 t bytestream2 get le16 c stream offset i j avctx width if flags VBHASVIDEO size bytestream2 get le32 c stream vb decode framedata c offset bytestream2 skip c stream size 4 if flags VBHASPALETTE size bytestream2 get le32 c stream vb decode palette c size memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed flags VBHASPALETTE outptr frame data 0 srcptr c frame for i 0 i avctx height i memcpy outptr srcptr avctx width srcptr avctx width outptr frame linesize 0 FFSWAP uint8 t c frame c prev frame got frame 1 return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt MDEC Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size Thread Frame frame f data int i ret if ret ff thread get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret frame f pict type AVPICTURETYPEI frame f key frame 1 av fast malloc a bitstream buffer a bitstream buffer size buf size FFINPUTBUFFERPADDINGSIZE if a bitstream buffer return AVERRORENOMEM for i 0 i buf size i 2 a bitstream buffer i buf i 1 a bitstream buffer i 1 buf i init get bits a gb a bitstream buffer buf size 8 skip bits a gb 32 a qscale get bits a gb 16 a version get bits a gb 16 a last dc 0 a last dc 1 a last dc 2 128 for a mb x 0 a mb x a mb width a mb x for a mb y 0 a mb y a mb height a mb y if ret decode mb a a block 0 return ret idct put a frame f a mb x a mb y got frame 1 return get bits count a gb 31 32 4 static void LMBCS Open Worker U Converter this U Converter Load Args p Args U Error Code err ulmbcs byte t Opt Group U Converter Data LMBCS extra Info this extra Info U Converter Data LMBCS uprv malloc sizeof U Converter Data LMBCS if extra Info NULLU Converter Name Pieces stack Pieces U Converter Load Args stack Args int32 t sizeof U Converter Load Args ulmbcs byte t i uprv memset extra Info 0 sizeof U Converter Data LMBCS stack Args only Test Is Loadable p Args only Test Is Loadable for i 0 i ULMBCSGRPLASTUSUCCESS err i if Opt Group Byte To CP Name i NULL extra Info Opt Grp Converter i ucnv load Shared Data Opt Group Byte To CP Name i stack Pieces stack Args err if UFAILURE err p Args only Test Is Loadable LMBCS Close this return extra Info Opt Group Opt Group extra Info locale Converter Index Find LMBCS Locale p Args locale else err int Imaging Pcd Decode Imaging im Imaging Codec State state UIN T8 buf int bytes int x int chunk UIN T8 out UIN T8 ptr ptr buf chunk 3 state xsize for if bytes chunk return ptr buf out state buffer for x 0 x state xsize x out 0 ptr x out 1 ptr x 4 state xsize 2 out 2 ptr x 5 state xsize 2 out 3 state shuffle UIN T8 im image state y state buffer state xsize if state y state ysize return 1 out state buffer for x 0 x state xsize x out 0 ptr x state xsize out 1 ptr x 4 state xsize 2 out 2 ptr x 5 state xsize 2 out 3 state shuffle UIN T8 im image state y state buffer state xsize if state y state ysize return 1 ptr chunk bytes chunk static int rc pick q and bounds one pass vbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality calc active worst quality one pass vbr cpi int q int inter minq ASSIGNMINQTABLE cm bit depth inter minq if frame is intra only cm if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q cm bit depth active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q cm bit depth else active best quality get gf active quality rc q cm bit depth else if oxcf rc mode VPXQ active best quality cq level else if cm current video frame 1 active best quality inter minq rc avg frame qindex INTERFRAME else active best quality inter minq rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state if cm frame type KEYFRAME rc this key frame forced cm current video frame 0 qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 1 75 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index static int ilbc decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size ILBC Dec Context s avctx priv data AV Frame frame data int ret if s decoder no of bytes buf size av log avctx AVLOGERROR i LBC frame too short u should be u n buf size s decoder no of bytes return AVERRORINVALIDDATA frame nb samples s decoder blockl if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret Web Rtc Ilbcfix Decode Impl Web Rtc Word16 frame data 0 const Web Rtc U Word16 buf s decoder 1 got frame ptr 1 return s decoder no of bytes static int pefromupx const char src uint32 t ssize char dst uint32 t dsize uint32 t ep uint32 t upx0 uint32 t upx1 uint32 t magic uint32 t dend char imports sections NULL pehdr NULL newbuf unsigned int sectcnt 0 upd 1 uint32 t realstuffsz 0 valign 0 uint32 t foffset 0xd0 0xf8 if dst NULL src NULL return 0 while valign magic sectcnt if ep upx1 valign ssize 5 src ep upx1 valign 2 x8d src ep upx1 valign 1 xbe break if valign ep upx1 0x80 ssize 8 const char pt src ep upx1 0x80 cli dbgmsg UPX bad magic scanning for imports n while pt cli memstr pt ssize pt src 8 x8d xbe 2 if pt 6 x8b pt 7 x07 valign pt src 2 ep upx1 break pt if valign CLIISCONTAINED src ssize src ep upx1 valign 4 imports dst cli readint32 src ep upx1 valign realstuffsz imports dst if realstuffsz dsize cli dbgmsg UPX wrong realstuff size n else pehdr imports while CLIISCONTAINED dst dsize pehdr 8 cli readint32 pehdr pehdr 8 while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr pehdr pehdr pehdr 4 if sections checkpe dst dsize pehdr valign sectcnt pehdr NULL if pehdr dend 0xf8 0x28 cli dbgmsg UPX no luck scanning for PE n pehdr dst dend 0xf8 0x28 while pehdr dst if sections checkpe dst dsize pehdr valign sectcnt break pehdr if realstuffsz pehdr dst pehdr NULL if pehdr uint32 t rebsz PESALIGN dend 0x1000 cli dbgmsg UPX no luck brutally crafing a reasonable PE n if newbuf char cli calloc rebsz 0x200 sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 FAKEPE 0x120 memcpy newbuf 0x200 dst dend memcpy dst newbuf dend 0x200 free newbuf cli writeint32 dst 0xd0 0x50 rebsz 0x1000 cli writeint32 dst 0xd0 0x100 rebsz cli writeint32 dst 0xd0 0x108 rebsz dsize rebsz 0x200 cli dbgmsg UPXPE structure added to uncompressed data n return 1 if sections sectcnt 0 foffset PESALIGN foffset 0x28 sectcnt valign for upd 0 upd sectcnt upd uint32 t vsize PESALIGN uint32 t cli readint32 sections 8 valign uint32 t urva PEALIGN uint32 t cli readint32 sections 12 valign if CLIISCONTAINED upx0 realstuffsz urva vsize cli dbgmsg UPX Sect d out of bounds giving up rebuild n upd return 0 cli writeint32 sections 8 vsize cli writeint32 sections 12 urva cli writeint32 sections 16 vsize cli writeint32 sections 20 foffset if foffset vsize foffset return 0 foffset vsize sections 0x28 cli writeint32 pehdr 8 0x4d414c43 cli writeint32 pehdr 0x3c valign if newbuf char cli calloc foffset sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 pehdr 0xf8 0x28 sectcnt sections pehdr 0xf8 for upd 0 upd sectcnt upd uint32 t offset1 offset2 offset3 offset1 uint32 t cli readint32 sections 20 offset2 uint32 t cli readint32 sections 16 if offset1 foffset offset2 foffset offset1 offset2 foffset free newbuf return 1 offset3 uint32 t cli readint32 sections 12 if offset3 upx0 dsize free newbuf return 1 memcpy newbuf offset1 dst offset3 upx0 offset2 sections 0x28 if foffset dsize 8192 cli dbgmsg UPX wrong raw size giving up rebuild n free newbuf return 0 memcpy dst newbuf foffset dsize foffset free newbuf cli dbgmsg UPXPE structure rebuilt from compressed file n return 1 void ff MPV common end Mpeg Enc Context s int i if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i s slice context count 1 else free duplicate context s av freep s parse context buffer s parse context buffer size 0 av freep s bitstream buffer s allocated bitstream buffer size 0 av freep s avctx stats out av freep s ac stats av freep s q intra matrix av freep s q inter matrix av freep s q intra matrix16 av freep s q inter matrix16 av freep s input picture av freep s reordered input picture av freep s dct offset if s picture s avctx internal is copy for i 0 i s picture count i free picture s s picture i av freep s picture free context frame s if s avctx active thread type FFTHREADFRAME avcodec default free buffers s avctx s context initialized 0 s last picture ptr s next picture ptr s current picture ptr NULL s linesize s uvlinesize 0 int ff generate sliding window mmcos H264 Context h int first slice MMCO mmco temp MAXMMCOCOUNT mmco first slice h mmco mmco temp int mmco index 0 i assert h long ref count h short ref count h sps ref frame count if h short ref count h long ref count h short ref count h sps ref frame count FIELDPICTURE h first field h cur pic ptr f reference mmco 0 opcode MMCOSHOR T2 UNUSED mmco 0 short pic num h short ref h short ref count 1 frame num mmco index 1 if FIELDPICTURE mmco 0 short pic num 2 mmco 1 opcode MMCOSHOR T2 UNUSED mmco 1 short pic num mmco 0 short pic num 1 mmco index 2 if first slice h mmco index mmco index else if first slice mmco index 0 mmco index h mmco index i check opcodes h mmco mmco temp mmco index av log h avctx AVLOGERROR Inconsistent MMCO state between slices d d d n mmco index h mmco index i return AVERRORINVALIDDATA return 0 static int aasc decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Aasc Context s avctx priv data int compr i stride ret if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret compr AVR L32 buf buf 4 buf size 4 switch compr case 0 stride avctx width 3 3 3 for i avctx height 1 i 0 i memcpy s frame data 0 i s frame linesize 0 buf avctx width 3 buf stride break case 1 bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame 8 s gb break default av log avctx AVLOGERROR Unknown compression type d n compr return AVERRORINVALIDDATA got frame 1 if ret av frame ref data s frame 0 return ret return buf size static void kq dealloc struct event base base void arg struct kqop kqop arg evsignal dealloc base if kqop changes free kqop changes if kqop events free kqop events if kqop kq 0 kqop pid getpid close kqop kq memset kqop 0 sizeof struct kqop free kqop const char vpx svc dump statistics Svc Context svc ctx int number of frames encode frame count int i j uint32 t bytes total 0 double scale COMPONENTS double psnr COMPONENTS double mse COMPONENTS double y scale Svc Internal const si get svc internal svc ctx if svc ctx NULL si NULL return NULL svc log reset svc ctx encode frame count si encode frame count if si encode frame count 0 return vpx svc get message svc ctx svc log svc ctx SVCLOGINFO n for i 0 i si layers i number of frames encode frame count svc log svc ctx SVCLOGINFO Layer d Average PSNR 2 3f 2 3f 2 3f 2 3f Bytes u n i double si psnr sum i 0 number of frames double si psnr sum i 1 number of frames double si psnr sum i 2 number of frames double si psnr sum i 3 number of frames si bytes sum i y scale si width si height 255 0 255 0 number of frames scale 1 y scale scale 2 scale 3 y scale 4 scale 0 y scale 1 5 for j 0 j COMPONENTS j psnr j calc psnr si sse sum i j scale j mse j si sse sum i j 255 0 255 0 scale j svc log svc ctx SVCLOGINFO Layer d Overall PSNR 2 3f 2 3f 2 3f 2 3f n i psnr 0 psnr 1 psnr 2 psnr 3 svc log svc ctx SVCLOGINFO Layer d Overall MSE 2 3f 2 3f 2 3f 2 3f n i mse 0 mse 1 mse 2 mse 3 bytes total si bytes sum i si bytes sum i 0 for j 0 j COMPONENTS j si psnr sum i j 0 si sse sum i j 0 si encode frame count 0 svc log svc ctx SVCLOGINFO Total Bytes u n bytes total return vpx svc get message svc ctx void vp9 setup scale factors for frame struct scale factors sf int other w int other h int this w int this h sf x scale fp REFINVALIDSCALE sf y scale fp REFINVALIDSCALE return struct event base event base new void int i struct event base base if base calloc 1 sizeof struct event base NULL event err 1 s calloc func event sigcb NULL event gotsig 0 gettime base base event tv min heap ctor base timeheap TAILQINIT base eventqueue base sig ev signal pair 0 1 base sig ev signal pair 1 1 base evbase NULL for i 0 eventops i base evbase i base evsel eventops i base evbase base evsel init base if base evbase NULL event errx 1 s no event mechanism available func if evutil getenv EVENTSHOWMETHOD event msgx libevent using s n base evsel name event base priority init base 1 return base static void encode breakout test V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col MVREFERENCEFRAME ref frame PREDICTIONMODE this mode unsigned int var y unsigned int sse y struct buf 2d yv12 mb MAXMBPLANE int rate int64 t dist MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi const BLOCKSIZE uv size get plane block size bsize xd plane 1 unsigned int var var y sse sse y unsigned int thresh ac unsigned int thresh dc if x encode breakout 0 const unsigned int max thresh 36000 const unsigned int min thresh MIN unsigned int x encode breakout 4 max thresh thresh ac xd plane 0 dequant 1 xd plane 0 dequant 1 9 thresh ac clamp thresh ac min thresh max thresh thresh ac b width log2 bsize b height log2 bsize thresh dc xd plane 0 dequant 0 xd plane 0 dequant 0 6 else thresh ac 0 thresh dc 0 if var thresh ac sse var thresh dc unsigned int sse u sse v unsigned int var u var v if x encode breakout 0 xd plane 1 pre 0 yv12 mb ref frame 1 xd plane 2 pre 0 yv12 mb ref frame 2 vp9 build inter predictors sbuv xd mi row mi col bsize var u cpi fn ptr uv size vf x plane 1 src buf x plane 1 src stride xd plane 1 dst buf xd plane 1 dst stride sse u if var u 4 thresh ac sse u var u thresh dc var v cpi fn ptr uv size vf x plane 2 src buf x plane 2 src stride xd plane 2 dst buf xd plane 2 dst stride sse v if var v 4 thresh ac sse v var v thresh dc x skip 1 rate cpi inter mode cost mbmi mode context ref frame INTEROFFSET this mode dist sse 4 static void pred temp direct motion H264 Context const h int mb type int b8 stride 2 int b4 stride h b stride int mb xy h mb xy mb y h mb y int mb type col 2 const int16 t l1mv0 2 l1mv1 2 const int8 t l1ref0 l1ref1 const int is b8x8 IS 8 X8 mb type unsigned int sub mb type int i8 i4 assert h ref list 1 0 reference 3 await reference mb row h h ref list 1 0 h mb y ISINTERLACED mb type if ISINTERLACED h ref list 1 0 mb type mb xy if ISINTERLACED mb type mb y h mb y 1 h col parity mb xy h mb x h mb y 1 h col parity h mb stride b8 stride 0 else mb y h col fieldoff mb xy h mb stride h col fieldoff goto single col else if ISINTERLACED mb type mb y h mb y 1 mb xy h mb x h mb y 1 h mb stride mb type col 0 h ref list 1 0 mb type mb xy mb type col 1 h ref list 1 0 mb type mb xy h mb stride b8 stride 2 4 h mb stride b4 stride 6 if ISINTERLACED mb type col 0 ISINTERLACED mb type col 1 mb type col 0 MBTYPEINTERLACED mb type col 1 MBTYPEINTERLACED sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if mb type col 0 MBTYPE 16x16 ORINTRA mb type col 1 MBTYPE 16x16 ORINTRA is b8x8 mb type MBTYPE 16x8 MBTYPE L0 L1 MBTYPEDIREC T2 else mb type MBTYPE 8x8 MBTYPE L0 L1 else single col mb type col 0 mb type col 1 h ref list 1 0 mb type mb xy sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if is b8x8 mb type col 0 MBTYPE 16x16 ORINTRA mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 else if is b8x8 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 mb type MBTYPE L0 L1 MBTYPEDIREC T2 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 else if h sps direct 8x8 inference flag sub mb type MBTYPE 8x8 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 mb type MBTYPE 8x8 MBTYPE L0 L1 await reference mb row h h ref list 1 0 mb y l1mv0 h ref list 1 0 motion val 0 h mb2b xy mb xy l1mv1 h ref list 1 0 motion val 1 h mb2b xy mb xy l1ref0 h ref list 1 0 ref index 0 4 mb xy l1ref1 h ref list 1 0 ref index 1 4 mb xy if b8 stride if h mb y 1 l1ref0 2 l1ref1 2 l1mv0 2 b4 stride l1mv1 2 b4 stride const int map col to list0 2 h map col to list0 0 h map col to list0 1 const int dist scale factor h dist scale factor int ref offset if FRAMEMBAFFISINTERLACED mb type map col to list0 0 h map col to list0 field h mb y 1 0 map col to list0 1 h map col to list0 field h mb y 1 1 dist scale factor h dist scale factor field h mb y 1 ref offset h ref list 1 0 mbaff 4 mb type col 0 3 if ISINTERLACED mb type ISINTERLACED mb type col 0 int y shift 2 ISINTERLACED mb type assert h sps direct 8x8 inference flag for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col y8 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue ref0 l1ref0 x8 y8 b8 stride if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 x8 y8 b8 stride ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 const int16 t mv col l1mv x8 3 y8 b4 stride int my col mv col 1 y shift 2 int mx scale mv col 0 128 8 int my scale my col 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my my col 4 return if IS 16 X16 mb type int ref mv0 mv1 fill rectangle h ref cache 1 scan8 0 4 4 8 0 1 if ISINTRA mb type col 0 ref mv0 mv1 0 else const int ref0 l1ref0 0 0 map col to list0 0 l1ref0 0 ref offset map col to list0 1 l1ref1 0 ref offset const int scale dist scale factor ref0 const int16 t mv col l1ref0 0 0 l1mv0 0 l1mv1 0 int mv l0 2 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 ref ref0 mv0 pack16to32 mv l0 0 mv l0 1 mv1 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 fill rectangle h ref cache 0 scan8 0 4 4 8 ref 1 fill rectangle h mv cache 0 scan8 0 4 4 8 mv0 4 fill rectangle h mv cache 1 scan8 0 4 4 8 mv1 4 else for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col 0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue assert b8 stride 2 ref0 l1ref0 i8 if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 i8 ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 if ISSUB 8 X8 sub mb type const int16 t mv col l1mv x8 3 y8 3 b4 stride int mx scale mv col 0 128 8 int my scale mv col 1 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my mv col 1 4 else for i4 0 i4 4 i4 const int16 t mv col l1mv x8 2 i4 1 y8 2 i4 1 b4 stride int16 t mv l0 h mv cache 0 scan8 i8 4 i4 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 AVW N32 A h mv cache 1 scan8 i8 4 i4 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 static inline int h263 mv4 search Mpeg Enc Context s int mx int my int shift Motion Est Context const c s me const int size 1 const int h 8 int block int P 10 2 int dmin sum 0 mx4 sum 0 my4 sum 0 int same 1 const int stride c stride uint8 t mv penalty c current mv penalty init mv4 ref c for block 0 block 4 block int mx4 my4 int pred x4 pred y4 int dmin4 static const int off 4 2 1 1 1 const int mot stride s b8 stride const int mot xy s block index block PLEFT 0 s current picture f motion val 0 mot xy 1 0 PLEFT 1 s current picture f motion val 0 mot xy 1 1 if PLEFT 0 c xmax shift PLEFT 0 c xmax shift if s first slice line block 2 c pred x pred x4 PLEFT 0 c pred y pred y4 PLEFT 1 else PTOP 0 s current picture f motion val 0 mot xy mot stride 0 PTOP 1 s current picture f motion val 0 mot xy mot stride 1 PTOPRIGHT 0 s current picture f motion val 0 mot xy mot stride off block 0 PTOPRIGHT 1 s current picture f motion val 0 mot xy mot stride off block 1 if PTOP 1 c ymax shift PTOP 1 c ymax shift if PTOPRIGHT 0 c xmin shift PTOPRIGHT 0 c xmin shift if PTOPRIGHT 0 c xmax shift PTOPRIGHT 0 c xmax shift if PTOPRIGHT 1 c ymax shift PTOPRIGHT 1 c ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 c pred x pred x4 PMEDIAN 0 c pred y pred y4 PMEDIAN 1 PM V1 0 mx PM V1 1 my dmin4 epzs motion search4 s mx4 my4 P block block s p mv table 1 16 shift dmin4 c sub motion search s mx4 my4 dmin4 block block size h if s dsp me sub cmp 0 s dsp mb cmp 0 int dxy const int offset block 1 block 1 stride 8 uint8 t dest y c scratchpad offset if s quarter sample uint8 t ref c ref block 0 mx4 2 my4 2 stride dxy my4 3 2 mx4 3 if s no rounding s dsp put no rnd qpel pixels tab 1 dxy dest y ref stride else s dsp put qpel pixels tab 1 dxy dest y ref stride else uint8 t ref c ref block 0 mx4 1 my4 1 stride dxy my4 1 1 mx4 1 if s no rounding s dsp put no rnd pixels tab 1 dxy dest y ref stride h else s dsp put pixels tab 1 dxy dest y ref stride h dmin sum mv penalty mx4 pred x4 mv penalty my4 pred y4 c mb penalty factor else dmin sum dmin4 if s quarter sample mx4 sum mx4 2 my4 sum my4 2 else mx4 sum mx4 my4 sum my4 s current picture f motion val 0 s block index block 0 mx4 s current picture f motion val 0 s block index block 1 my4 if mx4 mx my4 my same 0 if same return INTMAX if s dsp me sub cmp 0 s dsp mb cmp 0 dmin sum s dsp mb cmp 0 s s new picture f data 0 s mb x 16 s mb y 16 stride c scratchpad stride 16 if c avctx mb cmp FFCMPCHROMA int dxy int mx my int offset mx ff h263 round chroma mx4 sum my ff h263 round chroma my4 sum dxy my 1 1 mx 1 offset s mb x 8 mx 1 s mb y 8 my 1 s uvlinesize if s no rounding s dsp put no rnd pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put no rnd pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 else s dsp put pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 1 s mb x 8 s mb y 8 s uvlinesize c scratchpad s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 2 s mb x 8 s mb y 8 s uvlinesize c scratchpad 8 s uvlinesize 8 c pred x mx c pred y my switch c avctx mb cmp 0x FF case FFCMPRD return dmin sum default return dmin sum 11 c mb penalty factor void xmlrpc char encode char outbuffer const char s1 long unsigned int i unsigned char c char buf2 15 mowgli string t s mowgli string create buf2 0 outbuffer 0 if s1 s1 0 return for i 0 s1 i 0 i c s1 i if c 127 snprintf buf2 sizeof buf2 d c s append s buf2 strlen buf2 else if c s append s amp 5 else if c s append s lt 4 else if c s append s gt 4 else if c s append s quot 6 else s append char s c memcpy outbuffer s str static int mpc8 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size MPC Context c avctx priv data Get Bit Context gb2 gb gb2 int i j k ch cnt res t Band bands c bands int off int maxband keyframe int last 2 frame nb samples MPCFRAMESIZE if res ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return res keyframe c cur frame 0 if keyframe memset c Q 0 sizeof c Q c last bits used 0 init get bits gb buf buf size 8 skip bits gb c last bits used 7 if keyframe maxband mpc8 get mod golomb gb c maxbands 1 else maxband c last max band get vlc2 gb band vlc table MP C8 BANDSBITS 2 if maxband 32 maxband 33 if maxband c maxbands 1 return AVERRORINVALIDDATA c last max band maxband if maxband last 0 last 1 0 for i maxband 1 i 0 i for ch 0 ch 2 ch last ch get vlc2 gb res vlc last ch 2 table MP C8 RESBITS 2 last ch if last ch 15 last ch 17 bands i res ch last ch if c MSS int mask cnt 0 for i 0 i maxband i if bands i res 0 bands i res 1 cnt t mpc8 get mod golomb gb cnt mask mpc8 get mask gb cnt t for i maxband 1 i 0 i if bands i res 0 bands i res 1 bands i msf mask 1 mask 1 for i maxband i c maxbands i bands i res 0 bands i res 1 0 if keyframe for i 0 i 32 i c old DSCF 0 i c old DSCF 1 i 1 for i 0 i maxband i if bands i res 0 bands i res 1 cnt bands i res 0 bands i res 1 1 if cnt 0 t get vlc2 gb scfi vlc cnt table scfi vlc cnt bits 1 if bands i res 0 bands i scfi 0 t 2 cnt if bands i res 1 bands i scfi 1 t 3 for i 0 i maxband i for ch 0 ch 2 ch if bands i res ch continue if c old DSCF ch i bands i scf idx ch 0 get bits gb 7 6 c old DSCF ch i 0 else t get vlc2 gb dscf vlc 1 table MP C8 DSC F1 BITS 2 if t 64 t get bits gb 6 bands i scf idx ch 0 bands i scf idx ch 2 t 25 0x7 F 6 for j 0 j 2 j if bands i scfi ch j 2 bands i scf idx ch j 1 bands i scf idx ch j else t get vlc2 gb dscf vlc 0 table MP C8 DSC F0 BITS 2 if t 31 t 64 get bits gb 6 bands i scf idx ch j 1 bands i scf idx ch j t 25 0x7 F 6 for i 0 off 0 i maxband i off SAMPLESPERBAND for ch 0 ch 2 ch res bands i res ch switch res case 1 for j 0 j SAMPLESPERBAND j c Q ch off j av lfg get c rnd 0x3 FC 510 break case 0 break case 1 for j 0 j SAMPLESPERBAND j SAMPLESPERBAND 2 cnt get vlc2 gb q1 vlc table MP C8 Q1 BITS 2 t mpc8 get mask gb 18 cnt for k 0 k SAMPLESPERBAND 2 k t 1 c Q ch off j k t 0x20000 get bits1 gb 1 1 0 break case 2 cnt 6 for j 0 j SAMPLESPERBAND j 3 t get vlc2 gb q2 vlc cnt 3 table MP C8 Q2 BITS 2 c Q ch off j 0 mpc8 idx50 t c Q ch off j 1 mpc8 idx51 t c Q ch off j 2 mpc8 idx52 t cnt cnt 1 mpc8 huffq2 t break case 3 case 4 for j 0 j SAMPLESPERBAND j 2 t get vlc2 gb q3 vlc res 3 table MP C8 Q3 BITS 2 q3 offsets res 3 c Q ch off j 1 t 4 c Q ch off j 0 t 8 t 0x F 16 t 0x F break case 5 case 6 case 7 case 8 cnt 2 mpc8 thres res for j 0 j SAMPLESPERBAND j t get vlc2 gb quant vlc res 5 cnt mpc8 thres res table quant vlc res 5 cnt mpc8 thres res bits 2 quant offsets res 5 c Q ch off j t cnt cnt 1 FFABS c Q ch off j break default for j 0 j SAMPLESPERBAND j c Q ch off j get vlc2 gb q9up vlc table MP C8 Q9 UPBITS 2 if res 9 c Q ch off j res 9 c Q ch off j get bits gb res 9 c Q ch off j 1 res 2 1 ff mpc dequantize and synth c maxband 1 int16 t frame extended data avctx channels c cur frame c last bits used get bits count gb if get bits left gb 8 c last bits used buf size 3 if c cur frame c frames c cur frame 0 got frame ptr 1 return c cur frame c last bits used 3 buf size int ff rv34 decode frame AV Codec Context avctx void data int got picture ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size R V34 Dec Context r avctx priv data Mpeg Enc Context s r s AV Frame pict data Slice Info si int i int slice count const uint8 t slices hdr NULL int last 0 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got picture ptr 1 return 0 if avctx slice count slice count buf 1 slices hdr buf 4 buf 8 slice count buf size 1 8 slice count else slice count avctx slice count if get slice offset avctx slices hdr 0 0 get slice offset avctx slices hdr 0 buf size av log avctx AVLOGERROR Slice offset is invalid n return AVERRORINVALIDDATA init get bits s gb buf get slice offset avctx slices hdr 0 buf size get slice offset avctx slices hdr 0 8 if r parse slice header r r s gb si 0 si start av log avctx AVLOGERROR First slice header is incorrect n return AVERRORINVALIDDATA if s last picture ptr s last picture ptr f data 0 si type AVPICTURETYPEB av log avctx AVLOGERROR Invalid decoder state B frame without reference data n return AVERRORINVALIDDATA if avctx skip frame AVDISCARDNONREF si type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY si type AVPICTURETYPEI avctx skip frame AVDISCARDALL return avpkt size if si start 0 if s mb num left 0 av log avctx AVLOGERROR New frame but still d MB left s mb num left ff er frame end s er ff MPV frame end s if s width si width s height si height int err av log s avctx AVLOGWARNING Changing dimensions to dx d n si width si height s width si width s height si height avcodec set dimensions s avctx s width s height if err ff MPV common frame size change s 0 return err if err rv34 decoder realloc r 0 return err s pict type si type si type AVPICTURETYPEI if ff MPV frame start s s avctx 0 return 1 ff mpeg er frame start s if r tmp b block base int i r tmp b block base av malloc s linesize 48 for i 0 i 2 i r tmp b block y i r tmp b block base i 16 s linesize for i 0 i 4 i r tmp b block uv i r tmp b block base 32 s linesize i 1 8 s uvlinesize i 1 16 r cur pts si pts if s pict type AVPICTURETYPEB r last pts r next pts r next pts r cur pts else int refdist GETPTSDIFF r next pts r last pts int dist0 GETPTSDIFF r cur pts r last pts int dist1 GETPTSDIFF r next pts r cur pts if refdist r mv weight1 r mv weight2 r weight1 r weight2 8192 r scaled weight 0 else r mv weight1 dist0 14 refdist r mv weight2 dist1 14 refdist if r mv weight1 r mv weight2 511 r weight1 r mv weight1 r weight2 r mv weight2 r scaled weight 0 else r weight1 r mv weight1 9 r weight2 r mv weight2 9 r scaled weight 1 s mb x s mb y 0 ff thread finish setup s avctx else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log s avctx AVLOGERROR Decoder needs full frames in frame multithreading mode start MB is d n si start return AVERRORINVALIDDATA for i 0 i slice count i int offset get slice offset avctx slices hdr i int size if i 1 slice count size buf size offset else size get slice offset avctx slices hdr i 1 offset if offset 0 offset buf size av log avctx AVLOGERROR Slice offset is invalid n break r si end s mb width s mb height s mb num left r s mb x r s mb y r s mb width r si start if i 1 slice count if get slice offset avctx slices hdr i 1 0 get slice offset avctx slices hdr i 1 buf size av log avctx AVLOGERROR Slice offset is invalid n break init get bits s gb buf get slice offset avctx slices hdr i 1 buf size get slice offset avctx slices hdr i 1 8 if r parse slice header r r s gb si 0 if i 2 slice count size get slice offset avctx slices hdr i 2 offset else size buf size offset else r si end si start if size 0 size buf size offset av log avctx AVLOGERROR Slice size is invalid n break last rv34 decode slice r r si end buf offset size if last break if s current picture ptr if last if r loop filter r loop filter r s mb height 1 got picture ptr finish frame avctx pict else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log avctx AVLOGINFO marking unfished frame as finished n ff er frame end s er ff MPV frame end s s mb num left 0 ff thread report progress s current picture ptr f INTMAX 0 return AVERRORINVALIDDATA return avpkt size static void kq init struct event base base int i kq struct kqop kqueueop if evutil getenv EVENTNOKQUEUE return NULL if kqueueop calloc 1 sizeof struct kqop return NULL if kq kqueue 1 event warn kqueue free kqueueop return NULL kqueueop kq kq kqueueop pid getpid kqueueop changes malloc NEVENT sizeof struct kevent if kqueueop changes NULL free kqueueop return NULL kqueueop events malloc NEVENT sizeof struct kevent if kqueueop events NULL free kqueueop changes free kqueueop return NULL kqueueop nevents NEVENT for i 0 i NSIG i TAILQINIT kqueueop evsigevents i memset kqueueop changes 0 0 sizeof kqueueop changes 0 kqueueop changes 0 ident 1 kqueueop changes 0 filter EVFILTREAD kqueueop changes 0 flags EVADD if kevent kq kqueueop changes 1 kqueueop events NEVENTNULL 1 kqueueop events 0 ident 1 kqueueop events 0 flags EVERROR event warn s detected broken kqueue not using func free kqueueop changes free kqueueop events free kqueueop close kq return NULL return kqueueop static int rv34 set deblock coef R V34 Dec Context r Mpeg Enc Context s r s int hmvmask 0 vmvmask 0 i j int midx s mb x 2 s mb y 2 s b8 stride int16 t motion val 2 s current picture ptr f motion val 0 midx for j 0 j 16 j 8 for i 0 i 2 i if is mv diff gt 3 motion val i 1 vmvmask 0x11 j i 2 if j s mb y is mv diff gt 3 motion val i s b8 stride hmvmask 0x03 j i 2 motion val s b8 stride if s first slice line hmvmask 0x000 F if s mb x vmvmask 0x1111 if r rv30 vmvmask vmvmask 0x4444 1 hmvmask hmvmask 0x0 F00 4 if s mb x r deblock coefs s mb x 1 s mb y s mb stride vmvmask 0x1111 3 if s first slice line r deblock coefs s mb x s mb y 1 s mb stride hmvmask 0x F 12 return hmvmask vmvmask static int rc pick q and bounds one pass vbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality calc active worst quality one pass vbr cpi int q int inter minq ASSIGNMINQTABLE cm bit depth inter minq if frame is intra only cm if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q cm bit depth active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q cm bit depth else active best quality get gf active quality rc q cm bit depth else if oxcf rc mode VPXQ active best quality cq level else if cm current video frame 1 active best quality inter minq rc avg frame qindex INTERFRAME else active best quality inter minq rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state if cm frame type KEYFRAME rc this key frame forced cm current video frame 0 qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 1 75 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index static inline int h263 mv4 search Mpeg Enc Context s int mx int my int shift Motion Est Context const c s me const int size 1 const int h 8 int block int P 10 2 int dmin sum 0 mx4 sum 0 my4 sum 0 int same 1 const int stride c stride uint8 t mv penalty c current mv penalty init mv4 ref c for block 0 block 4 block int mx4 my4 int pred x4 pred y4 int dmin4 static const int off 4 2 1 1 1 const int mot stride s b8 stride const int mot xy s block index block PLEFT 0 s current picture f motion val 0 mot xy 1 0 PLEFT 1 s current picture f motion val 0 mot xy 1 1 if PLEFT 0 c xmax shift PLEFT 0 c xmax shift if s first slice line block 2 c pred x pred x4 PLEFT 0 c pred y pred y4 PLEFT 1 else PTOP 0 s current picture f motion val 0 mot xy mot stride 0 PTOP 1 s current picture f motion val 0 mot xy mot stride 1 PTOPRIGHT 0 s current picture f motion val 0 mot xy mot stride off block 0 PTOPRIGHT 1 s current picture f motion val 0 mot xy mot stride off block 1 if PTOP 1 c ymax shift PTOP 1 c ymax shift if PTOPRIGHT 0 c xmin shift PTOPRIGHT 0 c xmin shift if PTOPRIGHT 0 c xmax shift PTOPRIGHT 0 c xmax shift if PTOPRIGHT 1 c ymax shift PTOPRIGHT 1 c ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 c pred x pred x4 PMEDIAN 0 c pred y pred y4 PMEDIAN 1 PM V1 0 mx PM V1 1 my dmin4 epzs motion search4 s mx4 my4 P block block s p mv table 1 16 shift dmin4 c sub motion search s mx4 my4 dmin4 block block size h if s dsp me sub cmp 0 s dsp mb cmp 0 int dxy const int offset block 1 block 1 stride 8 uint8 t dest y c scratchpad offset if s quarter sample uint8 t ref c ref block 0 mx4 2 my4 2 stride dxy my4 3 2 mx4 3 if s no rounding s dsp put no rnd qpel pixels tab 1 dxy dest y ref stride else s dsp put qpel pixels tab 1 dxy dest y ref stride else uint8 t ref c ref block 0 mx4 1 my4 1 stride dxy my4 1 1 mx4 1 if s no rounding s dsp put no rnd pixels tab 1 dxy dest y ref stride h else s dsp put pixels tab 1 dxy dest y ref stride h dmin sum mv penalty mx4 pred x4 mv penalty my4 pred y4 c mb penalty factor else dmin sum dmin4 if s quarter sample mx4 sum mx4 2 my4 sum my4 2 else mx4 sum mx4 my4 sum my4 s current picture f motion val 0 s block index block 0 mx4 s current picture f motion val 0 s block index block 1 my4 if mx4 mx my4 my same 0 if same return INTMAX if s dsp me sub cmp 0 s dsp mb cmp 0 dmin sum s dsp mb cmp 0 s s new picture f data 0 s mb x 16 s mb y 16 stride c scratchpad stride 16 if c avctx mb cmp FFCMPCHROMA int dxy int mx my int offset mx ff h263 round chroma mx4 sum my ff h263 round chroma my4 sum dxy my 1 1 mx 1 offset s mb x 8 mx 1 s mb y 8 my 1 s uvlinesize if s no rounding s dsp put no rnd pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put no rnd pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 else s dsp put pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 1 s mb x 8 s mb y 8 s uvlinesize c scratchpad s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 2 s mb x 8 s mb y 8 s uvlinesize c scratchpad 8 s uvlinesize 8 c pred x mx c pred y my switch c avctx mb cmp 0x FF case FFCMPRD return dmin sum default return dmin sum 11 c mb penalty factor static int roq encode frame AV Codec Context avctx AV Packet pkt const AV Frame frame int got packet Roq Context enc avctx priv data int size ret enc avctx avctx enc frame to enc frame if frame quality enc lambda frame quality 1 else enc lambda 2 ROQLAMBDASCALE size enc width enc height 64 138 7 8 256 6 4 8 if ret ff alloc packet pkt size 0 av log avctx AVLOGERROR Error getting output packet with size d n size return ret enc out buf pkt data if enc frames Since Keyframe avctx gop size enc frames Since Keyframe 0 if enc first frame if ff get buffer avctx enc current frame 0 ff get buffer avctx enc last frame 0 av log avctx AVLOGERROR Ro Q get buffer failed n return 1 roq write video info chunk enc enc first frame 0 roq encode video enc pkt size enc out buf pkt data if enc frames Since Keyframe 1 pkt flags AVPKTFLAGKEY got packet 1 return 0 static int rv34 decode intra macroblock R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s int cbp dist int mb pos s mb x s mb y s mb stride memset r avail cache 0 sizeof r avail cache fill rectangle r avail cache 6 2 2 4 1 4 dist s mb x s resync mb x s mb y s resync mb y s mb width if s mb x dist r avail cache 5 r avail cache 9 s current picture ptr mb type mb pos 1 if dist s mb width r avail cache 2 r avail cache 3 s current picture ptr mb type mb pos s mb stride if s mb x 1 s mb width dist s mb width 1 r avail cache 4 s current picture ptr mb type mb pos s mb stride 1 if s mb x dist s mb width r avail cache 1 s current picture ptr mb type mb pos s mb stride 1 s qscale r si quant cbp rv34 decode intra mb header r intra types r cbp luma mb pos cbp r cbp chroma mb pos cbp 16 r deblock coefs mb pos 0x FFFF s current picture ptr qscale table mb pos s qscale if cbp 1 return 1 if r is16 rv34 output i16x16 r intra types cbp return 0 rv34 output intra r intra types cbp return 0 static void write header FILE sql file char db name if opt xml fputs xml version 1 0 n sql file fputs mysqldump sql file fputs xmlns xsi http fputs n sql file check io sql file else if opt compact print comment sql file 0 My SQL dump s Distrib s for s s n n DUMPVERSIONMYSQLSERVERVERSIONSYSTEMTYPEMACHINETYPE print comment sql file 0 Host s Database s n current host current host localhost db name db name print comment sql file 0 n print comment sql file 0 Server version t s n mysql get server info mysql connection if opt set charset fprintf sql file n n n n n default charset if opt tz utc fprintf sql file n fprintf sql file n if path if opt no create info fprintf md result file n fprintf md result file n fprintf sql file n n path NOAUTOVALUEONZERO compatible mode normal str 0 0 compatible mode normal str check io sql file static int alloc frame buffer Mpeg Enc Context s Picture pic int r ret if s avctx hwaccel assert pic hwaccel picture private if s avctx hwaccel priv data size pic hwaccel picture private av mallocz s avctx hwaccel priv data size if pic hwaccel picture private av log s avctx AVLOGERROR alloc frame buffer failed hwaccel private data allocation n return 1 pic tf f pic f if s codec id AVCODECIDWM V3 IMAGE s codec id AVCODECIDV C1 IMAGE s codec id AVCODECIDMS S2 r ff thread get buffer s avctx pic tf pic reference AVGETBUFFERFLAGREF 0 else pic f width s avctx width pic f height s avctx height pic f format s avctx pix fmt r avcodec default get buffer2 s avctx pic f 0 if r 0 pic f data 0 av log s avctx AVLOGERROR get buffer failed d p n r pic f data 0 av freep pic hwaccel picture private return 1 if s linesize s linesize pic f linesize 0 s uvlinesize pic f linesize 1 av log s avctx AVLOGERROR get buffer failed stride changed n ff mpeg unref picture s pic return 1 if pic f linesize 1 pic f linesize 2 av log s avctx AVLOGERROR get buffer failed uv stride mismatch n ff mpeg unref picture s pic return 1 if s edge emu buffer ret ff mpv frame size alloc s pic f linesize 0 0 av log s avctx AVLOGERROR get buffer failed to allocate context scratch buffers n ff mpeg unref picture s pic return ret return 0 static int s aes process stream state ss stream cursor read pr stream cursor write pw bool last stream aes state const state stream aes state ss const unsigned char limit const long in size pr limit pr ptr const long out size pw limit pw ptr unsigned char temp 16 int status 0 if in size out size limit pr ptr out size status 1 else limit pr limit status last EOFC 0 if state ctx NULL state ctx aes context gs alloc bytes immovable state memory sizeof aes context aes context structure if state ctx NULL gs throw gs error V Merror could not allocate aes context return ERRC memset state ctx 0x00 sizeof aes context if state keylength 1 state keylength SAESMAXKEYLENGTH gs throw1 gs error rangecheck invalid aes key length d bytes state keylength return ERRC aes setkey dec state ctx state key state keylength 8 if state initialized if in size 16 return 0 memcpy state iv pr ptr 1 16 state initialized 1 pr ptr 16 while pr ptr 16 limit aes crypt cbc state ctx AESDECRYPT 16 state iv pr ptr 1 temp pr ptr 16 if last pr ptr pr limit int pad if state use padding pad temp 15 if pad 1 pad 16 gs warn1 invalid aes padding byte 0x 02x unsigned char pad pad 0 else pad 0 memcpy pw ptr 1 temp 16 pad pw ptr 16 pad return EOFC memcpy pw ptr 1 temp 16 pw ptr 16 if status EOFC gs throw gs error rangecheck aes stream isn t a multiple of 16 bytes return 0 return status static struct cvec range struct vars v celt a celt b int cases int nchrs struct cvec cv celt c cc if a b before a b ERRREGERANGE return NULL if cases cv getcvec v 0 1 NOERRN addrange cv a b return cv nchrs b a 1 if nchrs 0 nchrs 100000 nchrs 100000 cv getcvec v nchrs 1 NOERRN addrange cv a b for c a c b c cc pg wc tolower chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc cc pg wc toupper chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc if CANCELREQUESTED v re ERRREGCANCEL return NULL return cv static int decode picture header Prores Context ctx const uint8 t buf const int data size AV Codec Context avctx int i hdr size pic data size num slices int slice width factor slice height factor int remainder num x slices const uint8 t data ptr index ptr hdr size data size 0 buf 0 3 0 if hdr size 8 hdr size data size av log avctx AVLOGERROR picture header too small n return AVERRORINVALIDDATA pic data size AVR B32 buf 1 if pic data size data size av log avctx AVLOGERROR picture data too small n return AVERRORINVALIDDATA slice width factor buf 7 4 slice height factor buf 7 0x F if slice width factor 3 slice height factor av log avctx AVLOGERROR unsupported slice dimension d x d n 1 slice width factor 1 slice height factor return AVERRORINVALIDDATA ctx slice width factor slice width factor ctx slice height factor slice height factor ctx num x mbs avctx width 15 4 ctx num y mbs avctx height 1 4 ctx frame interlaced frame 1 4 ctx frame interlaced frame remainder ctx num x mbs 1 slice width factor 1 num x slices ctx num x mbs slice width factor remainder 1 remainder 1 1 remainder 2 1 num slices num x slices ctx num y mbs if num slices AVR B16 buf 5 av log avctx AVLOGERROR invalid number of slices n return AVERRORINVALIDDATA if ctx total slices num slices av freep ctx slice data ctx slice data av malloc num slices 1 sizeof ctx slice data 0 if ctx slice data return AVERRORENOMEM ctx total slices num slices if hdr size num slices 2 data size av log avctx AVLOGERROR slice table too small n return AVERRORINVALIDDATA index ptr buf hdr size data ptr index ptr num slices 2 for i 0 i num slices i ctx slice data i index data ptr ctx slice data i prev slice sf 0 data ptr AVR B16 index ptr i 2 ctx slice data i index data ptr ctx slice data i prev slice sf 0 if data ptr buf data size av log avctx AVLOGERROR out of slice data n return 1 return pic data size static int cdxl decode frame AV Codec Context avctx void data int got frame AV Packet pkt CDXL Video Context c avctx priv data AV Frame const p c frame int ret w h encoding aligned width buf size pkt size const uint8 t buf pkt data if buf size 32 return AVERRORINVALIDDATA encoding buf 1 7 c format buf 1 0x E0 w AVR B16 buf 14 h AVR B16 buf 16 c bpp buf 19 c palette size AVR B16 buf 20 c palette buf 32 c video c palette c palette size c video size buf size c palette size 32 if c palette size 512 return AVERRORINVALIDDATA if buf size c palette size 32 return AVERRORINVALIDDATA if c bpp 1 return AVERRORINVALIDDATA if c format BITPLANAR c format BITLINE av log ask for sample avctx unsupported pixel format 0x 0x n c format return AVERRORPATCHWELCOME if ret av image check size w h 0 avctx 0 return ret if w avctx width h avctx height avcodec set dimensions avctx w h aligned width FFALIGN c avctx width 16 c padded bits aligned width c avctx width if c video size aligned width avctx height c bpp 8 return AVERRORINVALIDDATA if encoding c palette size c bpp 8 avctx pix fmt AVPIXFMTPA L8 else if encoding 1 c bpp 6 c bpp 8 if c palette size 1 c bpp 1 return AVERRORINVALIDDATA avctx pix fmt AVPIXFMTBG R24 else av log ask for sample avctx unsupported encoding d and bpp d n encoding c bpp return AVERRORPATCHWELCOME if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI if encoding av fast padded malloc c new video c new video size h w FFINPUTBUFFERPADDINGSIZE if c new video return AVERRORENOMEM if c bpp 8 cdxl decode ham8 c else cdxl decode ham6 c else cdxl decode rgb c got frame 1 AV Frame data c frame return buf size void evhttp send reply end struct evhttp request req struct evhttp connection evcon req evcon if evcon NULL evhttp request free req return req userdone 1 if req chunked evbuffer add req evcon output buffer 0 r n r n 5 evhttp write buffer req evcon evhttp send done NULL req chunked 0 else if event pending evcon ev EVWRITEEVTIMEOUTNULL evhttp send done evcon NULL else evcon cb evhttp send done evcon cb arg static int evport dispatch struct event base base void arg struct timeval tv int i res struct evport data epdp arg port event t pevtlist EVENTSPERGETN int nevents 1 struct timespec ts struct timespec ts p NULL if tv NULL ts tv sec tv tv sec ts tv nsec tv tv usec 1000 ts p ts for i 0 i EVENTSPERGETN i struct fd info fdi NULL if epdp ed pending i 1 fdi epdp ed fds epdp ed pending i if fdi NULLFDIHASEVENTS fdi int fd FDIHASREAD fdi fdi fdi revt ev fd fdi fdi wevt ev fd reassociate epdp fdi fd epdp ed pending i 1 if res port getn epdp ed port pevtlist EVENTSPERGETN unsigned int nevents ts p 1 if errno EINTR errno EAGAIN evsignal process base return 0 else if errno ETIME if nevents 0 return 0 else event warn port getn return 1 else if base sig evsignal caught evsignal process base event debug s port getn reports d events func nevents for i 0 i nevents i struct event ev struct fd info fdi port event t pevt pevtlist i int fd int pevt portev object check evportop epdp check event pevt epdp ed pending i fd res 0 if pevt portev events POLLIN res EVREAD if pevt portev events POLLOUT res EVWRITE if pevt portev events POLLERRPOLLHUPPOLLNVAL res EVREADEVWRITE assert epdp ed nevents fd fdi epdp ed fds fd if res EVREAD ev fdi fdi revt NULL event active ev res 1 if res EVWRITE ev fdi fdi wevt NULL event active ev res 1 check evportop epdp return 0 static int amrnb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMR Context p avctx priv data AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float buf out int i subframe ret float fixed gain factor AMR Fixed fixed sparse 0 float spare vector AMRSUBFRAMESIZE float synth fixed gain const float synth fixed vector frame nb samples AMRBLOCKSIZE if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 p cur frame mode unpack bitstream p buf buf size if p cur frame mode NODATA av log avctx AVLOGERROR Corrupt bitstream n return AVERRORINVALIDDATA if p cur frame mode MODEDTX av log missing feature avctx dtx mode 1 return AVERRORPATCHWELCOME if p cur frame mode MODE 12k2 lsf2lsp 5 p else lsf2lsp 3 p for i 0 i 4 i ff acelp lspd2lpc p lsp i p lpc i 5 for subframe 0 subframe 4 subframe const AMRNB Subframe amr subframe p frame subframe subframe decode pitch vector p amr subframe subframe decode fixed sparse fixed sparse amr subframe pulses p cur frame mode subframe decode gains p amr subframe p cur frame mode subframe fixed gain factor pitch sharpening p subframe p cur frame mode fixed sparse if fixed sparse pitch lag 0 av log avctx AVLOGERROR The file is corrupted pitch lag 0 is not allowed n return AVERRORINVALIDDATA ff set fixed vector p fixed vector fixed sparse 1 0 AMRSUBFRAMESIZE p fixed gain 4 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c p fixed vector p fixed vector AMRSUBFRAMESIZEAMRSUBFRAMESIZE p prediction error energy mean p cur frame mode energy pred fac for i 0 i AMRSUBFRAMESIZE i p excitation i p pitch gain 4 ff set fixed vector p excitation fixed sparse p fixed gain 4 AMRSUBFRAMESIZE for i 0 i AMRSUBFRAMESIZE i p excitation i truncf p excitation i synth fixed gain fixed gain smooth p p lsf q subframe p lsf avg p cur frame mode synth fixed vector anti sparseness p fixed sparse p fixed vector synth fixed gain spare vector if synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 0 synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 1 postfilter p p lpc subframe buf out subframe AMRSUBFRAMESIZE ff clear fixed vector p fixed vector fixed sparse AMRSUBFRAMESIZE update state p ff acelp apply order 2 transfer function buf out buf out highpass zeros highpass poles highpass gain AMRSAMPLESCALE p high pass mem AMRBLOCKSIZE ff weighted vector sumf p lsf avg p lsf avg p lsf q 3 0 84 0 16 LPFILTERORDER got frame ptr 1 return frame sizes nb p cur frame mode 1 int vp9 get compressed data V P9 COMP cpi unsigned int frame flags size t size uint8 t dest int64 t time stamp int64 t time end int flush const V P9 Encoder Config const oxcf cpi oxcf V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd RATECONTROL const rc cpi rc struct vpx usec timer cmptimer Y V12 BUFFERCONFIG force src buffer NULL struct lookahead entry last source NULL struct lookahead entry source NULLMVREFERENCEFRAME ref frame int arf src index if is two pass svc cpi vpx usec timer start cmptimer vp9 set high precision mv cpi ALTREFHIGHPRECISIONMV cm reset frame context 0 cm refresh frame context 1 cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 arf src index get arf src index cpi if arf src index assert arf src index rc frames to key if source vp9 lookahead peek cpi lookahead arf src index NULL cpi alt ref source source int i for i cpi svc spatial layer id 1 i 0 i if oxcf ss play alternate i cpi gld fb idx cpi svc layer context i alt ref idx break cpi svc layer context cpi svc spatial layer id has alt frame 1 vp9 temporal filter cpi arf src index vp9 extend frame borders cpi alt ref buffer force src buffer cpi alt ref buffer cm show frame 0 cpi refresh alt ref frame 1 cpi refresh golden frame 0 cpi refresh last frame 0 rc is src frame alt ref 0 rc source alt ref pending 0 static int decode chunks AV Codec Context avctx AV Frame picture int got output const uint8 t buf int buf size Mpeg1 Context s avctx priv data Mpeg Enc Context s2 s mpeg enc ctx const uint8 t buf ptr buf const uint8 t buf end buf buf size int ret input size int last code 0 for uint32 t start code 1 buf ptr avpriv mpv find start code buf ptr buf end start code if start code 0x1ff if s2 pict type AVPICTURETYPEB avctx skip frame AVDISCARDDEFAULT if HAVETHREADS avctx active thread type FFTHREADSLICE int i avctx execute avctx slice decode thread s2 thread context 0 NULL s slice count sizeof void for i 0 i s slice count i s2 er error count s2 thread context i er error count if CONFIGMPEGVDPAUDECODER avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau mpeg picture complete s2 buf buf size s slice count ret slice end avctx picture if ret 0 return ret else if ret if s2 last picture ptr s2 low delay got output 1 s2 pict type 0 return FFMAX 0 buf ptr buf s2 parse context last index input size buf end buf ptr if avctx debug FFDEBUGSTARTCODE av log avctx AVLOGDEBUG 3 X at td left d n start code buf ptr buf input size switch start code case SEQSTARTCODE if last code 0 mpeg1 decode sequence avctx buf ptr input size s sync 1 else av log avctx AVLOGERROR ignoring SEQSTARTCODE after X n last code if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break case PICTURESTARTCODE if HAVETHREADS avctx active thread type FFTHREADSLICE s slice count int i avctx execute avctx slice decode thread s2 thread context NULL s slice count sizeof void for i 0 i s slice count i s2 er error count s2 thread context i er error count s slice count 0 if last code 0 last code SLICEMINSTARTCODE ret mpeg decode postinit avctx if ret 0 av log avctx AVLOGERROR mpeg decode postinit failure n return ret if mpeg1 decode picture avctx buf ptr input size 0 s2 pict type 0 s2 first slice 1 last code PICTURESTARTCODE else av log avctx AVLOGERROR ignoring pic after X n last code if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break case EXTSTARTCODE init get bits s2 gb buf ptr input size 8 switch get bits s2 gb 4 case 0x1 if last code 0 mpeg decode sequence extension s else av log avctx AVLOGERROR ignoring seq ext after X n last code if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break case 0x2 mpeg decode sequence display extension s break case 0x3 mpeg decode quant matrix extension s2 break case 0x7 mpeg decode picture display extension s break case 0x8 if last code PICTURESTARTCODE mpeg decode picture coding extension s else av log avctx AVLOGERROR ignoring pic cod ext after X n last code if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break break case USERSTARTCODE mpeg decode user data avctx buf ptr input size break case GOPSTARTCODE if last code 0 s2 first field 0 mpeg decode gop avctx buf ptr input size s sync 1 else av log avctx AVLOGERROR ignoring GOPSTARTCODE after X n last code if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break default if start code SLICEMINSTARTCODE start code SLICEMAXSTARTCODE last code 0 const int field pic s2 picture structure PICTFRAME int mb y start code SLICEMINSTARTCODE field pic last code SLICEMINSTARTCODE if s2 picture structure PICTBOTTOMFIELD mb y if mb y s2 mb height av log s2 avctx AVLOGERROR slice below image d d n mb y s2 mb height return 1 if s2 last picture ptr NULL if s2 pict type AVPICTURETYPEB if s closed gop break if s2 pict type AVPICTURETYPEI s sync 1 if s2 next picture ptr NULL if s2 pict type AVPICTURETYPEP s sync break if avctx skip frame AVDISCARDNONREF s2 pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s2 pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL break if s mpeg enc ctx allocated break if s2 codec id AVCODECIDMPE G2 VIDEO if mb y avctx skip top mb y s2 mb height avctx skip bottom break if s2 pict type av log avctx AVLOGERROR Missing picture start code n if avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA break if s2 first slice s2 first slice 0 if mpeg field start s2 buf buf size 0 return 1 if s2 current picture ptr av log avctx AVLOGERROR current picture not initialized n return AVERRORINVALIDDATA if avctx codec capabilities CODECCAPHWACCELVDPAU s slice count break if HAVETHREADS avctx active thread type FFTHREADSLICE int threshold s2 mb height s slice count s2 slice context count 2 s2 slice context count if threshold mb y Mpeg Enc Context thread context s2 thread context s slice count thread context start mb y mb y thread context end mb y s2 mb height if s slice count s2 thread context s slice count 1 end mb y mb y ret ff update duplicate context thread context s2 if ret 0 return ret init get bits thread context gb buf ptr input size 8 s slice count buf ptr 2 else ret mpeg decode slice s2 mb y buf ptr input size emms c if ret 0 if avctx err recognition AVEFEXPLODE return ret if s2 resync mb x 0 s2 resync mb y 0 ff er add slice s2 er s2 resync mb x s2 resync mb y s2 mb x s2 mb y ERACERRORERDCERRORERMVERROR else ff er add slice s2 er s2 resync mb x s2 resync mb y s2 mb x 1 s2 mb y ERACENDERDCENDERMVEND break static Image Read ART Image const Image Info image info Exception Info exception const unsigned char pixels Image image Quantum Info quantum info Quantum Type quantum type Magick Boolean Type status size t length ssize t count y assert image info const Image Info NULL assert image info signature Magick Signature if image info debug Magick False void Log Magick Event Trace Event Get Magick Module s image info filename assert exception Exception Info NULL assert exception signature Magick Signature image Acquire Image image info status Open Blob image info image Read Binary Blob Mode exception if status Magick False image Destroy Image List image return Image NULL image depth 1 image endian MSB Endian void Read Blob LSB Short image image columns size t Read Blob LSB Short image void Read Blob LSB Short image image rows size t Read Blob LSB Short image if image columns 0 image rows 0 Throw Reader Exception Corrupt Image Error Improper Image Header if Acquire Image Colormap image 2 Magick False Throw Reader Exception Resource Limit Error Memory Allocation Failed if image info ping Magick False void Close Blob image return Get First Image In List image status Set Image Extent image image columns image rows if status Magick False Inherit Exception exception image exception return Destroy Image List image Set Image Colorspace image GRAY Colorspace quantum type Index Quantum quantum info Acquire Quantum Info image info image if quantum info Quantum Info NULL Throw Reader Exception Resource Limit Error Memory Allocation Failed length Get Quantum Extent image quantum info quantum type for y 0 y ssize t image rows y register Pixel Packet magick restrict q q Queue Authentic Pixels image 0 y image columns 1 exception if q Pixel Packet NULL break pixels const unsigned char Read Blob Stream image length Get Quantum Pixels quantum info count if count ssize t length quantum info Destroy Quantum Info quantum info Throw Reader Exception Corrupt Image Error Unable To Read Image Data void Import Quantum Pixels image Cache View NULL quantum info quantum type pixels exception void Read Blob Stream image size t ssize t length 0x01 Get Quantum Pixels quantum info count if Sync Authentic Pixels image exception Magick False break status Set Image Progress image Load Image Tag Magick Offset Type y image rows if status Magick False break Set Quantum Image Type image quantum type quantum info Destroy Quantum Info quantum info if EOF Blob image Magick False Throw File Exception exception Corrupt Image Error Unexpected End Of File image filename void Close Blob image return Get First Image In List image static int mpeg decode slice Mpeg Enc Context s int mb y const uint8 t buf int buf size AV Codec Context avctx s avctx const int field pic s picture structure PICTFRAME s resync mb x s resync mb y 1 assert mb y s mb height init get bits s gb buf buf size 8 ff mpeg1 clean buffers s s interlaced dct 0 s qscale get qscale s if s qscale 0 av log s avctx AVLOGERROR qscale 0 n return 1 while get bits1 s gb 0 skip bits s gb 8 s mb x 0 if mb y 0 s codec tag AVR L32 SLIF skip bits1 s gb else while get bits left s gb 0 int code get vlc2 s gb mbincr vlc table MBINCRVLCBITS 2 if code 0 av log s avctx AVLOGERROR first mb incr damaged n return 1 if code 33 if code 33 s mb x 33 else s mb x code break if s mb x unsigned s mb width av log s avctx AVLOGERROR initial skip overflow n return 1 if avctx hwaccel const uint8 t buf end buf start buf 4 int start code 1 buf end avpriv mpv find start code buf start 2 buf buf size start code if buf end buf buf size buf end 4 s mb y mb y if avctx hwaccel decode slice avctx buf start buf end buf start 0 return DECODESLICEERROR buf buf end return DECODESLICEOK s resync mb x s mb x s resync mb y s mb y mb y s mb skip run 0 ff init block index s if s mb y 0 s mb x 0 s first field s picture structure PICTFRAME if s avctx debug FFDEBUGPICTINFO av log s avctx AVLOGDEBUG qp d fc 2d 2d 2d 2d s s s s s dc d pstruct d fdct d cmv d qtype d ivlc d rff d s n s qscale s mpeg f code 0 0 s mpeg f code 0 1 s mpeg f code 1 0 s mpeg f code 1 1 s pict type AVPICTURETYPEII s pict type AVPICTURETYPEPP s pict type AVPICTURETYPEBBS s progressive sequence ps s progressive frame pf s alternate scan alt s top field first top s intra dc precision s picture structure s frame pred frame dct s concealment motion vectors s q scale type s intra vlc format s repeat first field s chroma 420 type 420 for if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration 1 ff xvmc init block s if mpeg decode mb s s block 0 return 1 if s current picture motion val 0 s encoding const int wrap s b8 stride int xy s mb x 2 s mb y 2 wrap int b8 xy 4 s mb x s mb y s mb stride int motion x motion y dir i for i 0 i 2 i for dir 0 dir 2 dir if s mb intra dir 1 s pict type AVPICTURETYPEB motion x motion y 0 else if s mv type MVTYPE 16 X16 s mv type MVTYPEFIELD field pic motion x s mv dir 0 0 motion y s mv dir 0 1 else motion x s mv dir i 0 motion y s mv dir i 1 s current picture motion val dir xy 0 motion x s current picture motion val dir xy 1 motion y s current picture motion val dir xy 1 0 motion x s current picture motion val dir xy 1 1 motion y s current picture ref index dir b8 xy s current picture ref index dir b8 xy 1 s field select dir i assert s field select dir i 0 s field select dir i 1 xy wrap b8 xy 2 s dest 0 16 s dest 1 16 s chroma x shift s dest 2 16 s chroma x shift ff MPV decode mb s s block if s mb x s mb width const int mb size 16 ff mpeg draw horiz band s mb size s mb y field pic mb size ff MPV report decode progress s s mb x 0 s mb y 1 field pic if s mb y s mb height int left get bits left s gb int is d10 s chroma format 2 s pict type AVPICTURETYPEI avctx profile 0 avctx level 5 s intra dc precision 2 s q scale type 1 s alternate scan 0 s progressive frame 0 if left 0 left show bits s gb FFMIN left 23 is d10 avctx err recognition AVEFBUFFER left 8 av log avctx AVLOGERROR end mismatch left d 0 X n left show bits s gb FFMIN left 23 return 1 else goto eos ff init block index s if s mb skip run 1 s mb skip run 0 for int code get vlc2 s gb mbincr vlc table MBINCRVLCBITS 2 if code 0 av log s avctx AVLOGERROR mb incr damaged n return 1 if code 33 if code 33 s mb skip run 33 else if code 35 if s mb skip run 0 show bits s gb 15 0 av log s avctx AVLOGERROR slice mismatch n return 1 goto eos else s mb skip run code break if s mb skip run int i if s pict type AVPICTURETYPEI av log s avctx AVLOGERROR skipped MB in I frame at d d n s mb x s mb y return 1 s mb intra 0 for i 0 i 12 i s block last index i 1 if s picture structure PICTFRAME s mv type MVTYPE 16 X16 else s mv type MVTYPEFIELD if s pict type AVPICTURETYPEP s mv dir MVDIRFORWARD s mv 0 0 0 s mv 0 0 1 0 s last mv 0 0 0 s last mv 0 0 1 0 s last mv 0 1 0 s last mv 0 1 1 0 s field select 0 0 s picture structure 1 1 else s mv 0 0 0 s last mv 0 0 0 s mv 0 0 1 s last mv 0 0 1 s mv 1 0 0 s last mv 1 0 0 s mv 1 0 1 s last mv 1 0 1 eos buf get bits count s gb 1 8 av dlog s y d d d d n s resync mb x s resync mb y s mb x s mb y return 0 static int gsm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data int res Get Bit Context gb const uint8 t buf avpkt data int buf size avpkt size int16 t samples if buf size avctx block align av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA frame nb samples avctx frame size if res ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return res samples int16 t frame data 0 switch avctx codec id case AVCODECIDGSM init get bits gb buf buf size 8 if get bits gb 4 0xd av log avctx AVLOGWARNING Missing GSM magic n res gsm decode block avctx samples gb if res 0 return res break case AVCODECIDGSMMS res ff msgsm decode block avctx samples buf if res 0 return res got frame ptr 1 return avctx block align static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cam Studio Context c avctx priv data AV Frame picture data int ret if buf size 2 av log avctx AVLOGERROR coded frame too small n return AVERRORINVALIDDATA if ret ff get buffer avctx picture 0 0 av log avctx AVLOGERROR get buffer failed n return ret switch buf 0 1 7 case 0 int outlen c decomp size inlen buf size 2 if av lzo1x decode c decomp buf outlen buf 2 inlen av log avctx AVLOGERROR error during lzo decompression n break case 1 if uncompress c decomp buf dlen buf 2 buf size 2 ZOK av log avctx AVLOGERROR error during zlib decompression n break return AVERRORENOSYS default av log avctx AVLOGERROR unknown compression n return AVERRORINVALIDDATA if buf 0 1 picture pict type AVPICTURETYPEI picture key frame 1 switch c bpp case 16 copy frame 16 picture c decomp buf c linelen c height break case 32 copy frame 32 picture c decomp buf c linelen c height break default copy frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height else picture pict type AVPICTURETYPEP picture key frame 0 switch c bpp case 16 add frame 16 picture c decomp buf c linelen c height break case 32 add frame 32 picture c decomp buf c linelen c height break default add frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height got frame 1 return buf size static void slurm rpc job will run slurm msg t msg DEFTIMERS int error code SLURMSUCCESS struct job record job ptr NULL job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint16 t port slurm addr t resp addr will run response msg t resp NULL char err msg NULL job submit user msg NULL if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED goto send reply STARTTIMER debug2 Processing RPCREQUESTJOBWILLRUN from uid d uid if is valid will run user job desc msg uid error code ESLURMUSERIDMISSING error Security violation JOBWILLRUNRPC from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTJOBWILLRUN lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if slurm get peer addr msg conn fd resp addr job desc msg resp host xmalloc 16 slurm get ip str resp addr port job desc msg resp host 16 dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job write lock if job desc msg job id NOVAL job desc msg pack job offset NOVAL error code job allocate job desc msg false true resp true uid job ptr err msg msg protocol version else error code job start data job desc msg resp unlock slurmctld job write lock ENDTIME R2 slurm rpc job will run else if errno error code errno else error code SLURMERROR send reply if error code debug2 slurm rpc job will run s slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else if resp slurm msg t response msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg address msg address response msg conn msg conn response msg msg type RESPONSEJOBWILLRUN response msg data resp resp job submit user msg job submit user msg job submit user msg NULL slurm send node msg msg conn fd response msg slurm free will run response msg resp debug2 slurm rpc job will run success s TIMESTR else debug2 slurm rpc job will run success s TIMESTR if job desc msg job id NOVAL slurm send rc msg msg SLURMSUCCESS xfree err msg xfree job submit user msg static int bfi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Get Byte Context g int buf size avpkt size BFI Context bfi avctx priv data uint8 t dst bfi dst uint8 t src dst offset colour1 colour2 uint8 t frame end bfi dst avctx width avctx height uint32 t pal int i j ret height avctx height if bfi frame data 0 avctx release buffer avctx bfi frame bfi frame reference 1 if ret ff get buffer avctx bfi frame 0 av log avctx AVLOGERROR get buffer failed n return ret bytestream2 init g avpkt data buf size if avctx frame number bfi frame pict type AVPICTURETYPEI bfi frame key frame 1 if avctx extradata size 768 av log NULLAVLOGERROR Palette is too large n return AVERRORINVALIDDATA pal uint32 t bfi frame data 1 for i 0 i avctx extradata size 3 i int shift 16 pal 0 for j 0 j 3 j shift 8 pal avctx extradata i 3 j 2 avctx extradata i 3 j 4 shift pal bfi frame palette has changed 1 else bfi frame pict type AVPICTURETYPEP bfi frame key frame 0 bytestream2 skip g 4 while dst frame end static const uint8 t lentab 4 0 2 0 1 unsigned int byte bytestream2 get byte g av uninit offset unsigned int code byte 6 unsigned int length byte 0x C0 if bytestream2 get bytes left g av log avctx AVLOGERROR Input resolution larger than actual frame n return AVERRORINVALIDDATA if length 0 if code 1 length bytestream2 get byte g offset bytestream2 get le16 g else length bytestream2 get le16 g if code 2 length 0 break else if code 1 offset bytestream2 get byte g if dst length lentab code frame end break switch code case 0 if length bytestream2 get bytes left g av log avctx AVLOGERROR Frame larger than buffer n return AVERRORINVALIDDATA bytestream2 get buffer g dst length dst length break case 1 dst offset dst offset length 4 if dst offset bfi dst break while length dst dst offset break case 2 dst length break case 3 colour1 bytestream2 get byte g colour2 bytestream2 get byte g while length dst colour1 dst colour2 break src bfi dst dst bfi frame data 0 while height memcpy dst src avctx width src avctx width dst bfi frame linesize 0 got frame 1 AV Frame data bfi frame return buf size static void joint motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mv frame mv int mi row int mi col int mv single newmv MAXREFFRAMES int rate mv const int pw 4 num 4x4 blocks wide lookup bsize const int ph 4 num 4x4 blocks high lookup bsize MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi const int refs 2 mbmi ref frame 0 mbmi ref frame 1 0 0 mbmi ref frame 1 int mv ref mv 2 int ite ref uint8 t second pred vpx memalign 16 pw ph sizeof uint8 t const Interp Kernel kernel vp9 get interp kernel mbmi interp filter struct buf 2d backup yv12 2 MAXMBPLANE struct buf 2d scaled first yv12 xd plane 0 pre 0 int last besterr 2 INTMAXINTMAX const Y V12 BUFFERCONFIG const scaled ref frame 2 vp9 get scaled ref frame cpi mbmi ref frame 0 vp9 get scaled ref frame cpi mbmi ref frame 1 for ref 0 ref 2 ref ref mv ref mbmi ref mvs refs ref 0 if scaled ref frame ref int i for i 0 i MAXMBPLANE i backup yv12 ref i xd plane i pre ref vp9 setup pre planes xd ref scaled ref frame ref mi row mi col NULL frame mv refs ref as int single newmv refs ref as int for ite 0 ite 4 ite struct buf 2d ref yv12 2 int bestsme INTMAX int sadpb x sadperbit16 MV tmp mv int search range 3 int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int id ite 2 ref yv12 0 xd plane 0 pre 0 ref yv12 1 xd plane 0 pre 1 vp9 build inter predictor ref yv12 id buf ref yv12 id stride second pred pw frame mv refs id as mv xd block refs id sf pw ph 0 kernel MVPRECISION Q3 mi col MISIZE mi row MISIZE if id xd plane 0 pre 0 ref yv12 id vp9 set mv search range x ref mv id as mv tmp mv frame mv refs id as mv tmp mv col 3 tmp mv row 3 bestsme vp9 refining search 8p c x tmp mv sadpb search range cpi fn ptr bsize ref mv id as mv second pred if bestsme INTMAX bestsme vp9 get mvpred av var x tmp mv ref mv id as mv second pred cpi fn ptr bsize 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis unsigned int sse bestsme cpi find fractional mv step x tmp mv ref mv id as mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize 0 cpi sf mv subpel iters per step NULL x nmvjointcost x mvcost dis sse second pred pw ph if id xd plane 0 pre 0 scaled first yv12 if bestsme last besterr id frame mv refs id as mv tmp mv last besterr id bestsme else break rate mv 0 for ref 0 ref 2 ref if scaled ref frame ref int i for i 0 i MAXMBPLANE i xd plane i pre ref backup yv12 ref i rate mv vp9 mv bit cost frame mv refs ref as mv mbmi ref mvs refs ref 0 as mv x nmvjointcost x mvcost MVCOSTWEIGHT vpx free second pred static inline int direct search Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me int P 10 2 const int mot stride s mb stride const int mot xy mb y mot stride mb x const int shift 1 s quarter sample int dmin i const int time pp s pp time const int time pb s pb time int mx my xmin xmax ymin ymax int16 t mv table 2 s b direct mv table c current mv penalty c mv penalty 1 MAXMV ymin xmin 32 shift ymax xmax 31 shift if IS 8 X8 s next picture mb type mot xy s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 for i 0 i 4 i int index s block index i int min max c co located mv i 0 s next picture motion val 0 index 0 c co located mv i 1 s next picture motion val 0 index 1 c direct basis mv i 0 c co located mv i 0 time pb time pp i 1 shift 3 c direct basis mv i 1 c co located mv i 1 time pb time pp i 1 shift 3 max FFMAX c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift min FFMIN c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift max 16 mb x 1 min 16 mb x 1 xmax FFMIN xmax s width max xmin FFMAX xmin 16 min max FFMAX c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift min FFMIN c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift max 16 mb y 1 min 16 mb y 1 ymax FFMIN ymax s height max ymin FFMAX ymin 16 min if s mv type MVTYPE 16 X16 break assert xmax 15 ymax 15 xmin 16 ymin 16 if xmax 0 xmin 0 ymax 0 ymin 0 s b direct mv table mot xy 0 0 s b direct mv table mot xy 1 0 return 256 256 256 64 c xmin xmin c ymin ymin c xmax xmax c ymax ymax c flags FLAGDIRECT c sub flags FLAGDIRECT c pred x 0 c pred y 0 PLEFT 0 av clip mv table mot xy 1 0 xmin shift xmax shift PLEFT 1 av clip mv table mot xy 1 1 ymin shift ymax shift if s first slice line PTOP 0 av clip mv table mot xy mot stride 0 xmin shift xmax shift PTOP 1 av clip mv table mot xy mot stride 1 ymin shift ymax shift PTOPRIGHT 0 av clip mv table mot xy mot stride 1 0 xmin shift xmax shift PTOPRIGHT 1 av clip mv table mot xy mot stride 1 1 ymin shift ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 dmin ff epzs motion search s mx my P 0 0 mv table 1 16 shift 0 16 if c sub flags FLAGQPEL dmin qpel motion search s mx my dmin 0 0 0 16 else dmin hpel motion search s mx my dmin 0 0 0 16 if c avctx me sub cmp c avctx mb cmp c skip dmin get mb score s mx my 0 0 0 16 1 get limits s 16 mb x 16 mb y mv table mot xy 0 mx mv table mot xy 1 my c flags FLAGDIRECT c sub flags FLAGDIRECT return dmin static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Eight Bps Context const c avctx priv data const unsigned char encoded buf unsigned char pixptr pixptr end unsigned int height avctx height unsigned int dlen p row const unsigned char lp dp unsigned char count unsigned int px inc unsigned int planes c planes unsigned char planemap c planemap int ret if c pic data 0 avctx release buffer avctx c pic c pic reference 0 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret dp encoded planes height 1 if planes 4 planes px inc planes avctx pix fmt AVPIXFMTRG B32 for p 0 p planes p lp encoded p height 1 for row 0 row height row pixptr c pic data 0 row c pic linesize 0 planemap p pixptr end pixptr c pic linesize 0 dlen av be2ne16 const unsigned short lp row 2 while dlen 0 if dp 1 buf buf size return AVERRORINVALIDDATA if count dp 127 count dlen count 1 if pixptr count px inc pixptr end break if dp count buf buf size return AVERRORINVALIDDATA while count pixptr dp pixptr px inc else count 257 count if pixptr count px inc pixptr end break while count pixptr dp pixptr px inc dp dlen 2 if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static int ws snd decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int in size out size ret int sample 128 uint8 t samples uint8 t samples end if buf size return 0 if buf size 4 av log avctx AVLOGERROR packet is too small n return AVERROREINVAL out size AVR L16 buf 0 in size AVR L16 buf 2 buf 4 if in size buf size av log avctx AVLOGERROR Frame data is larger than input buffer n return 1 frame nb samples out size if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples frame data 0 samples end samples out size if in size out size memcpy samples buf out size got frame ptr 1 return buf size while samples samples end buf avpkt data buf size int code smp size uint8 t count code buf 6 count buf 0x3 F buf switch code case 0 smp 4 count 1 break case 1 smp 2 count 1 break case 2 smp count 0x20 1 count 1 break default smp count 1 break if samples end samples smp break size code 2 count 0x20 code 3 0 count 1 if buf avpkt data size buf size break switch code case 0 for count count 0 count code buf sample code 0x3 2 sample av clip uint8 sample samples sample sample code 2 0x3 2 sample av clip uint8 sample samples sample sample code 4 0x3 2 sample av clip uint8 sample samples sample sample code 6 2 sample av clip uint8 sample samples sample break case 1 for count count 0 count code buf sample ws adpcm 4bit code 0x F sample av clip uint8 sample samples sample sample ws adpcm 4bit code 4 sample av clip uint8 sample samples sample break case 2 if count 0x20 int8 t t t count t 3 sample t 3 sample av clip uint8 sample samples sample else memcpy samples buf smp samples smp buf smp sample buf 1 break default memset samples sample smp samples smp frame nb samples samples frame data 0 got frame ptr 1 return buf size static void loop filter rows mt const Y V12 BUFFERCONFIG const frame buffer V P9 COMMON const cm struct macroblockd plane planes MAXMBPLANE int start int stop int y only V P9 Lf Sync const lf sync int num lf workers const int num planes y only 1 MAXMBPLANE int r c const int sb cols mi cols aligned to sb cm mi cols MIBLOCKSIZELO G2 for r start r stop r num lf workers const int mi row r MIBLOCKSIZELO G2 MODEINFO const mi cm mi grid visible mi row cm mi stride for c 0 c sb cols c const int mi col c MIBLOCKSIZELO G2 LOOPFILTERMASK lfm int plane sync read lf sync r c vp9 setup dst planes planes frame buffer mi row mi col vp9 setup mask cm mi row mi col mi mi col cm mi stride lfm for plane 0 plane num planes plane vp9 filter block plane cm planes plane mi row lfm sync write lf sync r c sb cols static int execstack2 continue i ctx t i ctx p os ptr op osp return do execstack i ctx p op value boolval true op 1 static int64 t encode inter mb segment V P9 COMP cpi MACROBLOCK x int64 t best yrd int i int labelyrate int64 t distortion int64 t sse ENTROPYCONTEXT ta ENTROPYCONTEXT tl int mi row int mi col int k MACROBLOCKD xd x e mbd struct macroblockd plane const pd xd plane 0 struct macroblock plane const p x plane 0 MODEINFO const mi xd mi 0 src mi const BLOCKSIZE plane bsize get plane block size mi mbmi sb type pd const int width 4 num 4x4 blocks wide lookup plane bsize const int height 4 num 4x4 blocks high lookup plane bsize int idx idy const uint8 t const src p src buf raster block offset BLOCK 8 X8 i p src stride uint8 t const dst pd dst buf raster block offset BLOCK 8 X8 i pd dst stride int64 t thisdistortion 0 thissse 0 int thisrate 0 ref const scan order so vp9 default scan orders TX 4 X4 const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter for ref 0 ref 1 is compound ref const uint8 t pre pd pre ref buf raster block offset BLOCK 8 X8 i pd pre ref stride vp9 build inter predictor pre pd pre ref stride dst pd dst stride mi bmi i as mv ref as mv xd block refs ref sf width height ref kernel MVPRECISION Q3 mi col MISIZE 4 i 2 mi row MISIZE 4 i 2 vp9 subtract block height width raster block offset int16 BLOCK 8 X8 i p src diff 8 src p src stride dst pd dst stride k i for idy 0 idy height 4 idy for idx 0 idx width 4 idx int64 t ssz rd rd1 rd2 tran low t coeff k idy 2 idx coeff BLOCKOFFSET p coeff k x fwd txm4x4 raster block offset int16 BLOCK 8 X8 k p src diff coeff 8 vp9 regular quantize b 4x4 x 0 k so scan so iscan thisdistortion vp9 block error coeff BLOCKOFFSET pd dqcoeff k 16 ssz thissse ssz thisrate cost coeffs x 0 k ta k 1 tl k 1 TX 4 X4 so scan so neighbors cpi sf use fast coef costing rd1 RDCOST x rdmult x rddiv thisrate thisdistortion 2 rd2 RDCOST x rdmult x rddiv 0 thissse 2 rd MIN rd1 rd2 if rd best yrd return IN T64 MAX distortion thisdistortion 2 labelyrate thisrate sse thissse 2 return RDCOST x rdmult x rddiv labelyrate distortion static int mpeg4 decode partitioned mb Mpeg Enc Context s int16 t block 6 64 int cbp mb type const int xy s mb x s mb y s mb stride mb type s current picture f mb type xy cbp s cbp table xy s use intra dc vlc s qscale s intra dc threshold if s current picture f qscale table xy s qscale ff set qscale s s current picture f qscale table xy if s pict type AVPICTURETYPEP s pict type AVPICTURETYPES int i for i 0 i 4 i s mv 0 i 0 s current picture f motion val 0 s block index i 0 s mv 0 i 1 s current picture f motion val 0 s block index i 1 s mb intra ISINTRA mb type if ISSKIP mb type for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s mcsel 1 s mb skipped 0 else s mcsel 0 s mb skipped 1 else if s mb intra s ac pred ISACPRED s current picture f mb type xy else if s mb intra s mv dir MVDIRFORWARD if IS 8 X8 mb type s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 else s mb intra 1 s ac pred ISACPRED s current picture f mb type xy if ISSKIP mb type int i s dsp clear blocks s block 0 for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 s mb intra s rvlc 0 av log s avctx AVLOGERROR texture corrupted at d d d n s mb x s mb y s mb intra return 1 cbp cbp if s mb num left 0 if mpeg4 is resync s return SLICEEND else return SLICENOEND else if mpeg4 is resync s const int delta s mb x 1 s mb width 2 1 if s cbp table xy delta return SLICEEND return static int roq encode end AV Codec Context avctx Roq Context enc avctx priv data av frame free enc current frame av frame free enc last frame av free enc tmp Data av free enc this motion4 av free enc last motion4 av free enc this motion8 av free enc last motion8 return 0 static void setup frame size with refs V P9 COMMON cm struct vp9 read bit buffer rb int width height int found 0 i int has valid ref frame 0 for i 0 i REFSPERFRAME i if vp9 rb read bit rb Y V12 BUFFERCONFIG const buf cm frame refs i buf width buf y crop width height buf y crop height if buf corrupted vpx internal error cm error VPXCODECCORRUPTFRAME Frame reference is corrupt found 1 break if found vp9 read frame size rb width height if width 0 height 0 vpx internal error cm error VPXCODECCORRUPTFRAME Invalid frame size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i has valid ref frame valid ref frame size ref frame buf y crop width ref frame buf y crop height width height if has valid ref frame vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has invalid size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i if valid ref frame img fmt ref frame buf bit depth ref frame buf uv crop width ref frame buf y crop width ref frame buf uv crop height ref frame buf y crop height cm bit depth cm subsampling x cm subsampling y vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has incompatible color space resize context buffers cm width height setup display size cm rb if vp9 realloc frame buffer get frame new buffer cm cm width cm height cm subsampling x cm subsampling y if CONFIGV P9 HIGHBITDEPTH cm use highbitdepth endif V P9 DECBORDERINPIXELS cm frame bufs cm new fb idx raw frame buffer cm get fb cb cm cb priv vpx internal error cm error VPXCODECMEMERROR Failed to allocate frame buffer cm frame bufs cm new fb idx buf bit depth unsigned int cm bit depth static gcry err code t sexp to enc gcry sexp t sexp gcry mpi t retarray gcry module t retalgo int ret modern int flags struct pk encoding ctx ctx gcry err code t err 0 gcry sexp t list NULL l2 NULL gcry pk spec t pubkey NULL gcry module t module NULL char name NULL size t n int parsed flags 0 const char elems gcry mpi t array NULL ret modern 0 list gcry sexp find token sexp enc val 0 if list err GPGERRINVOBJ goto leave l2 gcry sexp nth list 1 if l2 err GPGERRNOOBJ goto leave name gcry sexp nth string l2 0 if name err GPGERRINVOBJ goto leave if strcmp name flags const char s int i ret modern 1 for i gcry sexp length l2 1 i 0 i s gcry sexp nth data l2 i n if s else if n 3 memcmp s raw 3 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCRAW else if n 5 memcmp s pkcs1 5 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCPKC S1 else if n 4 memcmp s oaep 4 ctx encoding PUBKEYENCUNKNOWN ctx encoding PUBKEYENCOAEP else if n 3 memcmp s pss 3 ctx encoding PUBKEYENCUNKNOWN err GPGERRCONFLICT goto leave else if n 11 memcmp s no blinding 11 parsed flags PUBKEYFLAGNOBLINDING else err GPGERRINVFLAG goto leave gcry sexp release l2 if ctx encoding PUBKEYENCOAEP l2 gcry sexp find token list hash algo 0 if l2 s gcry sexp nth data l2 1 n if s err GPGERRNOOBJ else ctx hash algo get hash algo s n if ctx hash algo err GPGERRDIGESTALGO gcry sexp release l2 if err goto leave l2 gcry sexp find token list label 0 if l2 s gcry sexp nth data l2 1 n if s err GPGERRNOOBJ else if n 0 ctx label gcry malloc n if ctx label err gpg err code from syserror else memcpy ctx label s n ctx labellen n gcry sexp release l2 if err goto leave for i 2 l2 gcry sexp nth list i NULL i s gcry sexp nth data l2 0 n if n 9 memcmp s hash algo 9 n 5 memcmp s label 5 n 15 memcmp s random override 15 break gcry sexp release l2 if l2 err GPGERRNOOBJ goto leave gcry free name name gcry sexp nth string l2 0 if name err GPGERRINVOBJ goto leave gcry sexp release list list l2 l2 NULL ath mutex lock pubkeys registered lock module gcry pk lookup name name ath mutex unlock pubkeys registered lock if module err GPGERRPUBKEYALGO goto leave pubkey gcry pk spec t module spec elems pubkey elements enc array gcry calloc strlen elems 1 sizeof array if array err gpg err code from syserror goto leave err sexp elements extract list elems array NULL 0 leave gcry sexp release list gcry sexp release l2 gcry free name if err ath mutex lock pubkeys registered lock gcry module release module ath mutex unlock pubkeys registered lock gcry free array gcry free ctx label ctx label NULL else retarray array retalgo module flags parsed flags return err void ff h263 loop filter Mpeg Enc Context s int qp c const int linesize s linesize const int uvlinesize s uvlinesize const int xy s mb y s mb stride s mb x uint8 t dest y s dest 0 uint8 t dest cb s dest 1 uint8 t dest cr s dest 2 if ISSKIP s current picture mb type xy qp c s qscale s dsp h263 v loop filter dest y 8 linesize linesize qp c s dsp h263 v loop filter dest y 8 linesize 8 linesize qp c else qp c 0 if s mb y int qp dt qp tt qp tc if ISSKIP s current picture mb type xy s mb stride qp tt 0 else qp tt s current picture qscale table xy s mb stride if qp c qp tc qp c else qp tc qp tt if qp tc const int chroma qp s chroma qscale table qp tc s dsp h263 v loop filter dest y linesize qp tc s dsp h263 v loop filter dest y 8 linesize qp tc s dsp h263 v loop filter dest cb uvlinesize chroma qp s dsp h263 v loop filter dest cr uvlinesize chroma qp if qp tt s dsp h263 h loop filter dest y 8 linesize 8 linesize qp tt if s mb x if qp tt ISSKIP s current picture mb type xy 1 s mb stride qp dt qp tt else qp dt s current picture qscale table xy 1 s mb stride if qp dt const int chroma qp s chroma qscale table qp dt s dsp h263 h loop filter dest y 8 linesize linesize qp dt s dsp h263 h loop filter dest cb 8 uvlinesize uvlinesize chroma qp s dsp h263 h loop filter dest cr 8 uvlinesize uvlinesize chroma qp if qp c s dsp h263 h loop filter dest y 8 linesize qp c if s mb y 1 s mb height s dsp h263 h loop filter dest y 8 linesize 8 linesize qp c if s mb x int qp lc if qp c ISSKIP s current picture mb type xy 1 qp lc qp c else qp lc s current picture qscale table xy 1 if qp lc s dsp h263 h loop filter dest y linesize qp lc if s mb y 1 s mb height const int chroma qp s chroma qscale table qp lc s dsp h263 h loop filter dest y 8 linesize linesize qp lc s dsp h263 h loop filter dest cb uvlinesize chroma qp s dsp h263 h loop filter dest cr uvlinesize chroma qp void ff MPV frame end Mpeg Enc Context s int i if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s else if s er error count s encoding s avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU s unrestricted mv s current picture f reference s intra only s flags CODECFLAGEMUEDGE const AV Pix Fmt Descriptor desc av pix fmt desc get s avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h s dsp draw edges s current picture f data 0 s linesize s h edge pos s v edge pos EDGEWIDTHEDGEWIDTHEDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 1 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 2 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM emms c s last pict type s pict type s last lambda for s pict type s current picture ptr f quality if s pict type AVPICTURETYPEB s last non b pict type s pict type i MAXPICTURECOUNT i if s picture i f data 0 s current picture f data 0 s picture i s current picture break assert i MAXPICTURECOUNT for i 0 i s picture count i if s picture i f data 0 s picture i f reference free frame buffer s s picture i static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w AV Frame pic avctx coded frame const uint8 t src avpkt data uint8 t Y1 Y2 UV int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 3 2 16 av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 if AVR L32 src 0x01000002 av log ask for sample avctx Unknown frame header X n AVR L32 src return AVERRORPATCHWELCOME src 16 Y1 pic data 0 Y2 pic data 0 pic linesize 0 U pic data 1 V pic data 2 for h 0 h avctx height h 2 for w 0 w avctx width w 2 AVCOP Y16 Y1 w src AVCOP Y16 Y2 w src 2 U w 1 src 4 0x80 V w 1 src 5 0x80 src 6 Y1 pic linesize 0 1 Y2 pic linesize 0 1 U pic linesize 1 V pic linesize 2 got frame 1 AV Frame data pic return avpkt size static int mss1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S1 Context ctx avctx priv data MS S12 Context c ctx ctx Get Bit Context gb Arith Coder acoder int pal changed 0 int ret init get bits gb buf buf size 8 arith init acoder gb ctx pic reference 3 ctx pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSREADABLEFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx ctx pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pal pic ctx pic data 0 ctx pic linesize 0 avctx height 1 c pal stride ctx pic linesize 0 c keyframe arith get bit acoder if c keyframe c corrupted 0 ff mss12 slicecontext reset ctx sc pal changed decode pal c acoder ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else if c corrupted return AVERRORINVALIDDATA ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP c corrupted ff mss12 decode rect ctx sc acoder 0 0 avctx width avctx height if c corrupted return AVERRORINVALIDDATA memcpy ctx pic data 1 c pal AVPALETTESIZE ctx pic palette has changed pal changed got frame 1 AV Frame data ctx pic return buf size static Selectivity calc arraycontsel Variable Stat Data vardata Datum constval Oid elemtype Oid operator Selectivity selec Type Cache Entry typentry Fmgr Info cmpfunc Array Type array typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid return DEFAULTSEL operator cmpfunc typentry cmp proc finfo array Datum Get Array Type P constval if Heap Tuple Is Valid vardata stats Tuple Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if operator OIDARRAYCONTAINEDOP get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 selec mcelem array selec array typentry values nvalues numbers nnumbers hist nhist operator cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc selec 1 0 stats stanullfrac else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc if Pointer Get Datum array constval pfree array return selec enum Imap Auth Res imap auth cram md5 struct Imap Data idata const char method char ibuf LONGSTRING 2 obuf LONGSTRING unsigned char hmac response M D5 DIGESTLEN int len int rc if mutt bit isset idata capabilities ACRAMM D5 return IMAPAUTHUNAVAIL mutt message Authenticating CRAMM D5 if mutt account getlogin idata conn account 0 return IMAPAUTHFAILURE if mutt account getpass idata conn account 0 return IMAPAUTHFAILURE imap cmd start idata AUTHENTICATECRAMM D5 do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 Invalid response from server s n ibuf goto bail len mutt b64 decode obuf idata buf 2 sizeof obuf if len 1 mutt debug 1 Error decoding base64 response n goto bail obuf len 0 mutt debug 2 CRAM challenge s n obuf hmac md5 idata conn account pass obuf hmac response int off snprintf obuf sizeof obuf s idata conn account user mutt md5 toascii hmac response obuf off mutt debug 2 CRAM response s n obuf mutt b64 encode ibuf obuf strlen obuf sizeof ibuf 2 mutt str strcat ibuf sizeof ibuf r n mutt socket send idata conn ibuf do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDOK mutt debug 1 Error receiving server response n goto bail if imap code idata buf return IMAPAUTHSUCCESS bail mutt error CRAMM D5 authentication failed return static void resolv conf parse line char const start int flags char strtok state static const char const delims t if first token return if strcmp first token nameserver flags DNSOPTIONNAMESERVERS const char const nameserver NEXTTOKEN struct in addr ina if inet aton nameserver ina evdns nameserver add ina s addr else if strcmp first token domain flags DNSOPTIONSEARCH const char const domain NEXTTOKEN if domain search postfix clear search postfix add domain else if strcmp first token search flags DNSOPTIONSEARCH const char domain search postfix clear while domain NEXTTOKEN search postfix add domain search reverse else if strcmp first token options const char option while option NEXTTOKEN const char val strchr option evdns set option option val val 1 flags static void create new objects void int dbnum prep status Restoring database schemas in the new cluster n for dbnum 0 dbnum old cluster dbarr ndbs dbnum char sql file name MAXPGPATH log file name MAXPGPATH Db Info old db old cluster dbarr dbs dbnum PQ Exp Buffer Data connstr escaped connstr init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr old db db name init PQ Exp Buffer escaped connstr append Shell String escaped connstr connstr data term PQ Exp Buffer connstr pg log PGSTATUS s old db db name snprintf sql file name sizeof sql file name DBDUMPFILEMASK old db db oid snprintf log file name sizeof log file name DBDUMPLOGFILEMASK old db db oid parallel exec prog log file name NULL s pg restore s exit on error verbose dbname s s new cluster bindir cluster conn opts new cluster escaped connstr data sql file name term PQ Exp Buffer escaped connstr while reap child true true end progress output check ok if GETMAJORVERSION old cluster major version 903 set frozenxids true get db and rel infos new cluster void vp9 xform quant fp MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize fp 32x32 coeff 1024 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize fp coeff 256 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize fp coeff 64 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize fp coeff 16 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break void ff clean h263 qscales Mpeg Enc Context s int i int8 t const qscale table s current picture f qscale table ff init qscale tab s for i 1 i s mb num i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 for i s mb num 2 i 0 i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 if s codec id AVCODECID H263 P for i 1 i s mb num i int mb xy s mb index2xy i if qscale table mb xy qscale table s mb index2xy i 1 s mb type mb xy CANDIDATEMBTYPEINTE R4 V s mb type mb xy static int atrac1 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size A T1 Ctx q avctx priv data int ch ret Get Bit Context gb if buf size 212 avctx channels av log avctx AVLOGERROR Not enough data to decode n return AVERRORINVALIDDATA frame nb samples A T1 SUSAMPLES if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for ch 0 ch avctx channels ch A T1 SU Ctx su q S Us ch init get bits gb buf 212 ch 212 8 ret at1 parse bsm gb su log2 block count if ret 0 return ret ret at1 unpack dequant gb su q spec if ret 0 return ret ret at1 imdct block su q if ret 0 return ret at1 subband synthesis q su float frame extended data ch got frame ptr 1 return avctx block align static void rv40 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int alpha beta beta Y beta C int q int mbtype 4 int mb strong 4 int clip 4 int cbp 4 int uvcbp 4 2 unsigned mvmasks 4 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r cbp luma mb pos r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int y h deblock y v deblock int c v deblock 2 c h deblock 2 int clip left int avail 4 unsigned y to deblock int c to deblock 2 q s current picture ptr f qscale table mb pos alpha rv40 alpha tab q beta rv40 beta tab q beta Y beta C beta 3 if s width s height 176 144 beta Y beta avail 0 1 avail 1 row avail 2 mb x avail 3 row s mb height 1 for i 0 i 4 i if avail i int pos mb pos neighbour offs x i neighbour offs y i s mb stride mvmasks i r deblock coefs pos mbtype i s current picture ptr f mb type pos cbp i r cbp luma pos uvcbp i 0 r cbp chroma pos 0x F uvcbp i 1 r cbp chroma pos 4 else mvmasks i 0 mbtype i mbtype 0 cbp i 0 uvcbp i 0 uvcbp i 1 0 mb strong i ISINTRA mbtype i ISSEPARATEDC mbtype i clip i rv40 filter clip tbl mb strong i 1 q y to deblock mvmasks POSCUR mvmasks POSBOTTOM 16 y h deblock y to deblock cbp POSCUR 4 MASKYTOPROW cbp POSTOPMASKYLASTROW 12 y v deblock y to deblock cbp POSCUR 1 MASKYLEFTCOL cbp POSLEFTMASKYRIGHTCOL 3 if mb x y v deblock MASKYLEFTCOL if row y h deblock MASKYTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM y h deblock MASKYTOPROW 16 for i 0 i 2 i c to deblock i uvcbp POSBOTTOM i 4 uvcbp POSCUR i c v deblock i c to deblock i uvcbp POSCUR i 1 MASKCLEFTCOL uvcbp POSLEFT i MASKCRIGHTCOL 1 c h deblock i c to deblock i uvcbp POSTOP i MASKCLASTROW 2 uvcbp POSCUR i 2 if mb x c v deblock i MASKCLEFTCOL if row c h deblock i MASKCTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM c h deblock i MASKCTOPROW 4 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j int clip cur y to deblock MASKCUR ij clip POSCUR 0 int dither j ij i 4 if y h deblock MASKBOTTOM ij rv40 adaptive loop filter r rdsp Y 4 s linesize s linesize dither y to deblock MASKBOTTOM ij clip POSCUR 0 clip cur alpha beta beta Y 0 0 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 else clip left y to deblock MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 0 1 if j y h deblock MASKCUR i mb strong POSCUR mb strong POSTOP rv40 adaptive loop filter r rdsp Y s linesize dither clip cur mvmasks POSTOPMASKTOP i clip POSTOP 0 alpha beta beta Y 0 1 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 1 1 for k 0 k 2 k for j 0 j 2 j C s current picture ptr f data k 1 mb x 8 row 8 j 4 s uvlinesize for i 0 i 2 i C 4 int ij i j 2 int clip cur c to deblock k MASKCUR ij clip POSCUR 0 if c h deblock k MASKCUR ij 2 int clip bot c to deblock k MASKCUR ij 2 clip POSCUR 0 rv40 adaptive loop filter r rdsp C 4 s uvlinesize s uvlinesize i 8 clip bot clip cur alpha beta beta C 1 0 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 else clip left c to deblock k MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 0 1 if j c h deblock k MASKCUR ij mb strong POSCUR mb strong POSTOP int clip top uvcbp POSTOP k MASKCUR ij 2 clip POSTOP 0 rv40 adaptive loop filter r rdsp C s uvlinesize i 8 clip cur clip top alpha beta beta C 1 1 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 1 1 void vp9 xform quant dc MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 vp9 fdct32x32 1 src diff coeff diff stride vp9 quantize dc 32x32 coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 16 X16 vp9 fdct16x16 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 8 X8 vp9 fdct8x8 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break default assert 0 break void vp9 dec build inter predictors sb MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane 0 plane MAXMBPLANE plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x dec build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else dec build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static double var eq const Variable Stat Data vardata Oid operator Datum constval bool constisnull bool varonleft double selec bool isdefault Oid opfuncoid if constisnull return 0 0 if vardata isunique vardata rel vardata rel tuples 1 0 return 1 0 vardata rel tuples if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opfuncoid get opcode operator Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers bool match false int i stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDMCV Invalid Oid NULL values nvalues numbers nnumbers Fmgr Info eqproc fmgr info opfuncoid eqproc for i 0 i nvalues i if varonleft match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values i constval else match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID constval values i if match break else values NULL numbers NULL i nvalues nnumbers 0 if match selec numbers i else double sumcommon 0 0 double otherdistinct for i 0 i nnumbers i sumcommon numbers i selec 1 0 sumcommon stats stanullfrac CLAMPPROBABILITY selec otherdistinct get variable numdistinct vardata isdefault nnumbers if otherdistinct 1 selec otherdistinct if nnumbers 0 selec numbers nnumbers 1 selec numbers nnumbers 1 free attstatsslot vardata atttype values nvalues numbers nnumbers else selec 1 0 get variable numdistinct vardata isdefault CLAMPPROBABILITY selec return selec int ff h263 decode mb Mpeg Enc Context s int16 t block 6 64 int cbpc cbpy i cbp pred x pred y mx my dquant int16 t mot val const int xy s mb x s mb y s mb stride int cbpb 0 pb mv count 0 assert s h263 pred if s pict type AVPICTURETYPEP do if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped s obmc s loop filter goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc damaged at d d n s mb x s mb y return 1 while cbpc 20 s dsp clear blocks s block 0 dquant cbpc 8 s mb intra cbpc 4 0 if s mb intra goto intra if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s s mv dir MVDIRFORWARD if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 0 0 mx s mv 0 0 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 s mv type MVTYPE 8 X8 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my else if s pict type AVPICTURETYPEB int mb type const int stride s b8 stride int16 t mot val0 s current picture motion val 0 2 s mb x s mb y stride int16 t mot val1 s current picture motion val 1 2 s mb x s mb y stride mot val0 0 mot val0 2 mot val0 0 2 stride mot val0 2 2 stride mot val0 1 mot val0 3 mot val0 1 2 stride mot val0 3 2 stride mot val1 0 mot val1 2 mot val1 0 2 stride mot val1 2 2 stride mot val1 1 mot val1 3 mot val1 1 2 stride mot val1 3 2 stride 0 do mb type get vlc2 s gb h263 mbtype b vlc table H263 MBTYPEBVLCBITS 2 if mb type 0 av log s avctx AVLOGERROR b mb type damaged at d d n s mb x s mb y return 1 mb type h263 mb type b map mb type while mb type s mb intra ISINTRA mb type if HASCBP mb type s dsp clear blocks s block 0 cbpc get vlc2 s gb cbpc b vlc table CBPCBVLCBITS 1 if s mb intra dquant ISQUANT mb type goto intra cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERROR b cbpy damaged at d d n s mb x s mb y return 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 else cbp 0 assert s mb intra if ISQUANT mb type h263 decode dquant s if ISDIRECT mb type s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT mb type ff mpeg4 set direct mv s 0 0 else s mv dir 0 s mv type MVTYPE 16 X16 if USESLIST mb type 0 int16 t mot val ff h263 pred motion s 0 0 mx my s mv dir MVDIRFORWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 0 0 0 mx s mv 0 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my if USESLIST mb type 1 int16 t mot val ff h263 pred motion s 0 1 mx my s mv dir MVDIRBACKWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 1 0 0 mx s mv 1 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my s current picture mb type xy mb type else do cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERRORI cbpc damaged at d d n s mb x s mb y return 1 while cbpc 8 s dsp clear blocks s block 0 dquant cbpc 4 s mb intra 1 intra s current picture mb type xy MBTYPEINTRA if s h263 aic s ac pred get bits1 s gb if s ac pred s current picture mb type xy MBTYPEINTRAMBTYPEACPRED s h263 aic dir get bits1 s gb else s ac pred 0 if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy damaged at d d n s mb x s mb y return 1 cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s pb mv count s pb frame while pb mv count ff h263 decode motion s 0 1 ff h263 decode motion s 0 1 for i 0 i 6 i if h263 decode block s block i i cbp 32 0 return 1 cbp cbp if s pb frame h263 skip b part s cbpb 0 return 1 if s obmc s mb intra if s pict type AVPICTURETYPEP s mb x 1 s mb width s mb num left 1 preview obmc s end int v show bits s gb 16 if get bits left s gb 16 v 16 get bits left s gb if v 0 return SLICEEND return static int vcr1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size VC R1 Context const a avctx priv data AV Frame picture data AV Frame const p a picture const uint8 t bytestream buf int i x y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 for i 0 i 16 i a delta i bytestream bytestream for y 0 y avctx height y int offset uint8 t luma a picture data 0 y a picture linesize 0 if y 3 0 uint8 t cb a picture data 1 y 2 a picture linesize 1 uint8 t cr a picture data 2 y 2 a picture linesize 2 for i 0 i 4 i a offset i bytestream offset a offset 0 a delta bytestream 2 0x F for x 0 x avctx width x 4 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 0 0x F luma 3 offset a delta bytestream 0 4 luma 4 cb bytestream 3 cr bytestream 1 bytestream 4 else offset a offset y 3 a delta bytestream 2 0x F for x 0 x avctx width x 8 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 3 0x F luma 3 offset a delta bytestream 3 4 luma 4 offset a delta bytestream 0 0x F luma 5 offset a delta bytestream 0 4 luma 6 offset a delta bytestream 1 0x F luma 7 offset a delta bytestream 1 4 luma 8 bytestream 4 picture a picture got frame 1 return buf size static void fill picture parameters struct dxva context ctx const H264 Context h DXVA Pic Params H264 pp const Picture current picture h cur pic ptr int i j memset pp 0 sizeof pp fill picture entry pp Curr Pic ff dxva2 get surface index ctx current picture h picture structure PICTBOTTOMFIELD pp Used For Reference Flags 0 pp Non Existing Frame Flags 0 for i 0 j 0 i FFARRAYELEMS pp Ref Frame List i const Picture r if j h short ref count r h short ref j else r NULL while r j h short ref count 16 r h long ref j h short ref count if r fill picture entry pp Ref Frame List i ff dxva2 get surface index ctx r r long ref 0 if r reference PICTTOPFIELD r field poc 0 INTMAX pp Field Order Cnt List i 0 r field poc 0 if r reference PICTBOTTOMFIELD r field poc 1 INTMAX pp Field Order Cnt List i 1 r field poc 1 pp Frame Num List i r long ref r pic id r frame num if r reference PICTTOPFIELD pp Used For Reference Flags 1 2 i 0 if r reference PICTBOTTOMFIELD pp Used For Reference Flags 1 2 i 1 else pp Ref Frame List i b Pic Entry 0xff pp Field Order Cnt List i 0 0 pp Field Order Cnt List i 1 0 pp Frame Num List i 0 pp w Frame Width In Mbs Minus1 h mb width 1 pp w Frame Height In Mbs Minus1 h mb height 1 pp num ref frames h sps ref frame count pp w Bit Fields h picture structure PICTFRAME 0 h sps mb aff h picture structure PICTFRAME 1 h sps residual color transform flag 2 0 3 h sps chroma format idc 4 h nal ref idc 0 6 h pps constrained intra pred 7 h pps weighted pred 8 h pps weighted bipred idc 9 1 11 h sps frame mbs only flag 12 h pps transform 8x8 mode 13 h sps level idc 31 14 1 15 pp bit depth luma minus8 h sps bit depth luma 8 pp bit depth chroma minus8 h sps bit depth chroma 8 if ctx workaround FFDXV A2 WORKAROUNDSCALINGLISTZIGZAG pp Reserved16 Bits 0 else pp Reserved16 Bits 3 pp Status Report Feedback Number 1 ctx report id pp Curr Field Order Cnt 0 0 if h picture structure PICTTOPFIELD current picture field poc 0 INTMAX pp Curr Field Order Cnt 0 current picture field poc 0 pp Curr Field Order Cnt 1 0 if h picture structure PICTBOTTOMFIELD current picture field poc 1 INTMAX pp Curr Field Order Cnt 1 current picture field poc 1 pp pic init qs minus26 h pps init qs 26 pp chroma qp index offset h pps chroma qp index offset 0 pp second chroma qp index offset h pps chroma qp index offset 1 pp Continuation Flag 1 pp pic init qp minus26 h pps init qp 26 pp num ref idx l0 active minus1 h pps ref count 0 1 pp num ref idx l1 active minus1 h pps ref count 1 1 pp Reserved8 Bits A 0 pp frame num h frame num pp log2 max frame num minus4 h sps log2 max frame num 4 pp pic order cnt type h sps poc type if h sps poc type 0 pp log2 max pic order cnt lsb minus4 h sps log2 max poc lsb 4 else if h sps poc type 1 pp delta pic order always zero flag h sps delta pic order always zero flag pp direct 8x8 inference flag h sps direct 8x8 inference flag pp entropy coding mode flag h pps cabac pp pic order present flag h pps pic order present pp num slice groups minus1 h pps slice group count 1 pp slice group map type h pps mb slice group map type pp deblocking filter control present flag h pps deblocking filter parameters present pp redundant pic cnt present flag h pps redundant pic cnt present pp Reserved8 Bits B 0 pp slice group change rate minus1 0 static inline int direct search Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me int P 10 2 const int mot stride s mb stride const int mot xy mb y mot stride mb x const int shift 1 s quarter sample int dmin i const int time pp s pp time const int time pb s pb time int mx my xmin xmax ymin ymax int16 t mv table 2 s b direct mv table c current mv penalty c mv penalty 1 MAXMV ymin xmin 32 shift ymax xmax 31 shift if IS 8 X8 s next picture mb type mot xy s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 for i 0 i 4 i int index s block index i int min max c co located mv i 0 s next picture motion val 0 index 0 c co located mv i 1 s next picture motion val 0 index 1 c direct basis mv i 0 c co located mv i 0 time pb time pp i 1 shift 3 c direct basis mv i 1 c co located mv i 1 time pb time pp i 1 shift 3 max FFMAX c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift min FFMIN c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift max 16 mb x 1 min 16 mb x 1 xmax FFMIN xmax s width max xmin FFMAX xmin 16 min max FFMAX c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift min FFMIN c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift max 16 mb y 1 min 16 mb y 1 ymax FFMIN ymax s height max ymin FFMAX ymin 16 min if s mv type MVTYPE 16 X16 break assert xmax 15 ymax 15 xmin 16 ymin 16 if xmax 0 xmin 0 ymax 0 ymin 0 s b direct mv table mot xy 0 0 s b direct mv table mot xy 1 0 return 256 256 256 64 c xmin xmin c ymin ymin c xmax xmax c ymax ymax c flags FLAGDIRECT c sub flags FLAGDIRECT c pred x 0 c pred y 0 PLEFT 0 av clip mv table mot xy 1 0 xmin shift xmax shift PLEFT 1 av clip mv table mot xy 1 1 ymin shift ymax shift if s first slice line PTOP 0 av clip mv table mot xy mot stride 0 xmin shift xmax shift PTOP 1 av clip mv table mot xy mot stride 1 ymin shift ymax shift PTOPRIGHT 0 av clip mv table mot xy mot stride 1 0 xmin shift xmax shift PTOPRIGHT 1 av clip mv table mot xy mot stride 1 1 ymin shift ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 dmin ff epzs motion search s mx my P 0 0 mv table 1 16 shift 0 16 if c sub flags FLAGQPEL dmin qpel motion search s mx my dmin 0 0 0 16 else dmin hpel motion search s mx my dmin 0 0 0 16 if c avctx me sub cmp c avctx mb cmp c skip dmin get mb score s mx my 0 0 0 16 1 get limits s 16 mb x 16 mb y mv table mot xy 0 mx mv table mot xy 1 my c flags FLAGDIRECT c sub flags FLAGDIRECT return dmin static int jpc enc encodemainbody jpc enc t enc int tileno int tilex int tiley int i jpc sot t sot jpc enc tcmpt t comp jpc enc tcmpt t endcomps jpc enc band t band jpc enc band t endbands jpc enc rlvl t lvl int rlvlno jpc qcc t qcc jpc cod t cod int adjust int j int absbandno long numbytes long tilehdrlen long tilelen jpc enc tile t tile jpc enc cp t cp double rho int lyrno int cmptno int samestepsizes jpc enc ccp t ccps jpc enc tccp t tccp int bandno uint fast32 t x uint fast32 t y int mingbits int actualnumbps jpc fix t mxmag jpc fix t mag int numgbits cp enc cp numbytes 0 for tileno 0 tileno JASCAST int cp numtiles tileno tilex tileno cp numhtiles tiley tileno cp numhtiles if enc curtile jpc enc tile create enc cp enc image tileno abort tile enc curtile if jas getdbglevel 10 jpc enc dump enc endcomps tile tcmpts tile numtcmpts for cmptno 0 comp tile tcmpts cmptno tile numtcmpts cmptno comp if cp ccps cmptno sgnd adjust 1 cp ccps cmptno prec 1 for i 0 i jas matrix numrows comp data i for j 0 j jas matrix numcols comp data j jas matrix getref comp data i j adjust if tile intmode endcomps tile tcmpts tile numtcmpts for comp tile tcmpts comp endcomps comp jas matrix asl comp data JPCFIXFRACBITS switch tile mctid case JPCMCTRCT assert jas image numcmpts enc image 3 jpc rct tile tcmpts 0 data tile tcmpts 1 data tile tcmpts 2 data break case JPCMCTICT assert jas image numcmpts enc image 3 jpc ict tile tcmpts 0 data tile tcmpts 1 data tile tcmpts 2 data break default break for i 0 i jas image numcmpts enc image i comp tile tcmpts i jpc tsfb analyze comp tsfb comp data endcomps tile tcmpts tile numtcmpts for cmptno 0 comp tile tcmpts comp endcomps cmptno comp mingbits 0 absbandno 0 memset comp stepsizes 0 sizeof comp stepsizes for rlvlno 0 lvl comp rlvls rlvlno comp numrlvls rlvlno lvl if lvl bands absbandno rlvlno 3 1 continue endbands lvl bands lvl numbands for band lvl bands band endbands band if band data absbandno continue actualnumbps 0 mxmag 0 for y 0 y JASCAST uint fast32 t jas matrix numrows band data y for x 0 x JASCAST uint fast32 t jas matrix numcols band data x mag JASABS jas matrix get band data y x if mag mxmag mxmag mag if tile intmode actualnumbps jpc firstone mxmag 1 else actualnumbps jpc firstone mxmag 1 JPCFIXFRACBITS numgbits actualnumbps cp ccps cmptno prec 1 band analgain mingbits numgbits if tile intmode band absstepsize jpc fix div jpc inttofix 1 band analgain 1 band synweight else band absstepsize jpc inttofix 1 band stepsize jpc abstorelstepsize band absstepsize cp ccps cmptno prec band analgain band numbps cp tccp numgbits JPCQCXGETEXPN band stepsize 1 if tile intmode band data jpc quantize band data band absstepsize comp stepsizes absbandno band stepsize absbandno assert JPCFIXFRACBITSJPCNUMEXTRABITS if tile intmode jas matrix divpow2 comp data JPCFIXFRACBITSJPCNUMEXTRABITS else jas matrix asl comp data JPCNUMEXTRABITS jas eprintf error too few guard bits need at least d n mingbits return 1 static int msrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Msrle Context s avctx priv data int istride FFALIGN avctx width avctx bits per coded sample 32 8 int ret s buf buf s size buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE if avctx height istride avpkt size int linesize avctx width avctx bits per coded sample 8 uint8 t ptr s frame data 0 uint8 t buf avpkt data avctx height 1 istride int i j for i 0 i avctx height i if avctx bits per coded sample 4 for j 0 j avctx width 1 j 2 ptr j 0 buf j 1 4 ptr j 1 buf j 1 0x F if avctx width 1 ptr j 0 buf j 1 4 else memcpy ptr buf linesize buf istride ptr s frame linesize 0 else bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame avctx bits per coded sample s gb if ret av frame ref data s frame 0 return ret got frame 1 return buf size static int dissect ipmi trace tvbuff t tvb packet info pinfo proto tree tree void data U guint block type chn num data type tmp tvbuff t next tvb if tvb captured length tvb 11 call data dissector tvb pinfo tree return tvb captured length tvb tmp tvb get guint8 tvb 0 block type tmp 4 3 chn num tmp 0x F data type tvb get guint8 tvb 7 col add fstr pinfo cinfo COLDEFSRC Channel d chn num col add str pinfo cinfo COLPROTOCOL val to str data type str protocol types Reserved 0x 02x col clear pinfo cinfo COLINFO if block type HP M2 TRACEPACKETDATA col set str pinfo cinfo COLINFO Trace Packet Data else if block type HP M2 CHNSTATENOTIFY col set str pinfo cinfo COLINFO Channel State Change Notification else if block type HP M2 EMBEDASCIIMSG char str 257 guint str len tvb get guint8 tvb 10 if str len tvb memcpy tvb str 11 str len str str len 0 col add str pinfo cinfo COLINFO str else col set str pinfo cinfo COLINFO Reserved if tree proto item ti proto tree trace tree proto tree stamp tree nstime t timestamp ti proto tree add item tree proto ipmi trace tvb 0 1 ENCNA trace tree proto item add subtree ti ett ipmi trace proto tree add bitmask trace tree tvb 0 hf trace block type ett trace block type bits trace block type ENCLITTLEENDIAN timestamp secs tvb get letohl tvb 1 timestamp nsecs int tvb get letohs tvb 5 1000000 ti proto tree add time trace tree hf trace timestamp tvb 1 6 timestamp stamp tree proto item add subtree ti ett trace timestamp proto tree add item stamp tree hf trace timestamp sec tvb 1 4 ENCLITTLEENDIAN proto tree add item stamp tree hf trace timestamp msec tvb 5 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data type tvb 7 1 ENCLITTLEENDIAN if data type IPMIPROTOIPMB 1 0 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits ipmb protocol data ENCLITTLEENDIAN else if data type IPMIPROTOKCS data type IPMIPROTOSMIC data type IPMIPROTOBT 10 data type IPMIPROTOBT 15 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits host protocol data ENCLITTLEENDIAN else proto tree add item trace tree hf trace protocol data tvb 8 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data len tvb 10 1 ENCLITTLEENDIAN next tvb tvb new subset remaining tvb 11 if block type HP M2 TRACEPACKETDATA ipmi dissect arg t arg arg context IPMIENONE arg channel chn num arg flags tvb get guint8 tvb 8 if dissector try uint new proto dissector table data type next tvb pinfo tree TRUE arg call data dissector next tvb pinfo tree else if block type HP M2 CHNSTATENOTIFY data type IPMIPROTOIPMB 1 0 dissect ipmb state notify next tvb tree else call data dissector next tvb pinfo tree return tvb captured length tvb void vp9 swap mi and prev mi V P9 COMMON cm const int tmp cm mi idx cm mi idx cm prev mi idx cm prev mi idx tmp cm mip cm mip array cm mi idx cm prev mip cm mip array cm prev mi idx cm mi grid base cm mi grid base array cm mi idx cm prev mi grid base cm mi grid base array cm prev mi idx cm mi cm mip cm mi stride 1 cm prev mi cm prev mip cm mi stride 1 cm mi grid visible cm mi grid base cm mi stride 1 cm prev mi grid visible cm prev mi grid base cm mi stride 1 void dtls1 stop timer SSL s memset s d1 timeout 0 sizeof s d1 timeout memset s d1 next timeout 0 sizeof s d1 next timeout s d1 timeout duration 1 BIO ctrl SSL get rbio s BIOCTRLDGRAMSETNEXTTIMEOUT 0 s d1 next timeout dtls1 clear sent buffer s void xps parse glyphs xps document doc const fz matrix ctm char base uri xps resource dict fz xml root fz xml node char fill uri char opacity mask uri char bidi level att char fill att char font size att char font uri att char origin x att char origin y att char is sideways att char indices att char unicode att char style att char transform att char clip att char opacity att char opacity mask att char navigate uri att fz xml transform tag NULL fz xml clip tag NULL fz xml fill tag NULL fz xml opacity mask tag NULL char fill opacity att NULL xps part part fz font font char partname 1024 char fakename 1024 char subfont float font size 10 int subfontid 0 int is sideways 0 int bidi level 0 fz text text fz rect area fz matrix local ctm ctm bidi level att fz xml att root Bidi Level fill att fz xml att root Fill font size att fz xml att root Font Rendering Em Size font uri att fz xml att root Font Uri origin x att fz xml att root Origin X origin y att fz xml att root Origin Y is sideways att fz xml att root Is Sideways indices att fz xml att root Indices unicode att fz xml att root Unicode String style att fz xml att root Style Simulations transform att fz xml att root Render Transform clip att fz xml att root Clip opacity att fz xml att root Opacity opacity mask att fz xml att root Opacity Mask navigate uri att fz xml att root Fixed Page Navigate Uri for node fz xml down root node node fz xml next node if strcmp fz xml tag node Glyphs Render Transform transform tag fz xml down node if strcmp fz xml tag node Glyphs Opacity Mask opacity mask tag fz xml down node if strcmp fz xml tag node Glyphs Clip clip tag fz xml down node if strcmp fz xml tag node Glyphs Fill fill tag fz xml down node fill uri base uri opacity mask uri base uri xps resolve resource reference doc dict transform att transform tag NULL xps resolve resource reference doc dict clip att clip tag NULL xps resolve resource reference doc dict fill att fill tag fill uri xps resolve resource reference doc dict opacity mask att opacity mask tag opacity mask uri if font size att font uri att origin x att origin y att fz warn doc ctx missing attributes in glyphs element return if indices att unicode att return if is sideways att is sideways strcmp is sideways att true if bidi level att bidi level atoi bidi level att xps resolve url partname base uri font uri att sizeof partname subfont strrchr partname if subfont subfontid atoi subfont 1 subfont 0 fz strlcpy fakename partname sizeof fakename if style att if strcmp style att Bold Simulation fz strlcat fakename Bold sizeof fakename else if strcmp style att Italic Simulation fz strlcat fakename Italic sizeof fakename else if strcmp style att Bold Italic Simulation fz strlcat fakename Bold Italic sizeof fakename font xps lookup font doc fakename if font fz try doc ctx part xps read part doc partname fz catch doc ctx fz rethrow if doc ctx FZERRORTRYLATER fz warn doc ctx cannot find font resource part s partname return if strstr part name odttf xps deobfuscate font resource doc part if strstr part name ODTTF xps deobfuscate font resource doc part fz try doc ctx fz buffer buf fz new buffer from data doc ctx part data part size font fz new font from buffer doc ctx NULL buf subfontid 1 fz drop buffer doc ctx buf fz catch doc ctx fz rethrow if doc ctx FZERRORTRYLATER fz warn doc ctx cannot load font resource s partname xps free part doc part return if style att font ft bold strstr style att Bold font ft italic strstr style att Italic xps select best font encoding doc font xps insert font doc fakename font fz free doc ctx part name fz free doc ctx part if transform att transform tag fz matrix transform if transform att xps parse render transform doc transform att transform if transform tag xps parse matrix transform doc transform tag transform fz concat local ctm transform local ctm if clip att clip tag xps clip doc local ctm dict clip att clip tag font size fz atof font size att text xps parse glyphs imp doc local ctm font font size fz atof origin x att fz atof origin y att is sideways bidi level indices att unicode att fz bound text doc ctx text NULL local ctm area if navigate uri att xps add link doc area base uri navigate uri att xps begin opacity doc local ctm area opacity mask uri dict opacity att opacity mask tag if fill tag strcmp fz xml tag fill tag Solid Color Brush fill opacity att fz xml att fill tag Opacity fill att fz xml att fill tag Color fill tag NULL if fill att float samples 32 fz colorspace colorspace xps parse color doc base uri fill att colorspace samples if fill opacity att samples 0 fz atof fill opacity att xps set color doc colorspace samples fz fill text doc dev text local ctm doc colorspace doc color doc alpha if fill tag fz clip text doc dev text local ctm 0 xps parse brush doc local ctm area fill uri dict fill tag fz pop clip doc dev xps end opacity doc opacity mask uri dict opacity att opacity mask tag fz free text doc ctx text if clip att clip tag fz pop clip doc dev fz drop font doc ctx font static guint32 dissect fullpacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint16 dcallno guint32 ts guint8 type guint8 csub guint32 codec proto tree packet type tree NULL iax call data iax call iax packet data iax packet gboolean reversed gboolean rtp marker dcallno tvb get ntohs tvb offset 0x7 FFF ts tvb get ntohl tvb offset 2 type tvb get guint8 tvb offset 8 csub tvb get guint8 tvb offset 9 iax2 info ftype type iax2 info csub csub iax2 info scallno scallno iax2 info dcallno dcallno iax packet iax packet data p get proto data wmem file scope pinfo proto iax2 0 if iax packet if type ASTFRAMEIAX csub IAXCOMMANDNEW iax call iax new call pinfo scallno reversed FALSE else iax call iax lookup call pinfo scallno dcallno reversed iax packet iax new packet data iax call reversed p add proto data wmem file scope pinfo proto iax2 0 iax packet else iax call iax packet call data reversed iax packet reversed iax2 populate pinfo from packet data pinfo iax packet if iax2 tree proto item packet type base proto tree add item iax2 tree hf iax2 dcallno tvb offset 2 ENCBIGENDIAN proto tree add item iax2 tree hf iax2 retransmission tvb offset 2 ENCBIGENDIAN if iax call proto item item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax call forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add uint iax2 tree hf iax2 ts tvb offset 2 4 ts iax2 add ts fields pinfo iax2 tree iax packet guint16 ts proto tree add item iax2 tree hf iax2 oseqno tvb offset 6 1 ENCBIGENDIAN proto tree add item iax2 tree hf iax2 iseqno tvb offset 7 1 ENCBIGENDIAN packet type base proto tree add uint iax2 tree hf iax2 type tvb offset 8 1 type packet type tree proto item add subtree packet type base ett iax2 type else iax2 add ts fields pinfo iax2 tree iax packet guint16 ts col add fstr pinfo cinfo COLINFO s source call d timestamp ums val to str ext type iax frame types ext Unknown 0x 02x scallno ts iax2 info message Name val to str ext type iax frame types ext Unknown 0x 02x switch type case ASTFRAMEIAX offset dissect iax2 command tvb offset 9 pinfo packet type tree iax packet iax2 info message Name val to str ext csub iax iax subclasses ext unknown 0x 02x if csub NUMTAPIAXVOIPSTATES iax2 info call State tap iax voip state csub break case ASTFRAMEDTMFBEGIN case ASTFRAMEDTMFEND proto tree add item packet type tree hf iax2 dtmf csub tvb offset 9 1 ENCASCIIENCNA offset 10 col append fstr pinfo cinfo COLINFO digit c csub break case ASTFRAMECONTROL proto tree add uint packet type tree hf iax2 cmd csub tvb offset 9 1 csub offset 10 col append fstr pinfo cinfo COLINFO s val to str ext csub iax cmd subclasses ext unknown 0x 02x iax2 info message Name val to str ext csub iax cmd subclasses ext unknown 0x 02x if csub NUMTAPCMDVOIPSTATES iax2 info call State tap cmd voip state csub break case ASTFRAMEVOICE iax packet codec codec uncompress subclass csub if packet type tree proto item item proto tree add item packet type tree hf iax2 voice csub tvb offset 9 1 ENCBIGENDIAN item proto tree add uint packet type tree hf iax2 voice codec tvb offset 9 1 codec PROTOITEMSETGENERATED item offset 10 if iax call if reversed iax call dst codec codec else iax call src codec codec dissect payload tvb offset pinfo iax2 tree main tree ts FALSE iax packet break case ASTFRAMEVIDEO rtp marker csub 0x40 TRUEFALSE iax packet codec codec uncompress subclass guint8 csub 40 if packet type tree proto item item proto tree add item packet type tree hf iax2 video csub tvb offset 9 1 ENCBIGENDIAN proto tree add item packet type tree hf iax2 marker tvb offset 9 1 ENCBIGENDIAN item proto tree add uint packet type tree hf iax2 video codec tvb offset 9 1 codec PROTOITEMSETGENERATED item offset 10 if iax call iax packet first time if reversed iax call dst vformat codec else iax call src vformat codec if rtp marker col append str pinfo cinfo COLINFO Mark dissect payload tvb offset pinfo iax2 tree main tree ts TRUE iax packet break case ASTFRAMEMODEM proto tree add item packet type tree hf iax2 modem csub tvb offset 9 1 ENCBIGENDIAN offset 10 col append fstr pinfo cinfo COLINFO s val to str csub iax modem subclasses unknown 0x 02x break case ASTFRAMETEXT proto tree add item packet type tree hf iax2 text csub tvb offset 9 1 ENCBIGENDIAN offset 10 int textlen tvb captured length remaining tvb offset if textlen 0 proto tree add item packet type tree hf iax2 text text tvb offset textlen ENCUTF 8 ENCNA offset textlen break case ASTFRAMEHTML proto tree add item packet type tree hf iax2 html csub tvb offset 9 1 ENCBIGENDIAN offset 10 if csub 0x01 int urllen tvb captured length remaining tvb offset if urllen 0 proto item pi proto tree add item packet type tree hf iax2 html url tvb offset urllen ENCUTF 8 ENCNAPROTOITEMSETURL pi offset urllen break case ASTFRAMECNG default proto tree add uint packet type tree hf iax2 csub tvb offset 9 1 csub offset 10 col append fstr pinfo cinfo COLINFO subclass d csub break iax packet first time FALSE return offset static int shorten decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Shorten Context s avctx priv data int i input buf size 0 int ret if s max framesize 0 void tmp ptr s max framesize 1024 tmp ptr av fast realloc s bitstream s allocated bitstream size s max framesize if tmp ptr av log avctx AVLOGERROR error allocating bitstream buffer n return AVERRORENOMEM s bitstream tmp ptr if 1 s max framesize buf size FFMIN buf size s max framesize s bitstream size input buf size buf size if s bitstream index s bitstream size buf size s allocated bitstream size memmove s bitstream s bitstream s bitstream index s bitstream size s bitstream index 0 if buf memcpy s bitstream s bitstream index s bitstream size buf buf size buf s bitstream s bitstream index buf size s bitstream size s bitstream size buf size if buf size s max framesize avpkt data got frame ptr 0 return input buf size init get bits s gb buf buf size 8 skip bits s gb s bitindex if s got header if ret read header s 0 return ret got frame ptr 0 goto finish frame if s got quit command got frame ptr 0 return avpkt size s cur chan 0 while s cur chan s channels unsigned cmd int len if get bits left s gb 3 FNSIZE got frame ptr 0 break cmd get ur golomb shorten s gb FNSIZE if cmd FNVERBATIM av log avctx AVLOGERROR unknown shorten function d n cmd got frame ptr 0 break if is audio command cmd switch cmd case FNVERBATIM len get ur golomb shorten s gb VERBATIMCKSIZESIZE while len get ur golomb shorten s gb VERBATIMBYTESIZE break case FNBITSHIFT s bitshift get ur golomb shorten s gb BITSHIFTSIZE break case FNBLOCKSIZE unsigned blocksize get uint s av log2 s blocksize if blocksize s blocksize av log avctx AVLOGERROR Increasing block size is not supported n return AVERRORPATCHWELCOME if blocksize blocksize MAXBLOCKSIZE av log avctx AVLOGERROR invalid or unsupported block size d n blocksize return AVERROREINVAL s blocksize blocksize break case FNQUIT s got quit command 1 break if cmd FNBLOCKSIZE cmd FNQUIT got frame ptr 0 break else int residual size 0 int channel s cur chan int32 t coffset if cmd FNZERO residual size get ur golomb shorten s gb ENERGYSIZE if s version 0 residual size if s nmean 0 coffset s offset channel 0 else int32 t sum s version 2 0 s nmean 2 for i 0 i s nmean i sum s offset channel i coffset sum s nmean if s version 2 coffset FFMIN 1 s bitshift if cmd FNZERO for i 0 i s blocksize i s decoded channel i 0 else if ret decode subframe lpc s cmd channel residual size coffset 0 return ret if s nmean 0 int32 t sum s version 2 0 s blocksize 2 for i 0 i s blocksize i sum s decoded channel i for i 1 i s nmean i s offset channel i 1 s offset channel i if s version 2 s offset channel s nmean 1 sum s blocksize else s offset channel s nmean 1 sum s blocksize s bitshift for i s nwrap i 0 i s decoded channel i s decoded channel i s blocksize fix bitshift s s decoded channel s cur chan if s cur chan s channels frame nb samples s blocksize if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret output buffer int16 t frame extended data s channels s blocksize s decoded got frame ptr 1 if s cur chan s channels got frame ptr 0 finish frame s bitindex get bits count s gb 8 get bits count s gb 8 i get bits count s gb 8 if i buf size av log s avctx AVLOGERROR overread d n i buf size s bitstream size 0 s bitstream index 0 return AVERRORINVALIDDATA if s bitstream size s bitstream index i s bitstream size i return input buf size else return i static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Eight Bps Context const c avctx priv data const unsigned char encoded buf unsigned char pixptr pixptr end unsigned int height avctx height unsigned int dlen p row const unsigned char lp dp unsigned char count unsigned int px inc unsigned int planes c planes unsigned char planemap c planemap int ret if c pic data 0 avctx release buffer avctx c pic c pic reference 0 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret dp encoded planes height 1 if planes 4 planes px inc planes avctx pix fmt AVPIXFMTRG B32 for p 0 p planes p lp encoded p height 1 for row 0 row height row pixptr c pic data 0 row c pic linesize 0 planemap p pixptr end pixptr c pic linesize 0 dlen av be2ne16 const unsigned short lp row 2 while dlen 0 if dp 1 buf buf size return AVERRORINVALIDDATA if count dp 127 count dlen count 1 if pixptr count px inc pixptr end break if dp count buf buf size return AVERRORINVALIDDATA while count pixptr dp pixptr px inc else count 257 count if pixptr count px inc pixptr end break while count pixptr dp pixptr px inc dp dlen 2 if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static int vc1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size n slices 0 i ret V C1 Context v avctx priv data Mpeg Enc Context s v s AV Frame pict data uint8 t buf2 NULL const uint8 t buf start buf int mb height n slices1 struct uint8 t buf Get Bit Context gb int mby start slices NULL tmp if buf size 0 buf size 4 AVR B32 buf V C1 CODEENDOFSEQ if s low delay 0 s next picture ptr if ret av frame ref pict s next picture ptr f 0 return ret s next picture ptr NULL got frame 1 return 0 if s avctx codec capabilities CODECCAPHWACCELVDPAU if v profile PROFILEADVANCED avctx pix fmt AVPIXFMTVDPAUWM V3 else avctx pix fmt AVPIXFMTVDPAUV C1 if avctx codec id AVCODECIDV C1 avctx codec id AVCODECIDV C1 IMAGE int buf size2 0 buf2 av mallocz buf size FFINPUTBUFFERPADDINGSIZE if ISMARKERAVR B32 buf const uint8 t start end next int size next buf for start buf end buf buf size next end start next next find next marker start 4 end size next start 4 if size 0 continue switch AVR B32 start case V C1 CODEFRAME if avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU buf start start buf size2 vc1 unescape buffer start 4 size buf2 break case V C1 CODEFIELD int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices break case V C1 CODEENTRYPOINT buf size2 vc1 unescape buffer start 4 size buf2 init get bits s gb buf2 buf size2 8 ff vc1 decode entry point avctx v s gb break case V C1 CODESLICE int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start get bits slices n slices gb 9 n slices break else if v interlace buf 0 0x C0 0x C0 const uint8 t divider int buf size3 divider find next marker buf buf buf size if divider buf buf size AVR B32 divider V C1 CODEFIELD av log avctx AVLOGERROR Error in WV C1 interlaced frame n goto err else tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer divider 4 buf buf size divider 4 slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices buf size2 vc1 unescape buffer buf divider buf buf2 else buf size2 vc1 unescape buffer buf buf size buf2 init get bits s gb buf2 buf size2 8 else init get bits s gb buf buf size 8 if v res sprite v new sprite get bits1 s gb v two sprites get bits1 s gb if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE if v new sprite avctx width avctx coded width v sprite width avctx height avctx coded height v sprite height else goto image if s context initialized s width avctx coded width s height avctx coded height ff vc1 decode end avctx if s context initialized if ff msmpeg4 decode init avctx 0 ff vc1 decode init alloc tables v 0 goto err s low delay avctx has b frames v res sprite if v profile PROFILEADVANCED s h edge pos avctx coded width s v edge pos avctx coded height if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 goto err s current picture ptr s picture i v pic header flag 0 if v profile PROFILEADVANCED if ff vc1 parse frame header v s gb 1 goto err else if ff vc1 parse frame header adv v s gb 1 goto err if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE s pict type AVPICTURETYPEI av log v s avctx AVLOGERROR Sprite decoder expected I frame n goto err s current picture ptr f repeat pict 0 if v rff s current picture ptr f repeat pict 1 else if v rptfrm s current picture ptr f repeat pict v rptfrm 2 s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable goto err if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL goto end if s next p frame damaged if s pict type AVPICTURETYPEB goto end else s next p frame damaged 0 if ff MPV frame start s avctx 0 goto err s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if CONFIGV C1 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau vc1 decode picture s buf start buf buf size buf start else if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 goto err if avctx hwaccel decode slice avctx buf start buf buf size buf start 0 goto err if avctx hwaccel end frame avctx 0 goto err else ff mpeg er frame start s v bits buf size 8 v end mb x s mb width if v field mode uint8 t tmp 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 tmp 0 v mv f last 0 tmp 1 v mv f last 1 v mv f last 0 v mv f next 0 v mv f last 1 v mv f next 1 v mv f next 0 v mv f 0 v mv f next 1 v mv f 1 v mv f 0 tmp 0 v mv f 1 tmp 1 mb height s mb height v field mode for i 0 i n slices i if i 0 slices i 1 mby start mb height if v field mode 0 av log v s avctx AVLOGERROR Slice d starts beyond picture boundary d d n i slices i 1 mby start mb height continue v second field 1 v blocks off s mb width s mb height 1 v mb off s mb stride s mb height 1 else v second field 0 v blocks off 0 v mb off 0 if i v pic header flag 0 if v field mode i n slices1 2 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Field header damaged n continue else if get bits1 s gb v pic header flag 1 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Slice header damaged n continue s start mb y i 0 0 FFMAX 0 slices i 1 mby start mb height if v field mode v second field s end mb y i n slices mb height FFMIN mb height slices i mby start mb height else s end mb y i n slices1 1 mb height FFMIN mb height slices i mby start mb height ff vc1 decode blocks v if i n slices s gb slices i gb if v field mode v second field 0 if s pict type AVPICTURETYPEB memcpy v mv f base v mv f next base 2 s b8 stride s mb height 2 1 s mb stride s mb height 1 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 av dlog s avctx Consumed i i bits n get bits count s gb s gb size in bits ff er frame end s er ff MPV frame end s if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE image avctx width avctx coded width v output width avctx height avctx coded height v output height if avctx skip frame AVDISCARDNONREF goto end got frame 1 else if s pict type AVPICTURETYPEB s low delay if ret av frame ref pict s current picture ptr f 0 goto err ff print debug info s s current picture ptr else if s last picture ptr NULL if ret av frame ref pict s last picture ptr f 0 goto err ff print debug info s s last picture ptr if s last picture ptr s low delay got frame 1 end av free buf2 for i 0 i n slices i av free slices i buf av free slices return buf size err av free buf2 for i 0 i n slices i av free slices i buf av free slices return 1 int main int argc char argv const char globfile one two three NULL char tmpdir 32 struct passwd pw const char cwd int test int fail 0 int i struct test case struct ts if argc 1 command line test argv 1 return 0 cwd getcwd NULL 0 tmpnam tmpdir if mkdir tmpdir SIRWXU chdir tmpdir return 1 else int fd for i 0 globfile i i if fd creat globfile i SIRUSRSIWUSR 1 close fd return 1 if app register atfork register fork NULLNULL 0 printf Failed to register fork handler n return 1 for test 0 test case test retval 1 test if testit test case test fail pw getpwnam root if pw NULL ts retval 0 ts env NULL ts words root ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail ts retval 0 ts env pw pw dir ts words var root x ts flags 0 ts wordc 1 ts wordv 0 x ts ifs IFS if testit ts fail setenv HOME dummy home 1 ts retval 0 ts env NULL ts words foo ts flags 0 ts wordc 2 ts wordv 0 dummy home ts wordv 1 dummy home foo ts ifs IFS if testit ts fail pw getpwuid getuid if pw NULL unsetenv HOME ts retval 0 ts env NULL ts words ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail puts tests completed now cleaning up for i 0 globfile i i remove globfile i if cwd NULL cwd chdir cwd rmdir tmpdir printf tests failed d n fail return fail 0 static void encode sb rt V P9 COMP cpi const Tile Info const tile TOKENEXTRA tp int mi row int mi col int output enabled BLOCKSIZE bsize PCTREE pc tree V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const int bsl b width log2 bsize hbs 1 bsl 4 int ctx PARTITIONTYPE partition BLOCKSIZE subsize if mi row cm mi rows mi col cm mi cols return if bsize BLOCK 8 X8 const int idx str xd mi stride mi row mi col MODEINFO mi 8x8 cm mi idx str src mi ctx partition plane context xd mi row mi col bsize subsize mi 8x8 0 src mi mbmi sb type else ctx 0 subsize BLOCK 4 X4 partition partition lookup bsl subsize if output enabled bsize BLOCK 4 X4 cm counts partition ctx partition switch partition case PARTITIONNONE encode b rt cpi tile tp mi row mi col output enabled subsize pc tree none break case PARTITIONVERT encode b rt cpi tile tp mi row mi col output enabled subsize pc tree vertical 0 if mi col hbs cm mi cols bsize BLOCK 8 X8 encode b rt cpi tile tp mi row mi col hbs output enabled subsize pc tree vertical 1 break case PARTITIONHORZ encode b rt cpi tile tp mi row mi col output enabled subsize pc tree horizontal 0 if mi row hbs cm mi rows bsize BLOCK 8 X8 encode b rt cpi tile tp mi row hbs mi col output enabled subsize pc tree horizontal 1 break case PARTITIONSPLIT subsize get subsize bsize PARTITIONSPLIT encode sb rt cpi tile tp mi row mi col output enabled subsize pc tree split 0 encode sb rt cpi tile tp mi row mi col hbs output enabled subsize pc tree split 1 encode sb rt cpi tile tp mi row hbs mi col output enabled subsize pc tree split 2 encode sb rt cpi tile tp mi row hbs mi col hbs output enabled subsize pc tree split 3 break default assert Invalid partition type break if partition PARTITIONSPLIT bsize BLOCK 8 X8 update partition context xd mi row mi col subsize bsize static int dissect q931 ie cs7 tvbuff t tvb packet info pinfo proto tree tree void data U dissect q931 I Es tvb pinfo NULL tree FALSE 0 7 return tvb captured length tvb static void create new objects void int dbnum prep status Restoring database schemas in the new cluster n for dbnum 0 dbnum old cluster dbarr ndbs dbnum char sql file name MAXPGPATH log file name MAXPGPATH Db Info old db old cluster dbarr dbs dbnum PQ Exp Buffer Data connstr escaped connstr init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr old db db name init PQ Exp Buffer escaped connstr append Shell String escaped connstr connstr data term PQ Exp Buffer connstr pg log PGSTATUS s old db db name snprintf sql file name sizeof sql file name DBDUMPFILEMASK old db db oid snprintf log file name sizeof log file name DBDUMPLOGFILEMASK old db db oid parallel exec prog log file name NULL s pg restore s exit on error verbose dbname s s new cluster bindir cluster conn opts new cluster escaped connstr data sql file name term PQ Exp Buffer escaped connstr while reap child true true end progress output check ok if GETMAJORVERSION old cluster major version 903 set frozenxids true get db and rel infos new cluster static void rfb Process Client Normal Message rfb Client Ptr cl int n 0 rfb Client To Server Msg msg char str int i uint32 t enc 0 uint32 t last Preferred Encoding 1 char enc Buf 64 char enc Buf2 64 if n rfb Read Exact cl char msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return switch msg type case rfb Set Pixel Format if n rfb Read Exact cl char msg 1 sz rfb Set Pixel Format Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return cl format bits Per Pixel msg spf format bits Per Pixel cl format depth msg spf format depth cl format big Endian msg spf format big Endian TRUEFALSE cl format true Colour msg spf format true Colour TRUEFALSE cl format red Max Swap16 If LE msg spf format red Max cl format green Max Swap16 If LE msg spf format green Max cl format blue Max Swap16 If LE msg spf format blue Max cl format red Shift msg spf format red Shift cl format green Shift msg spf format green Shift cl format blue Shift msg spf format blue Shift cl ready For Set Colour Map Entries TRUE cl screen set Translate Function cl rfb Stat Record Message Rcvd cl msg type sz rfb Set Pixel Format Msg sz rfb Set Pixel Format Msg return case rfb Fix Colour Map Entries if n rfb Read Exact cl char msg 1 sz rfb Fix Colour Map Entries Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Set Pixel Format Msg sz rfb Set Pixel Format Msg rfb Log rfb Process Client Normal Message s Fix Colour Map Entries unsupported n rfb Close Client cl return case rfb Set Encodings if n rfb Read Exact cl char msg 1 sz rfb Set Encodings Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return msg se n Encodings Swap16 If LE msg se n Encodings rfb Stat Record Message Rcvd cl msg type sz rfb Set Encodings Msg msg se n Encodings 4 sz rfb Set Encodings Msg msg se n Encodings 4 if cl preferred Encoding 1 last Preferred Encoding cl preferred Encoding cl preferred Encoding 1 cl use Copy Rect FALSE cl use New FB Size FALSE cl cursor Was Changed FALSE cl use Rich Cursor Encoding FALSE cl enable Cursor Pos Updates FALSE cl enable Cursor Shape Updates FALSE cl enable Cursor Shape Updates FALSE cl enable Last Rect Encoding FALSE cl enable Keyboard Led State FALSE cl enable Supported Messages FALSE cl enable Supported Encodings FALSE cl enable Server Identity FALSE cl turbo Subsamp Level TURBODEFAULTSUBSAMP cl turbo Quality Level 1 i msg se n Encodings i if n rfb Read Exact cl char enc 4 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return enc Swap32 If LE enc switch enc case rfb Encoding Copy Rect cl use Copy Rect TRUE break case rfb Encoding Raw case rfb Encoding RRE case rfb Encoding Co RRE case rfb Encoding Hextile case rfb Encoding Ultra ifdef LIBVNCSERVERHAVELIBZ case rfb Encoding Zlib case rfb Encoding ZRLE case rfb Encoding ZYWRLE ifdef LIBVNCSERVERHAVELIBJPEG case rfb Encoding Tight endif endif ifdef LIBVNCSERVERHAVELIBPNG case rfb Encoding Tight Png endif if cl preferred Encoding 1 cl preferred Encoding enc break case rfb Encoding X Cursor if cl screen dont Convert Rich Cursor To X Cursor rfb Log Enabling X style cursor updates for client s n cl host if cl enable Cursor Shape Updates rfb Redraw After Hide Cursor cl NULL cl enable Cursor Shape Updates TRUE cl cursor Was Changed TRUE break case rfb Encoding Rich Cursor rfb Log Enabling full color cursor updates for client s n cl host if cl enable Cursor Shape Updates rfb Redraw After Hide Cursor cl NULL cl enable Cursor Shape Updates TRUE cl use Rich Cursor Encoding TRUE cl cursor Was Changed TRUE break case rfb Encoding Pointer Pos if cl enable Cursor Pos Updates rfb Log Enabling cursor position updates for client s n cl host cl enable Cursor Pos Updates TRUE cl cursor Was Moved TRUE break case rfb Encoding Last Rect if cl enable Last Rect Encoding rfb Log Enabling Last Rect protocol extension for client s n cl host cl enable Last Rect Encoding TRUE break case rfb Encoding New FB Size if cl use New FB Size rfb Log Enabling New FB Size protocol extension for client s n cl host cl use New FB Size TRUE break case rfb Encoding Keyboard Led State if cl enable Keyboard Led State rfb Log Enabling Keyboard Led State protocol extension for client s n cl host cl enable Keyboard Led State TRUE break case rfb Encoding Supported Messages if cl enable Supported Messages rfb Log Enabling Supported Messages protocol extension for client s n cl host cl enable Supported Messages TRUE break case rfb Encoding Supported Encodings if cl enable Supported Encodings rfb Log Enabling Supported Encodings protocol extension for client s n cl host cl enable Supported Encodings TRUE break case rfb Encoding Server Identity if cl enable Server Identity rfb Log Enabling Server Identity protocol extension for client s n cl host cl enable Server Identity TRUE break case rfb Encoding Xvp if cl screen xvp Hook rfb Log Enabling Xvp protocol extension for client s n cl host if rfb Send Xvp cl 1 rfb Xvp Init rfb Close Client cl return break default if defined LIBVNCSERVERHAVELIBZ defined LIBVNCSERVERHAVELIBPNG if enc uint32 t rfb Encoding Compress Level0 enc uint32 t rfb Encoding Compress Level9 cl zlib Compress Level enc 0x0 F rfb Log Using compression level d for client s n cl tight Compress Level cl host else if enc uint32 t rfb Encoding Quality Level0 enc uint32 t rfb Encoding Quality Level9 cl tight Quality Level enc 0x0 F rfb Log Using image quality level d for client s n cl tight Quality Level cl host cl turbo Subsamp Level tight2turbo subsamp enc 0x0 F rfb Log Using JPEG subsampling d Q d for client s n cl turbo Subsamp Level cl turbo Quality Level cl host else if enc uint32 t rfb Encoding Fine Quality Level0 1 enc uint32 t rfb Encoding Fine Quality Level100 cl turbo Quality Level enc 0x FF rfb Log Using fine quality level d for client s n cl turbo Quality Level cl host else if enc uint32 t rfb Encoding Subsamp1 X enc uint32 t rfb Encoding Subsamp Gray cl turbo Subsamp Level enc 0x FF rfb Log Using subsampling level d for client s n cl turbo Subsamp Level cl host else endif rfb Extension Data e for e cl extensions e rfb Extension Data next e next if e extension enable Pseudo Encoding e extension enable Pseudo Encoding cl e data int enc break e next if e NULL rfb Bool handled FALSE rfb Protocol Extension e for e rfb Get Extension Iterator e int encs e pseudo Encodings while encs encs 0 if encs int enc void data NULL if e enable Pseudo Encoding cl data int enc rfb Log Installed extension pretends to handle pseudo encoding 0x x but does not n int enc else rfb Enable Extension cl e data handled TRUE e NULL break encs if e e e next rfb Release Extension Iterator if handled rfb Log rfb Process Client Normal Message ignoring unsupported encoding type s n encoding Name enc enc Buf sizeof enc Buf if cl preferred Encoding 1 if last Preferred Encoding 1 cl preferred Encoding rfb Encoding Raw rfb Log Defaulting to s encoding for client s n encoding Name cl preferred Encoding enc Buf sizeof enc Buf cl host else cl preferred Encoding last Preferred Encoding rfb Log Sticking with s encoding for client s n encoding Name cl preferred Encoding enc Buf sizeof enc Buf cl host else if last Preferred Encoding 1 rfb Log Using s encoding for client s n encoding Name cl preferred Encoding enc Buf sizeof enc Buf cl host else rfb Log Switching from s to s Encoding for client s n encoding Name last Preferred Encoding enc Buf2 sizeof enc Buf2 encoding Name cl preferred Encoding enc Buf sizeof enc Buf cl host if cl enable Cursor Pos Updates cl enable Cursor Shape Updates rfb Log Disabling cursor position updates for client s n cl host cl enable Cursor Pos Updates FALSE return case rfb Framebuffer Update Request sra Region Ptr tmp Region if n rfb Read Exact cl char msg 1 sz rfb Framebuffer Update Request Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Framebuffer Update Request Msg sz rfb Framebuffer Update Request Msg if rect Swap If LE And Clip msg fur x msg fur y msg fur w msg fur h cl rfb Log Warning ignoring rfb Framebuffer Update Request d Xx d Y d Wx d H n msg fur x msg fur y msg fur w msg fur h return tmp Region sra Rgn Create Rect msg fur x msg fur y msg fur x msg fur w msg fur y msg fur h LOCK cl update Mutex sra Rgn Or cl requested Region tmp Region if cl ready For Set Colour Map Entries cl ready For Set Colour Map Entries TRUE if cl format true Colour if rfb Set Client Colour Map cl 0 0 sra Rgn Destroy tmp Region TSIGNAL cl update Cond UNLOCK cl update Mutex return if msg fur incremental sra Rgn Or cl modified Region tmp Region sra Rgn Subtract cl copy Region tmp Region TSIGNAL cl update Cond UNLOCK cl update Mutex sra Rgn Destroy tmp Region return case rfb Key Event if n rfb Read Exact cl char msg 1 sz rfb Key Event Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Key Event Msg sz rfb Key Event Msg if cl view Only cl screen kbd Add Event msg ke down rfb Key Sym Swap32 If LE msg ke key cl return case rfb Pointer Event if n rfb Read Exact cl char msg 1 sz rfb Pointer Event Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Pointer Event Msg sz rfb Pointer Event Msg if cl screen pointer Client cl screen pointer Client cl return if msg pe button Mask 0 cl screen pointer Client NULL else cl screen pointer Client cl if cl view Only if msg pe button Mask cl last Ptr Buttons cl screen defer Ptr Update Time 0 cl screen ptr Add Event msg pe button Mask Scale X cl scaled Screen cl screen Swap16 If LE msg pe x Scale Y cl scaled Screen cl screen Swap16 If LE msg pe y cl cl last Ptr Buttons msg pe button Mask else cl last Ptr X Scale X cl scaled Screen cl screen Swap16 If LE msg pe x cl last Ptr Y Scale Y cl scaled Screen cl screen Swap16 If LE msg pe y cl last Ptr Buttons msg pe button Mask return case rfb File Transfer if n rfb Read Exact cl char msg 1 sz rfb File Transfer Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return msg ft size Swap32 If LE msg ft size msg ft length Swap32 If LE msg ft length rfb Process File Transfer cl msg ft content Type msg ft content Param msg ft size msg ft length return case rfb Set SW if n rfb Read Exact cl char msg 1 sz rfb Set SW Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return msg sw x Swap16 If LE msg sw x msg sw y Swap16 If LE msg sw y rfb Stat Record Message Rcvd cl msg type sz rfb Set SW Msg sz rfb Set SW Msg rfb Log Received a rfb Set Single Window d x d y n msg sw x msg sw y if cl screen set Single Window NULL cl screen set Single Window cl msg sw x msg sw y return case rfb Set Server Input if n rfb Read Exact cl char msg 1 sz rfb Set Server Input Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Set Server Input Msg sz rfb Set Server Input Msg rfb Log Received a rfb Set Server Input d status n msg sim status if cl screen set Server Input NULL cl screen set Server Input cl msg sim status return case rfb Text Chat if n rfb Read Exact cl char msg 1 sz rfb Text Chat Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return msg tc pad2 Swap16 If LE msg tc pad2 msg tc length Swap32 If LE msg tc length switch msg tc length case rfb Text Chat Open case rfb Text Chat Close case rfb Text Chat Finished str NULL rfb Stat Record Message Rcvd cl msg type sz rfb Text Chat Msg sz rfb Text Chat Msg break default if msg tc length 0 msg tc length rfb Text Max Size str char malloc msg tc length if str NULL rfb Log Unable to malloc d bytes for a Text Chat Message n msg tc length rfb Close Client cl return if n rfb Read Exact cl str msg tc length 0 if n 0 rfb Log Perror rfb Process Client Normal Message read free str rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Text Chat Msg msg tc length sz rfb Text Chat Msg msg tc length else rfb Log client sent us a Text Message that is too big d d n msg tc length rfb Text Max Size rfb Close Client cl return if cl screen set Text Chat NULL cl screen set Text Chat cl msg tc length str free str return case rfb Client Cut Text if n rfb Read Exact cl char msg 1 sz rfb Client Cut Text Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return msg cct length Swap32 If LE msg cct length str char malloc msg cct length if str NULL rfb Log Perror rfb Process Client Normal Message not enough memory rfb Close Client cl return if n rfb Read Exact cl str msg cct length 0 if n 0 rfb Log Perror rfb Process Client Normal Message read free str rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Client Cut Text Msg msg cct length sz rfb Client Cut Text Msg msg cct length if cl view Only cl screen set X Cut Text str msg cct length cl free str return case rfb Palm VNC Set Scale Factor cl Palm VNCTRUE if n rfb Read Exact cl char msg 1 sz rfb Set Scale Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return if msg ssc scale 0 rfb Log Perror rfb Process Client Normal Message will not accept a scale factor of zero rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Set Scale Msg sz rfb Set Scale Msg rfb Log rfb Set Scale d n msg ssc scale rfb Scaling Setup cl cl screen width msg ssc scale cl screen height msg ssc scale rfb Send New Scale Size cl return case rfb Set Scale if n rfb Read Exact cl char msg 1 sz rfb Set Scale Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return if msg ssc scale 0 rfb Log Perror rfb Process Client Normal Message will not accept a scale factor of zero rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Set Scale Msg sz rfb Set Scale Msg rfb Log rfb Set Scale d n msg ssc scale rfb Scaling Setup cl cl screen width msg ssc scale cl screen height msg ssc scale rfb Send New Scale Size cl return case rfb Xvp if n rfb Read Exact cl char msg 1 sz rfb Xvp Msg 1 0 if n 0 rfb Log Perror rfb Process Client Normal Message read rfb Close Client cl return rfb Stat Record Message Rcvd cl msg type sz rfb Xvp Msg sz rfb Xvp Msg if msg xvp version 1 rfb Send Xvp cl msg xvp version rfb Xvp Fail else if cl screen xvp Hook cl screen xvp Hook cl msg xvp version msg xvp code rfb Send Xvp cl 1 rfb Xvp Fail return default rfb Extension Data e next for e cl extensions e next e next if e extension handle Message e extension handle Message cl e data msg rfb Stat Record Message Rcvd cl msg type 0 0 return e next rfb Log rfb Process Client Normal Message unknown message type d n msg type rfb Log closing connection n rfb Close Client cl return static int32 t append Variants To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status char buf ULOCFULLNAMECAPACITYU Error Code tmp Status UZEROERROR int32 t len i int32 t reslen 0 if UFAILURE status return 0 len uloc get Variant locale ID buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR return 0 if len 0 char p p Var U Bool b Next TRUE Variant List Entry var Variant List Entry var First NULL p Var NULL p buf while b Next if p SEP p LOCALESEP p 0 if p 0 b Next FALSE else p 0 if p Var NULL if strict status UILLEGALARGUMENTERROR break else for i 0 p Var i 0 i p Var i uprv tolower p Var i if is Variant Subtag p Var 1 if uprv strcmp p Var POSIXVALUE len uprv strlen POSIXVALUE var Variant List Entry uprv malloc sizeof Variant List Entry if var NULL status UMEMORYALLOCATIONERROR break var variant p Var if add Variant To List var First var uprv free var if strict status UILLEGALARGUMENTERROR break else had Posix TRUE else if strict status UILLEGALARGUMENTERROR break else if is Privateuse Value Subtag p Var 1 break p Var NULL else if p Var NULL p Var p p if USUCCESS status if var First NULL int32 t var Len var var First while var NULL if reslen capacity append At reslen SEP reslen var Len int32 t uprv strlen var variant if reslen capacity uprv memcpy append At reslen var variant uprv min var Len capacity reslen reslen var Len var var next var var First while var NULL Variant List Entry tmp Var var next uprv free var var tmp Var if UFAILURE status return 0 u terminate Chars append At capacity reslen status return reslen int zrestore i ctx t i ctx p os ptr op osp alloc save t asave bool last vm save t vmsave int code restore check operand op asave idmemory if code 0 return code if debug2m u imemory u vmrestore 0x lx id lu n ulong alloc save client data asave ulong op value saveid if IVALIDATEBEFORERESTORE ivalidate clean spaces i ctx p osp int code if code restore check stack i ctx p o stack asave false 0 code restore check stack i ctx p e stack asave true 0 code restore check stack i ctx p d stack asave false 0 osp return code restore fix stack i ctx p o stack asave false restore fix stack i ctx p e stack asave true restore fix stack i ctx p d stack asave false do vmsave alloc save client data alloc save current idmemory gs grestoreall for restore igs vmsave gsave vmsave gsave 0 code alloc restore step in idmemory asave if code 0 return code last code while last uint space icurrent space ialloc set space idmemory avm local ifree object vmsave zrestore ialloc set space idmemory space dict set top if IVALIDATEAFTERRESTORE ivalidate clean spaces i ctx p i ctx p Lock File Permissions false return 0 void kadmin addprinc int argc char argv kadm5 principal ent rec princ kadm5 policy ent rec defpol long mask krb5 boolean randkey FALSE old style randkey FALSE int n ks tuple krb5 key salt tuple ks tuple NULL char pass canon NULL krb5 error code retval char newpw 1024 dummybuf 256 static char prompt1 1024 prompt2 1024 memset princ 0 sizeof princ princ attributes 0 if kadmin parse princ args argc argv princ mask pass randkey ks tuple n ks tuple add principal kadmin addprinc usage goto cleanup retval krb5 unparse name context princ principal canon if retval com err add principal retval while canonicalizing principal goto cleanup if mask KAD M5 POLICY mask KAD M5 POLICYCLR if kadm5 get policy handle default defpol fprintf stderr NOTICE no policy specified for s assigning default n canon princ policy default mask KAD M5 POLICY kadm5 free policy ent handle defpol else fprintf stderr WARNING no policy specified for s defaulting to no policy n canon mask KAD M5 POLICYCLR if randkey pass NULL else if pass NULL unsigned int sz sizeof newpw 1 snprintf prompt1 sizeof prompt1 Enter password for principal s canon snprintf prompt2 sizeof prompt2 Re enter password for principal s canon retval krb5 read password context prompt1 prompt2 newpw sz if retval com err add principal retval while reading password for s canon goto cleanup pass newpw mask KAD M5 PRINCIPAL retval create princ princ mask n ks tuple ks tuple pass if retval EINVAL randkey prepare dummy password dummybuf sizeof dummybuf princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES pass dummybuf retval create princ princ mask n ks tuple ks tuple pass old style randkey 1 if retval com err add principal retval while creating s canon goto cleanup if old style randkey retval randkey princ princ principal FALSE n ks tuple ks tuple if retval com err add principal retval while randomizing key for s canon goto cleanup princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES retval kadm5 modify principal handle princ mask if retval com err add principal retval while clearing DISALLOWALLTIX for s canon goto cleanup printf Principal s created n canon cleanup krb5 free principal context princ principal free ks tuple free canon kadmin free tl data princ n tl data princ tl data static int yop decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Yop Dec Context s avctx priv data AV Frame frame data int tag firstcolor is odd frame int ret i x y uint32 t palette if avpkt size 4 3 s num pal colors av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA ret ff get buffer avctx frame 0 if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset frame data 1 0 AVPALETTESIZE s dstbuf frame data 0 s dstptr frame data 0 s srcptr avpkt data 4 s src end avpkt data avpkt size s low nibble NULL is odd frame avpkt data 0 firstcolor s first color is odd frame palette uint32 t frame data 1 for i 0 i s num pal colors i s srcptr 3 palette i firstcolor s srcptr 0 18 s srcptr 1 10 s srcptr 2 2 frame palette has changed 1 for y 0 y avctx height y 2 for x 0 x avctx width x 2 if s srcptr avpkt data avpkt size av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA tag yop get next nibble s if tag 0xf ret yop paint block s frame linesize 0 tag if ret 0 return ret else tag yop get next nibble s ret yop copy previous block s frame linesize 0 tag if ret 0 return ret s dstptr 2 s dstptr 2 frame linesize 0 x got frame 1 return avpkt size static gint dissect attribute value proto tree tree proto item patron item packet info pinfo tvbuff t old tvb gint old offset gint length guint16 handle bluetooth uuid t uuid btatt data t att data proto item sub item proto tree sub tree NULL tvbuff t tvb gint offset 0 bluetooth uuid t sub uuid bluetooth uuid t service uuid guint16 sub handle guint32 value guint32 flags guint32 operator value guint32 opcode guint32 operand offset const gint hfs bluetooth data t bluetooth data NULL tvb tvb new subset length caplen old tvb old offset length length DISSECTORASSERT att data bluetooth data att data bluetooth data if p get proto data pinfo pool pinfo proto btatt PROTODATABTATTHANDLENULL guint16 value data value data wmem new wmem file scope guint16 value data handle p add proto data pinfo pool pinfo proto btatt PROTODATABTATTHANDLE value data if btatt dissect attribute handle handle tvb pinfo tree att data return old offset length if p get proto data pinfo pool pinfo proto bluetooth PROTODATABLUETOOTHSERVICEUUIDNULL guint8 value data value data wmem strdup wmem file scope print numeric uuid uuid p add proto data pinfo pool pinfo proto bluetooth PROTODATABLUETOOTHSERVICEUUID value data if dissector try string bluetooth uuid table print numeric uuid uuid tvb pinfo tree att data return old offset length else if uuid bt uuid if bluetooth gatt has no parameter att data opcode return old offset proto tree add item tree hf btatt value tvb offset 1 ENCNA return old offset tvb captured length tvb service uuid get service uuid from handle pinfo handle bluetooth data switch uuid bt uuid case 0x2800 case 0x2801 if is readable request att data opcode att data opcode ATTOPCODEREADBYGROUPTYPEREQUEST break if is readable response att data opcode att data opcode ATTOPCODEREADBYGROUPTYPERESPONSE expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt uuid16 tvb offset 2 ENCLITTLEENDIAN sub uuid get uuid tvb offset 2 proto item append text patron item UUID s print uuid sub uuid offset 2 col append fstr pinfo cinfo COLINFO s print uuid sub uuid save handle pinfo sub uuid handle ATTRIBUTETYPESERVICE bluetooth data else if tvb reported length remaining tvb offset 16 proto tree add item tree hf btatt uuid128 tvb offset 16 ENCNA sub uuid get uuid tvb offset 16 proto item append text patron item UUI D128 s print uuid sub uuid offset 16 col append fstr pinfo cinfo COLINFO s print uuid sub uuid save handle pinfo sub uuid handle ATTRIBUTETYPESERVICE bluetooth data else sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt bad data offset tvb captured length tvb break case 0x2802 if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break offset dissect handle tree pinfo hf btatt included service handle tvb offset bluetooth data NULLHANDLETVB sub handle tvb get guint16 tvb offset 2 ENCLITTLEENDIAN proto tree add item tree hf btatt ending handle tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt uuid16 tvb offset 2 ENCLITTLEENDIAN sub uuid get uuid tvb offset 2 proto item append text patron item Included Handle 0x 04x UUID s sub handle print uuid sub uuid offset 2 col append fstr pinfo cinfo COLINFO s print uuid sub uuid save handle pinfo sub uuid sub handle ATTRIBUTETYPEOTHER bluetooth data break case 0x2803 if is readable request att data opcode att data opcode ATTOPCODEREADBYTYPEREQUEST break if is readable response att data opcode att data opcode ATTOPCODEREADBYTYPERESPONSE expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt characteristic properties ett btatt characteristic properties hfx btatt characteristic properties ENCNA offset 1 offset dissect handle tree pinfo hf btatt characteristic value handle tvb offset bluetooth data NULLHANDLETVB sub handle tvb get guint16 tvb offset 2 ENCLITTLEENDIAN if tvb reported length remaining tvb offset 16 proto tree add item tree hf btatt uuid128 tvb offset 16 ENCNA sub uuid get uuid tvb offset 16 proto item append text patron item Characteristic Handle 0x 04x UUI D128 s tvb get guint16 tvb offset 2 ENCLITTLEENDIAN print uuid sub uuid offset 16 col append fstr pinfo cinfo COLINFO s print uuid sub uuid save handle pinfo sub uuid sub handle ATTRIBUTETYPECHARACTERISTIC bluetooth data else if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt uuid16 tvb offset 2 ENCLITTLEENDIAN sub uuid get uuid tvb offset 2 proto item append text patron item Characteristic Handle 0x 04x UUID s sub handle print uuid sub uuid offset 2 col append fstr pinfo cinfo COLINFO s print uuid sub uuid save handle pinfo sub uuid sub handle ATTRIBUTETYPECHARACTERISTIC bluetooth data else sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt bad data offset tvb captured length tvb break case 0x2900 if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt characteristic extended properties ett btatt value hfx btatt characteristic extended properties ENCLITTLEENDIAN offset 2 break case 0x2901 if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt characteristic user description tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2902 if is readable request att data opcode is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt characteristic configuration client ett btatt value hfx btatt characteristic configuration client ENCLITTLEENDIAN value tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 bluetooth uuid t characteristic uuid characteristic uuid get characteristic uuid from handle pinfo handle bluetooth data if value 0x1 switch characteristic uuid bt uuid case 0x2 A05 case 0x2 A1 C case 0x2 A21 case 0x2 A35 case 0x2 A52 case 0x2 A55 case 0x2 A66 case 0x2 A6 B case 0x2 A99 case 0x2 A9 C case 0x2 A9 D case 0x2 A9 F case 0x2 ABC case 0x2 A C5 case 0x2 A C6 case 0x2 A C8 case 0x2 A C9 case 0x2 ACC case 0x2 A D4 case 0x2 A D5 case 0x2 A D6 case 0x2 A D7 case 0x2 A D8 case 0x2 A D9 expert add info pinfo tree ei btatt invalid usage break case 0x2 A18 case 0x2 A19 case 0x2 A1 E case 0x2 A22 case 0x2 A2 C case 0x2 A2 B case 0x2 A31 case 0x2 A33 case 0x2 A34 case 0x2 A36 case 0x2 A37 case 0x2 A3 F case 0x2 A45 case 0x2 A46 case 0x2 A4 D case 0x2 A53 case 0x2 A56 case 0x2 A58 case 0x2 A5 A case 0x2 A5 B case 0x2 A63 case 0x2 A64 case 0x2 A67 case 0x2 A68 case 0x2 A6 C case 0x2 A6 D case 0x2 A6 E case 0x2 A6 F case 0x2 A70 case 0x2 A71 case 0x2 A72 case 0x2 A73 case 0x2 A74 case 0x2 A75 case 0x2 A76 case 0x2 A77 case 0x2 A78 case 0x2 A79 case 0x2 A7 A case 0x2 A7 B case 0x2 A A0 case 0x2 A A1 case 0x2 A A3 case 0x2 A A7 case 0x2 A B8 case 0x2 ACD case 0x2 ACE case 0x2 ACF case 0x2 A D0 case 0x2 A D1 case 0x2 A D2 case 0x2 A D3 case 0x2 ADA default break if value 0x2 switch characteristic uuid bt uuid case 0x2 A18 case 0x2 A19 case 0x2 A1 E case 0x2 A22 case 0x2 A2 B case 0x2 A2 C case 0x2 A31 case 0x2 A33 case 0x2 A34 case 0x2 A36 case 0x2 A37 case 0x2 A3 F case 0x2 A45 case 0x2 A46 case 0x2 A4 D case 0x2 A53 case 0x2 A5 B case 0x2 A63 case 0x2 A64 case 0x2 A67 case 0x2 A68 case 0x2 A6 C case 0x2 A6 D case 0x2 A6 E case 0x2 A6 F case 0x2 A70 case 0x2 A71 case 0x2 A72 case 0x2 A73 case 0x2 A74 case 0x2 A75 case 0x2 A76 case 0x2 A77 case 0x2 A78 case 0x2 A79 case 0x2 A7 A case 0x2 A7 B case 0x2 A A0 case 0x2 A A1 case 0x2 A A3 case 0x2 A A7 case 0x2 A B8 case 0x2 A C9 case 0x2 ACC case 0x2 ACD case 0x2 ACE case 0x2 ACF case 0x2 A D0 case 0x2 A D1 case 0x2 A D2 case 0x2 A D3 case 0x2 A D4 case 0x2 A D5 case 0x2 A D6 case 0x2 A D7 case 0x2 A D8 case 0x2 ADA expert add info pinfo tree ei btatt invalid usage break case 0x2 A05 case 0x2 A1 C case 0x2 A21 case 0x2 A35 case 0x2 A52 case 0x2 A55 case 0x2 A56 case 0x2 A58 case 0x2 A5 A case 0x2 A66 case 0x2 A6 B case 0x2 A99 case 0x2 A9 C case 0x2 A9 D case 0x2 A9 F case 0x2 ABC case 0x2 A C5 case 0x2 A C6 case 0x2 A C8 case 0x2 A D9 default break if value 0x3 expert add info pinfo tree ei btatt bad data break case 0x2903 if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt characteristic configuration server ett btatt value hfx btatt characteristic configuration server ENCLITTLEENDIAN offset 2 break case 0x2904 if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt characteristic presentation format tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt characteristic presentation exponent tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt characteristic presentation unit tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt characteristic presentation namespace tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 0x01 proto tree add item tree hf btatt characteristic presentation namespace description btsig tvb offset 2 ENCLITTLEENDIAN else proto tree add item tree hf btatt characteristic presentation namespace description tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2905 if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add none format tree hf btatt handles info tvb offset tvb captured length tvb Handles i items tvb captured length tvb 2 sub tree proto item add subtree sub item ett btatt list while offset gint64 tvb captured length tvb offset dissect handle sub tree pinfo hf btatt handle tvb offset bluetooth data NULLHANDLETVB break case 0x2906 bluetooth uuid t characteristic uuid guint8 characteristic dissector name dissector handle t characteristic dissector if bluetooth gatt has no parameter att data opcode break characteristic uuid get characteristic uuid from handle pinfo handle bluetooth data characteristic dissector name wmem strdup printf wmem packet scope btgatt uuid0x s print numeric uuid characteristic uuid characteristic dissector find dissector characteristic dissector name sub item proto tree add item tree hf btatt valid range lower inclusive value tvb offset tvb reported length remaining tvb offset 2 ENCNA sub tree proto item add subtree sub item ett btatt list if characteristic dissector call dissector with data characteristic dissector tvb new subset length caplen tvb offset tvb reported length remaining tvb offset 2 tvb reported length remaining tvb offset 2 pinfo sub tree att data sub item proto tree add item tree hf btatt valid range upper inclusive value tvb offset tvb reported length remaining tvb offset 2 tvb reported length remaining tvb offset 2 ENCNA sub tree proto item add subtree sub item ett btatt list if characteristic dissector call dissector with data characteristic dissector tvb new subset length caplen tvb offset tvb reported length remaining tvb offset 2 tvb reported length remaining tvb offset 2 tvb reported length remaining tvb offset 2 pinfo sub tree att data offset tvb reported length remaining tvb offset break case 0x2907 if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt uuid16 tvb offset 2 ENCLITTLEENDIAN offset 2 else if tvb reported length remaining tvb offset 16 proto tree add item tree hf btatt uuid128 tvb offset 16 ENCNA offset 16 else sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt bad data offset tvb captured length tvb break case 0x2908 if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt report reference report id tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt report reference report type tvb offset 1 ENCNA offset 1 break case 0x2909 if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt number of digitals tvb offset 1 ENCNA offset 1 break case 0x290 A if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt value trigger setting condition tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 1 value 3 proto tree add item tree hf btatt value trigger setting analog tvb offset 2 ENCLITTLEENDIAN offset 2 else if value 4 btatt call dissector by dissector name with data btgatt uuid0x2a56 tvb new subset length caplen tvb offset 1 1 pinfo tree att data offset 1 else if value 5 value 6 proto tree add item tree hf btatt value trigger setting analog one tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt value trigger setting analog two tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x290 B if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt esp trigger logic tvb offset 1 ENCNA offset 1 break case 0x290 C if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt esp flags tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt esp sampling function tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt esp measurement period tvb offset 3 ENCLITTLEENDIAN offset 3 proto tree add item tree hf btatt esp update interval tvb offset 3 ENCLITTLEENDIAN offset 3 proto tree add item tree hf btatt esp application tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt esp measurement uncertainty tvb offset 1 ENCNA offset 1 break case 0x290 D if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt esp condition tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt esp operand tvb offset tvb captured length remaining tvb offset ENCNA offset tvb captured length remaining tvb offset break case 0x290 E if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time trigger setting condition tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 0 proto tree add item tree hf btatt time trigger setting value tvb offset 1 ENCNA offset 1 else if value 1 value 2 proto tree add item tree hf btatt time trigger setting value time interval tvb offset 3 ENCLITTLEENDIAN offset 3 else if value 3 proto tree add item tree hf btatt time trigger setting value count tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A00 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt device name tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A01 if bluetooth gatt has no parameter att data opcode break switch tvb get guint16 tvb offset ENCLITTLEENDIAN 0x FF C0 6 case 0x003 hfs hfx btatt appearance watch break case 0x00 C hfs hfx btatt appearance thermometer break case 0x00 D hfs hfx btatt appearance heart rate break case 0x00 E hfs hfx btatt appearance blood pressure break case 0x00 F hfs hfx btatt appearance hid break case 0x011 hfs hfx btatt appearance running walking sensor break case 0x012 hfs hfx btatt appearance cycling break case 0x031 hfs hfx btatt appearance pulse oximeter break case 0x033 hfs hfx btatt appearance personal mobility device break case 0x035 hfs hfx btatt appearance insulin pump break case 0x051 hfs hfx btatt appearance outdoor sports activity break default hfs hfx btatt appearance proto tree add bitmask tree tvb offset hf btatt appearance ett btatt value hfs ENCLITTLEENDIAN offset 2 break case 0x2 A02 if service uuid bt uuid GATTSERVICEGENERICACCESSPROFILE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt peripheral privacy flag tvb offset 1 ENCNA offset 1 break case 0x2 A03 if service uuid bt uuid GATTSERVICEGENERICACCESSPROFILE if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break offset dissect bd addr hf btatt reconnection address pinfo tree tvb offset FALSE bluetooth data interface id bluetooth data adapter id NULL break case 0x2 A04 if service uuid bt uuid GATTSERVICEGENERICACCESSPROFILE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt minimum connection interval tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt maximum connection interval tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt slave latency tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt connection supervision timeout multiplier tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A05 if service uuid bt uuid GATTSERVICEGENERICATTRIBUTEPROFILE if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt starting handle tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt ending handle tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A06 if service uuid bt uuid GATTSERVICEIMMEDIATEALERT if att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage else if service uuid bt uuid GATTSERVICELINKLOSS if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt alert level tvb offset 1 ENCNA offset 1 break case 0x2 A07 if service uuid bt uuid GATTSERVICETXPOWER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt tx power level tvb offset 1 ENCNA offset 1 break case 0x2 A08 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt seconds tvb offset 1 ENCNA offset 1 break case 0x2 A09 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt day of week tvb offset 1 ENCNA offset 1 break case 0x2 A0 A case 0x2 A0 B case 0x2 A0 C case 0x2 A2 B if uuid bt uuid 0x2 A2 B if service uuid bt uuid GATTSERVICECURRENTTIMESERVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt seconds tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt day of week tvb offset 1 ENCNA offset 1 if uuid bt uuid 0x2 A0 C uuid bt uuid 0x2 A2 B proto tree add item tree hf btatt fractions256 tvb offset 1 ENCNA offset 1 else if uuid bt uuid 0x2 A0 B proto tree add item tree hf btatt fractions100 tvb offset 1 ENCNA offset 1 if uuid bt uuid 0x2 A2 B proto tree add bitmask tree tvb offset hf btatt time adjust reason ett btatt value hfx btatt time adjust reason ENCNA offset 1 break case 0x2 A0 D if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt dst offset tvb offset 1 ENCNA offset 1 break case 0x2 A0 E if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt timezone tvb offset 1 ENCNA offset 1 break case 0x2 A0 F case 0x2 A10 if service uuid bt uuid GATTSERVICECURRENTTIMESERVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break if uuid bt uuid 0x2 A10 proto tree add bitmask tree tvb offset hf btatt timezone information ett btatt value hfx btatt timezone information ENCNA offset 1 proto tree add item tree hf btatt timezone tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt dst offset tvb offset 1 ENCNA offset 1 break case 0x2 A11 if service uuid bt uuid GATTSERVICENEXTDSTCHANGESERVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt seconds tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt dst offset tvb offset 1 ENCNA offset 1 break case 0x2 A12 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time accuracy tvb offset 1 ENCNA offset 1 break case 0x2 A13 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time source tvb offset 1 ENCNA offset 1 break case 0x2 A14 if service uuid bt uuid GATTSERVICECURRENTTIMESERVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time source tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt time accuracy tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt time days since update tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt time hours since update tvb offset 1 ENCNA offset 1 break case 0x2 A15 if bluetooth gatt has no parameter att data opcode break btatt call dissector by dissector name with data btgatt uuid0x2 A0 C tvb new subset length caplen tvb offset 9 9 pinfo tree att data offset 9 btatt call dissector by dissector name with data btgatt uuid0x2 A0 F tvb new subset length caplen tvb offset 2 2 pinfo tree att data offset 2 btatt call dissector by dissector name with data btgatt uuid0x2 A14 tvb new subset length caplen tvb offset 4 4 pinfo tree att data offset 4 break case 0x2 A16 if service uuid bt uuid GATTSERVICEREFERENCETIMEUPDATESERVICE if att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time update control point tvb offset 1 ENCNA offset 1 break case 0x2 A17 if service uuid bt uuid GATTSERVICEREFERENCETIMEUPDATESERVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt time current state tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt time result tvb offset 1 ENCNA offset 1 break case 0x2 A18 if service uuid bt uuid GATTSERVICEGLUCOSE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt glucose measurement flags ett btatt value hfx btatt glucose measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt glucose measurement sequence number tvb offset 2 ENCLITTLEENDIAN offset 2 sub item proto tree add item tree hf btatt glucose measurement base time tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 if flags 0x01 proto tree add item tree hf btatt glucose measurement time offset tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 flags 0x04 proto tree add item tree hf btatt glucose measurement glucose concentration kg per l tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 flags 0x04 proto tree add item tree hf btatt glucose measurement glucose concentration mol per l tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add bitmask tree tvb offset hf btatt glucose measurement type and sample location ett btatt value hfx btatt glucose measurement type and sample location ENCNA offset 1 if flags 0x08 proto tree add bitmask tree tvb offset hf btatt glucose measurement sensor status annunciation ett btatt value hfx btatt glucose measurement sensor status annunciation ENCLITTLEENDIAN offset 2 break case 0x2 A19 if service uuid bt uuid GATTSERVICEBATTERYSERVICE if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break guint32 battery level sub item proto tree add item ret uint tree hf btatt battery level tvb offset 1 ENCNA battery level if battery level 100 expert add info pinfo sub item ei btatt bad data offset 1 break case 0x2 A1 A if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt battery power state ett btatt value hfx btatt battery power state ENCNA offset 1 break case 0x2 A1 B if bluetooth gatt has no parameter att data opcode break guint32 battery level sub item proto tree add item ret uint tree hf btatt battery level tvb offset 1 ENCNA battery level if battery level 100 expert add info pinfo sub item ei btatt bad data offset 1 if tvb reported length remaining tvb offset 1 proto tree add bitmask tree tvb offset hf btatt battery power state ett btatt value hfx btatt battery power state ENCNA offset 1 break case 0x2 A1 C case 0x2 A1 E if uuid bt uuid 0x2 A1 C if service uuid bt uuid GATTSERVICEHEALTHTHERMOMETER if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage else if uuid bt uuid 0x2 A1 E if service uuid bt uuid GATTSERVICEHEALTHTHERMOMETER if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt temperature measurement flags ett btatt value hfx btatt temperature measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt temperature measurement value celsius tvb offset 4 ENCLITTLEENDIAN offset 4 else proto tree add item tree hf btatt temperature measurement value fahrenheit tvb offset 4 ENCLITTLEENDIAN offset 4 if flags 0x02 sub item proto tree add item tree hf btatt temperature measurement timestamp tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt temperature type tvb offset 1 ENCNA offset 1 break case 0x2 A1 D if service uuid bt uuid GATTSERVICEHEALTHTHERMOMETER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt temperature type tvb offset 1 ENCNA offset 1 break case 0x2 A21 if service uuid bt uuid GATTSERVICEHEALTHTHERMOMETER if is readable request att data opcode is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt measurement interval tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A22 if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break call dissector with data usb hid boot keyboard input report handle tvb new subset remaining tvb offset pinfo tree NULL offset tvb reported length remaining tvb offset break case 0x2 A23 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt system id manufacturer identifier tvb offset 5 ENCLITTLEENDIAN offset 5 proto tree add item tree hf btatt system id organizationally unique identifier tvb offset 3 ENCLITTLEENDIAN offset 3 break case 0x2 A24 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt model number string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A25 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt serial number string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A26 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt firmware revision string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A27 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt hardware revision string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A28 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt software revision string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A29 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt manufacturer string tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A2 A guint16 count guint16 list length 0 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt regulatory certification data list count tvb offset 2 ENCLITTLEENDIAN count tvb get guint16 tvb offset ENCLITTLEENDIAN list length 2 offset 2 proto tree add item tree hf btatt regulatory certification data list length tvb offset 2 ENCLITTLEENDIAN list length 2 offset 2 while count proto item authorizing body data item proto tree authorizing body data tree guint8 item type guint16 item length guint16 certification data list count 0 guint16 certification data list length 0 proto item list length item sub item proto tree add item tree hf btatt regulatory certification data list item tvb offset 0 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt regulatory certification data list item body tvb offset 1 ENCNA list length 1 offset 1 proto tree add item sub tree hf btatt regulatory certification data list item body structure type tvb offset 1 ENCNA item type tvb get guint8 tvb offset list length 1 offset 1 list length item proto tree add item sub tree hf btatt regulatory certification data list item body structure length tvb offset 2 ENCLITTLEENDIAN item length tvb get guint16 tvb offset ENCLITTLEENDIAN list length 2 item length offset 2 if item type 0x01 authorizing body data item proto tree add item sub tree hf btatt regulatory certification data list item authorizing body data tvb offset item length ENCNA authorizing body data tree proto item add subtree authorizing body data item ett btatt list if item length 0 proto tree add item authorizing body data tree hf btatt regulatory certification data list item authorizing body data major ig version tvb offset 1 ENCNA offset 1 if item length 1 proto tree add item authorizing body data tree hf btatt regulatory certification data list item authorizing body data minor ig version tvb offset 1 ENCNA offset 1 if item length 2 proto tree add item authorizing body data tree hf btatt regulatory certification data list item authorizing body data certification data list count tvb offset 2 ENCLITTLEENDIAN certification data list count tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 if item length 4 proto tree add item authorizing body data tree hf btatt regulatory certification data list item authorizing body data certification data list length tvb offset 2 ENCLITTLEENDIAN certification data list length tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 if item length 6 certification data list count proto item certification data list item proto tree certification data list tree certification data list item proto tree add item sub tree hf btatt regulatory certification data list item authorizing body data certification data list tvb offset certification data list length ENCNA certification data list tree proto item add subtree certification data list item ett btatt list while certification data list count proto tree add item certification data list tree hf btatt regulatory certification data list item authorizing body data certified device class tvb offset 2 ENCLITTLEENDIAN offset 2 else if item type 0x02 proto tree add item sub tree hf btatt regulatory certification data list item regulation bit field type tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item sub tree hf btatt regulatory certification data list item data tvb offset item length ENCNA offset item length proto item set len sub item 1 1 2 item length if list length length expert add info pinfo list length item ei btatt invalid length break case 0x2 A2 C if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt magnetic declination tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A31 if service uuid bt uuid GATTSERVICESCANPARAMETERS if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt scan refresh tvb offset 1 ENCNA offset 1 break case 0x2 A32 if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break call dissector with data usb hid boot keyboard output report handle tvb new subset remaining tvb offset pinfo tree NULL offset tvb reported length remaining tvb offset break case 0x2 A33 if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break call dissector with data usb hid boot mouse input report handle tvb new subset remaining tvb offset pinfo tree NULL offset tvb reported length remaining tvb offset break case 0x2 A34 if service uuid bt uuid GATTSERVICEGLUCOSE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt glucose measurement context flags ett btatt value hfx btatt glucose measurement context flags ENCNA flags tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt glucose measurement context sequence number tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x80 proto tree add bitmask tree tvb offset hf btatt glucose measurement context extended flags ett btatt value hfx btatt glucose measurement context extended flags ENCNA offset 1 if flags 0x01 proto tree add item tree hf btatt glucose measurement context carbohydrate id tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt glucose measurement context carbohydrate kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt glucose measurement context meal tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add bitmask tree tvb offset hf btatt glucose measurement context tester health ett btatt value hfx btatt glucose measurement context tester health ENCNA offset 1 if flags 0x08 proto tree add item tree hf btatt glucose measurement context exercise duration tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt glucose measurement context exercise intensity tvb offset 1 ENCNA offset 1 if flags 0x10 proto tree add item tree hf btatt glucose measurement context medication id tvb offset 1 ENCNA offset 1 if flags 0x20 proto tree add item tree hf btatt glucose measurement context medication l tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item tree hf btatt glucose measurement context medication kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x40 proto tree add item tree hf btatt glucose measurement context hba1c tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A35 case 0x2 A36 if uuid bt uuid 0x2 A35 if service uuid bt uuid GATTSERVICEBLOODPRESSURE if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage else if uuid bt uuid 0x2 A36 if service uuid bt uuid GATTSERVICEBLOODPRESSURE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt blood pressure measurement flags ett btatt value hfx btatt blood pressure measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt blood pressure measurement compound value systolic kpa tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt blood pressure measurement compound value diastolic kpa tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt blood pressure measurement compound value mean arterial pressure kpa tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item tree hf btatt blood pressure measurement compound value systolic mmhg tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt blood pressure measurement compound value diastolic mmhg tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt blood pressure measurement compound value mean arterial pressure mmhg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 sub item proto tree add item tree hf btatt blood pressure measurement timestamp tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt blood pressure measurement pulse rate tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x08 proto tree add item tree hf btatt blood pressure measurement user id tvb offset 1 ENCNA offset 1 if flags 0x10 proto tree add bitmask tree tvb offset hf btatt blood pressure measurement status ett btatt value hfx btatt blood pressure measurement status ENCLITTLEENDIAN offset 2 break case 0x2 A37 if service uuid bt uuid GATTSERVICEHEARTRATE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt heart rate measurement flags ett btatt value hfx btatt heart rate measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt heart rate measurement value 16 tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item tree hf btatt heart rate measurement value 8 tvb offset 1 ENCNA offset 1 if flags 0x08 proto tree add item tree hf btatt heart rate measurement energy expended tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x10 guint interval count 0 sub item proto tree add item tree hf btatt heart rate measurement rr intervals tvb offset tvb captured length remaining tvb offset ENCNA sub tree proto item add subtree sub item ett btatt list while tvb reported length remaining tvb offset proto tree add item sub tree hf btatt heart rate measurement rr interval tvb offset 2 ENCLITTLEENDIAN offset 2 interval count 1 proto item append text sub item count 2u interval count break case 0x2 A38 if service uuid bt uuid GATTSERVICEHEARTRATE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt body sensor location tvb offset 1 ENCNA offset 1 break case 0x2 A39 if service uuid bt uuid GATTSERVICEHEARTRATE if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt heart rate control point tvb offset 1 ENCNA offset 1 break case 0x2 A3 F if service uuid bt uuid GATTSERVICEPHONEALERTSTATUSSERVICE if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt alert status ett btatt value hfx btatt alert status ENCNA offset 1 break case 0x2 A40 if service uuid bt uuid GATTSERVICEPHONEALERTSTATUSSERVICE if att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ringer control point tvb offset 1 ENCNA offset 1 break case 0x2 A41 if service uuid bt uuid GATTSERVICEPHONEALERTSTATUSSERVICE if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ringer setting tvb offset 1 ENCNA offset 1 break case 0x2 A42 case 0x2 A47 case 0x2 A48 if uuid bt uuid 0x2 A47 uuid bt uuid 0x2 A48 if service uuid bt uuid GATTSERVICEALERTNOTIFICATIONSERVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt alert category id bitmask 1 ett btatt value hfx btatt alert category id bitmask 1 ENCNA offset 1 if tvb reported length remaining tvb offset 1 proto tree add bitmask tree tvb offset hf btatt alert category id bitmask 2 ett btatt value hfx btatt alert category id bitmask 2 ENCNA offset 1 break case 0x2 A43 if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt alert category id tvb offset 1 ENCNA offset 1 break case 0x2 A44 if service uuid bt uuid GATTSERVICEALERTNOTIFICATIONSERVICE if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt alert command id tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt alert category id tvb offset 1 ENCNA offset 1 break case 0x2 A45 if service uuid bt uuid GATTSERVICEALERTNOTIFICATIONSERVICE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt alert category id tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt alert unread count tvb offset 1 ENCNA offset 1 break case 0x2 A46 if service uuid bt uuid GATTSERVICEALERTNOTIFICATIONSERVICE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt alert category id tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt alert number of new alert tvb offset 1 ENCNA offset 1 if tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt alert text string information tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A49 if service uuid bt uuid GATTSERVICEBLOODPRESSURE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt blood pressure feature ett btatt value hfx btatt blood pressure feature ENCLITTLEENDIAN offset 2 break case 0x2 A4 A if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt hogp bcd hid tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt hogp b country code tvb offset 1 ENCNA offset 1 proto tree add bitmask tree tvb offset hf btatt hogp flags ett btatt value hfx btatt hogp flags ENCNA offset 1 break case 0x2 A4 B if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break offset dissect usb hid get report descriptor pinfo tree tvb offset NULL break case 0x2 A4 C if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt hogp hid control point command tvb offset 1 ENCNA offset 1 break case 0x2 A4 D if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A4 E if service uuid bt uuid GATTSERVICEHUMANINTERFACEDEVICE if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt hogp protocol mode tvb offset 1 ENCNA offset 1 break case 0x2 A4 F if service uuid bt uuid GATTSERVICESCANPARAMETERS if att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt le scan interval tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt le scan window tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A50 if service uuid bt uuid GATTSERVICEDEVICEINFORMATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt pnp id vendor id source tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 1 proto tree add item tree hf btatt pnp id vendor id bluetooth sig tvb offset 2 ENCLITTLEENDIAN else if value 2 proto tree add item tree hf btatt pnp id vendor id usb forum tvb offset 2 ENCLITTLEENDIAN else proto tree add item tree hf btatt pnp id vendor id tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt pnp id product id tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt pnp id product version tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A51 if service uuid bt uuid GATTSERVICEGLUCOSE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt glucose feature ett btatt value hfx btatt glucose feature ENCLITTLEENDIAN offset 2 break case 0x2 A52 if service uuid bt uuid GATTSERVICEGLUCOSE service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING service uuid bt uuid GATTSERVICEPULSEOXIMETER if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt record access control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt record access control point operator tvb offset 1 ENCNA operator value tvb get guint8 tvb offset offset 1 sub item proto tree add item tree hf btatt record access control point operand tvb offset 0 ENCNA sub tree proto item add subtree sub item ett btatt list operand offset offset switch opcode case 1 case 2 case 4 switch operator value case 0 case 1 case 5 case 6 break case 2 proto tree add item sub tree hf btatt record access control point operand filter type tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 0x01 proto tree add item sub tree hf btatt record access control point operand max time offset tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item sub tree hf btatt value tvb offset 1 ENCNA offset tvb captured length tvb break case 3 proto tree add item sub tree hf btatt record access control point operand filter type tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 0x01 proto tree add item sub tree hf btatt record access control point operand min time offset tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item sub tree hf btatt value tvb offset 1 ENCNA offset tvb captured length tvb break case 4 proto tree add item sub tree hf btatt record access control point operand filter type tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 if value 0x01 proto tree add item sub tree hf btatt record access control point operand min time offset tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt record access control point operand max time offset tvb offset 2 ENCLITTLEENDIAN offset 2 else proto tree add item sub tree hf btatt value tvb offset 1 ENCNA offset tvb captured length tvb break break case 3 break case 5 proto tree add item sub tree hf btatt record access control point operand number of records tvb offset 2 ENCLITTLEENDIAN offset 2 break case 6 proto tree add item sub tree hf btatt record access control point request opcode tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt record access control point response code tvb offset 1 ENCNA offset 1 break proto item set len sub item offset operand offset break case 0x2 A53 if service uuid bt uuid GATTSERVICERUNNINGSPEEDANDCADENCE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt rsc measurement flags ett btatt value hfx btatt rsc measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt rsc measurement instantaneous speed tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt rsc measurement instantaneous cadence tvb offset 1 ENCNA offset 1 if flags 0x01 proto tree add item tree hf btatt rsc measurement instantaneous stride length tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt rsc measurement total distance tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A54 if service uuid bt uuid GATTSERVICERUNNINGSPEEDANDCADENCE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt rsc feature ett btatt value hfx btatt rsc feature ENCLITTLEENDIAN offset 2 break case 0x2 A55 if service uuid bt uuid GATTSERVICERUNNINGSPEEDANDCADENCE service uuid bt uuid GATTSERVICECYCLINGSPEEDANDCADENCE if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt sc control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 1 proto tree add item tree hf btatt sc control point cumulative value tvb offset 4 ENCLITTLEENDIAN offset 4 break case 3 proto tree add item tree hf btatt sensor location tvb offset 1 ENCNA offset 1 break case 16 proto tree add item tree hf btatt sc control point request opcode tvb offset 1 ENCNA value tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt sc control point response value tvb offset 1 ENCNA offset 1 if value 0x04 tvb get guint8 tvb offset 0x01 while tvb captured length remaining tvb offset proto tree add item tree hf btatt sensor location tvb offset 1 ENCNA offset 1 break case 2 case 4 break break case 0x2 A56 if service uuid bt uuid GATTSERVICEAUTOMATIONIO if is readable request att data opcode is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt digital tvb offset 1 ENCNA offset 1 break case 0x2 A58 if service uuid bt uuid GATTSERVICEAUTOMATIONIO if is readable request att data opcode is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt analog tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A5 A if service uuid bt uuid GATTSERVICEAUTOMATIONIO if is readable request att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break btatt call dissector by dissector name with data btgatt uuid0x2a56 tvb new subset length caplen tvb offset 1 1 pinfo tree att data offset 1 btatt call dissector by dissector name with data btgatt uuid0x2a58 tvb new subset length caplen tvb offset 2 2 pinfo tree att data offset 2 break case 0x2 A5 B if service uuid bt uuid GATTSERVICECYCLINGSPEEDANDCADENCE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt csc measurement flags ett btatt value hfx btatt csc measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt csc measurement cumulative wheel revolutions tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt csc measurement last event time tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt csc measurement cumulative crank revolutions tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt csc measurement last event time tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A5 C if service uuid bt uuid GATTSERVICECYCLINGSPEEDANDCADENCE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt csc feature ett btatt value hfx btatt csc feature ENCLITTLEENDIAN offset 2 break case 0x2 A5 D if service uuid bt uuid GATTSERVICERUNNINGSPEEDANDCADENCE service uuid bt uuid GATTSERVICECYCLINGSPEEDANDCADENCE service uuid bt uuid GATTSERVICECYCLINGPOWER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt sensor location tvb offset 1 ENCNA offset 1 break case 0x2 A5 E if service uuid bt uuid GATTSERVICEPULSEOXIMETER if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt plx spot check measurement flags ett btatt value hfx btatt plx spot check measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 sub item proto tree add item tree hf btatt plx spo2pr spot check tvb offset 4 ENCNA sub tree proto item add subtree sub item ett btatt value proto tree add item sub tree hf btatt plx spo2 tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt plx pulse rate tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x01 sub item proto tree add item tree hf btatt plx spot check measurement timestamp tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt value btatt call dissector by dissector name with data btgatt uuid0x2a08 tvb new subset length caplen tvb offset 7 7 pinfo sub tree att data offset 7 if flags 0x02 proto tree add bitmask tree tvb offset hf btatt plx measurement status ett btatt value hfx btatt plx measurement status ENCLITTLEENDIAN offset 2 if flags 0x04 proto tree add bitmask tree tvb offset hf btatt plx device and sensor status ett btatt value hfx btatt plx device and sensor status ENCLITTLEENDIAN offset 3 if flags 0x08 proto tree add item tree hf btatt plx pulse amplitude index tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A5 F if service uuid bt uuid GATTSERVICEPULSEOXIMETER if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt plx continuous measurement flags ett btatt value hfx btatt plx continuous measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 sub item proto tree add item tree hf btatt plx spo2pr normal tvb offset 4 ENCNA sub tree proto item add subtree sub item ett btatt value proto tree add item sub tree hf btatt plx spo2 tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt plx pulse rate tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x01 sub item proto tree add item tree hf btatt plx spo2pr fast tvb offset 4 ENCNA sub tree proto item add subtree sub item ett btatt value proto tree add item sub tree hf btatt plx spo2 tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt plx pulse rate tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 sub item proto tree add item tree hf btatt plx spo2pr slow tvb offset 4 ENCNA sub tree proto item add subtree sub item ett btatt value proto tree add item sub tree hf btatt plx spo2 tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt plx pulse rate tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x04 proto tree add bitmask tree tvb offset hf btatt plx measurement status ett btatt value hfx btatt plx measurement status ENCLITTLEENDIAN offset 2 if flags 0x08 proto tree add bitmask tree tvb offset hf btatt plx device and sensor status ett btatt value hfx btatt plx device and sensor status ENCLITTLEENDIAN offset 3 if flags 0x10 proto tree add item tree hf btatt plx pulse amplitude index tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A60 if service uuid bt uuid GATTSERVICEPULSEOXIMETER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt plx features supported features ett btatt value hfx btatt plx features supported features ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add bitmask tree tvb offset hf btatt plx measurement status ett btatt value hfx btatt plx measurement status ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add bitmask tree tvb offset hf btatt plx device and sensor status ett btatt value hfx btatt plx device and sensor status ENCLITTLEENDIAN offset 3 break case 0x2 A63 if service uuid bt uuid GATTSERVICECYCLINGPOWER if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt cycling power measurement flags ett btatt value hfx btatt cycling power measurement flags ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cycling power measurement instantaneous power tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add item tree hf btatt cycling power measurement pedal power balance tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt cycling power measurement accumulated torque tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x10 proto tree add item tree hf btatt cycling power measurement wheel revolution data cumulative wheel revolutions tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt cycling power measurement wheel revolution data last wheel event time tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x20 proto tree add item tree hf btatt cycling power measurement crank revolution data cumulative crank revolutions tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cycling power measurement crank revolution data last crank event time tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x40 proto tree add item tree hf btatt cycling power measurement extreme force magnitudes maximum force magnitude tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cycling power measurement extreme force magnitudes minimum force magnitude tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x80 proto tree add item tree hf btatt cycling power measurement extreme torque magnitudes maximum torque magnitude tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cycling power measurement extreme torque magnitudes minimum torque magnitude tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x100 proto tree add bitmask tree tvb offset hf btatt cycling power measurement extreme angles ett btatt value hfx btatt cycling power measurement extreme angles ENCNA offset 3 if flags 0x200 proto tree add item tree hf btatt cycling power measurement top dead spot angle tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x400 proto tree add item tree hf btatt cycling power measurement bottom dead spot angle tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x800 proto tree add item tree hf btatt cycling power measurement accumulated energy tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A64 if service uuid bt uuid GATTSERVICECYCLINGPOWER if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt cycling power vector flags ett btatt value hfx btatt cycling power vector flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt cycling power vector crank revolution data cumulative crank revolutions tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cycling power vector crank revolution data last crank event time tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt cycling power vector first crank measurement angle tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x04 while tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt cycling power vector instantaneous force magnitude array tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x08 while tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt cycling power vector instantaneous torque magnitude array tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A65 if service uuid bt uuid GATTSERVICECYCLINGPOWER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt cycling power feature ett btatt value hfx btatt cycling power feature ENCLITTLEENDIAN offset 4 break case 0x2 A66 if service uuid bt uuid GATTSERVICECYCLINGPOWER if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt cycling power control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 1 proto tree add item tree hf btatt cycling power control point cumulative value tvb offset 4 ENCLITTLEENDIAN offset 4 break case 2 proto tree add item tree hf btatt cycling power control point sensor location tvb offset 1 ENCNA offset 1 break case 4 proto tree add item tree hf btatt cycling power control point crank length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 6 proto tree add item tree hf btatt cycling power control point chain length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 8 proto tree add item tree hf btatt cycling power control point chain weight tvb offset 2 ENCLITTLEENDIAN offset 2 break case 10 proto tree add item tree hf btatt cycling power control point span length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 13 proto tree add bitmask tree tvb offset hf btatt cycling power control point content mask ett btatt value hfx btatt cycling power control point content mask ENCLITTLEENDIAN offset 2 break case 3 case 5 case 7 case 9 case 11 case 12 case 14 case 15 break case 32 proto tree add item tree hf btatt cycling power control point request opcode tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt cycling power control point response value tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset 2 case 1 case 2 case 4 case 6 case 8 case 10 case 13 break case 3 if tvb get guint8 tvb offset 1 0x01 while tvb captured length remaining tvb offset proto tree add item tree hf btatt sensor location tvb offset 1 ENCNA offset 1 break case 5 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point crank length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 7 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point chain length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 9 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point chain weight tvb offset 2 ENCLITTLEENDIAN offset 2 break case 11 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point span length tvb offset 2 ENCLITTLEENDIAN offset 2 break case 12 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point start offset compensation tvb offset 2 ENCLITTLEENDIAN offset 2 break case 14 if tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt cycling power control point sampling rate tvb offset 1 ENCNA offset 1 break case 15 if tvb get guint8 tvb offset 1 0x01 sub item proto tree add item tree hf btatt cycling power control point factory calibration date tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 break break break case 0x2 A67 if service uuid bt uuid GATTSERVICELOCATIONANDNAVIGATION if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt location and speed flags ett btatt value hfx btatt location and speed flags ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add item tree hf btatt location and speed instantaneous speed tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt location and speed total distance tvb offset 3 ENCLITTLEENDIAN offset 3 if flags 0x04 proto tree add item tree hf btatt location and speed location latitude tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt location and speed location longitude tvb offset 4 ENCLITTLEENDIAN offset 4 if flags 0x08 proto tree add item tree hf btatt location and speed elevation tvb offset 3 ENCLITTLEENDIAN offset 3 if flags 0x10 proto tree add item tree hf btatt location and speed heading tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x20 proto tree add item tree hf btatt location and speed rolling time tvb offset 1 ENCNA offset 1 if flags 0x40 sub item proto tree add item tree hf btatt location and speed utc time tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 break case 0x2 A68 if service uuid bt uuid GATTSERVICELOCATIONANDNAVIGATION if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt navigation flags ett btatt value hfx btatt navigation flags ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt navigation bearing tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt navigation heading tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add item tree hf btatt navigation remaining distance tvb offset 3 ENCLITTLEENDIAN offset 3 if flags 0x02 proto tree add item tree hf btatt navigation remaining vertical distance tvb offset 3 ENCLITTLEENDIAN offset 3 if flags 0x04 sub item proto tree add item tree hf btatt navigation estimated time of arrival tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 break case 0x2 A69 if service uuid bt uuid GATTSERVICELOCATIONANDNAVIGATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt position quality flags ett btatt value hfx btatt position quality flags ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add item tree hf btatt position quality number of beacons in solution tvb offset 1 ENCNA offset 1 if flags 0x02 proto tree add item tree hf btatt position quality number of beacons in view tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt position quality time to first fix tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x08 proto tree add item tree hf btatt position quality ehpe tvb offset 4 ENCLITTLEENDIAN offset 4 if flags 0x10 proto tree add item tree hf btatt position quality evpe tvb offset 4 ENCLITTLEENDIAN offset 4 if flags 0x20 proto tree add item tree hf btatt position quality hdop tvb offset 1 ENCNA offset 1 if flags 0x40 proto tree add item tree hf btatt position quality vdop tvb offset 1 ENCNA offset 1 break case 0x2 A6 A if service uuid bt uuid GATTSERVICELOCATIONANDNAVIGATION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt ln feature ett btatt value hfx btatt ln feature ENCLITTLEENDIAN offset 4 break case 0x2 A6 B if service uuid bt uuid GATTSERVICELOCATIONANDNAVIGATION if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ln control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 1 proto tree add item tree hf btatt ln control point cumulative value tvb offset 3 ENCLITTLEENDIAN offset 3 break case 2 proto tree add bitmask tree tvb offset hf btatt ln control point content mask ett btatt value hfx btatt ln control point content mask ENCLITTLEENDIAN offset 2 break case 3 proto tree add item tree hf btatt ln control point navigation control tvb offset 1 ENCNA offset 1 break case 4 break case 5 case 6 proto tree add item tree hf btatt ln control point route number tvb offset 2 ENCLITTLEENDIAN offset 2 break case 7 proto tree add item tree hf btatt ln control point fix rate tvb offset 1 ENCNA offset 1 break case 8 proto tree add item tree hf btatt ln control point elevation tvb offset 3 ENCLITTLEENDIAN offset 3 break case 32 proto tree add item tree hf btatt ln control point request opcode tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt ln control point response value tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset 2 case 1 case 2 case 3 case 6 case 7 case 8 break case 4 proto tree add item tree hf btatt ln control point response value number of routes tvb offset 2 ENCLITTLEENDIAN offset 2 break case 5 proto tree add item tree hf btatt ln control point response value name of route tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break break break case 0x2 A6 C if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt elevation tvb offset 3 ENCLITTLEENDIAN offset 3 break case 0x2 A6 D if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt pressure tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A6 E if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt temperature tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A6 F if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt humidity tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A70 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt true wind speed tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A71 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt true wind direction tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A72 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt apparent wind speed tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A73 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt apparent wind direction tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A74 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt gust factor tvb offset 1 ENCNA offset 1 break case 0x2 A75 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt pollen concentration tvb offset 3 ENCLITTLEENDIAN offset 3 break case 0x2 A76 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt uv index tvb offset 1 ENCNA offset 1 break case 0x2 A77 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt irradiance tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A78 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt rainfall tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A79 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt wind chill tvb offset 1 ENCNA offset 1 break case 0x2 A7 A if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt heart index tvb offset 1 ENCNA offset 1 break case 0x2 A7 B if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt dew point tvb offset 1 ENCNA offset 1 break case 0x2 A7 D if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt descriptor value changed flags ett btatt value hfx btatt descriptor value changed flags ENCLITTLEENDIAN offset 2 if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt uuid16 tvb offset 2 ENCLITTLEENDIAN offset 2 else if tvb reported length remaining tvb offset 16 proto tree add item tree hf btatt uuid128 tvb offset 16 ENCNA offset 16 else sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt bad data offset tvb captured length tvb break case 0x2 A7 E if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt aerobic heart rate lower limit tvb offset 1 ENCNA offset 1 break case 0x2 A7 F if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt aerobic threshold tvb offset 1 ENCNA offset 1 break case 0x2 A80 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt age tvb offset 1 ENCNA offset 1 break case 0x2 A81 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt anaerobic heart rate lower limit tvb offset 1 ENCNA offset 1 break case 0x2 A82 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt anaerobic heart rate upper limit tvb offset 1 ENCNA offset 1 break case 0x2 A83 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt anaerobic threshold tvb offset 1 ENCNA offset 1 break case 0x2 A84 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt aerobic heart rate upper limit tvb offset 1 ENCNA offset 1 break case 0x2 A85 case 0x2 A86 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt day tvb offset 1 ENCNA offset 1 break case 0x2 A87 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt email address tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A88 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt fat burn heart rate lower limit tvb offset 1 ENCNA offset 1 break case 0x2 A89 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt fat burn heart rate upper limit tvb offset 1 ENCNA offset 1 break case 0x2 A8 A if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt first name tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A8 B if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt five zone heart rate limits very light light limit tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt five zone heart rate limits light moderate limit tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt five zone heart rate limits moderate hard limit tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt five zone heart rate limits hard maximum limit tvb offset 1 ENCNA offset 1 break case 0x2 A8 C if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt gender tvb offset 1 ENCNA offset 1 break case 0x2 A8 D if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt heart rate max tvb offset 1 ENCNA offset 1 break case 0x2 A8 E if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt height tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A8 F if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt hip circumference tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A90 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt last name tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A91 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt maximum recommended heart rate tvb offset 1 ENCNA offset 1 break case 0x2 A92 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt resting heart rate tvb offset 1 ENCNA offset 1 break case 0x2 A93 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt sport type for aerobic and anaerobic thresholds tvb offset 1 ENCNA offset 1 break case 0x2 A94 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt three zone heart rate limits light moderate tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt three zone heart rate limits moderate hard tvb offset 1 ENCNA offset 1 break case 0x2 A95 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt two zone heart rate limit fat burn fitness tvb offset 1 ENCNA offset 1 break case 0x2 A96 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt vo2 max tvb offset 1 ENCNA offset 1 break case 0x2 A97 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt waist circumference tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A98 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt weight tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A99 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt database change increment tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A9 A if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt user index tvb offset 1 ENCNA offset 1 break case 0x2 A9 B if service uuid bt uuid GATTSERVICEBODYCOMPOSITION if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt body composition feature ett btatt value hfx btatt body composition feature ENCLITTLEENDIAN offset 4 break case 0x2 A9 C if service uuid bt uuid GATTSERVICEBODYCOMPOSITION if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt body composition measurement flags ett btatt value hfx btatt body composition measurement flags ENCLITTLEENDIAN flags tvb get guint16 tvb offset ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt body composition measurement body fat percentage tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 sub item proto tree add item tree hf btatt body composition measurement timestamp tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt body composition measurement user id tvb offset 1 ENCNA offset 1 if flags 0x08 proto tree add item sub tree hf btatt body composition measurement basal metabolism tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x10 proto tree add item sub tree hf btatt body composition measurement muscle percentage tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x20 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement muscle mass lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement muscle mass kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x40 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement fat free mass lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement fat free mass kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x80 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement soft lean mass lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement soft lean mass kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x100 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement body water mass lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement body water mass kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x200 proto tree add item sub tree hf btatt body composition measurement impedance tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x400 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement weight lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement weight kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x800 if flags 0x01 proto tree add item sub tree hf btatt body composition measurement height inches tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt body composition measurement height meter tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A9 D if service uuid bt uuid GATTSERVICEWEIGHTSCALE if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt weight measurement flags ett btatt value hfx btatt weight measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 if flags 0x01 proto tree add item tree hf btatt weight measurement weight lb tvb offset 2 ENCLITTLEENDIAN else proto tree add item tree hf btatt weight measurement weight kg tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 sub item proto tree add item tree hf btatt weight measurement timestamp tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 if flags 0x04 proto tree add item tree hf btatt weight measurement user id tvb offset 1 ENCNA offset 1 if flags 0x08 proto tree add item sub tree hf btatt weight measurement bmi tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x01 proto tree add item sub tree hf btatt weight measurement height in tvb offset 2 ENCLITTLEENDIAN else proto tree add item sub tree hf btatt weight measurement height m tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A9 E if service uuid bt uuid GATTSERVICEWEIGHTSCALE if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt weight scale feature ett btatt value hfx btatt weight scale feature ENCLITTLEENDIAN offset 4 break case 0x2 A9 F if service uuid bt uuid GATTSERVICEUSERDATA if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt user control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 0x01 sub item proto tree add item tree hf btatt user control point consent code tvb offset 2 ENCLITTLEENDIAN value tvb get guint16 tvb offset ENCLITTLEENDIAN if value 9999 expert add info pinfo sub item ei btatt consent out of bounds offset 2 break case 0x02 proto tree add item tree hf btatt user index tvb offset 1 ENCNA offset 1 sub item proto tree add item tree hf btatt user control point consent code tvb offset 2 ENCLITTLEENDIAN value tvb get guint16 tvb offset ENCLITTLEENDIAN if value 9999 expert add info pinfo sub item ei btatt consent out of bounds offset 2 break case 0x03 break case 0x20 proto tree add item tree hf btatt user control point request opcode tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt user control point response value tvb offset 1 ENCNA offset 1 if tvb get guint8 tvb offset 2 0x01 tvb get guint8 tvb offset 1 0x01 proto tree add item tree hf btatt user index tvb offset 1 ENCNA offset 1 break break case 0x2 A A0 case 0x2 A A1 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt magnetic flux density x tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt magnetic flux density y tvb offset 2 ENCLITTLEENDIAN offset 2 if uuid bt uuid 0x2 A A1 proto tree add item tree hf btatt magnetic flux density z tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A A2 if service uuid bt uuid GATTSERVICEUSERDATA if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt language tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A A3 if service uuid bt uuid GATTSERVICEENVIRONMENTALSENSING if is readable request att data opcode break if is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt barometric pressure trend tvb offset 1 ENCNA offset 1 break case 0x2 A A4 if service uuid bt uuid GATTSERVICEBONDMANAGEMENT if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt bond management control point opcode tvb offset 1 ENCNA offset 1 if tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt bond management control point authorization code tvb offset length 1 ENCNAENCUTF 8 offset tvb reported length remaining tvb offset break case 0x2 A A5 if service uuid bt uuid GATTSERVICEBONDMANAGEMENT if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt bond management feature ett btatt value hfx btatt bond management feature ENCLITTLEENDIAN flags tvb get guint24 tvb offset ENCLITTLEENDIAN offset 3 if flags 0x800000 do proto tree add bitmask tree tvb offset hf btatt bond management feature nth ett btatt value hfx btatt bond management feature nth ENCLITTLEENDIAN offset 1 while tvb get guint8 tvb offset 1 0x80 break case 0x2 A A6 if service uuid bt uuid GATTSERVICEGENERICACCESSPROFILE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt central address resolution tvb offset 1 ENCNA offset 1 break case 0x2 A A7 if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt cgm measurement size tvb offset 1 ENCNA if tvb get guint8 tvb offset 6 expert add info pinfo sub item ei btatt cgm size too small offset 1 proto tree add bitmask tree tvb offset hf btatt cgm measurement flags ett btatt value hfx btatt cgm measurement flags ENCNA flags tvb get guint8 tvb offset offset 1 proto tree add item tree hf btatt cgm measurement glucose concentration tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item tree hf btatt cgm measurement time offset tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x E0 value 0 if flags 0x80 value 1 if flags 0x40 value 1 if flags 0x20 value 1 sub item proto tree add item tree hf btatt cgm sensor status annunciation tvb offset value ENCNA sub tree proto item add subtree sub item ett btatt list if flags 0x80 proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation status ett btatt value hfx btatt cgm sensor status annunciation status ENCNA offset 1 if flags 0x40 proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation cal temp ett btatt value hfx btatt cgm sensor status annunciation cal temp ENCNA offset 1 if flags 0x20 proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation warning ett btatt value hfx btatt cgm sensor status annunciation warning ENCNA offset 1 if flags 0x01 proto tree add item tree hf btatt cgm measurement trend information tvb offset 2 ENCLITTLEENDIAN offset 2 if flags 0x02 proto tree add item tree hf btatt cgm measurement quality tvb offset 2 ENCLITTLEENDIAN offset 2 if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A A8 if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt cgm feature feature ett btatt value hfx btatt cgm feature feature ENCLITTLEENDIAN offset 3 proto tree add bitmask tree tvb offset hf btatt cgm type and sample location ett btatt value hfx btatt cgm type and sample location ENCNA offset 1 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A A9 if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt cgm time offset tvb offset 2 ENCLITTLEENDIAN offset 2 sub item proto tree add item tree hf btatt cgm status tvb offset 3 ENCLITTLEENDIAN sub tree proto item add subtree sub item ett btatt list proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation status ett btatt value hfx btatt cgm sensor status annunciation status ENCNA offset 1 proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation cal temp ett btatt value hfx btatt cgm sensor status annunciation cal temp ENCNA offset 1 proto tree add bitmask sub tree tvb offset hf btatt cgm sensor status annunciation warning ett btatt value hfx btatt cgm sensor status annunciation warning ENCNA offset 1 if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 AAA if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt cgm session start time tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt list proto tree add item sub tree hf btatt year tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt month tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt day tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt hours tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt minutes tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt seconds tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt timezone tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt dst offset tvb offset 1 ENCNA offset 1 if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 AAB if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt cgm session run time tvb offset 2 ENCLITTLEENDIAN offset 2 if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 AAC if service uuid bt uuid GATTSERVICECONTINUOUSGLUCOSEMONITORING if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt cgm specific ops control point opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 sub item proto tree add item tree hf btatt cgm specific ops control point operand tvb offset 0 ENCNA sub tree proto item add subtree sub item ett btatt list operand offset offset switch opcode case 1 proto tree add item sub tree hf btatt cgm specific ops control point operand communication interval tvb offset 1 ENCNA offset 1 break case 2 case 8 case 11 case 14 case 17 case 20 case 23 case 25 case 26 case 27 break case 4 proto tree add item sub tree hf btatt cgm specific ops control point calibration glucose concentration tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt cgm specific ops control point calibration time tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add bitmask sub tree tvb offset hf btatt cgm type and sample location ett btatt value hfx btatt cgm type and sample location ENCNA offset 1 proto tree add item sub tree hf btatt cgm specific ops control point next calibration time tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt cgm specific ops control point calibration data record number tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add bitmask sub tree tvb offset hf btatt cgm specific ops control point calibration status ett btatt value hfx btatt cgm specific ops control point calibration status ENCNA offset 1 break case 5 proto tree add item sub tree hf btatt cgm specific ops control point operand calibration data record number tvb offset 2 ENCLITTLEENDIAN offset 2 break case 7 case 10 case 13 case 16 proto tree add item sub tree hf btatt cgm specific ops control point operand alert level tvb offset 2 ENCLITTLEENDIAN offset 2 break case 19 case 22 proto tree add item sub tree hf btatt cgm specific ops control point operand alert level rate tvb offset 2 ENCLITTLEENDIAN offset 2 break case 3 case 6 case 9 case 12 case 15 case 18 case 21 case 24 expert add info pinfo sub item ei btatt opcode invalid request break case 28 proto tree add item sub tree hf btatt cgm specific ops control point request opcode tvb offset 1 ENCNA offset 1 proto tree add item sub tree hf btatt cgm specific ops control point response code tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset 2 case 1 case 2 case 4 case 5 case 7 case 8 case 10 case 11 case 13 case 14 case 16 case 17 case 19 case 20 case 22 case 23 case 25 case 26 case 27 expert add info pinfo sub item ei btatt opcode invalid response break case 3 proto tree add item sub tree hf btatt cgm specific ops control point operand communication interval tvb offset 1 ENCNA offset 1 break case 6 proto tree add item sub tree hf btatt cgm specific ops control point calibration glucose concentration tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt cgm specific ops control point calibration time tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add bitmask sub tree tvb offset hf btatt cgm type and sample location ett btatt value hfx btatt cgm type and sample location ENCNA offset 1 proto tree add item sub tree hf btatt cgm specific ops control point next calibration time tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add item sub tree hf btatt cgm specific ops control point calibration data record number tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add bitmask sub tree tvb offset hf btatt cgm specific ops control point calibration status ett btatt value hfx btatt cgm specific ops control point calibration status ENCNA offset 1 break case 9 case 12 case 15 case 18 proto tree add item sub tree hf btatt cgm specific ops control point operand alert level tvb offset 2 ENCLITTLEENDIAN offset 2 break case 21 case 24 proto tree add item sub tree hf btatt cgm specific ops control point operand alert level rate tvb offset 2 ENCLITTLEENDIAN offset 2 break break proto item set len sub item offset operand offset if tvb reported length remaining tvb offset 2 proto tree add item tree hf btatt cgm e2e crc tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 AAD if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt indoor positioning configuration ett btatt value hfx btatt indoor positioning configuration ENCNA offset 1 break case 0x2 AAE if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt latitude tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 AAF if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt longitude tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A B0 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt local north coordinate tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A B1 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt local east coordinate tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A B2 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt floor number tvb offset 1 ENCNA offset 1 break case 0x2 A B3 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt altitude tvb offset 2 ENCLITTLEENDIAN offset 2 break case 0x2 A B4 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt uncertainty ett btatt value hfx btatt uncertainty ENCNA offset 1 break case 0x2 A B5 if service uuid bt uuid GATTSERVICEINDOORPOSITIONING if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode att data opcode ATTOPCODEWRITECOMMAND expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt location name tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A B6 if service uuid bt uuid GATTSERVICEHTTPPROXY if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt uri tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 A B7 if service uuid bt uuid GATTSERVICEHTTPPROXY if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt http headers tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 sub tree proto item add subtree sub item ett btatt value call dissector http handle tvb new subset remaining tvb offset pinfo sub tree offset tvb captured length remaining tvb offset break case 0x2 A B8 if service uuid bt uuid GATTSERVICEHTTPPROXY if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt http status code tvb offset 2 ENCLITTLEENDIAN offset 2 proto tree add bitmask tree tvb offset hf btatt http data status ett btatt value hfx btatt http data status ENCNA offset 1 break case 0x2 A B9 if service uuid bt uuid GATTSERVICEHTTPPROXY if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt http entity body tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 ABA if service uuid bt uuid GATTSERVICEHTTPPROXY if is writeable response att data opcode break if is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt http control point opcode tvb offset 1 ENCNA offset 1 break case 0x2 ABB if service uuid bt uuid GATTSERVICEHTTPPROXY if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt https security tvb offset 1 ENCNA offset 1 break case 0x2 ABC if service uuid bt uuid GATTSERVICETRANSPORTDISCOVERY if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt tds opcode tvb offset 1 ENCNA offset 1 if att data opcode 0x1 B att data opcode 0x1 D proto tree add item tree hf btatt tds result code tvb offset 1 ENCNA offset 1 else proto tree add item tree hf btatt tds organization id tvb offset 1 ENCNA offset 1 if tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt tds data tvb offset tvb reported length remaining tvb offset ENCNA offset tvb reported length remaining tvb offset break case 0x2 ABD if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt ots feature oacp ett btatt value hfx btatt ots feature oacp ENCLITTLEENDIAN offset 4 proto tree add bitmask tree tvb offset hf btatt ots feature olcp ett btatt value hfx btatt ots feature olcp ENCLITTLEENDIAN offset 4 break case 0x2 ABE if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots object name tvb offset tvb captured length remaining tvb offset ENCNAENCUTF 8 offset tvb captured length remaining tvb offset break case 0x2 ABF if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break offset dissect gatt uuid tree pinfo tvb offset break case 0x2 A C0 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots current size tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt ots allocated size tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A C1 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt ots object first created tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt value btatt call dissector by dissector name with data btgatt uuid0x2a08 tvb new subset length caplen tvb offset 7 7 pinfo sub tree att data offset 7 break case 0x2 A C2 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt ots object last modified tvb offset 7 ENCNA sub tree proto item add subtree sub item ett btatt value btatt call dissector by dissector name with data btgatt uuid0x2a08 tvb new subset length caplen tvb offset 7 7 pinfo sub tree att data offset 7 break case 0x2 A C3 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode break if is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots object id tvb offset 6 ENCLITTLEENDIAN offset 6 break case 0x2 A C4 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt ots properties ett btatt value hfx btatt ots properties ENCLITTLEENDIAN offset 4 break case 0x2 A C5 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots action opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 0x01 proto tree add item tree hf btatt ots size tvb offset 4 ENCLITTLEENDIAN offset 4 offset dissect gatt uuid tree pinfo tvb offset break case 0x02 case 0x07 break case 0x03 case 0x05 case 0x06 proto tree add item tree hf btatt ots offset tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt ots length tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x04 if tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt ots execute data tvb offset tvb reported length remaining tvb offset ENCNAENCUTF 8 offset tvb reported length remaining tvb offset break case 0x60 proto tree add item tree hf btatt ots action response opcode tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt ots action result code tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset case 0x01 case 0x02 case 0x05 case 0x06 case 0x07 case 0x60 break case 0x03 proto tree add checksum tree tvb offset hf btatt ots checksum 1 NULL pinfo 0 ENCBIGENDIANPROTOCHECKSUMNOFLAGS offset 4 break case 0x04 if tvb reported length remaining tvb offset 0 proto tree add item tree hf btatt ots execute data tvb offset tvb reported length remaining tvb offset ENCNAENCUTF 8 offset tvb reported length remaining tvb offset break break case 0x2 A C6 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots list opcode tvb offset 1 ENCNA opcode tvb get guint8 tvb offset offset 1 switch opcode case 0x01 case 0x02 case 0x03 case 0x04 case 0x07 case 0x08 break case 0x05 proto tree add item tree hf btatt ots object id tvb offset 6 ENCLITTLEENDIAN offset 6 break case 0x06 proto tree add item tree hf btatt ots list order tvb offset 1 ENCNA offset 1 break case 0x70 proto tree add item tree hf btatt ots list response opcode tvb offset 1 ENCNA offset 1 proto tree add item tree hf btatt ots list result code tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset 2 case 0x01 case 0x02 case 0x03 case 0x04 case 0x05 case 0x06 case 0x08 case 0x70 break case 0x07 proto tree add item tree hf btatt ots list total number of objects tvb offset 4 ENCLITTLEENDIAN offset 4 break case 0x2 A C7 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if is readable request att data opcode is writeable response att data opcode break if is readable response att data opcode is writeable request att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt ots filter tvb offset 1 ENCNA offset 1 switch tvb get guint8 tvb offset 1 case 0x00 case 0x0 A break case 0x01 case 0x02 case 0x03 case 0x04 proto tree add item tree hf btatt ots name string tvb offset tvb reported length remaining tvb offset ENCNAENCUTF 8 offset tvb reported length remaining tvb offset break case 0x05 offset dissect gatt uuid tree pinfo tvb offset break case 0x06 case 0x07 btatt call dissector by dissector name with data btgatt uuid0x2a08 tvb new subset length caplen tvb offset 7 7 pinfo tree att data offset 7 btatt call dissector by dissector name with data btgatt uuid0x2a08 tvb new subset length caplen tvb offset 7 7 pinfo tree att data offset 7 break case 0x08 case 0x09 proto tree add item tree hf btatt ots size from tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf btatt ots size to tvb offset 4 ENCLITTLEENDIAN offset 4 break break case 0x2 A C8 if service uuid bt uuid GATTSERVICEOBJECTTRANSFER if att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add bitmask tree tvb offset hf btatt ots flags ett btatt value hfx btatt ots flags ENCNA offset 1 proto tree add item tree hf btatt ots object id tvb offset 6 ENCLITTLEENDIAN offset 6 break case 0x2 A C9 if service uuid bt uuid GATTSERVICEGENERICACCESSPROFILE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt resolvable private address tvb offset 1 ENCNA offset 1 break case 0x2 ACC if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 ACD if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 ACE if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 ACF if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D0 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D1 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D2 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D3 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D4 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D5 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D6 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D7 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D8 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is readable request att data opcode is readable response att data opcode expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A D9 if service uuid bt uuid GATTSERVICEFITNESSMACHINE if is writeable response att data opcode att data opcode ATTOPCODEHANDLEVALUECONFIRMATION break if is writeable request att data opcode att data opcode ATTOPCODEHANDLEVALUEINDICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 ADA if service uuid bt uuid GATTSERVICEFITNESSMACHINE if att data opcode ATTOPCODEHANDLEVALUENOTIFICATION expert add info pinfo tree ei btatt invalid usage if bluetooth gatt has no parameter att data opcode break sub item proto tree add item tree hf btatt value tvb offset 1 ENCNA expert add info pinfo sub item ei btatt undecoded offset tvb captured length tvb break case 0x2 A1 F case 0x2 A20 case 0x2 A2 F case 0x2 A30 case 0x2 A3 A case 0x2 A3 B case 0x2 A3 C case 0x2 A3 D case 0x2 A3 E case 0x2 A57 case 0x2 A59 case 0x2 ADB case 0x2 ADC case 0x2 ADD case 0x2 ADE case 0x2 A E0 case 0x2 A E1 case 0x2 A E2 case 0x2 A E3 case 0x2 A E4 case 0x2 A E5 case 0x2 A E6 case 0x2 A E7 case 0x2 A E8 case 0x2 A E9 case 0x2 AEA case 0x2 AEB case 0x2 AEC case 0x2 AED case 0x2 AEE case 0x2 AEF case 0x2 A F0 case 0x2 A F1 case 0x2 A F2 case 0x2 A F3 case 0x2 A F4 case 0x2 A F5 case 0x2 A F6 case 0x2 A F7 case 0x2 A F8 case 0x2 A F9 case 0x2 AFA case 0x2 AFB case 0x2 AFC case 0x2 AFD case 0x2 AFE case 0x2 AFF case 0x2 B00 case 0x2 B01 case 0x2 B02 case 0x2 B03 case 0x2 B04 case 0x2 B05 case 0x2 B06 case 0x2 B07 case 0x2 B08 case 0x2 B09 case 0x2 B0 A case 0x2 B0 B case 0x2 B0 C case 0x2 B0 D case 0x2 B0 E case 0x2 B0 F case 0x2 B10 case 0x2 B11 case 0x2 B12 case 0x2 B13 case 0x2 B14 case 0x2 B15 case 0x2 B16 case 0x2 B17 case 0x2 B18 case 0x2 B19 case 0x2 B1 A case 0x2 B1 B case 0x2 B1 C case 0x2 B1 D case 0x2 B1 E case 0x2 B1 F default if bluetooth gatt has no parameter att data opcode break proto tree add item tree hf btatt value tvb offset 1 ENCNA offset tvb captured length tvb return old offset offset static int select input picture Mpeg Enc Context s int i ret for i 1 i MAXPICTURECOUNT i s reordered input picture i 1 s reordered input picture i s reordered input picture MAXPICTURECOUNT 1 NULL if s reordered input picture 0 NULL s input picture 0 if s next picture ptr NULL s intra only s reordered input picture 0 s input picture 0 s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f coded picture number s coded picture number else int b frames if s avctx frame skip threshold s avctx frame skip factor if s picture in gop number s gop size skip check s s input picture 0 s next picture ptr av frame unref s input picture 0 f emms c ff vbv update s 0 goto no output pic if s flags CODECFLAGPAS S2 for i 0 i s max b frames 1 i int pict num s input picture 0 f display picture number i if pict num s rc context num entries break if s input picture i s rc context entry pict num 1 new pict type AVPICTURETYPEP break s input picture i f pict type s rc context entry pict num new pict type if s avctx b frame strategy 0 b frames s max b frames while b frames s input picture b frames b frames else if s avctx b frame strategy 1 for i 1 i s max b frames 1 i if s input picture i s input picture i b frame score 0 s input picture i b frame score get intra count s s input picture i f data 0 s input picture i 1 f data 0 s linesize 1 for i 0 i s max b frames 1 i if s input picture i NULL s input picture i b frame score 1 s mb num s avctx b sensitivity break b frames FFMAX 0 i 1 for i 0 i b frames 1 i s input picture i b frame score 0 else if s avctx b frame strategy 2 b frames estimate best b count s else av log s avctx AVLOGERROR illegal b frame strategy n b frames 0 emms c for i b frames 1 i 0 i int type s input picture i f pict type if type type AVPICTURETYPEB b frames i if s input picture b frames f pict type AVPICTURETYPEB b frames s max b frames av log s avctx AVLOGERROR warning too many b frames in a row n if s picture in gop number b frames s gop size if s mpv flags FFMPVFLAGSTRICTGOP s gop size s picture in gop number b frames s gop size s picture in gop number 1 else if s flags CODECFLAGCLOSEDGOP b frames 0 s input picture b frames f pict type AVPICTURETYPEI if s flags CODECFLAGCLOSEDGOP b frames s input picture b frames f pict type AVPICTURETYPEI b frames s reordered input picture 0 s input picture b frames if s reordered input picture 0 f pict type AVPICTURETYPEI s reordered input picture 0 f pict type AVPICTURETYPEP s reordered input picture 0 f coded picture number s coded picture number for i 0 i b frames i s reordered input picture i 1 s input picture i s reordered input picture i 1 f pict type AVPICTURETYPEB s reordered input picture i 1 f coded picture number s coded picture number no output pic if s reordered input picture 0 s reordered input picture 0 reference s reordered input picture 0 f pict type AVPICTURETYPEB 3 0 ff mpeg unref picture s s new picture if ret ff mpeg ref picture s s new picture s reordered input picture 0 return ret if s reordered input picture 0 shared s avctx rc buffer size Picture pic int i ff find unused picture s 0 if i 0 return i pic s picture i pic reference s reordered input picture 0 reference if ff alloc picture s pic 0 0 return 1 copy picture attributes s pic f s reordered input picture 0 f av frame unref s reordered input picture 0 f s reordered input picture 0 shared 0 s current picture ptr pic else s current picture ptr s reordered input picture 0 for i 0 i 4 i s new picture f data i INPLACEOFFSET ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret s picture number s new picture f display picture number else ff mpeg unref picture s s new picture return 0 int ff h264 decode mb cabac H264 Context h int mb xy int mb type partition count cbp 0 int dct8x8 allowed h pps transform 8x8 mode int decode chroma h sps chroma format idc 1 h sps chroma format idc 2 const int pixel shift h pixel shift mb xy h mb xy h mb x h mb y h mb stride tprintf h avctx pic d mb d d n h frame num h mb x h mb y if h slice type nos AVPICTURETYPEI int skip if FRAMEMBAFF h mb y 1 1 h prev mb skipped skip h next mb skipped else skip decode cabac mb skip h h mb x h mb y if skip if FRAMEMBAFF h mb y 1 0 h cur pic mb type mb xy MBTYPESKIP h next mb skipped decode cabac mb skip h h mb x h mb y 1 if h next mb skipped h mb mbaff h mb field decoding flag decode cabac field decoding flag h decode mb skip h h cbp table mb xy 0 h chroma pred mode table mb xy 0 h last qscale diff 0 return 0 if FRAMEMBAFF if h mb y 1 0 h mb mbaff h mb field decoding flag decode cabac field decoding flag h h prev mb skipped 0 fill decode neighbors h MBFIELD if h slice type nos AVPICTURETYPEB int ctx 0 assert h slice type nos AVPICTURETYPEB if ISDIRECT h left type LTOP 1 ctx if ISDIRECT h top type 1 ctx if get cabac noinline h cabac h cabac state 27 ctx mb type 0 else if get cabac noinline h cabac h cabac state 27 3 mb type 1 get cabac noinline h cabac h cabac state 27 5 else int bits bits get cabac noinline h cabac h cabac state 27 4 3 bits get cabac noinline h cabac h cabac state 27 5 2 bits get cabac noinline h cabac h cabac state 27 5 1 bits get cabac noinline h cabac h cabac state 27 5 if bits 8 mb type bits 3 else if bits 13 mb type decode cabac intra mb type h 32 0 goto decode intra mb else if bits 14 mb type 11 else if bits 15 mb type 22 else bits bits 1 get cabac noinline h cabac h cabac state 27 5 mb type bits 4 partition count b mb type info mb type partition count mb type b mb type info mb type type else if h slice type nos AVPICTURETYPEP if get cabac noinline h cabac h cabac state 14 0 if get cabac noinline h cabac h cabac state 15 0 mb type 3 get cabac noinline h cabac h cabac state 16 else mb type 2 get cabac noinline h cabac h cabac state 17 partition count p mb type info mb type partition count mb type p mb type info mb type type else mb type decode cabac intra mb type h 17 0 goto decode intra mb else mb type decode cabac intra mb type h 3 1 if h slice type AVPICTURETYPESI mb type mb type assert h slice type nos AVPICTURETYPEI decode intra mb partition count 0 cbp i mb type info mb type cbp h intra16x16 pred mode i mb type info mb type pred mode mb type i mb type info mb type type if MBFIELD mb type MBTYPEINTERLACED h slice table mb xy h slice num if ISINTRAPCM mb type const int mb size ff h264 mb sizes h sps chroma format idc h sps bit depth luma 3 const uint8 t ptr ptr h cabac bytestream if h cabac low 0x1 ptr if CABACBITS 16 if h cabac low 0x1 FF ptr if int h cabac bytestream end ptr mb size return 1 h intra pcm ptr ptr ptr mb size ff init cabac decoder h cabac ptr h cabac bytestream end ptr h cbp table mb xy 0xf7ef h chroma pred mode table mb xy 0 h cur pic qscale table mb xy 0 memset h non zero count mb xy 16 48 h cur pic mb type mb xy mb type h last qscale diff 0 return 0 fill decode caches h mb type if ISINTRA mb type int i pred mode if ISINTR A4x4 mb type if dct8x8 allowed get cabac noinline h cabac h cabac state 399 h neighbor transform size mb type MBTYPE 8x8 DCT for i 0 i 16 i 4 int pred pred intra mode h i int mode decode cabac mb intra4x4 pred mode h pred fill rectangle h intra4x4 pred mode cache scan8 i 2 2 8 mode 1 else for i 0 i 16 i int pred pred intra mode h i h intra4x4 pred mode cache scan8 i decode cabac mb intra4x4 pred mode h pred av dlog h avctx i4x4 pred d mode d n pred h intra4x4 pred mode cache scan8 i write back intra pred mode h if ff h264 check intra4x4 pred mode h 0 return 1 else h intra16x16 pred mode ff h264 check intra pred mode h h intra16x16 pred mode 0 if h intra16x16 pred mode 0 return 1 if decode chroma h chroma pred mode table mb xy pred mode decode cabac mb chroma pre mode h pred mode ff h264 check intra pred mode h pred mode 1 if pred mode 0 return 1 h chroma pred mode pred mode else h chroma pred mode DC 128 PRE D8x8 else if partition count 4 int i j sub partition count 4 list ref 2 4 if h slice type nos AVPICTURETYPEB for i 0 i 4 i h sub mb type i decode cabac b mb sub type h sub partition count i b sub mb type info h sub mb type i partition count h sub mb type i b sub mb type info h sub mb type i type if ISDIRECT h sub mb type 0 h sub mb type 1 h sub mb type 2 h sub mb type 3 ff h264 pred direct motion h mb type h ref cache 0 scan8 4 h ref cache 1 scan8 4 h ref cache 0 scan8 12 h ref cache 1 scan8 12 PARTNOTAVAILABLE for i 0 i 4 i fill rectangle h direct cache scan8 4 i 2 2 8 h sub mb type i 1 0x FF 1 else for i 0 i 4 i h sub mb type i decode cabac p mb sub type h sub partition count i p sub mb type info h sub mb type i partition count h sub mb type i p sub mb type info h sub mb type i type for list 0 list h list count list for i 0 i 4 i if ISDIRECT h sub mb type i continue if ISDIR h sub mb type i 0 list int rc h ref count list MBMBAFF if rc 1 ref list i decode cabac mb ref h list 4 i if ref list i unsigned rc av log h avctx AVLOGERROR Reference d d n ref list i rc return 1 else ref list i 0 else ref list i 1 h ref cache list scan8 4 i 1 h ref cache list scan8 4 i 8 h ref cache list scan8 4 i 9 ref list i if dct8x8 allowed dct8x8 allowed get dct8x8 allowed h for list 0 list h list count list for i 0 i 4 i h ref cache list scan8 4 i h ref cache list scan8 4 i 1 if ISDIRECT h sub mb type i fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 continue if ISDIR h sub mb type i 0 list ISDIRECT h sub mb type i const int sub mb type h sub mb type i const int block width sub mb type MBTYPE 16x16 MBTYPE 16x8 2 1 for j 0 j sub partition count i j int mpx mpy int mx my const int index 4 i block width j int16 t mv cache 2 h mv cache list scan8 index uint8 t mvd cache 2 h mvd cache list scan8 index pred motion h index block width list h ref cache list scan8 index mx my DECODECABACMBMVD h list index tprintf h avctx final mv d d n mx my if ISSUB 8 X8 sub mb type mv cache 1 0 mv cache 8 0 mv cache 9 0 mx mv cache 1 1 mv cache 8 1 mv cache 9 1 my mvd cache 1 0 mvd cache 8 0 mvd cache 9 0 mpx mvd cache 1 1 mvd cache 8 1 mvd cache 9 1 mpy else if ISSUB 8 X4 sub mb type mv cache 1 0 mx mv cache 1 1 my mvd cache 1 0 mpx mvd cache 1 1 mpy else if ISSUB 4 X8 sub mb type mv cache 8 0 mx mv cache 8 1 my mvd cache 8 0 mpx mvd cache 8 1 mpy mv cache 0 0 mx mv cache 0 1 my mvd cache 0 0 mpx mvd cache 0 1 mpy else fill rectangle h mv cache list scan8 4 i 2 2 8 0 4 fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 else if ISDIRECT mb type ff h264 pred direct motion h mb type fill rectangle h mvd cache 0 scan8 0 4 4 8 0 2 fill rectangle h mvd cache 1 scan8 0 4 4 8 0 2 dct8x8 allowed h sps direct 8x8 inference flag else int list i if IS 16 X16 mb type for list 0 list h list count list if ISDIR mb type 0 list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 0 if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 4 4 8 ref 1 for list 0 list h list count list if ISDIR mb type 0 list int mx my mpx mpy pred motion h 0 4 list h ref cache list scan8 0 mx my DECODECABACMBMVD h list 0 tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 4 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 4 4 8 pack16to32 mx my 4 else if IS 16 X8 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 8 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 16 i 4 2 8 ref 1 else fill rectangle h ref cache list scan8 0 16 i 4 2 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 16x8 motion h 8 i list h ref cache list scan8 0 16 i mx my DECODECABACMBMVD h list 8 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 16 i 4 2 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 16 i 4 2 8 0 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 0 4 else assert IS 8 X16 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 4 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 2 i 2 4 8 ref 1 else fill rectangle h ref cache list scan8 0 2 i 2 4 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 8x16 motion h i 4 list h ref cache list scan8 0 2 i mx my DECODECABACMBMVD h list 4 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 2 i 2 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 2 i 2 4 8 0 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 0 4 if ISINTER mb type h chroma pred mode table mb xy 0 write back motion h mb type if ISINTR A16x16 mb type cbp decode cabac mb cbp luma h if decode chroma cbp decode cabac mb cbp chroma h 4 h cbp table mb xy h cbp cbp if dct8x8 allowed cbp 15 ISINTRA mb type mb type MBTYPE 8x8 DCT get cabac noinline h cabac h cabac state 399 h neighbor transform size if CHROM A444 IS 8x8 DCT mb type int i uint8 t nnz cache h non zero count cache for i 0 i 2 i if h left type LEFT i IS 8x8 DCT h left type LEFT i nnz cache 3 8 1 2 8 i nnz cache 3 8 2 2 8 i nnz cache 3 8 6 2 8 i nnz cache 3 8 7 2 8 i nnz cache 3 8 11 2 8 i nnz cache 3 8 12 2 8 i ISINTRA mb type 64 0 if h top type IS 8x8 DCT h top type uint32 t top empty CABACISINTRA mb type 0 0x40404040 AVW N32 A nnz cache 4 8 0 top empty AVW N32 A nnz cache 4 8 5 top empty AVW N32 A nnz cache 4 8 10 top empty h cur pic mb type mb xy mb type if cbp ISINTR A16x16 mb type const uint8 t scan scan8x8 const uint32 t qmul if ISINTERLACED mb type scan8x8 h qscale h field scan8x8 h field scan8x8 q0 scan h qscale h field scan h field scan q0 else scan8x8 h qscale h zigzag scan8x8 h zigzag scan8x8 q0 scan h qscale h zigzag scan h zigzag scan q0 if get cabac noinline h cabac h cabac state 60 h last qscale diff 0 int val 1 int ctx 2 const int max qp 51 6 h sps bit depth luma 8 while get cabac noinline h cabac h cabac state 60 ctx ctx 3 val if val 2 max qp av log h avctx AVLOGERROR cabac decode of qscale diff failed at d d n h mb x h mb y return 1 if val 0x01 val val 1 1 else val val 1 1 h last qscale diff val h qscale val if unsigned h qscale max qp if h qscale 0 h qscale max qp 1 else h qscale max qp 1 h chroma qp 0 get chroma qp h 0 h qscale h chroma qp 1 get chroma qp h 1 h qscale else h last qscale diff 0 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 0 if CHROM A444 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 1 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 2 else if CHROM A422 if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc 422 h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma422 dc scan 8 if cbp 0x20 int c i i8x8 for c 0 c 2 c int16 t mb h mb 16 16 16 c pixel shift qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i8x8 0 i8x8 2 i8x8 for i 0 i 4 i const int index 16 16 c 8 i8x8 i decode cabac residual nondc h mb 4 index scan 1 qmul 15 mb 16 pixel shift else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma dc scan 4 if cbp 0x20 int c i for c 0 c 2 c qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i 0 i 4 i const int index 16 16 c i decode cabac residual nondc h h mb 16 index pixel shift 4 index scan 1 qmul 15 else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else fill rectangle h non zero count cache scan8 0 4 4 8 0 1 fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 h last qscale diff 0 h cur pic qscale table mb xy h qscale write back non zero count h return 0 static inline int get current cpu ARMMP Timer State s CPU State cpu single cpu ENVGETCPU cpu single env if cpu single cpu cpu index s num cpu hw error arm mptimer num cpu d but this cpu is d n s num cpu cpu single cpu cpu index return cpu single cpu cpu index static int key notify policy flush const struct km event c struct sk buff skb out struct sadb msg hdr skb out alloc skb sizeof struct sadb msg 16 GFPATOMIC if skb out return ENOBUFS hdr struct sadb msg skb put skb out sizeof struct sadb msg hdr sadb msg type SADBXSPDFLUSH hdr sadb msg seq c seq hdr sadb msg pid c portid hdr sadb msg version PFKEY V2 hdr sadb msg errno uint8 t 0 hdr sadb msg satype SADBSATYPEUNSPEC hdr sadb msg len sizeof struct sadb msg sizeof uint64 t pfkey broadcast skb out GFPATOMICBROADCASTALLNULL c net return 0 static int aes gcm ctrl EVPCIPHERCTX c int type int arg void ptr EVPAESGCMCTX gctx EVPCDATAEVPAESGCMCTX c switch type case EVPCTRLINIT gctx key set 0 gctx iv set 0 gctx ivlen EVPCIPHERCTX iv length c gctx iv EVPCIPHERCTX iv noconst c gctx taglen 1 gctx iv gen 0 gctx tls aad len 1 return 1 case EVPCTRLAEADSETIVLEN if arg 0 return 0 if arg EVPMAXIVLENGTH arg gctx ivlen if gctx iv EVPCIPHERCTX iv noconst c OPENSSL free gctx iv gctx iv OPENSSL malloc arg if gctx iv NULL return 0 gctx ivlen arg return 1 case EVPCTRLAEADSETTAG if arg 0 arg 16 EVPCIPHERCTX encrypting c return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg gctx taglen arg return 1 case EVPCTRLAEADGETTAG if arg 0 arg 16 EVPCIPHERCTX encrypting c gctx taglen 0 return 0 memcpy ptr EVPCIPHERCTX buf noconst c arg return 1 case EVPCTRLGCMSETIVFIXED if arg 1 memcpy gctx iv ptr gctx ivlen gctx iv gen 1 return 1 if arg 4 gctx ivlen arg 8 return 0 if arg memcpy gctx iv ptr arg if EVPCIPHERCTX encrypting c RAND bytes gctx iv arg gctx ivlen arg 0 return 0 gctx iv gen 1 return 1 case EVPCTRLGCMIVGEN if gctx iv gen 0 gctx key set 0 return 0 CRYPTO gcm128 setiv gctx gcm gctx iv gctx ivlen if arg 0 arg gctx ivlen arg gctx ivlen memcpy ptr gctx iv gctx ivlen arg arg ctr64 inc gctx iv gctx ivlen 8 gctx iv set 1 return 1 case EVPCTRLGCMSETIVINV if gctx iv gen 0 gctx key set 0 EVPCIPHERCTX encrypting c return 0 memcpy gctx iv gctx ivlen arg ptr arg CRYPTO gcm128 setiv gctx gcm gctx iv gctx ivlen gctx iv set 1 return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg gctx tls aad len arg unsigned int len EVPCIPHERCTX buf noconst c arg 2 8 EVPCIPHERCTX buf noconst c arg 1 if len EVPGCMTLSEXPLICITIVLEN return 0 len EVPGCMTLSEXPLICITIVLEN if EVPCIPHERCTX encrypting c if len EVPGCMTLSTAGLEN return 0 len EVPGCMTLSTAGLENEVPCIPHERCTX buf noconst c arg 2 len 8 EVPCIPHERCTX buf noconst c arg 1 len 0xff return EVPGCMTLSTAGLEN case EVPCTRLCOPYEVPCIPHERCTX out ptr EVPAESGCMCTX gctx out EVPCDATAEVPAESGCMCTX out if gctx gcm key if gctx gcm key gctx ks return 0 gctx out gcm key gctx out ks if gctx iv EVPCIPHERCTX iv noconst c gctx out iv EVPCIPHERCTX iv noconst out else gctx out iv OPENSSL malloc gctx ivlen if gctx out iv NULL return 0 memcpy gctx out iv gctx iv gctx ivlen return 1 default return 1 Selectivity scalararraysel containment Planner Info root Node leftop Node rightop Oid elemtype bool is Equality bool use Or int var Relid Selectivity selec Variable Stat Data vardata Datum constval Type Cache Entry typentry Fmgr Info cmpfunc examine variable root rightop var Relid vardata if vardata rel Release Variable Stats vardata return 1 0 if Is A leftop Const Release Variable Stats vardata return 1 0 if Const leftop constisnull Release Variable Stats vardata return Selectivity 0 0 constval Const leftop constvalue typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid Release Variable Stats vardata return 1 0 cmpfunc typentry cmp proc finfo if is Equality use Or use Or if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata cmpfunc fn oid Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if use Or get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 if use Or selec mcelem array contain overlap selec values nvalues numbers nnumbers constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec values nvalues numbers nnumbers constval 1 hist nhist OIDARRAYCONTAINEDOP cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc selec 1 0 stats stanullfrac else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc Release Variable Stats vardata if is Equality selec 1 0 selec CLAMPPROBABILITY selec return selec static int imc decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int ret i IMC Context q avctx priv data LOCALALIGNED 16 uint16 t buf16 IMCBLOCKSIZE 2 if buf size IMCBLOCKSIZE avctx channels av log avctx AVLOGERROR frame too small n return AVERRORINVALIDDATA frame nb samples COEFFS if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for i 0 i avctx channels i q out samples float frame extended data i q dsp bswap16 buf buf16 const uint16 t buf IMCBLOCKSIZE 2 init get bits q gb const uint8 t buf16 IMCBLOCKSIZE 8 buf IMCBLOCKSIZE if ret imc decode block avctx q i 0 return ret if avctx channels 2 q fdsp butterflies float float frame extended data 0 float frame extended data 1 COEFFS got frame ptr 1 return IMCBLOCKSIZE avctx channels static void MCFUNC hl motion H264 Context h uint8 t dest y uint8 t dest cb uint8 t dest cr qpel mc func qpix put 16 h264 chroma mc func chroma put qpel mc func qpix avg 16 h264 chroma mc func chroma avg h264 weight func weight op h264 biweight func weight avg const int mb xy h mb xy const int mb type h cur pic mb type mb xy assert ISINTER mb type if HAVETHREADS h avctx active thread type FFTHREADFRAME await references h prefetch motion h 0 PIXELSHIFTCHROMAIDC if IS 16 X16 mb type mc part h 0 1 16 0 dest y dest cb dest cr 0 0 qpix put 0 chroma put 0 qpix avg 0 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 else if IS 16 X8 mb type mc part h 0 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 0 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 8 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 4 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 1 0 ISDIR mb type 1 1 else if IS 8 X16 mb type mc part h 0 0 16 8 h mb linesize dest y dest cb dest cr 0 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 4 0 16 8 h mb linesize dest y dest cb dest cr 4 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 1 0 ISDIR mb type 1 1 else int i assert IS 8 X8 mb type for i 0 i 4 i const int sub mb type h sub mb type i const int n 4 i int x offset i 1 2 int y offset i 2 1 if ISSUB 8 X8 sub mb type mc part h n 1 8 0 dest y dest cb dest cr x offset y offset qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 8 X4 sub mb type mc part h n 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 2 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset 2 qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 4 X8 sub mb type mc part h n 0 8 4 h mb linesize dest y dest cb dest cr x offset y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 1 0 8 4 h mb linesize dest y dest cb dest cr x offset 2 y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else int j assert ISSUB 4 X4 sub mb type for j 0 j 4 j int sub x offset x offset 2 j 1 int sub y offset y offset j 2 mc part h n j 1 4 0 dest y dest cb dest cr sub x offset sub y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 prefetch motion h 1 static int myisamchk MICHECK param char filename int error lock type recreate int rep quick param testflag TQUICKTFORCEUNIQUENESSMIINFO info File datafile char llbuff 22 llbuff2 22 my bool state updated 0 MYISAMSHARE share DBUGENTER myisamchk param out flag error param warning printed param error printed recreate 0 datafile 0 param isam file name filename if info mi open filename param testflag TDESCRIPTTREADONLYORDONLYORDWRHAOPENFORREPAIR param testflag TWAITFOREVERHAOPENWAITIFLOCKED param testflag TDESCRIPTHAOPENIGNOREIFLOCKEDHAOPENABORTIFLOCKED param error printed 1 switch my errno case HAERRCRASHED mi check print error param s doesn t have a correct index definition You need to recreate it before you can do a repair filename break case HAERRNOTATABLE mi check print error param s is not a My ISAM table filename break case HAERRCRASHEDONUSAGE mi check print error param s is marked as crashed filename break case HAERRCRASHEDONREPAIR mi check print error param s is marked as crashed after last repair filename break case HAERROLDFILE mi check print error param s is an old type of My ISAM table filename break case HAERRENDOFFILE mi check print error param Couldn t read complete header from s filename break case EAGAIN mi check print error param s is locked Use w to wait until unlocked filename break case ENOENT mi check print error param File s doesn t exist filename break case EACCES mi check print error param You don t have permission to use s filename break default mi check print error param d when opening My ISAM table s my errno filename break DBUGRETURN 1 share info s share options HAOPTIONREADONLYDATA share tot locks share r locks share r locks 0 if param testflag TFASTTCHECKONLYCHANGED my bool need to check mi is crashed info share state open count 0 if param testflag TREPANYTSORTRECORDS share state changed STATECHANGEDSTATECRASHEDSTATECRASHEDONREPAIR param testflag TCHECKONLYCHANGED need to check 1 if info s base keys info state records if param testflag TSTATISTICS share state changed STATENOTANALYZED need to check 1 if param testflag TSORTINDEX share state changed STATENOTSORTEDPAGES need to check 1 if param testflag TREPBYSORT share state changed STATENOTOPTIMIZEDKEYS need to check 1 if param testflag TCHECKONLYCHANGED share state changed STATECHANGEDSTATECRASHEDSTATECRASHEDONREPAIR need to check 1 if need to check if param testflag TSILENT param testflag TINFO printf My ISAM file s is already checked n filename if mi close info mi check print error param d when closing My ISAM table s my errno filename DBUGRETURN 1 DBUGRETURN 0 if param testflag TREPANYTSTATISTICSTSORTRECORDSTSORTINDEX param testflag TUNPACK share data file type COMPRESSEDRECORD mi uint2korr share state header state info length MISTATEINFOSIZE mi uint2korr share state header base info length MIBASEINFOSIZE mi is any intersect keys active param keys in use share base keys share state key map test if almost full info info s state header file version 3 myisam file magic 3 set collation set collation number share state header language myisam block size MIKEYBLOCKLENGTH if set collation param language set collation number if recreate table param info filename void fprintf stderr My ISAM table s is not fixed because of errors n filename return 1 recreate 1 if param testflag TREPANY param testflag TREPBYSORT if param testflag TSILENT printf s has old table format Recreating index n filename rep quick TQUICK share info s share tot locks share r locks share r locks 0 if param testflag TDESCRIPT param total files param total records info state records param total deleted info state del descript param info filename else if stopwords inited ft init stopwords if param testflag TREADONLY lock type FWRLCK else lock type FRDLCK if info lock type FRDLCK info lock type FUNLCK if mi readinfo info lock type 0 mi check print error param Can t lock indexfile of s error d filename my errno param error printed 0 goto end2 mi lock database info FEXTRALCK datafile info dfile if param testflag TREPANYTSORTRECORDSTSORTINDEX if param testflag TREPANY ulonglong tmp share state key map mi copy keys active share state key map share base keys param keys in use if tmp share state key map info update HASTATECHANGED if rep quick chk del param info param testflag TVERBOSE if param testflag TFORCECREATE rep quick 0 mi check print info param Creating new data file n else error 1 mi check print error param Quick recover aborted Run recovery without switch q if error if param testflag TREPBYSORTTREPPARALLEL mi is any key active share state key map rep quick param keys in use recreate mi test if sort rep info info state records info s state key map param force sort if param testflag TREPBYSORT error mi repair by sort param info filename rep quick else error mi repair parallel param info filename rep quick state updated 1 else if param testflag TREPANY error mi repair param info filename rep quick if error param testflag TSORTRECORDS void my close info dfile MYFMYWME error change to newfile filename MINAMEDEXTDATATMPEXTMYF 0 if mi open datafile info info s NULL 1 error 1 param out flag ONEWDATA param read cache file info dfile uint key my bool update index 1 for key 0 key share base keys key if share keyinfo key flag HABINARYPACKKEYHAFULLTEXT update index 0 error mi sort records param info filename param opt sort key my bool param testflag TREP update index datafile info dfile if error update index if param verbose puts Table had a compressed index We must now recreate the index error mi repair by sort param info filename 1 if error param testflag TSORTINDEX error mi sort index param info filename if error share state changed STATECHANGEDSTATECRASHEDSTATECRASHEDONREPAIR else mi mark crashed info static void model rd for sb V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum int i int64 t rate sum 0 int64 t dist sum 0 const int ref xd mi 0 src mi mbmi ref frame 0 unsigned int sse unsigned int var 0 unsigned int sum sse 0 const int shift 8 int rate int64 t dist x pred sse ref 0 for i 0 i MAXMBPLANE i struct macroblock plane const p x plane i struct macroblockd plane const pd xd plane i const BLOCKSIZE bs get plane block size bsize pd const TXSIZE max tx size max txsize lookup bs const BLOCKSIZE unit size txsize to bsize max tx size int bw 1 b width log2 lookup bs b width log2 lookup unit size int bh 1 b height log2 lookup bs b width log2 lookup unit size int idx idy int lw b width log2 lookup unit size 2 int lh b height log2 lookup unit size 2 sum sse 0 for idy 0 idy bh idy for idx 0 idx bw idx uint8 t src p src buf idy p src stride lh idx lw uint8 t dst pd dst buf idy pd dst stride lh idx lh int block idx idy 1 idx var cpi fn ptr unit size vf src p src stride dst pd dst stride sse x bsse i 2 block idx sse sum sse sse if x select tx size if x bsse i 2 block idx p quant thred 0 shift x skip txfm i 2 block idx 1 else if var p quant thred 1 shift x skip txfm i 2 block idx 2 else x skip txfm i 2 block idx 0 if i 0 x pred sse ref sse if cpi oxcf speed 4 int64 t rate int64 t dist int64 t square error sse int quantizer pd dequant 1 3 if quantizer 120 rate square error 280 quantizer 8 else rate 0 dist square error quantizer 8 rate sum rate dist sum dist else vp9 model rd from var lapndz sum sse 1 num pels log2 lookup bs pd dequant 1 3 rate dist rate sum rate dist sum dist out rate sum int rate sum out dist sum dist sum 4 static struct cvec range struct vars v celt a celt b int cases int nchrs struct cvec cv celt c cc if a b before a b ERRREGERANGE return NULL if cases cv getcvec v 0 1 NOERRN addrange cv a b return cv nchrs b a 1 if nchrs 0 nchrs 100000 nchrs 100000 cv getcvec v nchrs 1 NOERRN addrange cv a b for c a c b c cc pg wc tolower chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc cc pg wc toupper chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc if CANCELREQUESTED v re ERRREGCANCEL return NULL return cv int ff mpeg4 set direct mv Mpeg Enc Context s int mx int my const int mb index s mb x s mb y s mb stride const int colocated mb type s next picture mb type mb index uint16 t time pp uint16 t time pb int i if IS 8 X8 colocated mb type s mv type MVTYPE 8 X8 for i 0 i 4 i ff mpeg4 set one direct mv s mx my i return MBTYPEDIREC T2 MBTYPE 8x8 MBTYPE L0 L1 else if ISINTERLACED colocated mb type s mv type MVTYPEFIELD for i 0 i 2 i int field select s next picture ref index 0 4 mb index 2 i s field select 0 i field select s field select 1 i i if s top field first time pp s pp field time field select i time pb s pb field time field select i else time pp s pp field time field select i time pb s pb field time field select i s mv 0 i 0 s p field mv table i 0 mb index 0 time pb time pp mx s mv 0 i 1 s p field mv table i 0 mb index 1 time pb time pp my s mv 1 i 0 mx s mv 0 i 0 s p field mv table i 0 mb index 0 s p field mv table i 0 mb index 0 time pb time pp time pp s mv 1 i 1 my s mv 0 i 1 s p field mv table i 0 mb index 1 s p field mv table i 0 mb index 1 time pb time pp time pp return MBTYPEDIREC T2 MBTYPE 16x8 MBTYPE L0 L1 MBTYPEINTERLACED else ff mpeg4 set one direct mv s mx my 0 s mv 0 1 0 s mv 0 2 0 s mv 0 3 0 s mv 0 0 0 s mv 0 1 1 s mv 0 2 1 s mv 0 3 1 s mv 0 0 1 s mv 1 1 0 s mv 1 2 0 s mv 1 3 0 s mv 1 0 0 s mv 1 1 1 s mv 1 2 1 s mv 1 3 1 s mv 1 0 1 if s avctx workaround bugs FFBUGDIRECTBLOCKSIZE s quarter sample s mv type MVTYPE 16 X16 else s mv type MVTYPE 8 X8 return MBTYPEDIREC T2 MBTYPE 16x16 MBTYPE L0 L1 static void encode block int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd struct optimize ctx const ctx args ctx struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block int i j uint8 t dst ENTROPYCONTEXT a l txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j pd dst stride 4 i a ctx ta plane i l ctx tl plane j if x zcoeff blk tx size block plane 0 p eobs block 0 a l 0 return if x skip recode if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 if x quant fp vp9 xform quant fp x plane block plane bsize tx size else vp9 xform quant x plane block plane bsize tx size else if x skip txfm plane 2 block tx size 1 2 vp9 xform quant dc x plane block plane bsize tx size else p eobs block 0 a l 0 return else vp9 xform quant x plane block plane bsize tx size if x optimize x skip recode x skip optimize const int ctx combine entropy contexts a l a l optimize b x plane block tx size ctx 0 else a l p eobs block 0 if p eobs block args skip 0 if x skip encode p eobs block 0 return switch tx size case TX 32 X32 vp9 idct32x32 add dqcoeff dst pd dst stride p eobs block break case TX 16 X16 vp9 idct16x16 add dqcoeff dst pd dst stride p eobs block break case TX 8 X8 vp9 idct8x8 add dqcoeff dst pd dst stride p eobs block break case TX 4 X4 x itxm add dqcoeff dst pd dst stride p eobs block break default assert 0 Invalid transform size break static int dpcm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt int buf size avpkt size DPCM Context s avctx priv data AV Frame frame data int out 0 ret int predictor 2 int ch 0 int stereo avctx channels 1 int16 t output samples samples end Get Byte Context gb if stereo buf size 1 buf size bytestream2 init gb avpkt data buf size switch avctx codec id case AVCODECIDROQDPCM out buf size 8 break case AVCODECIDINTERPLAYDPCM out buf size 6 avctx channels break case AVCODECIDXANDPCM out buf size 2 avctx channels break case AVCODECIDSOLDPCM if avctx codec tag 3 out buf size 2 else out buf size break if out 0 av log avctx AVLOGERROR packet is too small n return AVERROREINVAL frame nb samples out avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret output samples int16 t frame data 0 samples end output samples out switch avctx codec id case AVCODECIDROQDPCM bytestream2 skipu gb 6 if stereo predictor 1 sign extend bytestream2 get byteu gb 8 16 predictor 0 sign extend bytestream2 get byteu gb 8 16 else predictor 0 sign extend bytestream2 get le16u gb 16 while output samples samples end predictor ch s roq square array bytestream2 get byteu gb predictor ch av clip int16 predictor ch output samples predictor ch ch stereo break case AVCODECIDINTERPLAYDPCM bytestream2 skipu gb 6 for ch 0 ch avctx channels ch predictor ch sign extend bytestream2 get le16u gb 16 output samples predictor ch ch 0 while output samples samples end predictor ch interplay delta table bytestream2 get byteu gb predictor ch av clip int16 predictor ch output samples predictor ch ch stereo break case AVCODECIDXANDPCM int shift 2 4 4 for ch 0 ch avctx channels ch predictor ch sign extend bytestream2 get le16u gb 16 ch 0 while output samples samples end int diff bytestream2 get byteu gb int n diff 3 if n 3 shift ch else shift ch 2 n diff sign extend diff 3 8 16 if shift ch 0 shift ch 0 diff shift ch predictor ch diff predictor ch av clip int16 predictor ch output samples predictor ch ch stereo break case AVCODECIDSOLDPCM if avctx codec tag 3 uint8 t output samples u8 frame data 0 samples end u8 output samples u8 out while output samples u8 samples end u8 int n bytestream2 get byteu gb s sample 0 s sol table n 4 s sample 0 av clip uint8 s sample 0 output samples u8 s sample 0 s sample stereo s sol table n 0x0 F s sample stereo av clip uint8 s sample stereo output samples u8 s sample stereo else while output samples samples end int n bytestream2 get byteu gb if n 0x80 s sample ch sol table 16 n 0x7 F else s sample ch sol table 16 n 0x7 F s sample ch av clip int16 s sample ch output samples s sample ch ch stereo break got frame ptr 1 return avpkt size static int pefromupx const char src uint32 t ssize char dst uint32 t dsize uint32 t ep uint32 t upx0 uint32 t upx1 uint32 t magic uint32 t dend char imports sections NULL pehdr NULL newbuf unsigned int sectcnt 0 upd 1 uint32 t realstuffsz 0 valign 0 uint32 t foffset 0xd0 0xf8 if dst NULL src NULL return 0 while valign magic sectcnt if ep upx1 valign ssize 5 src ep upx1 valign 2 x8d src ep upx1 valign 1 xbe break if valign ep upx1 0x80 ssize 8 const char pt src ep upx1 0x80 cli dbgmsg UPX bad magic scanning for imports n while pt cli memstr pt ssize pt src 8 x8d xbe 2 if pt 6 x8b pt 7 x07 valign pt src 2 ep upx1 break pt if valign CLIISCONTAINED src ssize src ep upx1 valign 4 imports dst cli readint32 src ep upx1 valign realstuffsz imports dst if realstuffsz dsize cli dbgmsg UPX wrong realstuff size n else pehdr imports while CLIISCONTAINED dst dsize pehdr 8 cli readint32 pehdr pehdr 8 while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr pehdr pehdr pehdr 4 if sections checkpe dst dsize pehdr valign sectcnt pehdr NULL if pehdr dend 0xf8 0x28 cli dbgmsg UPX no luck scanning for PE n pehdr dst dend 0xf8 0x28 while pehdr dst if sections checkpe dst dsize pehdr valign sectcnt break pehdr if realstuffsz pehdr dst pehdr NULL if pehdr uint32 t rebsz PESALIGN dend 0x1000 cli dbgmsg UPX no luck brutally crafing a reasonable PE n if newbuf char cli calloc rebsz 0x200 sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 FAKEPE 0x120 memcpy newbuf 0x200 dst dend memcpy dst newbuf dend 0x200 free newbuf cli writeint32 dst 0xd0 0x50 rebsz 0x1000 cli writeint32 dst 0xd0 0x100 rebsz cli writeint32 dst 0xd0 0x108 rebsz dsize rebsz 0x200 cli dbgmsg UPXPE structure added to uncompressed data n return 1 if sections sectcnt 0 foffset PESALIGN foffset 0x28 sectcnt valign for upd 0 upd sectcnt upd uint32 t vsize PESALIGN uint32 t cli readint32 sections 8 valign uint32 t urva PEALIGN uint32 t cli readint32 sections 12 valign if CLIISCONTAINED upx0 realstuffsz urva vsize cli dbgmsg UPX Sect d out of bounds giving up rebuild n upd return 0 cli writeint32 sections 8 vsize cli writeint32 sections 12 urva cli writeint32 sections 16 vsize cli writeint32 sections 20 foffset if foffset vsize foffset return 0 foffset vsize sections 0x28 cli writeint32 pehdr 8 0x4d414c43 cli writeint32 pehdr 0x3c valign if newbuf char cli calloc foffset sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 pehdr 0xf8 0x28 sectcnt sections pehdr 0xf8 for upd 0 upd sectcnt upd uint32 t offset1 offset2 offset3 offset1 uint32 t cli readint32 sections 20 offset2 uint32 t cli readint32 sections 16 if offset1 foffset offset2 foffset offset1 offset2 foffset free newbuf return 1 offset3 uint32 t cli readint32 sections 12 if offset3 upx0 dsize free newbuf return 1 memcpy newbuf offset1 dst offset3 upx0 offset2 sections 0x28 if foffset dsize 8192 cli dbgmsg UPX wrong raw size giving up rebuild n free newbuf return 0 memcpy dst newbuf foffset dsize foffset free newbuf cli dbgmsg UPXPE structure rebuilt from compressed file n return 1 static int tipc nl compat link dump struct tipc nl compat msg msg struct nlattr attrs struct nlattr link TIPCNLALINKMAX 1 struct tipc link info link info int err if attrs TIPCNLALINK return EINVAL err nla parse nested link TIPCNLALINKMAX attrs TIPCNLALINKNULL if err return err link info dest nla get flag link TIPCNLALINKDEST link info up htonl nla get flag link TIPCNLALINKUP strcpy link info str nla data link TIPCNLALINKNAME return tipc add tlv msg rep TIPCTLVLINKINFO link info sizeof link info static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Video XL Context const a avctx priv data AV Frame const p a pic uint8 t YUV int i j ret int stride uint32 t val int y0 y1 y2 y3 0 c0 0 c1 0 if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 Y a pic data 0 U a pic data 1 V a pic data 2 stride avctx width 4 if buf size avctx width avctx height av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA for i 0 i avctx height i buf stride for j 0 j avctx width j 4 val AVR L32 buf buf 4 val val 16 0x FFFF val 0x FFFF 16 if j y0 val 0x1 F 2 else y0 y3 xl table val 0x1 F val 5 y1 y0 xl table val 0x1 F val 5 y2 y1 xl table val 0x1 F val 6 y3 y2 xl table val 0x1 F val 5 if j c0 val 0x1 F 2 else c0 xl table val 0x1 F val 5 if j c1 val 0x1 F 2 else c1 xl table val 0x1 FY j 0 y0 1 Y j 1 y1 1 Y j 2 y2 1 Y j 3 y3 1 U j 2 c0 1 V j 2 c1 1 buf avctx width 4 Y a pic linesize 0 U a pic linesize 1 V a pic linesize 2 got frame 1 AV Frame data a pic return buf size void traverse commit list struct rev info revs show commit fn show commit show object fn show object void data int i struct commit commit struct strbuf base strbuf init base PATHMAX while commit get revision revs NULL if commit tree add pending tree revs commit tree show commit commit data for i 0 i revs pending nr i struct object array entry pending revs pending objects i struct object obj pending item const char name pending name const char path pending path if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN show object obj NULL name data continue if path path if obj type OBJTREE process tree revs struct tree obj show object NULL base path data continue if obj type OBJBLOB process blob revs struct blob obj show object NULL path data continue die unknown pending object s s oid to hex obj oid name object array clear revs pending strbuf release base static int mpeg decode frame AV Codec Context avctx void data int got output AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg1 Context s avctx priv data AV Frame picture data Mpeg Enc Context s2 s mpeg enc ctx av dlog avctx fill buffer n if buf size 0 buf size 4 AVR B32 buf SEQENDCODE if s2 low delay 0 s2 next picture ptr int ret av frame ref picture s2 next picture ptr f if ret 0 return ret s2 next picture ptr NULL got output 1 return buf size if s2 flags CODECFLAGTRUNCATED int next ff mpeg1 find frame end s2 parse context buf buf size NULL if ff combine frame s2 parse context next const uint8 t buf buf size 0 return buf size if s mpeg enc ctx allocated 0 avctx codec tag AVR L32 VC R2 vcr2 init sequence avctx s slice count 0 if avctx extradata s extradata decoded int ret decode chunks avctx picture got output avctx extradata avctx extradata size s extradata decoded 1 if ret 0 avctx err recognition AVEFEXPLODE return ret return decode chunks avctx picture got output buf buf size void do exec struct st command command int error char buf 512 FILE res file char cmd command first argument DYNAMICSTRING ds cmd DYNAMICSTRING ds sorted ds result DBUGENTER do exec DBUGPRINT enter cmd s cmd while cmd my isspace charset info cmd cmd if cmd report or die Missing argument in exec return command last argument command end init dynamic string ds cmd 0 command query len 256 256 do eval ds cmd cmd command end is windows if builtin echo 0 strncmp cmd echo 4 0 replace ds cmd echo 4 builtin echo strlen builtin echo while replace ds cmd 3 4 3 0 DBUGPRINT info Executing s as s command first argument ds cmd str if res file my popen ds cmd r dynstr free ds cmd if command abort on error report or die popen s r failed command first argument return ds result ds res if display result sorted init dynamic string ds sorted 1024 1024 ds result ds sorted while fgets buf sizeof buf res file if disable result log buf strlen buf 1 0 DBUGPRINT exec result s buf else replace dynstr append ds result buf error pclose res file if display result sorted dynstr append sorted ds res ds sorted 0 dynstr free ds sorted if error 0 uint status WEXITSTATUS error int i if command abort on error report or die exec of s failed error d status d errno d n Output from before failure n s n ds cmd str error status errno ds res str dynstr free ds cmd return DBUGPRINT info error d status d error status i match expected error command status NULL if i 0 DBUGPRINT info command s failed with expected error d command first argument status else dynstr free ds cmd if command expected errors count 0 report or die command s failed with wrong error d command first argument status else if command expected errors err 0 type ERRERRNO command expected errors err 0 code errnum 0 log msg exec of s failed error d errno d ds cmd str error errno dynstr free ds cmd report or die command s succeeded should have failed with errno d command first argument command expected errors err 0 code errnum dynstr free ds cmd void vp8 mbpost proc down c unsigned char dst int pitch int rows int cols int flimit int r c i const short rv3 vp8 rv 63 rand for c 0 c cols c unsigned char s dst c int sumsq 0 int sum 0 unsigned char d 16 const short rv2 rv3 c 17 127 for i 8 i 0 i s i pitch s 0 for i rows i rows 17 i s i pitch s rows 1 pitch for i 8 i 6 i sumsq s i pitch s i pitch sum s i pitch for r 0 r rows 8 r sumsq s 7 pitch s 7 pitch s 8 pitch s 8 pitch sum s 7 pitch s 8 pitch d r 15 s 0 if sumsq 15 sum sum flimit d r 15 rv2 r 127 sum s 0 4 if r 8 s 8 pitch d r 8 15 s pitch double histogram selectivity Variable Stat Data vardata Fmgr Info opproc Datum constval bool varonleft int min hist size int n skip int hist size double result Datum values int nvalues Assert n skip 0 Assert min hist size 2 n skip if Heap Tuple Is Valid vardata stats Tuple get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid NULL values nvalues NULLNULL hist size nvalues if nvalues min hist size int nmatch 0 int i for i n skip i nvalues n skip i if varonleft Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values i constval Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID constval values i nmatch result double nmatch double nvalues 2 n skip else result 1 free attstatsslot vardata atttype values nvalues NULL 0 else hist size 0 result 1 return result void vp9 mv pred V P9 COMP cpi MACROBLOCK x uint8 t ref y buffer int ref y stride int ref frame BLOCKSIZE block size MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi int i int zero seen 0 int best index 0 int best sad INTMAX int this sad INTMAX int max mv 0 uint8 t src y ptr x plane 0 src buf uint8 t ref y ptr const int num mv refs MAXMVREFCANDIDATES cpi sf adaptive motion search block size cpi sf max partition size MV pred mv 3 pred mv 0 mbmi ref mvs ref frame 0 as mv pred mv 1 mbmi ref mvs ref frame 1 as mv pred mv 2 x pred mv ref frame for i 0 i num mv refs i const MV this mv pred mv i max mv MAX max mv MAX abs this mv row abs this mv col 3 if is zero mv this mv zero seen continue zero seen is zero mv this mv ref y ptr ref y buffer ref y stride this mv row 3 this mv col 3 this sad cpi fn ptr block size sdf src y ptr x plane 0 src stride ref y ptr ref y stride if this sad best sad best sad this sad best index i x mv best ref index ref frame best index x max mv context ref frame max mv x pred mv sad ref frame best sad static void vc1 decode b mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i j int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 0 int val int first block 1 int dst idx off int fwd int dmv x 2 dmv y 2 pred flag 2 int bmvtype BMVTYPEBACKWARD int idx mbmode interpmvp mquant v pq s mb intra 0 idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 0 0 s current picture motion val 1 s block index 0 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 v mb type 0 s block index i s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if v fmb is raw fwd v forward mb plane mb pos get bits1 gb else fwd v forward mb plane mb pos if idx mbmode 5 dmv x 0 dmv x 1 dmv y 0 dmv y 1 0 pred flag 0 pred flag 1 0 if fwd bmvtype BMVTYPEFORWARD else bmvtype decode012 gb switch bmvtype case 0 bmvtype BMVTYPEBACKWARD break case 1 bmvtype BMVTYPEDIRECT break case 2 bmvtype BMVTYPEINTERPOLATED interpmvp get bits1 gb v bmvtype bmvtype if bmvtype BMVTYPEDIRECT idx mbmode 1 get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD if bmvtype BMVTYPEINTERPOLATED interpmvp get mvdata interlaced v dmv x 1 dmv y 1 pred flag 1 if bmvtype BMVTYPEDIRECT dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 0 0 vc1 pred b mv intfi v 0 dmv x dmv y 1 pred flag vc1 b mc v dmv x dmv y bmvtype BMVTYPEDIRECT bmvtype mb has coeffs idx mbmode 2 else if fwd bmvtype BMVTYPEFORWARD v bmvtype bmvtype v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 1 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD vc1 pred b mv intfi v i dmv x dmv y 0 pred flag vc1 mc 4mv luma v i bmvtype BMVTYPEBACKWARD else if i 4 vc1 mc 4mv chroma v bmvtype BMVTYPEBACKWARD mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAYNULL if v ttmbf ttmb 8 ttmb 1 first block 0 static void inverse transform block MACROBLOCKD xd int plane int block TXSIZE tx size uint8 t dst int stride int eob struct macroblockd plane const pd xd plane plane if eob 0 TXTYPE tx type DCTDCT tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block if xd lossless tx type DCTDCT vp9 iwht4x4 add dqcoeff dst stride eob else const PLANETYPE plane type pd plane type switch tx size case TX 4 X4 tx type get tx type 4x4 plane type xd block vp9 iht4x4 add tx type dqcoeff dst stride eob break case TX 8 X8 tx type get tx type plane type xd vp9 iht8x8 add tx type dqcoeff dst stride eob break case TX 16 X16 tx type get tx type plane type xd vp9 iht16x16 add tx type dqcoeff dst stride eob break case TX 32 X32 tx type DCTDCT vp9 idct32x32 add dqcoeff dst stride eob break default assert 0 Invalid transform size if eob 1 vpx memset dqcoeff 0 2 sizeof dqcoeff 0 else if tx type DCTDCT tx size TX 16 X16 eob 10 vpx memset dqcoeff 0 4 4 tx size sizeof dqcoeff 0 else if tx size TX 32 X32 eob 34 vpx memset dqcoeff 0 256 sizeof dqcoeff 0 else vpx memset dqcoeff 0 16 tx size 1 sizeof dqcoeff 0 static int RTP packet void ptr U packet info pinfo epan dissect t edt U void const RT Pinfo voip rtp tapinfo t tapinfo the tapinfo rtp struct voip rtp stream info t tmp listinfo voip rtp stream info t strinfo NULLG List list struct rtp conversation info p conv data NULL const struct rtp info pi const struct rtp info RT Pinfo if pi info setup frame num 0 return 0 while list tmp listinfo voip rtp stream info t list data if tmp listinfo setup frame number pi info setup frame num tmp listinfo ssrc pi info sync src tmp listinfo end stream FALSE if tmp listinfo pt pi info payload type tmp listinfo end stream TRUE else strinfo voip rtp stream info t list data break list g list next list if rtp evt frame num pinfo fd num strinfo rtp evt end TRUE return 0 if strinfo NULL strinfo voip rtp stream info t g malloc sizeof voip rtp stream info t COPYADDRESS strinfo src addr pinfo src strinfo src port pinfo srcport COPYADDRESS strinfo dest addr pinfo dst strinfo dest port pinfo destport strinfo ssrc pi info sync src strinfo end stream FALSE strinfo pt pi info payload type strinfo pt str NULL strinfo is srtp pi info is srtp if strinfo pt PTUNDF 96 strinfo pt PTUNDF 127 p conv data struct rtp conversation info p get proto data wmem file scope pinfo proto get id by filter name rtp 0 if p conv data p conv data rtp dyn payload const gchar encoding name rtp dyn payload get name p conv data rtp dyn payload strinfo pt if encoding name strinfo pt str g strdup encoding name if strinfo pt str strinfo pt str g strdup val to str ext strinfo pt rtp payload type short vals ext u strinfo npackets 0 strinfo start fd pinfo fd strinfo start rel ts pinfo rel ts strinfo setup frame number pi info setup frame num strinfo rtp event 1 tapinfo list g list prepend tapinfo list strinfo strinfo npackets strinfo stop fd pinfo fd strinfo stop rel ts pinfo rel ts if rtp evt frame num pinfo fd num strinfo rtp event rtp evt if rtp evt end TRUE strinfo end stream TRUE the tapinfo struct redraw TRUE return 1 static void rd pick sb modes V P9 COMP cpi const Tile Info const tile int mi row int mi col int totalrate int64 t totaldist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd int block V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO mbmi struct macroblock plane const p x plane struct macroblockd plane const pd xd plane const AQMODE aq mode cpi oxcf aq mode int i orig rdmult double rdmult ratio vp9 clear system state rdmult ratio 1 0 x use lp32x32fdct 1 if bsize BLOCK 8 X8 if block 0 totalrate 0 totaldist 0 return set offsets cpi tile mi row mi col bsize mbmi xd mi 0 src mi mbmi mbmi sb type bsize for i 0 i MAXMBPLANE i p i coeff ctx coeff pbuf i 0 p i qcoeff ctx qcoeff pbuf i 0 pd i dqcoeff ctx dqcoeff pbuf i 0 p i eobs ctx eobs pbuf i 0 ctx is coded 0 ctx skippable 0 x skip recode 0 mbmi skip 0 x source variance get sby perpixel variance cpi x plane 0 src bsize orig rdmult x rdmult if aq mode VARIANCEAQ const int energy bsize BLOCK 16 X16 x mb energy vp9 block energy cpi x bsize if cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame cpi rc is src frame alt ref mbmi segment id vp9 vaq segment id energy else const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map mbmi segment id vp9 get segment id cm map bsize mi row mi col rdmult ratio vp9 vaq rdmult ratio energy vp9 init plane quantizers cpi x vp9 clear system state x rdmult int round x rdmult rdmult ratio else if aq mode COMPLEXITYAQ const int mi offset mi row cm mi cols mi col unsigned char complexity cpi complexity map mi offset const int is edge mi row 1 mi row cm mi rows 2 mi col 1 mi col cm mi cols 2 if is edge complexity 128 x rdmult x rdmult complexity 128 256 else if aq mode CYCLICREFRESHAQ const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map if vp9 get segment id cm map bsize mi row mi col x rdmult vp9 cyclic refresh get rdmult cpi cyclic refresh if frame is intra only cm vp9 rd pick intra mode sb cpi x totalrate totaldist bsize ctx best rd else if bsize BLOCK 8 X8 if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP vp9 rd pick inter mode sb seg skip cpi x totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sb cpi x tile mi row mi col totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sub8x8 cpi x tile mi row mi col totalrate totaldist bsize ctx best rd x rdmult orig rdmult if aq mode VARIANCEAQ totalrate INTMAX vp9 clear system state totalrate int round totalrate rdmult ratio static double get prediction decay rate const V P9 COMMON cm const FIRSTPASSSTATS next frame const double mb sr err diff next frame sr coded error next frame coded error cm M Bs const double second ref decay mb sr err diff 512 0 fclamp pow 1 0 mb sr err diff 512 0 0 5 0 85 1 0 0 85 return MIN second ref decay next frame pcnt inter static VALUE ossl cipher update int argc VALUE argv VALUE self EVPCIPHERCTX ctx unsigned char in long in len out len VALUE data str rb scan args argc argv 11 data str if RTEST rb attr get self id key set ossl raise e Cipher Error key not set String Value data in unsigned char RSTRINGPTR data if in len RSTRINGLEN data 0 ossl raise rb e Arg Error data must not be empty Get Cipher self ctx out len in len EVPCIPHERCTX block size ctx if out len 0 ossl raise rb e Range Error data too big to make output buffer ld bytes in len if NILP str str rb str new 0 out len else String Value str rb str resize str out len if ossl cipher update long ctx unsigned char RSTRINGPTR str out len in in len ossl raise e Cipher Error NULL assert out len RSTRINGLEN str rb str set len str out len return str static int svq3 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data SV Q3 Context s avctx priv data H264 Context h s h int buf size avpkt size int ret m i if buf size 0 if s next pic f data 0 h low delay s last frame output ret av frame ref data s next pic f if ret 0 return ret s last frame output 1 got frame 1 return 0 init get bits h gb buf 8 buf size h mb x h mb y h mb xy 0 if svq3 decode slice header avctx return 1 h pict type h slice type if h pict type AVPICTURETYPEBFFSWAP Picture s next pic s last pic av frame unref s cur pic f s cur pic f pict type h pict type s cur pic f key frame h pict type AVPICTURETYPEI ret get buffer avctx s cur pic if ret 0 return ret h cur pic ptr s cur pic av frame unref h cur pic f h cur pic s cur pic ret av frame ref h cur pic f s cur pic f if ret 0 return ret for i 0 i 16 i h block offset i 4 scan8 i scan8 0 7 4 h linesize scan8 i scan8 0 3 h block offset 48 i 4 scan8 i scan8 0 7 8 h linesize scan8 i scan8 0 3 for i 0 i 16 i h block offset 16 i h block offset 32 i 4 scan8 i scan8 0 7 4 h uvlinesize scan8 i scan8 0 3 h block offset 48 16 i h block offset 48 32 i 4 scan8 i scan8 0 7 8 h uvlinesize scan8 i scan8 0 3 if h pict type AVPICTURETYPEI if s last pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s last pic if ret 0 return ret memset s last pic f data 0 0 avctx height s last pic f linesize 0 memset s last pic f data 1 0x80 avctx height 2 s last pic f linesize 1 memset s last pic f data 2 0x80 avctx height 2 s last pic f linesize 2 if h pict type AVPICTURETYPEB s next pic f data 0 av log avctx AVLOGERROR Missing reference frame n ret get buffer avctx s next pic if ret 0 return ret memset s next pic f data 0 0 avctx height s next pic f linesize 0 memset s next pic f data 1 0x80 avctx height 2 s next pic f linesize 1 memset s next pic f data 2 0x80 avctx height 2 s next pic f linesize 2 if avctx debug FFDEBUGPICTINFO av log h avctx AVLOGDEBUG c hpel d tpel d aqp d qp d slice num 02 X n av get picture type char h pict type s halfpel flag s thirdpel flag s adaptive quant h qscale h slice num if avctx skip frame AVDISCARDNONREF h pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY h pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return 0 if s next p frame damaged if h pict type AVPICTURETYPEB return 0 else s next p frame damaged 0 if h pict type AVPICTURETYPEB h frame num offset h slice num h prev frame num if h frame num offset 0 h frame num offset 256 if h frame num offset 0 h frame num offset h prev frame num offset av log h avctx AVLOGERROR error in B frame picture id n return 1 else h prev frame num h frame num h frame num h slice num h prev frame num offset h frame num h prev frame num if h prev frame num offset 0 h prev frame num offset 256 for m 0 m 2 m int i for i 0 i 4 i int j for j 1 j 4 j h ref cache m scan8 0 8 i j 1 if i 3 h ref cache m scan8 0 8 i j PARTNOTAVAILABLE for h mb y 0 h mb y h mb height h mb y for h mb x 0 h mb x h mb width h mb x unsigned mb type h mb xy h mb x h mb y h mb stride if get bits count h gb 7 h gb size in bits get bits count h gb 7 0 show bits h gb get bits count h gb 7 0 skip bits h gb s next slice index get bits count h gb h gb size in bits 8 buf size if svq3 decode slice header avctx return 1 mb type svq3 get ue golomb h gb if h pict type AVPICTURETYPEI mb type 8 else if h pict type AVPICTURETYPEB mb type 4 mb type 4 if mb type 33 svq3 decode mb s mb type av log h avctx AVLOGERROR error while decoding MB d d n h mb x h mb y return 1 if mb type 0 ff h264 hl decode mb h if h pict type AVPICTURETYPEB h low delay h cur pic mb type h mb x h mb y h mb stride h pict type AVPICTURETYPEP mb type 8 mb type 1 1 ff draw horiz band avctx NULL s cur pic s last pic f data 0 s last pic NULL 16 h mb y 16 h picture structure 0 0 h low delay h mb height 16 h mb width 16 if h pict type AVPICTURETYPEB h low delay ret av frame ref data s cur pic f else if s last pic f data 0 ret av frame ref data s last pic f if ret 0 return ret if s last pic f data 0 h low delay got frame 1 if h pict type AVPICTURETYPEBFFSWAP Picture s cur pic s next pic else av frame unref s cur pic f return buf size int crypto authenticate and decrypt struct crypto instance instance unsigned char buf int buf len struct crypto config header cch struct crypto config header buf const char guessed str if buf len sizeof struct crypto config header log printf instance log level security Received message is too short ignoring return 1 if cch crypto cipher type CRYPTOCIPHERTYPE 2 3 guessed str NULL if cch crypto cipher type 0x C0 cch crypto hash type 0x70 cch crypto cipher type 0x70 cch crypto hash type 0x C0 guessed str Corosync 3 x else if cch crypto cipher type CRYPTOCIPHERTYPE 2 2 guessed str Corosync 2 2 else if cch crypto cipher type 0x01 guessed str unencrypted Kronosnet else if cch crypto cipher type 0 cch crypto cipher type 5 guessed str unencrypted Corosync 2 0 2 1 1 x Open AIS else guessed str encrypted Kronosnet Corosync 2 0 2 1 1 x Open AIS or unknown log printf instance log level security Unsupported incoming packet probably sent by s Rejecting guessed str return 1 if cch crypto hash type CRYPTOHASHTYPE 2 3 log printf instance log level security Incoming packet has different hash type Rejecting return 1 if authenticate nss 2 3 instance buf buf len 0 return 1 if cch pad0 0 cch pad1 0 log printf instance log level security Incoming packet appears to have features not supported by this version of corosync Rejecting return 1 if decrypt nss 2 3 instance buf buf len 0 return 1 cch NULL memmove buf buf sizeof struct crypto config header buf len return 0 int jbig2 decode halftone region Jbig2 Ctx ctx Jbig2 Segment segment Jbig2 Halftone Region Params params const byte data const size t size Jbig2 Image image Jbig2 Arith Cx GB stats uint32 t HBPP uint32 t HNUMPATS uint8 t GI Jbig2 Image HSKIPNULL Jbig2 Pattern Dict HPATS int i uint32 t mg ng int32 t x y uint8 t gray val memset image data params HDEFPIXEL image stride image height if params HENABLESKIP 1 jbig2 error ctx JBI G2 SEVERITYWARNING segment number unhandled option HENABLESKIPHPATS jbig2 decode ht region get hpats ctx segment if HPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number no pattern dictionary found skipping halftone image return 1 HNUMPATSHPATS n patterns HBPP 0 while HNUMPATS 1 HBPPGI jbig2 decode gray scale image ctx segment data size params HMMR params HGW params HGHHBPP params HENABLESKIPHSKIP params HTEMPLATEGB stats if GI jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to acquire gray scale image skipping halftone image return 1 for mg 0 mg params HGH mg for ng 0 ng params HGW ng x params HGX mg params HRY ng params HRX 8 y params HGY mg params HRX ng params HRY 8 gray val GI ng mg if gray val HNUMPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number gray scale image uses value d which larger than pattern dictionary gray val gray val HNUMPATS 1 jbig2 image compose ctx image HPATS patterns gray val x y params op for i 0 i params HGW i jbig2 free ctx allocator GI i jbig2 free ctx allocator GI return 0 void cpu stop current void if current cpu current cpu stop false current cpu stopped true cpu exit current cpu qemu cond signal qemu pause cond void vp9 change config struct V P9 COMP cpi const V P9 Encoder Config oxcf V P9 COMMON const cm cpi common RATECONTROL const rc cpi rc if cm profile oxcf profile cm profile oxcf profile cm bit depth oxcf bit depth if cm profile PROFILE 1 assert cm bit depth VPXBITS 8 else assert cm bit depth VPXBITS 8 cpi oxcf oxcf cpi mb e mbd bd int cm bit depth static inline void vc1 pred mv V C1 Context v int n int dmv x int dmv y int mv1 int r x int r y uint8 t is intra int pred flag int dir Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int mixedmv pic num samefield 0 num oppfield 0 int opposite a f b f c f int16 t field pred A 2 int16 t field pred B 2 int16 t field pred C 2 int a valid b valid c valid int hybridmv thresh y bias 0 if v mv mode MVPMODEMIXEDMV v mv mode MVPMODEINTENSITYCOMP v mv mode2 MVPMODEMIXEDMV mixedmv pic 1 else mixedmv pic 0 dmv x 1 s quarter sample dmv y 1 s quarter sample wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture f motion val 0 xy v blocks off 0 0 s mv 0 n 1 s current picture f motion val 0 xy v blocks off 1 0 s current picture f motion val 1 xy v blocks off 0 0 s current picture f motion val 1 xy v blocks off 1 0 if mv1 s current picture f motion val 0 xy 1 v blocks off 0 0 s current picture f motion val 0 xy 1 v blocks off 1 0 s current picture f motion val 0 xy wrap v blocks off 0 0 s current picture f motion val 0 xy wrap v blocks off 1 0 s current picture f motion val 0 xy wrap 1 v blocks off 0 0 s current picture f motion val 0 xy wrap 1 v blocks off 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture f motion val 1 xy 1 v blocks off 0 0 s current picture f motion val 1 xy 1 v blocks off 1 0 s current picture f motion val 1 xy wrap 0 0 s current picture f motion val 1 xy wrap v blocks off 1 0 s current picture f motion val 1 xy wrap 1 v blocks off 0 0 s current picture f motion val 1 xy wrap 1 v blocks off 1 0 return C s current picture f motion val dir xy 1 v blocks off A s current picture f motion val dir xy wrap v blocks off if mv1 if v field mode mixedmv pic off s mb x s mb width 1 2 2 else off s mb x s mb width 1 1 2 else switch n case 0 off s mb x 0 1 1 break case 1 off s mb x s mb width 1 1 1 break case 2 off 1 break case 3 off 1 B s current picture f motion val dir xy wrap off v blocks off a valid s first slice line n 2 n 3 b valid a valid s mb width 1 c valid s mb x n 1 n 3 if v field mode a valid a valid is intra xy wrap b valid b valid is intra xy wrap off c valid c valid is intra xy 1 if a valid a f v mv f dir xy wrap v blocks off num oppfield a f num samefield 1 a f field pred A 0 A 0 field pred A 1 A 1 else field pred A 0 field pred A 1 0 a f 0 if b valid b f v mv f dir xy wrap off v blocks off num oppfield b f num samefield 1 b f field pred B 0 B 0 field pred B 1 B 1 else field pred B 0 field pred B 1 0 b f 0 if c valid c f v mv f dir xy 1 v blocks off num oppfield c f num samefield 1 c f field pred C 0 C 0 field pred C 1 C 1 else field pred C 0 field pred C 1 0 c f 0 if v field mode if v numref opposite 1 v reffield else if num samefield num oppfield opposite 1 pred flag else opposite pred flag else opposite 0 if opposite if a valid a f field pred A 0 scaleforopp v field pred A 0 0 dir field pred A 1 scaleforopp v field pred A 1 1 dir if b valid b f field pred B 0 scaleforopp v field pred B 0 0 dir field pred B 1 scaleforopp v field pred B 1 1 dir if c valid c f field pred C 0 scaleforopp v field pred C 0 0 dir field pred C 1 scaleforopp v field pred C 1 1 dir v mv f dir xy v blocks off 1 v ref field type dir v cur field type else if a valid a f field pred A 0 scaleforsame v n field pred A 0 0 dir field pred A 1 scaleforsame v n field pred A 1 1 dir if b valid b f field pred B 0 scaleforsame v n field pred B 0 0 dir field pred B 1 scaleforsame v n field pred B 1 1 dir if c valid c f field pred C 0 scaleforsame v n field pred C 0 0 dir field pred C 1 scaleforsame v n field pred C 1 1 dir v mv f dir xy v blocks off 0 v ref field type dir v cur field type if a valid px field pred A 0 py field pred A 1 else if c valid px field pred C 0 py field pred C 1 else if b valid px field pred B 0 py field pred B 1 else px 0 py 0 if num samefield num oppfield 1 px mid pred field pred A 0 field pred B 0 field pred C 0 py mid pred field pred A 1 field pred B 1 field pred C 1 if v field mode int qx qy XY qx s mb x 6 n 1 n 3 32 0 qy s mb y 6 n 2 n 3 32 0 X s mb width 6 4 Y s mb height 6 4 if mv1 if qx px 60 px 60 qx if qy py 60 py 60 qy else if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy if v field mode s pict type AVPICTURETYPEB hybridmv thresh 32 if a valid c valid if is intra xy wrap sum FFABS px FFABS py else sum FFABS px field pred A 0 FFABS py field pred A 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 else if is intra xy 1 sum FFABS px FFABS py else sum FFABS px field pred C 0 FFABS py field pred C 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 if v field mode v numref r y 1 if v field mode v cur field type v ref field type dir 0 y bias 1 s mv dir n 0 s current picture f motion val dir xy v blocks off 0 px dmv x r x r x 1 1 r x s mv dir n 1 s current picture f motion val dir xy v blocks off 1 py dmv y r y y bias r y 1 1 r y y bias if mv1 s current picture f motion val dir xy 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 v mv f dir xy 1 v blocks off v mv f dir xy v blocks off v mv f dir xy wrap v blocks off v mv f dir xy wrap 1 v blocks off v mv f dir xy v blocks off static int bethsoftvid decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Bethsoftvid Context vid avctx priv data char block type uint8 t dst uint8 t frame end int remaining avctx width int wrap to next line int code ret int yoffset if ret ff reget buffer avctx vid frame 0 av log avctx AVLOGERROR reget buffer failed n return ret wrap to next line vid frame linesize 0 avctx width if avpkt side data elems 0 avpkt side data 0 type AVPKTDATAPALETTE bytestream2 init vid g avpkt side data 0 data avpkt side data 0 size if ret set palette vid 0 return ret bytestream2 init vid g avpkt data avpkt size dst vid frame data 0 frame end vid frame data 0 vid frame linesize 0 avctx height switch block type bytestream2 get byte vid g case PALETTEBLOCK got frame 0 if ret set palette vid 0 av log avctx AVLOGERROR error reading palette n return ret return bytestream2 tell vid g case VIDEOYOFFPFRAME yoffset bytestream2 get le16 vid g if yoffset avctx height return AVERRORINVALIDDATA dst vid frame linesize 0 yoffset while code bytestream2 get byte vid g int length code 0x7f while length remaining if code 0x80 bytestream2 get buffer vid g dst remaining else if block type VIDEOIFRAME memset dst bytestream2 peek byte vid g remaining length remaining dst remaining wrap to next line remaining avctx width if dst frame end goto end if code 0x80 bytestream2 get buffer vid g dst length else if block type VIDEOIFRAME memset dst bytestream2 get byte vid g length remaining length dst length end if ret av frame ref data vid frame 0 return ret got frame 1 return avpkt size static inline picture t ffmpeg New Pict Buf decoder t p dec AV Codec Context p context decoder sys t p sys p dec p sys int width p context coded width int height p context coded height if p sys p va NULL int aligns AVNUMDATAPOINTERS avcodec align dimensions2 p context width height aligns if width 0 height 0 width 8192 height 8192 msg Err p dec Invalid frame size dx d width height return NULL p dec fmt out video i width width p dec fmt out video i height height if width p context width height p context height p dec fmt out video i visible width p context width p dec fmt out video i visible height p context height else p dec fmt out video i visible width width p dec fmt out video i visible height height if p sys p va Get Vlc Chroma p dec fmt out video p context pix fmt p dec fmt out video i chroma VLCCODEC I420 p dec fmt out i codec p dec fmt out video i chroma if p dec fmt in video i sar num 0 p dec fmt in video i sar den 0 p dec fmt out video i sar num p dec fmt in video i sar num p dec fmt out video i sar den p dec fmt in video i sar den else p dec fmt out video i sar num p context sample aspect ratio num p dec fmt out video i sar den p context sample aspect ratio den if p dec fmt out video i sar num p dec fmt out video i sar den p dec fmt out video i sar num 1 p dec fmt out video i sar den 1 if p dec fmt in video i frame rate 0 p dec fmt in video i frame rate base 0 p dec fmt out video i frame rate p dec fmt in video i frame rate p dec fmt out video i frame rate base p dec fmt in video i frame rate base p dec fmt out video i frame rate p context framerate num p dec fmt out video i frame rate base p context framerate den p dec fmt out video i frame rate p context time base den p dec fmt out video i frame rate base p context time base num MAX p context ticks per frame 1 static int vc1 decode p mb V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i j int mb pos s mb x s mb y s mb stride int cbp int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int index index1 int val sign int first block 1 int dst idx off int skipped fourmv int block cbp 0 pat block tt 0 block intra 0 mquant v pq if v mv type is raw fourmv get bits1 gb else fourmv v mv type mb plane mb pos if v skip is raw skipped get bits1 gb else skipped v s mbskip table mb pos if fourmv if skipped GETMVDATA dmv x dmv y if s mb intra s current picture f motion val 1 s block index 0 0 0 s current picture f motion val 1 s block index 0 1 0 s current picture f mb type mb pos s mb intra MBTYPEINTRAMBTYPE 16x16 vc1 pred mv v 0 dmv x dmv y 1 v range x v range y v mb type 0 0 0 if s mb intra mb has coeffs GETMQUANT s ac pred get bits1 gb cbp 0 else if mb has coeffs if s mb intra s ac pred get bits1 gb cbp get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 GETMQUANT else mquant v pq cbp 0 s current picture f qscale table mb pos mquant if v ttmbf s mb intra mb has coeffs ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 if s mb intra vc1 mc 1mv v 0 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize v mb type 0 s block index i s mb intra if s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize if v pq 9 v overlap if v c avail v vc1dsp vc1 h overlap s dest dst idx off i 4 s uvlinesize s linesize if v a avail v vc1dsp vc1 v overlap s dest dst idx off i 4 s uvlinesize s linesize block cbp 0x F i 2 block intra 1 i else if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 else s mb intra 0 for i 0 i 6 i v mb type 0 s block index i 0 s dc val 0 s block index i 0 s current picture f mb type mb pos MBTYPESKIP s current picture f qscale table mb pos 0 vc1 pred mv v 0 0 0 1 v range x v range y v mb type 0 0 0 vc1 mc 1mv v 0 else if skipped int intra count 0 coded inter 0 int is intra 6 is coded 6 cbp get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 for i 0 i 6 i val cbp 5 i 1 s dc val 0 s block index i 0 s mb intra 0 if i 4 dmv x dmv y 0 s mb intra 0 mb has coeffs 0 if val GETMVDATA dmv x dmv y vc1 pred mv v i dmv x dmv y 0 v range x v range y v mb type 0 0 0 if s mb intra vc1 mc 4mv luma v i 0 intra count s mb intra is intra i s mb intra is coded i mb has coeffs if i 4 is intra i intra count 3 is coded i val if i 4 vc1 mc 4mv chroma v 0 v mb type 0 s block index i is intra i if coded inter coded inter is intra i is coded i dst idx 0 if intra count coded inter goto end GETMQUANT s current picture f qscale table mb pos mquant int intrapred 0 for i 0 i 6 i if is intra i if s first slice line i 2 i 3 v mb type 0 s block index i s block wrap i s mb x i 1 i 3 v mb type 0 s block index i 1 intrapred 1 break if intrapred s ac pred get bits1 gb else s ac pred 0 if v ttmbf coded inter ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 for i 0 i 6 i dst idx i 2 off i 4 0 i 1 8 i 2 4 s linesize s mb intra is intra i if is intra i v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i is coded i mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize if v pq 9 v overlap if v c avail v vc1dsp vc1 h overlap s dest dst idx off i 4 s uvlinesize s linesize if v a avail v vc1dsp vc1 v overlap s dest dst idx off i 4 s uvlinesize s linesize block cbp 0x F i 2 block intra 1 i else if is coded i pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 else s mb intra 0 s current picture f qscale table mb pos 0 for i 0 i 6 i v mb type 0 s block index i 0 s dc val 0 s block index i 0 for i 0 i 4 i vc1 pred mv v i 0 0 0 v range x v range y v mb type 0 0 0 vc1 mc 4mv luma v i 0 vc1 mc 4mv chroma v 0 s current picture f qscale table mb pos 0 end v cbp s mb x block cbp v ttblk s mb x block tt v is intra s mb x block intra return 0 void vp9 rc update rate correction factors V P9 COMP cpi int damp var const V P9 COMMON const cm cpi common int correction factor 100 double rate correction factor get rate correction factor cpi double adjustment limit int projected size based on q 0 if cpi rc is src frame alt ref return vp9 clear system state projected size based on q estimate bits at q cm frame type cm base qindex cm M Bs rate correction factor cm bit depth if projected size based on q 0 correction factor 100 cpi rc projected frame size projected size based on q switch damp var case 0 adjustment limit 0 75 break case 1 adjustment limit 0 375 break case 2 default adjustment limit 0 25 break if correction factor 102 correction factor int 100 correction factor 100 adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MAXBPBFACTOR rate correction factor MAXBPBFACTOR else if correction factor 99 correction factor int 100 100 correction factor adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MINBPBFACTOR rate correction factor MINBPBFACTOR set rate correction factor cpi rate correction factor static int mss3 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S3 Context c avctx priv data Range Coder acoder c coder Get Byte Context gb uint8 t dst 3 int dec width dec height dec x dec y quality keyframe int x y i mb width mb height blk size btype int ret if buf size HEADERSIZE av log avctx AVLOGERROR Frame should have at least d bytes got d instead n HEADERSIZE buf size return AVERRORINVALIDDATA bytestream2 init gb buf buf size keyframe bytestream2 get be32 gb if keyframe 0x301 av log avctx AVLOGERROR Invalid frame type X n keyframe return AVERRORINVALIDDATA keyframe keyframe 1 bytestream2 skip gb 6 dec x bytestream2 get be16 gb dec y bytestream2 get be16 gb dec width bytestream2 get be16 gb dec height bytestream2 get be16 gb if dec x dec width avctx width dec y dec height avctx height dec width dec height 0x F av log avctx AVLOGERROR Invalid frame dimensions dx d d d n dec width dec height dec x dec y return AVERRORINVALIDDATA bytestream2 skip gb 4 quality bytestream2 get byte gb if quality 1 quality 100 av log avctx AVLOGERROR Invalid quality setting d n quality return AVERRORINVALIDDATA bytestream2 skip gb 4 if keyframe bytestream2 get bytes left gb av log avctx AVLOGERROR Keyframe without data found n return AVERRORINVALIDDATA if keyframe c got error return buf size c got error 0 c pic reference 3 c pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx c pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pic key frame keyframe c pic pict type keyframe AVPICTURETYPEIAVPICTURETYPEP if bytestream2 get bytes left gb got frame 1 AV Frame data c pic return buf size reset coders c quality rac init acoder buf HEADERSIZE buf size HEADERSIZE mb width dec width 4 mb height dec height 4 dst 0 c pic data 0 dec x dec y c pic linesize 0 dst 1 c pic data 1 dec x 2 dec y 2 c pic linesize 1 dst 2 c pic data 2 dec x 2 dec y 2 c pic linesize 2 for y 0 y mb height y for x 0 x mb width x for i 0 i 3 i blk size 8 i btype decode block type acoder c btype i switch btype case FILLBLOCK decode fill block acoder c fill coder i dst i x blk size c pic linesize i blk size break case IMAGEBLOCK decode image block acoder c image coder i dst i x blk size c pic linesize i blk size break case DCTBLOCK decode dct block acoder c dct coder i dst i x blk size c pic linesize i blk size c dctblock x y break case HAARBLOCK decode haar block acoder c haar coder i dst i x blk size c pic linesize i blk size c hblock break if c got error acoder got error av log avctx AVLOGERROR Error decoding block d d n x y c got error 1 return AVERRORINVALIDDATA dst 0 c pic linesize 0 16 dst 1 c pic linesize 1 8 dst 2 c pic linesize 2 8 got frame 1 AV Frame data c pic return buf size int xml init modsec rec msr char error msg xml Parser Input Buffer Create Filename Func entity if error msg NULL return 1 error msg NULL msr xml apr pcalloc msr mp sizeof xml data if msr xml NULL return 1 if msr txcfg xml external entity 0 entity xml Parser Input Buffer Create Filename Default xml unload external entity return 1 static char rfc2047 decode word const char s size t len enum Content Encoding enc const char it s const char end s len if enc ENCQUOTEDPRINTABLE struct Buffer buf 0 for it end it if it mutt buffer addch buf else if it it 1 127 hexval it 1 1 it 2 127 hexval it 2 1 mutt buffer addch buf hexval it 1 4 hexval it 2 it 2 else mutt buffer addch buf it mutt buffer addch buf 0 return buf data else if enc ENCBAS E64 const int olen 3 len 4 1 char out mutt mem malloc olen int dlen mutt b64 decode out it olen if dlen 1 FREE out return NULL out dlen 0 return out assert 0 return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size Qdraw Context const a avctx priv data AV Frame const p a pic uint8 t outdata int colors int i ret uint32 t pal int r g b if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 outdata a pic data 0 if buf end buf 0x68 4 return AVERRORINVALIDDATA buf 0x68 colors AVR B32 buf buf 4 if colors 0 colors 256 av log avctx AVLOGERROR Error color count i 0x X n colors colors return AVERRORINVALIDDATA if buf end buf colors 1 8 return AVERRORINVALIDDATA pal uint32 t p data 1 for i 0 i colors i unsigned int idx idx AVR B16 buf buf 2 if idx 255 av log avctx AVLOGERROR Palette index out of range u n idx buf 6 continue r buf buf g buf buf b buf buf pal idx r 16 g 8 b p palette has changed 1 if buf end buf 18 return AVERRORINVALIDDATA buf 18 for i 0 i avctx height i int size left code pix const uint8 t next uint8 t out int tsize 0 out outdata size AVR B16 buf buf 2 if buf end buf size return AVERRORINVALIDDATA left size next buf size while left 0 code buf if code 0x80 pix buf if out 257 code outdata a pic linesize 0 break memset out pix 257 code out 257 code tsize 257 code left 2 else if out code outdata a pic linesize 0 break if buf end buf code 1 return AVERRORINVALIDDATA memcpy out buf code 1 out code 1 buf code 1 left 2 code tsize code 1 buf next outdata a pic linesize 0 got frame 1 AV Frame data a pic return buf size void ff h263 loop filter Mpeg Enc Context s int qp c const int linesize s linesize const int uvlinesize s uvlinesize const int xy s mb y s mb stride s mb x uint8 t dest y s dest 0 uint8 t dest cb s dest 1 uint8 t dest cr s dest 2 if ISSKIP s current picture mb type xy qp c s qscale s dsp h263 v loop filter dest y 8 linesize linesize qp c s dsp h263 v loop filter dest y 8 linesize 8 linesize qp c else qp c 0 if s mb y int qp dt qp tt qp tc if ISSKIP s current picture mb type xy s mb stride qp tt 0 else qp tt s current picture qscale table xy s mb stride if qp c qp tc qp c else qp tc qp tt if qp tc const int chroma qp s chroma qscale table qp tc s dsp h263 v loop filter dest y linesize qp tc s dsp h263 v loop filter dest y 8 linesize qp tc s dsp h263 v loop filter dest cb uvlinesize chroma qp s dsp h263 v loop filter dest cr uvlinesize chroma qp if qp tt s dsp h263 h loop filter dest y 8 linesize 8 linesize qp tt if s mb x if qp tt ISSKIP s current picture mb type xy 1 s mb stride qp dt qp tt else qp dt s current picture qscale table xy 1 s mb stride if qp dt const int chroma qp s chroma qscale table qp dt s dsp h263 h loop filter dest y 8 linesize linesize qp dt s dsp h263 h loop filter dest cb 8 uvlinesize uvlinesize chroma qp s dsp h263 h loop filter dest cr 8 uvlinesize uvlinesize chroma qp if qp c s dsp h263 h loop filter dest y 8 linesize qp c if s mb y 1 s mb height s dsp h263 h loop filter dest y 8 linesize 8 linesize qp c if s mb x int qp lc if qp c ISSKIP s current picture mb type xy 1 qp lc qp c else qp lc s current picture qscale table xy 1 if qp lc s dsp h263 h loop filter dest y linesize qp lc if s mb y 1 s mb height const int chroma qp s chroma qscale table qp lc s dsp h263 h loop filter dest y 8 linesize linesize qp lc s dsp h263 h loop filter dest cb uvlinesize chroma qp s dsp h263 h loop filter dest cr uvlinesize chroma qp static void ppp hdlc netdissect options ndo const u char p int length u char b s t c int i proto const void se if length 0 return b uint8 t malloc length if b NULL return for s u char p t b i length i 0 i c s if c 0x7d if i 1 i c s 0x20 else continue t c se ndo ndo snapend ndo ndo snapend t length t b if length 1 goto trunc proto b switch proto case PPPIP ip print ndo b 1 length 1 goto cleanup case PPPIP V6 ip6 print ndo b 1 length 1 goto cleanup default break if length 2 goto trunc proto EXTRACT 16 BITS b switch proto case PPPADDRESS 8 PPPCONTROL if length 4 goto trunc proto EXTRACT 16 BITS b 2 handle ppp ndo proto b 4 length 4 break default handle ppp ndo proto b 2 length 2 break cleanup ndo ndo snapend se free b return trunc ndo ndo snapend se free b NDPRINT ndo ppp void Default TTF English Names struct ttflangname dummy Spline Font sf time t now struct tm tm char buffer 200 if dummy names ttf copyright NULL dummy names ttf copyright 0 dummy names ttf copyright utf8 verify copy sf copyright if dummy names ttf family NULL dummy names ttf family 0 dummy names ttf family utf8 verify copy sf familyname if dummy names ttf subfamily NULL dummy names ttf subfamily 0 dummy names ttf subfamily utf8 verify copy SF Get Modifiers sf if dummy names ttf uniqueid NULL dummy names ttf uniqueid 0 time now tm localtime now sprintf buffer s s d d d BDF Foundry BDF Foundry TTF Foundry TTF Foundry Font Forge 2 0 sf fullname NULL sf fullname sf fontname tm tm mday tm tm mon 1 tm tm year 1900 dummy names ttf uniqueid copy buffer if dummy names ttf fullname NULL dummy names ttf fullname 0 dummy names ttf fullname utf8 verify copy sf fullname if dummy names ttf version NULL dummy names ttf version 0 if sf subfontcnt 0 sprintf buffer Version f double sf cidversion else if sf version NULL sprintf buffer Version 20s sf version else strcpy buffer Version 1 0 dummy names ttf version copy buffer if dummy names ttf postscriptname NULL dummy names ttf postscriptname 0 dummy names ttf postscriptname utf8 verify copy sf fontname static void dump Databases P Gconn conn P Gresult res int i if server version 70100 res execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 else res execute Query conn SELECT datname FROM pg database ORDERBY 1 for i 0 i P Qntuples res i int ret char dbname P Qgetvalue res i 0 PQ Exp Buffer Data connectbuf if verbose fprintf stderr s dumping database s n progname dbname init PQ Exp Buffer connectbuf append Psql Meta Connect connectbuf dbname fprintf OPF s n connectbuf data term PQ Exp Buffer connectbuf fprintf OPFSET default transaction read only off n n if filename fclose OPF ret run Pg Dump dbname if ret 0 fprintf stderr s pg dump failed on database s exiting n progname dbname exit nicely 1 if filename OPF fopen filename PGBINARYA if OPF fprintf stderr s could not re open the output file s s n progname filename strerror errno exit nicely 1 P Qclear res void qemu cpu kick self void if current cpu thread kicked qemu cpu kick thread current cpu current cpu thread kicked true static void write modes sb V P9 COMP cpi const Tile Info const tile vp9 writer w TOKENEXTRA tok const TOKENEXTRA const tok end int mi row int mi col BLOCKSIZE bsize const V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd const int bsl b width log2 bsize const int bs 1 bsl 4 PARTITIONTYPE partition BLOCKSIZE subsize const MODEINFO m NULL if mi row cm mi rows mi col cm mi cols return m cm mi mi row cm mi stride mi col src mi partition partition lookup bsl m mbmi sb type write partition cm xd bs mi row mi col partition bsize w subsize get subsize bsize partition if subsize BLOCK 8 X8 write modes b cpi tile w tok tok end mi row mi col else switch partition case PARTITIONNONE write modes b cpi tile w tok tok end mi row mi col break case PARTITIONHORZ write modes b cpi tile w tok tok end mi row mi col if mi row bs cm mi rows write modes b cpi tile w tok tok end mi row bs mi col break case PARTITIONVERT write modes b cpi tile w tok tok end mi row mi col if mi col bs cm mi cols write modes b cpi tile w tok tok end mi row mi col bs break case PARTITIONSPLIT write modes sb cpi tile w tok tok end mi row mi col subsize write modes sb cpi tile w tok tok end mi row mi col bs subsize write modes sb cpi tile w tok tok end mi row bs mi col subsize write modes sb cpi tile w tok tok end mi row bs mi col bs subsize break default assert 0 if bsize BLOCK 8 X8 bsize BLOCK 8 X8 partition PARTITIONSPLIT update partition context xd mi row mi col subsize bsize int main int argc char argv const char globfile one two three NULL char tmpdir 32 struct passwd pw const char cwd int test int fail 0 int i struct test case struct ts if argc 1 command line test argv 1 return 0 cwd getcwd NULL 0 tmpnam tmpdir if mkdir tmpdir SIRWXU chdir tmpdir return 1 else int fd for i 0 globfile i i if fd creat globfile i SIRUSRSIWUSR 1 close fd return 1 if app register atfork register fork NULLNULL 0 printf Failed to register fork handler n return 1 for test 0 test case test retval 1 test if testit test case test fail pw getpwnam root if pw NULL ts retval 0 ts env NULL ts words root ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail ts retval 0 ts env pw pw dir ts words var root x ts flags 0 ts wordc 1 ts wordv 0 x ts ifs IFS if testit ts fail setenv HOME dummy home 1 ts retval 0 ts env NULL ts words foo ts flags 0 ts wordc 2 ts wordv 0 dummy home ts wordv 1 dummy home foo ts ifs IFS if testit ts fail pw getpwuid getuid if pw NULL unsetenv HOME ts retval 0 ts env NULL ts words ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail puts tests completed now cleaning up for i 0 globfile i i remove globfile i if cwd NULL cwd chdir cwd rmdir tmpdir printf tests failed d n fail return fail 0 static void encode block intra int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane int16 t coeff BLOCKOFFSET p coeff block int16 t qcoeff BLOCKOFFSET p qcoeff block int16 t dqcoeff BLOCKOFFSET pd dqcoeff block const scan order scan order TXTYPE tx type PREDICTIONMODE mode const int bwl b width log2 plane bsize const int diff stride 4 1 bwl uint8 t src dst int16 t src diff uint16 t eob p eobs block const int src stride p src stride const int dst stride pd dst stride int i j txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j dst stride i src p src buf 4 j src stride i src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 scan order vp9 default scan orders TX 32 X32 mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 6 bwl TX 32 X32 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 32 32 src diff diff stride src src stride dst dst stride fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 idct32x32 add dqcoeff dst dst stride eob break case TX 16 X16 tx type get tx type pd plane type xd scan order vp9 scan orders TX 16 X16 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 4 bwl TX 16 X16 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 16 16 src diff diff stride src src stride dst dst stride vp9 fht16x16 src diff coeff diff stride tx type vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht16x16 add tx type dqcoeff dst dst stride eob break case TX 8 X8 tx type get tx type pd plane type xd scan order vp9 scan orders TX 8 X8 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 2 bwl TX 8 X8 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 8 8 src diff diff stride src src stride dst dst stride vp9 fht8x8 src diff coeff diff stride tx type vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht8x8 add tx type dqcoeff dst dst stride eob break case TX 4 X4 tx type get tx type 4x4 pd plane type xd block scan order vp9 scan orders TX 4 X4 tx type mode plane 0 get y mode xd mi 0 block mbmi uv mode vp9 predict intra block xd block bwl TX 4 X4 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 4 4 src diff diff stride src src stride dst dst stride if tx type DCTDCT vp9 fht4x4 src diff coeff diff stride tx type else x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob if tx type DCTDCT x itxm add dqcoeff dst dst stride eob else vp9 iht4x4 16 add dqcoeff dst dst stride tx type break default assert 0 break if eob args skip 0 static int init dumping char database int init func char if mysql select db mysql database DB error mysql when selecting the database return 1 if path opt xml if opt databases opt alldbs char quoted database buf NAMELEN 2 3 char qdatabase quote name database quoted database buf opt quoted print comment md result file 0 n n Current Database s n n qdatabase init func qdatabase fprintf md result file n USE s n qdatabase check io md result file return 0 void ff MPV report decode progress Mpeg Enc Context s if s pict type AVPICTURETYPEB s partitioned frame s er error occurred ff thread report progress s current picture ptr tf s mb y 0 int ff find unused picture Mpeg Enc Context s int shared int ret find unused picture s shared if ret 0 ret s picture range end if s picture ret needs realloc s picture ret needs realloc 0 free picture s s picture ret avcodec get frame defaults s picture ret f return ret void ff vdpau h264 picture complete H264 Context h struct vdpau render state render render struct vdpau render state h cur pic ptr f data 0 assert render render info h264 slice count h slice num if render info h264 slice count 1 return render info h264 is reference h cur pic ptr reference 3 VDPTRUEVDPFALSE render info h264 field pic flag h picture structure PICTFRAME render info h264 bottom field flag h picture structure PICTBOTTOMFIELD render info h264 num ref frames h sps ref frame count render info h264 mb adaptive frame field flag h sps mb aff render info h264 field pic flag render info h264 constrained intra pred flag h pps constrained intra pred render info h264 weighted pred flag h pps weighted pred render info h264 weighted bipred idc h pps weighted bipred idc render info h264 frame mbs only flag h sps frame mbs only flag render info h264 transform 8x8 mode flag h pps transform 8x8 mode render info h264 chroma qp index offset h pps chroma qp index offset 0 render info h264 second chroma qp index offset h pps chroma qp index offset 1 render info h264 pic init qp minus26 h pps init qp 26 render info h264 num ref idx l0 active minus1 h pps ref count 0 1 render info h264 num ref idx l1 active minus1 h pps ref count 1 1 render info h264 log2 max frame num minus4 h sps log2 max frame num 4 render info h264 pic order cnt type h sps poc type render info h264 log2 max pic order cnt lsb minus4 h sps poc type 0 h sps log2 max poc lsb 4 render info h264 delta pic order always zero flag h sps delta pic order always zero flag render info h264 direct 8x8 inference flag h sps direct 8x8 inference flag render info h264 entropy coding mode flag h pps cabac render info h264 pic order present flag h pps pic order present render info h264 deblocking filter control present flag h pps deblocking filter parameters present render info h264 redundant pic cnt present flag h pps redundant pic cnt present memcpy render info h264 scaling lists 4x4 h pps scaling matrix4 sizeof render info h264 scaling lists 4x4 memcpy render info h264 scaling lists 8x8 0 h pps scaling matrix8 0 sizeof render info h264 scaling lists 8x8 0 memcpy render info h264 scaling lists 8x8 1 h pps scaling matrix8 3 sizeof render info h264 scaling lists 8x8 0 ff h264 draw horiz band h 0 h avctx height render bitstream buffers used 0 void vmmouse set data const uint32 t data X86 CPU cpu X86 CPU current cpu CPU X86 State env cpu env env regs REAX data 0 env regs REBX data 1 env regs RECX data 2 env regs REDX data 3 env regs RESI data 4 env regs REDI data 5 static int amrnb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMR Context p avctx priv data AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float buf out int i subframe ret float fixed gain factor AMR Fixed fixed sparse 0 float spare vector AMRSUBFRAMESIZE float synth fixed gain const float synth fixed vector frame nb samples AMRBLOCKSIZE if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 p cur frame mode unpack bitstream p buf buf size if p cur frame mode NODATA av log avctx AVLOGERROR Corrupt bitstream n return AVERRORINVALIDDATA if p cur frame mode MODEDTX av log missing feature avctx dtx mode 1 return AVERRORPATCHWELCOME if p cur frame mode MODE 12k2 lsf2lsp 5 p else lsf2lsp 3 p for i 0 i 4 i ff acelp lspd2lpc p lsp i p lpc i 5 for subframe 0 subframe 4 subframe const AMRNB Subframe amr subframe p frame subframe subframe decode pitch vector p amr subframe subframe decode fixed sparse fixed sparse amr subframe pulses p cur frame mode subframe decode gains p amr subframe p cur frame mode subframe fixed gain factor pitch sharpening p subframe p cur frame mode fixed sparse if fixed sparse pitch lag 0 av log avctx AVLOGERROR The file is corrupted pitch lag 0 is not allowed n return AVERRORINVALIDDATA ff set fixed vector p fixed vector fixed sparse 1 0 AMRSUBFRAMESIZE p fixed gain 4 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c p fixed vector p fixed vector AMRSUBFRAMESIZEAMRSUBFRAMESIZE p prediction error energy mean p cur frame mode energy pred fac for i 0 i AMRSUBFRAMESIZE i p excitation i p pitch gain 4 ff set fixed vector p excitation fixed sparse p fixed gain 4 AMRSUBFRAMESIZE for i 0 i AMRSUBFRAMESIZE i p excitation i truncf p excitation i synth fixed gain fixed gain smooth p p lsf q subframe p lsf avg p cur frame mode synth fixed vector anti sparseness p fixed sparse p fixed vector synth fixed gain spare vector if synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 0 synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 1 postfilter p p lpc subframe buf out subframe AMRSUBFRAMESIZE ff clear fixed vector p fixed vector fixed sparse AMRSUBFRAMESIZE update state p ff acelp apply order 2 transfer function buf out buf out highpass zeros highpass poles highpass gain AMRSAMPLESCALE p high pass mem AMRBLOCKSIZE ff weighted vector sumf p lsf avg p lsf avg p lsf q 3 0 84 0 16 LPFILTERORDER got frame ptr 1 return frame sizes nb p cur frame mode 1 static guint16 dissect mpa fpdu tvbuff t tvb packet info pinfo proto tree tree mpa state t state struct tcpinfo tcpinfo guint8 endpoint proto item mpa item NULL proto item mpa header item NULL proto tree mpa tree NULL proto tree mpa header tree NULL guint8 pad length guint16 ulpdu length exp ulpdu length guint32 offset total length guint32 num of m 0 if state minfo endpoint valid get first marker offset state tcpinfo endpoint 0 offset MPAMARKERLEN else offset 0 ulpdu length guint16 tvb get ntohs tvb offset if state minfo endpoint valid num of m number of markers state tcpinfo endpoint pad length fpdu pad length ulpdu length exp ulpdu length expected ulpdu length state tcpinfo endpoint if exp ulpdu length exp ulpdu length ulpdu length pad length return 0 mpa packetlist pinfo MPAFPDU mpa item proto tree add item tree proto iwarp mpa tvb 0 1 ENCNA mpa tree proto item add subtree mpa item ett mpa mpa header item proto tree add item mpa tree hf mpa fpdu tvb offset 1 ENCNA mpa header tree proto item add subtree mpa header item ett mpa proto tree add uint mpa header tree hf mpa ulpdu length tvb offset MPAULPDULENGTHLEN ulpdu length if state minfo endpoint valid num of m 0 total length fpdu total length tcpinfo if pad length 0 proto tree add item mpa header tree hf mpa pad tvb pad offset tcpinfo total length pad length pad length ENCNA dissect fpdu crc tvb mpa header tree state total length MPACRCLEN num of m MPAMARKERLEN ulpdu length pad length MPAULPDULENGTHLEN dissect fpdu markers tvb mpa tree state tcpinfo endpoint else offset MPAULPDULENGTHLEN ulpdu length if pad length 0 proto tree add item mpa header tree hf mpa pad tvb offset pad length ENCNA offset pad length dissect fpdu crc tvb mpa header tree state offset ulpdu length pad length MPAULPDULENGTHLEN return ulpdu length int phar parse tarfile php stream fp char fname int fname len char alias int alias len phar archive data pphar int is data php uint32 compression char error TSRMLSDC char buf 512 actual alias NULL p phar entry info entry 0 size t pos 0 read totalsize tar header hdr php uint32 sum1 sum2 size old phar archive data myphar actual int last was longlink 0 if error error NULL php stream seek fp 0 SEEKEND totalsize php stream tell fp php stream seek fp 0 SEEKSET read php stream read fp buf sizeof buf if read sizeof buf if error spprintf error 4096 phar error s is not a tar file or is truncated fname php stream close fp return FAILURE hdr tar header buf old memcmp hdr magic ustar sizeof ustar 1 0 myphar phar archive data pecalloc 1 sizeof phar archive data PHARG persist myphar is persistent PHARG persist zend hash init myphar manifest 2 totalsize 12 zend get hash value destroy phar manifest entry zend bool myphar is persistent zend hash init myphar mounted dirs 5 zend get hash value NULL zend bool myphar is persistent zend hash init myphar virtual dirs 4 totalsize 11 zend get hash value NULL zend bool myphar is persistent myphar is tar 1 myphar flags compression entry is tar 1 entry is crc checked 1 entry phar myphar pos sizeof buf do phar entry info newentry pos php stream tell fp hdr tar header buf sum1 phar tar number hdr checksum sizeof hdr checksum if sum1 0 phar tar checksum buf sizeof buf 0 break memset hdr checksum sizeof hdr checksum sum2 phar tar checksum buf old sizeof old tar header sizeof tar header size entry uncompressed filesize entry compressed filesize phar tar number hdr size sizeof hdr size if old hdr prefix 0 0 old strlen hdr name sizeof phar signature bin 1 strncmp hdr name phar signature bin sizeof phar signature bin 1 off t curloc if size 511 if error spprintf error 4096 phar error tar based phar s has signature that is larger than 511 bytes cannot process fname bail php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE curloc php stream tell fp read php stream read fp buf size if read size if error spprintf error 4096 phar error tar based phar s signature cannot be read fname goto bail if FAILURE phar verify signature fp php stream tell fp size 512 myphar sig flags buf 8 size 8 fname myphar signature myphar sig len error TSRMLSCC if error char save error spprintf error 4096 phar error tar based phar s signature cannot be verified s fname save efree save goto bail php stream seek fp curloc 512 SEEKSET if hdr typeflag 0 hdr typeflag TARFILE size 0 php stream seek fp 512 SEEKCUR if uint php stream tell fp totalsize if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE read php stream read fp buf sizeof buf if read sizeof buf if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE hdr tar header buf sum1 phar tar number hdr checksum sizeof hdr checksum if sum1 0 phar tar checksum buf sizeof buf 0 break if error spprintf error 4096 phar error s has entries after signature invalid phar fname goto bail if last was longlink hdr typeflag L last was longlink 1 entry filename len entry uncompressed filesize if entry filename len UINTMAX if error spprintf error 4096 phar error s is a corrupted tar file invalid entry size fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE entry filename pemalloc entry filename len 1 myphar is persistent read php stream read fp entry filename entry filename len if read entry filename len efree entry filename if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE entry filename entry filename len 0 size size 511 511 size php stream seek fp size SEEKCUR if uint php stream tell fp totalsize efree entry filename if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE read php stream read fp buf sizeof buf if read sizeof buf efree entry filename if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE continue else if last was longlink old hdr prefix 0 0 char name 256 int i j for i 0 i 155 i name i hdr prefix i if name i 0 break name i for j 0 j 100 j name i j hdr name j if name i j 0 break entry filename len i j if name entry filename len 1 entry filename len entry filename pestrndup name entry filename len myphar is persistent else if last was longlink int i for i 0 i 100 i if hdr name i 0 break entry filename len i entry filename pestrndup hdr name i myphar is persistent if entry filename entry filename len 1 entry filename entry filename len 1 0 entry filename len last was longlink 0 phar add virtual dirs myphar entry filename entry filename len TSRMLSCC if sum1 sum2 if error spprintf error 4096 phar error s is a corrupted tar file checksum mismatch of file s fname entry filename pefree entry filename myphar is persistent php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE entry tar type old hdr typeflag 0 TARFILE hdr typeflag entry offset entry offset abs pos entry fp type PHARFP entry flags phar tar number hdr mode sizeof hdr mode PHARENTPERMMASK entry timestamp phar tar number hdr mtime sizeof hdr mtime entry is persistent myphar is persistent entry tar type TARDIR if entry tar type TARDIR entry is dir 1 else entry is dir 0 entry link NULL if entry tar type TARLINK if zend hash exists myphar manifest hdr linkname strlen hdr linkname if error spprintf error 4096 phar error s is a corrupted tar file hard link to non existent file s fname hdr linkname pefree entry filename entry is persistent php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE entry link estrdup hdr linkname else if entry tar type TARSYMLINK entry link estrdup hdr linkname phar set inode entry TSRMLSCC zend hash add myphar manifest entry filename entry filename len void entry sizeof phar entry info void newentry if entry is persistent entry manifest pos if entry filename len sizeof phar metadata 1 memcmp entry filename phar metadata sizeof phar metadata 1 if FAILURE phar tar process metadata newentry fp TSRMLSCC if error spprintf error 4096 phar error tar based phar s has invalid metadata in magic file s fname entry filename php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE if actual alias entry filename len sizeof phar alias txt 1 strncmp entry filename phar alias txt sizeof phar alias txt 1 if size 511 if error spprintf error 4096 phar error tar based phar s has alias that is larger than 511 bytes cannot process fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE read php stream read fp buf size if read size buf size 0 if phar validate alias buf size if size 50 buf 50 buf 51 buf 52 buf 53 0 if error spprintf error 4096 phar error invalid alias s in tar based phar s buf fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE actual alias pestrndup buf size myphar is persistent myphar alias actual alias myphar alias len size php stream seek fp pos SEEKSET else if error spprintf error 4096 phar error Unable to read alias from tar based phar s fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE size size 511 511 if hdr typeflag 0 hdr typeflag TARFILE size 0 php stream seek fp size SEEKCUR if uint php stream tell fp totalsize if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return FAILURE read php stream read fp buf sizeof buf if read sizeof buf if error spprintf error 4096 phar error s is a corrupted tar file truncated fname php stream close fp phar destroy phar data myphar TSRMLSCC return static int dissect spoolss uint16uni tvbuff t tvb int offset packet info pinfo U proto tree tree guint8 drep U char data int hf name gint len remaining char text if offset 2 offset 2 offset 2 remaining tvb reported length remaining tvb offset if remaining 0 if data data g strdup return offset text tvb get string enc NULL tvb offset remaining ENCUTF 16 ENCLITTLEENDIAN len int strlen text proto tree add string tree hf name tvb offset len 2 text if data data text else g free text return offset len 1 2 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic avctx coded frame const uint32 t src const uint32 t avpkt data int aligned width FFALIGN avctx width 64 uint8 t dst line if pic data 0 avctx release buffer avctx pic if avpkt size 4 aligned width avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 dst line pic data 0 for h 0 h avctx height h uint16 t dst uint16 t dst line for w 0 w avctx width w uint32 t pixel av be2ne32 src uint16 t r g b if avctx codec id AVCODECID R210 b pixel 6 g pixel 4 0xffc0 r pixel 14 0xffc0 else b pixel 4 g pixel 6 0xffc0 r pixel 16 0xffc0 dst r r 10 dst g g 10 dst b b 10 src aligned width avctx width dst line pic linesize 0 got frame 1 AV Frame data avctx coded frame return avpkt size static int amrnb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMR Context p avctx priv data AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float buf out int i subframe ret float fixed gain factor AMR Fixed fixed sparse 0 float spare vector AMRSUBFRAMESIZE float synth fixed gain const float synth fixed vector frame nb samples AMRBLOCKSIZE if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 p cur frame mode unpack bitstream p buf buf size if p cur frame mode NODATA av log avctx AVLOGERROR Corrupt bitstream n return AVERRORINVALIDDATA if p cur frame mode MODEDTX av log missing feature avctx dtx mode 1 return AVERRORPATCHWELCOME if p cur frame mode MODE 12k2 lsf2lsp 5 p else lsf2lsp 3 p for i 0 i 4 i ff acelp lspd2lpc p lsp i p lpc i 5 for subframe 0 subframe 4 subframe const AMRNB Subframe amr subframe p frame subframe subframe decode pitch vector p amr subframe subframe decode fixed sparse fixed sparse amr subframe pulses p cur frame mode subframe decode gains p amr subframe p cur frame mode subframe fixed gain factor pitch sharpening p subframe p cur frame mode fixed sparse if fixed sparse pitch lag 0 av log avctx AVLOGERROR The file is corrupted pitch lag 0 is not allowed n return AVERRORINVALIDDATA ff set fixed vector p fixed vector fixed sparse 1 0 AMRSUBFRAMESIZE p fixed gain 4 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c p fixed vector p fixed vector AMRSUBFRAMESIZEAMRSUBFRAMESIZE p prediction error energy mean p cur frame mode energy pred fac for i 0 i AMRSUBFRAMESIZE i p excitation i p pitch gain 4 ff set fixed vector p excitation fixed sparse p fixed gain 4 AMRSUBFRAMESIZE for i 0 i AMRSUBFRAMESIZE i p excitation i truncf p excitation i synth fixed gain fixed gain smooth p p lsf q subframe p lsf avg p cur frame mode synth fixed vector anti sparseness p fixed sparse p fixed vector synth fixed gain spare vector if synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 0 synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 1 postfilter p p lpc subframe buf out subframe AMRSUBFRAMESIZE ff clear fixed vector p fixed vector fixed sparse AMRSUBFRAMESIZE update state p ff acelp apply order 2 transfer function buf out buf out highpass zeros highpass poles highpass gain AMRSAMPLESCALE p high pass mem AMRBLOCKSIZE ff weighted vector sumf p lsf avg p lsf avg p lsf q 3 0 84 0 16 LPFILTERORDER got frame ptr 1 return frame sizes nb p cur frame mode 1 static int16 t wmv2 pred motion Wmv2 Context w int px int py Mpeg Enc Context const s w s int xy wrap diff type int16 t ABC mot val wrap s b8 stride xy s block index 0 mot val s current picture motion val 0 xy A s current picture motion val 0 xy 1 B s current picture motion val 0 xy wrap C s current picture motion val 0 xy 2 wrap if s mb x s first slice line s mspel w top left mv flag diff FFMAXFFABSA 0 B 0 FFABSA 1 B 1 else diff 0 if diff 8 type get bits1 s gb else type 2 if type 0 px A 0 py A 1 else if type 1 px B 0 py B 1 else if s first slice line px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val static int pnm decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size PNM Context const s avctx priv data AV Frame picture data AV Frame const p s picture int i j n linesize h upgrade 0 unsigned char ptr int components sample len ret s bytestream start s bytestream buf s bytestream end buf buf size if ret ff pnm decode header avctx s 0 return ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 switch avctx pix fmt default return AVERROREINVAL case AVPIXFMTRG B48 BE n avctx width 6 components 3 sample len 16 goto do read case AVPIXFMTRG B24 n avctx width 3 components 3 sample len 8 goto do read case AVPIXFMTGRA Y8 n avctx width components 1 sample len 8 if s maxval 255 upgrade 1 goto do read case AVPIXFMTGRA Y16 BE case AVPIXFMTGRA Y16 LE n avctx width 2 components 1 sample len 16 if s maxval 65535 upgrade 2 goto do read case AVPIXFMTMONOWHITE case AVPIXFMTMONOBLACK n avctx width 7 3 components 1 sample len 1 do read ptr p data 0 linesize p linesize 0 if s bytestream n avctx height s bytestream end return AVERRORINVALIDDATA if s type 4 for i 0 i avctx height i Put Bit Context pb init put bits pb ptr linesize for j 0 j avctx width components j unsigned int c 0 int v 0 while s bytestream s bytestream end s bytestream 0 s bytestream 9 s bytestream if s bytestream s bytestream end return AVERRORINVALIDDATA do v 10 v c c s bytestream 0 while c 9 put bits pb sample len 1 sample len 1 v s maxval 1 s maxval flush put bits pb ptr linesize else for i 0 i avctx height i if upgrade memcpy ptr s bytestream n else if upgrade 1 unsigned int j f 255 128 s maxval 2 s maxval for j 0 j n j ptr j s bytestream j f 64 7 else if upgrade 2 unsigned int j v f 65535 32768 s maxval 2 s maxval for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize break case AVPIXFMTYU V420 P case AVPIXFMTYU V420 P9 BE case AVPIXFMTYU V420 P10 BE unsigned char ptr1 ptr2 n avctx width ptr p data 0 linesize p linesize 0 if s maxval 256 n 2 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i memcpy ptr s bytestream n s bytestream n ptr linesize ptr1 p data 1 ptr2 p data 2 n 1 h avctx height 1 for i 0 i h i memcpy ptr1 s bytestream n s bytestream n memcpy ptr2 s bytestream n s bytestream n ptr1 p linesize 1 ptr2 p linesize 2 break case AVPIXFMTYU V420 P16 uint16 t ptr1 ptr2 const int f 65535 32768 s maxval 2 s maxval unsigned int j v n avctx width 2 ptr p data 0 linesize p linesize 0 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize ptr1 uint16 t p data 1 ptr2 uint16 t p data 2 n 1 h avctx height 1 for i 0 i h i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr1 j v f 16384 15 s bytestream n for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr2 j v f 16384 15 s bytestream n ptr1 p linesize 1 2 ptr2 p linesize 2 2 break case AVPIXFMTRG B32 ptr p data 0 linesize p linesize 0 if s bytestream avctx width avctx height 4 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i int j r g b a for j 0 j avctx width j r s bytestream g s bytestream b s bytestream a s bytestream uint32 t ptr j a 24 r 16 g 8 b ptr linesize break picture s picture got frame 1 return s bytestream s bytestream start int EVP Encrypt Update EVPCIPHERCTX ctx unsigned char out int outl const unsigned char in int inl int i j bl if ctx cipher flags EVPCIPHFLAGCUSTOMCIPHER i ctx cipher do cipher ctx out in inl if i 0 return 0 else outl i return 1 if inl 0 outl 0 return inl 0 if ctx buf len 0 inl ctx block mask 0 if ctx cipher do cipher ctx out in inl outl inl return 1 else outl 0 return 0 i ctx buf len bl ctx cipher block size OPENSSL assert bl int sizeof ctx buf if i 0 if bl i inl memcpy ctx buf i in inl ctx buf len inl outl 0 return 1 else j bl i memcpy ctx buf i in j if ctx cipher do cipher ctx out ctx buf bl return 0 inl j in j out bl outl bl else outl 0 i inl bl 1 inl i if inl 0 if ctx cipher do cipher ctx out in inl return 0 outl inl if i 0 memcpy ctx buf in inl i ctx buf len i return 1 static inline picture t ffmpeg New Pict Buf decoder t p dec AV Codec Context p context decoder sys t p sys p dec p sys int width p context coded width int height p context coded height if p sys p va NULL int aligns AVNUMDATAPOINTERS avcodec align dimensions2 p context width height aligns if width 0 height 0 width 8192 height 8192 msg Err p dec Invalid frame size dx d width height return NULL p dec fmt out video i width width p dec fmt out video i height height if width p context width height p context height p dec fmt out video i visible width p context width p dec fmt out video i visible height p context height else p dec fmt out video i visible width width p dec fmt out video i visible height height if p sys p va Get Vlc Chroma p dec fmt out video p context pix fmt p dec fmt out video i chroma VLCCODEC I420 p dec fmt out i codec p dec fmt out video i chroma if p dec fmt in video i sar num 0 p dec fmt in video i sar den 0 p dec fmt out video i sar num p dec fmt in video i sar num p dec fmt out video i sar den p dec fmt in video i sar den else p dec fmt out video i sar num p context sample aspect ratio num p dec fmt out video i sar den p context sample aspect ratio den if p dec fmt out video i sar num p dec fmt out video i sar den p dec fmt out video i sar num 1 p dec fmt out video i sar den 1 if p dec fmt in video i frame rate 0 p dec fmt in video i frame rate base 0 p dec fmt out video i frame rate p dec fmt in video i frame rate p dec fmt out video i frame rate base p dec fmt in video i frame rate base p dec fmt out video i frame rate p context framerate num p dec fmt out video i frame rate base p context framerate den p dec fmt out video i frame rate p context time base den p dec fmt out video i frame rate base p context time base num MAX p context ticks per frame 1 static void write modes sb V P9 COMP cpi const Tile Info const tile vp9 writer w TOKENEXTRA tok const TOKENEXTRA const tok end int mi row int mi col BLOCKSIZE bsize const V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd const int bsl b width log2 bsize const int bs 1 bsl 4 PARTITIONTYPE partition BLOCKSIZE subsize const MODEINFO m NULL if mi row cm mi rows mi col cm mi cols return m cm mi mi row cm mi stride mi col src mi partition partition lookup bsl m mbmi sb type write partition cm xd bs mi row mi col partition bsize w subsize get subsize bsize partition if subsize BLOCK 8 X8 write modes b cpi tile w tok tok end mi row mi col else switch partition case PARTITIONNONE write modes b cpi tile w tok tok end mi row mi col break case PARTITIONHORZ write modes b cpi tile w tok tok end mi row mi col if mi row bs cm mi rows write modes b cpi tile w tok tok end mi row bs mi col break case PARTITIONVERT write modes b cpi tile w tok tok end mi row mi col if mi col bs cm mi cols write modes b cpi tile w tok tok end mi row mi col bs break case PARTITIONSPLIT write modes sb cpi tile w tok tok end mi row mi col subsize write modes sb cpi tile w tok tok end mi row mi col bs subsize write modes sb cpi tile w tok tok end mi row bs mi col subsize write modes sb cpi tile w tok tok end mi row bs mi col bs subsize break default assert 0 if bsize BLOCK 8 X8 bsize BLOCK 8 X8 partition PARTITIONSPLIT update partition context xd mi row mi col subsize bsize static int alloc frame buffer Mpeg Enc Context s Picture pic int r ret if s avctx hwaccel assert pic hwaccel picture private if s avctx hwaccel priv data size pic hwaccel picture private av mallocz s avctx hwaccel priv data size if pic hwaccel picture private av log s avctx AVLOGERROR alloc frame buffer failed hwaccel private data allocation n return 1 pic tf f pic f if s codec id AVCODECIDWM V3 IMAGE s codec id AVCODECIDV C1 IMAGE s codec id AVCODECIDMS S2 r ff thread get buffer s avctx pic tf pic reference AVGETBUFFERFLAGREF 0 else pic f width s avctx width pic f height s avctx height pic f format s avctx pix fmt r avcodec default get buffer2 s avctx pic f 0 if r 0 pic f data 0 av log s avctx AVLOGERROR get buffer failed d p n r pic f data 0 av freep pic hwaccel picture private return 1 if s linesize s linesize pic f linesize 0 s uvlinesize pic f linesize 1 av log s avctx AVLOGERROR get buffer failed stride changed n ff mpeg unref picture s pic return 1 if pic f linesize 1 pic f linesize 2 av log s avctx AVLOGERROR get buffer failed uv stride mismatch n ff mpeg unref picture s pic return 1 if s edge emu buffer ret ff mpv frame size alloc s pic f linesize 0 0 av log s avctx AVLOGERROR get buffer failed to allocate context scratch buffers n ff mpeg unref picture s pic return ret return 0 static int rc pick q and bounds one pass vbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality calc active worst quality one pass vbr cpi int q int inter minq ASSIGNMINQTABLE cm bit depth inter minq if frame is intra only cm if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q cm bit depth active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q cm bit depth else active best quality get gf active quality rc q cm bit depth else if oxcf rc mode VPXQ active best quality cq level else if cm current video frame 1 active best quality inter minq rc avg frame qindex INTERFRAME else active best quality inter minq rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state if cm frame type KEYFRAME rc this key frame forced cm current video frame 0 qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 1 75 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index static void rv34 pred mv b R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mb pos s mb x s mb y s mb stride int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 0 C 2 0 int has A 0 has B 0 has C 0 int mx my int i j Picture cur pic s current picture ptr const int mask dir MBTYPE L1 MBTYPE L0 int type cur pic mb type mb pos if r avail cache 6 1 type mask A 0 cur pic motion val dir mv pos 1 0 A 1 cur pic motion val dir mv pos 1 1 has A 1 if r avail cache 6 4 type mask B 0 cur pic motion val dir mv pos s b8 stride 0 B 1 cur pic motion val dir mv pos s b8 stride 1 has B 1 if r avail cache 6 4 r avail cache 6 2 type mask C 0 cur pic motion val dir mv pos s b8 stride 2 0 C 1 cur pic motion val dir mv pos s b8 stride 2 1 has C 1 else if s mb x 1 s mb width r avail cache 6 5 type mask C 0 cur pic motion val dir mv pos s b8 stride 1 0 C 1 cur pic motion val dir mv pos s b8 stride 1 1 has C 1 rv34 pred b vector ABC has A has B has C mx my mx r dmv dir 0 my r dmv dir 1 for j 0 j 2 j for i 0 i 2 i cur pic motion val dir mv pos i j s b8 stride 0 mx cur pic motion val dir mv pos i j s b8 stride 1 my if block type R V34 MBBBACKWARD block type R V34 MBBFORWARDZER O8x2 cur pic motion val dir mv pos s b8 stride static void rd pick sb modes V P9 COMP cpi const Tile Info const tile int mi row int mi col int totalrate int64 t totaldist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd int block V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO mbmi struct macroblock plane const p x plane struct macroblockd plane const pd xd plane const AQMODE aq mode cpi oxcf aq mode int i orig rdmult double rdmult ratio vp9 clear system state rdmult ratio 1 0 x use lp32x32fdct 1 if bsize BLOCK 8 X8 if block 0 totalrate 0 totaldist 0 return set offsets cpi tile mi row mi col bsize mbmi xd mi 0 src mi mbmi mbmi sb type bsize for i 0 i MAXMBPLANE i p i coeff ctx coeff pbuf i 0 p i qcoeff ctx qcoeff pbuf i 0 pd i dqcoeff ctx dqcoeff pbuf i 0 p i eobs ctx eobs pbuf i 0 ctx is coded 0 ctx skippable 0 x skip recode 0 mbmi skip 0 x source variance get sby perpixel variance cpi x plane 0 src bsize orig rdmult x rdmult if aq mode VARIANCEAQ const int energy bsize BLOCK 16 X16 x mb energy vp9 block energy cpi x bsize if cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame cpi rc is src frame alt ref mbmi segment id vp9 vaq segment id energy else const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map mbmi segment id vp9 get segment id cm map bsize mi row mi col rdmult ratio vp9 vaq rdmult ratio energy vp9 init plane quantizers cpi x vp9 clear system state x rdmult int round x rdmult rdmult ratio else if aq mode COMPLEXITYAQ const int mi offset mi row cm mi cols mi col unsigned char complexity cpi complexity map mi offset const int is edge mi row 1 mi row cm mi rows 2 mi col 1 mi col cm mi cols 2 if is edge complexity 128 x rdmult x rdmult complexity 128 256 else if aq mode CYCLICREFRESHAQ const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map if vp9 get segment id cm map bsize mi row mi col x rdmult vp9 cyclic refresh get rdmult cpi cyclic refresh if frame is intra only cm vp9 rd pick intra mode sb cpi x totalrate totaldist bsize ctx best rd else if bsize BLOCK 8 X8 if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP vp9 rd pick inter mode sb seg skip cpi x totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sb cpi x tile mi row mi col totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sub8x8 cpi x tile mi row mi col totalrate totaldist bsize ctx best rd x rdmult orig rdmult if aq mode VARIANCEAQ totalrate INTMAX vp9 clear system state totalrate int round totalrate rdmult ratio void vp9 select in frame q segment V P9 COMP cpi int mi row int mi col int output enabled int projected rate V P9 COMMON const cm cpi common const int mi offset mi row cm mi cols mi col const int bw num 8x8 blocks wide lookup BLOCK 64 X64 const int bh num 8x8 blocks high lookup BLOCK 64 X64 const int xmis MIN cm mi cols mi col bw const int ymis MIN cm mi rows mi row bh int complexity metric 64 int x y unsigned char segment if output enabled segment 0 else const int target rate cpi rc sb64 target rate xmis ymis 256 bw bh const int aq strength get aq c strength cm base qindex const int active segments aq c active segments aq strength segment active segments 1 while segment 0 if projected rate target rate aq c transitions aq strength segment break segment if target rate 0 complexity metric clamp int projected rate 64 target rate 16 255 for y 0 y ymis y for x 0 x xmis x cpi segmentation map mi offset y cm mi cols x segment cpi complexity map mi offset y cm mi cols x unsigned char complexity metric int dtls1 get record SSL s int ssl major ssl minor int i n SS L3 RECORD rr unsigned char p NULL unsigned short version DTL S1 BITMAP bitmap unsigned int is next epoch rr RECORDLAYER get rrec s rlayer again if dtls1 process buffered records s 0 return 1 if dtls1 get processed record s return 1 if RECORDLAYER get rstate s rlayer SSLSTREADBODYRECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH n ssl3 read n s DTL S1 RTHEADERLENGTHSS L3 BUFFER get len s rlayer rbuf 0 1 if n 0 return n if RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTHRECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADBODY p RECORDLAYER get packet s rlayer if s msg callback s msg callback 0 0 SS L3 RTHEADER p DTL S1 RTHEADERLENGTH s s msg callback arg rr type p ssl major p ssl minor p version ssl major 8 ssl minor n2s p rr epoch memcpy RECORDLAYER get read sequence s rlayer 2 p 6 p 6 n2s p rr length if s first packet if version s version rr length 0 RECORDLAYER reset packet length s rlayer goto again if version 0xff00 s version 0xff00 rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length SS L3 RTMAXENCRYPTEDLENGTH rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH i rr length n ssl3 read n s i i 1 1 if n i rr length 0 RECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADHEADER bitmap dtls1 get bitmap s rr is next epoch if bitmap NULL rr length 0 RECORDLAYER reset packet length s rlayer goto again rr length 0 RECORDLAYER reset packet length s rlayer goto again void vp9 set rd speed thresholds sub8x8 V P9 COMP cpi const SPEEDFEATURES const sf cpi sf RDOPT const rd cpi rd int i for i 0 i MAXREFS i rd thresh mult sub8x8 i cpi oxcf mode BEST 500 0 rd thresh mult sub8x8 THRLAST 2500 rd thresh mult sub8x8 THRGOLD 2500 rd thresh mult sub8x8 THRALTR 2500 rd thresh mult sub8x8 THRINTRA 2500 rd thresh mult sub8x8 THRCOMPLA 4500 rd thresh mult sub8x8 THRCOMPGA 4500 for i 0 i MAXREFS i if sf disable split mask 1 i rd thresh mult sub8x8 i INTMAX if cpi ref frame flags V P9 LASTFLAG rd thresh mult sub8x8 THRLASTINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult sub8x8 THRGOLDINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult sub8x8 THRALTRINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult sub8x8 THRCOMPLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult sub8x8 static int vc1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size n slices 0 i ret V C1 Context v avctx priv data Mpeg Enc Context s v s AV Frame pict data uint8 t buf2 NULL const uint8 t buf start buf int mb height n slices1 struct uint8 t buf Get Bit Context gb int mby start slices NULL tmp if buf size 0 buf size 4 AVR B32 buf V C1 CODEENDOFSEQ if s low delay 0 s next picture ptr if ret av frame ref pict s next picture ptr f 0 return ret s next picture ptr NULL got frame 1 return 0 if s avctx codec capabilities CODECCAPHWACCELVDPAU if v profile PROFILEADVANCED avctx pix fmt AVPIXFMTVDPAUWM V3 else avctx pix fmt AVPIXFMTVDPAUV C1 if avctx codec id AVCODECIDV C1 avctx codec id AVCODECIDV C1 IMAGE int buf size2 0 buf2 av mallocz buf size FFINPUTBUFFERPADDINGSIZE if ISMARKERAVR B32 buf const uint8 t start end next int size next buf for start buf end buf buf size next end start next next find next marker start 4 end size next start 4 if size 0 continue switch AVR B32 start case V C1 CODEFRAME if avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU buf start start buf size2 vc1 unescape buffer start 4 size buf2 break case V C1 CODEFIELD int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices break case V C1 CODEENTRYPOINT buf size2 vc1 unescape buffer start 4 size buf2 init get bits s gb buf2 buf size2 8 ff vc1 decode entry point avctx v s gb break case V C1 CODESLICE int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start get bits slices n slices gb 9 n slices break else if v interlace buf 0 0x C0 0x C0 const uint8 t divider int buf size3 divider find next marker buf buf buf size if divider buf buf size AVR B32 divider V C1 CODEFIELD av log avctx AVLOGERROR Error in WV C1 interlaced frame n goto err else tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer divider 4 buf buf size divider 4 slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices buf size2 vc1 unescape buffer buf divider buf buf2 else buf size2 vc1 unescape buffer buf buf size buf2 init get bits s gb buf2 buf size2 8 else init get bits s gb buf buf size 8 if v res sprite v new sprite get bits1 s gb v two sprites get bits1 s gb if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE if v new sprite avctx width avctx coded width v sprite width avctx height avctx coded height v sprite height else goto image if s context initialized s width avctx coded width s height avctx coded height ff vc1 decode end avctx if s context initialized if ff msmpeg4 decode init avctx 0 ff vc1 decode init alloc tables v 0 goto err s low delay avctx has b frames v res sprite if v profile PROFILEADVANCED s h edge pos avctx coded width s v edge pos avctx coded height if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 goto err s current picture ptr s picture i v pic header flag 0 if v profile PROFILEADVANCED if ff vc1 parse frame header v s gb 1 goto err else if ff vc1 parse frame header adv v s gb 1 goto err if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE s pict type AVPICTURETYPEI av log v s avctx AVLOGERROR Sprite decoder expected I frame n goto err s current picture ptr f repeat pict 0 if v rff s current picture ptr f repeat pict 1 else if v rptfrm s current picture ptr f repeat pict v rptfrm 2 s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable goto err if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL goto end if s next p frame damaged if s pict type AVPICTURETYPEB goto end else s next p frame damaged 0 if ff MPV frame start s avctx 0 goto err s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if CONFIGV C1 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau vc1 decode picture s buf start buf buf size buf start else if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 goto err if avctx hwaccel decode slice avctx buf start buf buf size buf start 0 goto err if avctx hwaccel end frame avctx 0 goto err else ff mpeg er frame start s v bits buf size 8 v end mb x s mb width if v field mode uint8 t tmp 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 tmp 0 v mv f last 0 tmp 1 v mv f last 1 v mv f last 0 v mv f next 0 v mv f last 1 v mv f next 1 v mv f next 0 v mv f 0 v mv f next 1 v mv f 1 v mv f 0 tmp 0 v mv f 1 tmp 1 mb height s mb height v field mode for i 0 i n slices i if i 0 slices i 1 mby start mb height if v field mode 0 av log v s avctx AVLOGERROR Slice d starts beyond picture boundary d d n i slices i 1 mby start mb height continue v second field 1 v blocks off s mb width s mb height 1 v mb off s mb stride s mb height 1 else v second field 0 v blocks off 0 v mb off 0 if i v pic header flag 0 if v field mode i n slices1 2 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Field header damaged n continue else if get bits1 s gb v pic header flag 1 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Slice header damaged n continue s start mb y i 0 0 FFMAX 0 slices i 1 mby start mb height if v field mode v second field s end mb y i n slices mb height FFMIN mb height slices i mby start mb height else s end mb y i n slices1 1 mb height FFMIN mb height slices i mby start mb height ff vc1 decode blocks v if i n slices s gb slices i gb if v field mode v second field 0 if s pict type AVPICTURETYPEB memcpy v mv f base v mv f next base 2 s b8 stride s mb height 2 1 s mb stride s mb height 1 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 av dlog s avctx Consumed i i bits n get bits count s gb s gb size in bits ff er frame end s er ff MPV frame end s if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE image avctx width avctx coded width v output width avctx height avctx coded height v output height if avctx skip frame AVDISCARDNONREF goto end got frame 1 else if s pict type AVPICTURETYPEB s low delay if ret av frame ref pict s current picture ptr f 0 goto err ff print debug info s s current picture ptr else if s last picture ptr NULL if ret av frame ref pict s last picture ptr f 0 goto err ff print debug info s s last picture ptr if s last picture ptr s low delay got frame 1 end av free buf2 for i 0 i n slices i av free slices i buf av free slices return buf size err av free buf2 for i 0 i n slices i av free slices i buf av free slices return 1 static int vorbis decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size vorbis context vc avctx priv data AV Frame frame data Get Bit Context gb vc gb float channel ptrs 255 int i len ret av dlog NULL packet length d n buf size frame nb samples vc blocksize 1 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if vc audio channels 8 for i 0 i vc audio channels i channel ptrs i float frame extended data i else for i 0 i vc audio channels i int ch ff vorbis channel layout offsets vc audio channels 1 i channel ptrs ch float frame extended data i init get bits gb buf buf size 8 if len vorbis parse audio packet vc channel ptrs 0 return len if vc first frame vc first frame 1 got frame ptr 0 return buf size av dlog NULL parsed d bytes d bits returned d samples ch bits n get bits count gb 8 get bits count gb 8 len frame nb samples len got frame ptr 1 return buf size static void rv34 pred mv R V34 Dec Context r int block type int subblock no int dmv no Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j int mx my int avail r avail cache avail indexes subblock no int c off part sizes w block type mv pos subblock no 1 subblock no 1 s b8 stride if subblock no 3 c off 1 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail c off 4 if avail 4 avail 1 r rv30 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride c off 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride c off 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv dmv no 0 my r dmv dmv no 1 for j 0 j part sizes h block type j for i 0 i part sizes w block type i s current picture ptr f motion val 0 mv pos i j s b8 stride 0 mx s current picture ptr f motion val 0 mv pos i j s b8 stride 1 my void kadmin getpol int argc char argv krb5 error code retval kadm5 policy ent rec policy if argc 2 argc 3 strcmp terse argv 1 fprintf stderr usage get policy terse policy n return retval kadm5 get policy handle argv argc 1 policy if retval com err get policy retval while retrieving policy s argv argc 1 return if argc 2 printf Policy s n policy policy printf Maximum password life ld n policy pw max life printf Minimum password life ld n policy pw min life printf Minimum password length ld n policy pw min length printf Minimum number of password character classes ld n policy pw min classes printf Number of old keys kept ld n policy pw history num printf Maximum password failures before lockout lu n unsigned long policy pw max fail printf Password failure count reset interval s n strdur policy pw failcnt interval printf Password lockout duration s n strdur policy pw lockout duration if policy allowed keysalts NULL printf Allowed key salt types s n policy allowed keysalts else printf s t ld t ld t ld t ld t ld t ld t lu t ld t ld t s n policy policy policy pw max life policy pw min life policy pw min length policy pw min classes policy pw history num 0 unsigned long policy pw max fail long policy pw failcnt interval long policy pw lockout duration policy allowed keysalts NULL policy allowed keysalts kadm5 free policy ent handle policy static bool vmxnet tx pkt parse headers struct Vmxnet Tx Pkt pkt struct iovec l2 hdr l3 hdr size t bytes read size t full ip6hdr len uint16 t l3 proto assert pkt l2 hdr pkt vec VMXNETTXPKT L2 HDRFRAG l3 hdr pkt vec VMXNETTXPKT L3 HDRFRAG bytes read iov to buf pkt raw pkt raw frags 0 l2 hdr iov base ETHMAX L2 HDRLEN if bytes read sizeof struct eth header l2 hdr iov len 0 return false l2 hdr iov len sizeof struct eth header switch be16 to cpu PKTGETETHHDR l2 hdr iov base h proto case ETHPVLAN l2 hdr iov len sizeof struct vlan header break case ETHPDVLAN l2 hdr iov len 2 sizeof struct vlan header break if bytes read l2 hdr iov len l2 hdr iov len 0 return false l3 proto eth get l3 proto l2 hdr iov base l2 hdr iov len switch l3 proto case ETHPIP l3 hdr iov base g malloc ETHMAXI P4 HDRLEN bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base sizeof struct ip header if bytes read sizeof struct ip header l3 hdr iov len 0 return false l3 hdr iov len IPHDRGETLEN l3 hdr iov base pkt l4proto struct ip header l3 hdr iov base ip p bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len sizeof struct ip header l3 hdr iov base sizeof struct ip header l3 hdr iov len sizeof struct ip header if bytes read l3 hdr iov len sizeof struct ip header l3 hdr iov len 0 return false break case ETHPIP V6 if eth parse ipv6 hdr pkt raw pkt raw frags l2 hdr iov len pkt l4proto full ip6hdr len l3 hdr iov len 0 return false l3 hdr iov base g malloc full ip6hdr len bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base full ip6hdr len if bytes read full ip6hdr len l3 hdr iov len 0 return false else l3 hdr iov len full ip6hdr len break default l3 hdr iov len 0 break vmxnet tx pkt calculate hdr len pkt pkt packet type get eth packet type l2 hdr iov base return true static int svq1 encode frame AV Codec Context avctx AV Packet pkt const AV Frame pict int got packet SV Q1 Context const s avctx priv data AV Frame const p s picture AV Frame temp int i ret if pkt data ret av new packet pkt s y block width s y block height MAXMBBYTES 3 FFMINBUFFERSIZE 0 av log avctx AVLOGERROR Error getting output packet n return ret if avctx pix fmt AVPIXFMTYU V410 P av log avctx AVLOGERROR unsupported pixel format n return 1 if s current picture data 0 ff get buffer avctx s current picture 0 ff get buffer avctx s last picture 0 s scratchbuf av malloc s current picture linesize 0 16 2 temp s current picture s current picture s last picture s last picture temp init put bits s pb pkt data pkt size p pict p pict type avctx gop size avctx frame number avctx gop size AVPICTURETYPEPAVPICTURETYPEI p key frame p pict type AVPICTURETYPEI svq1 write header s p pict type for i 0 i 3 i if svq1 encode plane s i s picture data i s last picture data i s current picture data i s frame width i 4 1 s frame height i 4 1 s picture linesize i s current picture linesize i 0 return 1 while put bits count s pb 31 put bits s pb 1 0 flush put bits s pb pkt size put bits count s pb 8 if p pict type AVPICTURETYPEI pkt flags AVPKTFLAGKEY got packet 1 return 0 void vp8 mbpost proc across ip c unsigned char src int pitch int rows int cols int flimit int r c i unsigned char s src unsigned char d 16 for r 0 r rows r int sumsq 0 int sum 0 for i 8 i 0 i s i s 0 for i cols i cols 17 i s i s cols 1 for i 8 i 6 i sumsq s i s i sum s i d i 8 0 for c 0 c cols 8 c int x s c 7 s c 8 int y s c 7 s c 8 sum x sumsq x y d c 15 s c if sumsq 15 sum sum flimit d c 15 8 sum s c 4 s c 8 d c 8 15 s pitch static int cmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cmv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int ret if buf end buf EAPREAMBLESIZE return AVERRORINVALIDDATA if AVR L32 buf MV Ih TAGAVR B32 buf MV Ih TAG cmv process header s buf EAPREAMBLESIZE buf end return buf size if av image check size s width s height 0 s avctx return 1 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 s palette AVPALETTESIZE buf EAPREAMBLESIZE if buf 0 1 cmv decode inter s frame buf 2 buf end frame key frame 0 frame pict type AVPICTURETYPEP else frame key frame 1 frame pict type AVPICTURETYPEI cmv decode intra s frame buf 2 buf end av frame unref s last2 frame av frame move ref s last2 frame s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size void compute curve gamma table type parametric float gamma table 256 float parameter 7 int count size t X float interval float a b c e f float y parameter 0 if count 0 a 1 b 0 c 0 e 0 f 0 interval INFINITY else if count 1 a parameter 1 b parameter 2 c 0 e 0 f 0 interval 1 parameter 2 parameter 1 else if count 2 a parameter 1 b parameter 2 c 0 e parameter 3 f parameter 3 interval 1 parameter 2 parameter 1 else if count 3 a parameter 1 b parameter 2 c parameter 3 e c f 0 interval parameter 4 else if count 4 a parameter 1 b parameter 2 c parameter 3 e parameter 5 c f parameter 6 interval parameter 4 else assert 0 invalid parametric function type a 1 b 0 c 0 e 0 f 0 interval INFINITY for X 0 X 256 X float x X 255 0 if x interval gamma table X clamp float powf a x b y c e else gamma table X clamp float c x f static int dissect CPM Set Bindings tvbuff t tvb packet info pinfo proto tree parent tree gboolean in void private data gint offset 16 struct CPM Set Bindings In request col append str pinfo cinfo COLINFO Set Bindings if in struct mswsp ct ct NULL struct message data data NULL proto item ti proto tree tree pad tree guint32 size num n gint64 column size ti proto tree add item parent tree hf mswsp msg tvb offset 1 ENCNA tree proto item add subtree ti ett mswsp msg proto item set text ti Set Bindings In pad tree proto tree add subtree tree tvb offset 0 ett mswsp pad ti Padding proto tree add item tree hf mswsp msg cpmsetbinding hcursor tvb offset 4 ENCLITTLEENDIAN request hcursor tvb get letohl tvb offset offset 4 request brow tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmsetbinding cbrow tvb offset 4 ENCLITTLEENDIAN offset 4 size tvb get letohl tvb offset request bbindingdesc size proto tree add item tree hf mswsp msg cpmsetbinding desc tvb offset 4 ENCLITTLEENDIAN offset 4 request dummy tvb get letohl tvb offset proto tree add item tree hf mswsp msg cpmsetbinding dummy tvb offset 4 ENCLITTLEENDIAN offset 4 num tvb get letohl tvb offset request ccolumns num ti proto tree add item tree hf mswsp msg cpmsetbinding ccolumns tvb offset 4 ENCLITTLEENDIAN offset 4 proto tree add item tree hf mswsp msg cpmsetbinding acolumns tvb offset size 4 ENCNA column size num MINCTABLECOLSIZE if column size tvb reported length remaining tvb offset expert add info pinfo ti ei mswsp msg cpmsetbinding ccolumns return tvb reported length tvb ct get create converstation data pinfo request acolumns struct C Table Column wmem alloc wmem file scope sizeof struct C Table Column num for n 0 n num n offset parse padding tvb offset 4 pad tree padding a Columns u n offset parse C Table Column tvb offset tree pad tree request acolumns n a Columns u n data find or create message data ct pinfo 0x D0 in private data if data data content bindingsin request else return tvb reported length tvb static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Lcl Dec Context const c avctx priv data unsigned char encoded unsigned char buf unsigned int pixel ptr int row col unsigned char outptr uint8 t y out u out v out unsigned int width avctx width unsigned int height avctx height unsigned int mszh dlen unsigned char yq y1q uq vq int uqvq ret unsigned int mthread inlen mthread outlen unsigned int len buf size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret outptr frame data 0 switch avctx codec id case AVCODECIDMSZH switch c compression case COMPMSZH if c flags FLAGMULTITHREAD mthread inlen AVR L32 encoded mthread inlen FFMIN mthread inlen len 8 mthread outlen AVR L32 encoded 4 mthread outlen FFMIN mthread outlen c decomp size mszh dlen mszh decomp encoded 8 mthread inlen c decomp buf c decomp size if mthread outlen mszh dlen av log avctx AVLOGERROR Mthread1 decoded size differs d d n mthread outlen mszh dlen return AVERRORINVALIDDATA mszh dlen mszh decomp encoded 8 mthread inlen len 8 mthread inlen c decomp buf mthread outlen c decomp size mthread outlen if mthread outlen mszh dlen av log avctx AVLOGERROR Mthread2 decoded size differs d d n mthread outlen mszh dlen return AVERRORINVALIDDATA encoded c decomp buf len c decomp size else mszh dlen mszh decomp encoded len c decomp buf c decomp size if c decomp size mszh dlen av log avctx AVLOGERROR Decoded size differs d d n c decomp size mszh dlen return AVERRORINVALIDDATA encoded c decomp buf len mszh dlen break case COMPMSZHNOCOMP int bppx2 switch c imgtype case IMGTYPEYU V111 case IMGTYPERG B24 bppx2 6 break case IMGTYPEYU V422 case IMGTYPEYU V211 bppx2 4 break case IMGTYPEYU V411 case IMGTYPEYU V420 bppx2 3 break default bppx2 0 break if len width height bppx2 1 return AVERRORINVALIDDATA break default av log avctx AVLOGERRORBUG Unknown MSZH compression in frame decoder n return AVERRORINVALIDDATA break if c flags FLAGPNGFILTER memcpy c decomp buf encoded len encoded c decomp buf else break else if c flags FLAGMULTITHREAD mthread inlen AVR L32 encoded mthread inlen FFMIN mthread inlen len 8 mthread outlen AVR L32 encoded 4 mthread outlen FFMIN mthread outlen c decomp size ret zlib decomp avctx encoded 8 mthread inlen 0 mthread outlen if ret 0 return ret ret zlib decomp avctx encoded 8 mthread inlen len 8 mthread inlen mthread outlen mthread outlen if ret 0 return ret else int ret zlib decomp avctx encoded len 0 c decomp size if ret 0 return ret encoded c decomp buf len c decomp size break return void ff h264 fill mbaff ref list H264 Context h int list i j for list 0 list 2 list for i 0 i h ref count list i Picture frame h ref list list i Picture field h ref list list 16 2 i field 0 frame for j 0 j 3 j field 0 f linesize j 1 field 0 f reference PICTTOPFIELD field 0 poc field 0 field poc 0 field 1 field 0 for j 0 j 3 j field 1 f data j frame f linesize j field 1 f reference PICTBOTTOMFIELD field 1 poc field 1 field poc 1 h luma weight 16 2 i list 0 h luma weight 16 2 i 1 list 0 h luma weight i list 0 h luma weight 16 2 i list 1 h luma weight 16 2 i 1 list 1 h luma weight i list 1 for j 0 j 2 j h chroma weight 16 2 i list j 0 h chroma weight 16 2 i 1 list j 0 h chroma weight i list j 0 h chroma weight 16 2 i list j 1 h chroma weight 16 2 i 1 list j 1 h chroma weight i list j 1 static struct cvec range struct vars v celt a celt b int cases int nchrs struct cvec cv celt c cc if a b before a b ERRREGERANGE return NULL if cases cv getcvec v 0 1 NOERRN addrange cv a b return cv nchrs b a 1 if nchrs 0 nchrs 100000 nchrs 100000 cv getcvec v nchrs 1 NOERRN addrange cv a b for c a c b c cc pg wc tolower chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc cc pg wc toupper chr c if cc c before cc a before b cc if cv nchrs cv chrspace ERRREGETOOBIG return NULL addchr cv cc if CANCELREQUESTED v re ERRREGCANCEL return NULL return cv static void nonrd pick sb modes V P9 COMP cpi const Tile Info const tile int mi row int mi col int rate int64 t dist BLOCKSIZE bsize PICKMODECONTEXT ctx V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO mbmi set offsets cpi tile mi row mi col bsize mbmi xd mi 0 src mi mbmi mbmi sb type bsize if cpi oxcf aq mode CYCLICREFRESHAQ cm seg enabled if mbmi segment id x in static area x rdmult vp9 cyclic refresh get rdmult cpi cyclic refresh if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP set mode info seg skip x cm tx mode rate dist bsize else vp9 pick inter mode cpi x tile mi row mi col rate dist bsize ctx duplicate mode info in sb cm xd mi row mi col bsize static void LMBCS Open Worker U Converter this U Converter Load Args p Args U Error Code err ulmbcs byte t Opt Group U Converter Data LMBCS extra Info this extra Info U Converter Data LMBCS uprv malloc sizeof U Converter Data LMBCS if extra Info NULLU Converter Name Pieces stack Pieces U Converter Load Args stack Args int32 t sizeof U Converter Load Args ulmbcs byte t i uprv memset extra Info 0 sizeof U Converter Data LMBCS stack Args only Test Is Loadable p Args only Test Is Loadable for i 0 i ULMBCSGRPLASTUSUCCESS err i if Opt Group Byte To CP Name i NULL extra Info Opt Grp Converter i ucnv load Shared Data Opt Group Byte To CP Name i stack Pieces stack Args err if UFAILURE err p Args only Test Is Loadable LMBCS Close this return extra Info Opt Group Opt Group extra Info locale Converter Index Find LMBCS Locale p Args locale else err static int vcr1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size VC R1 Context const a avctx priv data AV Frame picture data AV Frame const p a picture const uint8 t bytestream buf int i x y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 for i 0 i 16 i a delta i bytestream bytestream for y 0 y avctx height y int offset uint8 t luma a picture data 0 y a picture linesize 0 if y 3 0 uint8 t cb a picture data 1 y 2 a picture linesize 1 uint8 t cr a picture data 2 y 2 a picture linesize 2 for i 0 i 4 i a offset i bytestream offset a offset 0 a delta bytestream 2 0x F for x 0 x avctx width x 4 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 0 0x F luma 3 offset a delta bytestream 0 4 luma 4 cb bytestream 3 cr bytestream 1 bytestream 4 else offset a offset y 3 a delta bytestream 2 0x F for x 0 x avctx width x 8 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 3 0x F luma 3 offset a delta bytestream 3 4 luma 4 offset a delta bytestream 0 0x F luma 5 offset a delta bytestream 0 4 luma 6 offset a delta bytestream 1 0x F luma 7 offset a delta bytestream 1 4 luma 8 bytestream 4 picture a picture got frame 1 return buf size static void test rfc2231 parser void const char input key4 us ascii foo key 2 ba key2 0 a key3 0 us ascii en xyz key 0 foo key2 1 b 25 key3 1 plop key 1 baz const char output key foobazba key2 ab 25 key3 us ascii en xyzplop 25 key4 us ascii foo NULL struct rfc822 parser context parser const char const result unsigned int i test begin rfc2231 parser rfc822 parser init parser const void input strlen input NULL test assert rfc2231 parse parser result 0 for i 0 output i NULL result i NULL i test assert strcmp output i result i 0 rfc822 parser deinit parser test assert output i NULL result i NULL test end static int dissect ipmi trace tvbuff t tvb packet info pinfo proto tree tree void data U guint block type chn num data type tmp tvbuff t next tvb if tvb captured length tvb 11 call data dissector tvb pinfo tree return tvb captured length tvb tmp tvb get guint8 tvb 0 block type tmp 4 3 chn num tmp 0x F data type tvb get guint8 tvb 7 col add fstr pinfo cinfo COLDEFSRC Channel d chn num col add str pinfo cinfo COLPROTOCOL val to str data type str protocol types Reserved 0x 02x col clear pinfo cinfo COLINFO if block type HP M2 TRACEPACKETDATA col set str pinfo cinfo COLINFO Trace Packet Data else if block type HP M2 CHNSTATENOTIFY col set str pinfo cinfo COLINFO Channel State Change Notification else if block type HP M2 EMBEDASCIIMSG char str 257 guint str len tvb get guint8 tvb 10 if str len tvb memcpy tvb str 11 str len str str len 0 col add str pinfo cinfo COLINFO str else col set str pinfo cinfo COLINFO Reserved if tree proto item ti proto tree trace tree proto tree stamp tree nstime t timestamp ti proto tree add item tree proto ipmi trace tvb 0 1 ENCNA trace tree proto item add subtree ti ett ipmi trace proto tree add bitmask trace tree tvb 0 hf trace block type ett trace block type bits trace block type ENCLITTLEENDIAN timestamp secs tvb get letohl tvb 1 timestamp nsecs int tvb get letohs tvb 5 1000000 ti proto tree add time trace tree hf trace timestamp tvb 1 6 timestamp stamp tree proto item add subtree ti ett trace timestamp proto tree add item stamp tree hf trace timestamp sec tvb 1 4 ENCLITTLEENDIAN proto tree add item stamp tree hf trace timestamp msec tvb 5 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data type tvb 7 1 ENCLITTLEENDIAN if data type IPMIPROTOIPMB 1 0 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits ipmb protocol data ENCLITTLEENDIAN else if data type IPMIPROTOKCS data type IPMIPROTOSMIC data type IPMIPROTOBT 10 data type IPMIPROTOBT 15 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits host protocol data ENCLITTLEENDIAN else proto tree add item trace tree hf trace protocol data tvb 8 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data len tvb 10 1 ENCLITTLEENDIAN next tvb tvb new subset remaining tvb 11 if block type HP M2 TRACEPACKETDATA ipmi dissect arg t arg arg context IPMIENONE arg channel chn num arg flags tvb get guint8 tvb 8 if dissector try uint new proto dissector table data type next tvb pinfo tree TRUE arg call data dissector next tvb pinfo tree else if block type HP M2 CHNSTATENOTIFY data type IPMIPROTOIPMB 1 0 dissect ipmb state notify next tvb tree else call data dissector next tvb pinfo tree return tvb captured length tvb static void cblk destroy jpc enc cblk t cblk uint fast16 t passno jpc enc pass t pass if cblk passes for passno 0 pass cblk passes passno cblk numpasses passno pass pass destroy pass jas free cblk passes cblk passes NULL if cblk stream jas stream close cblk stream cblk stream NULL if cblk mqenc jpc mqenc destroy cblk mqenc cblk mqenc NULL if cblk data jas seq2d destroy cblk data cblk data NULL if cblk flags jas seq2d destroy cblk flags cblk flags static int64 t rd pick intra sby mode V P9 COMP cpi MACROBLOCK x int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize int64 t tx cache TXMODES int64 t best rd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPREDMACROBLOCKD const xd x e mbd MODEINFO const mic xd mi 0 int this rate this rate tokenonly s int64 t this distortion this rd TXSIZE best tx TX 4 X4 int i int bmode costs cpi mbmode cost if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i tx cache i IN T64 MAX for mode DCPRED mode TMPRED mode int64 t local tx cache TXMODESMODEINFO above mi xd mi xd mi stride MODEINFO left mi xd left available xd mi 1 NULL if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi 0 const PREDICTIONMODEL vp9 left block mode mic left mi 0 bmode costs cpi y mode costs AL mic mbmi mode mode super block yrd cpi x this rate tokenonly this distortion s NULL bsize local tx cache best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly bmode costs mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd best tx mic mbmi tx size rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if cpi sf tx size search method USEFULLRD this rd IN T64 MAX for i 0 i TXMODES local tx cache i IN T64 MAX i const int64 t adj rd this rd local tx cache i local tx cache cpi common tx mode if adj rd tx cache i tx cache i adj rd mic mbmi mode mode selected mic mbmi tx size best tx return best rd CUR Lcode Curl auth create plain message struct Curl easy data const char userp const char passwdp char outptr size t outlen CUR Lcode result char plainauth size t ulen size t plen size t plainlen outlen 0 outptr NULL ulen strlen userp plen strlen passwdp if ulen SIZETMAX 4 plen SIZETMAX 2 2 return CURLEOUTOFMEMORY plainlen 2 ulen plen 2 plainauth malloc plainlen if plainauth return CURLEOUTOFMEMORY memcpy plainauth userp ulen plainauth ulen 0 memcpy plainauth ulen 1 userp ulen plainauth 2 ulen 1 0 memcpy plainauth 2 ulen 2 passwdp plen result Curl base64 encode data plainauth plainlen outptr outlen free plainauth return result static int mpc7 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size MPC Context c avctx priv data Get Bit Context gb int i ch int mb 1 Band bands c bands int off ret last frame skip int bits used bits avail memset bands 0 sizeof bands c maxbands 1 buf size avpkt size 3 if buf size 0 av log avctx AVLOGERROR packet size is too small i bytes n avpkt size return AVERRORINVALIDDATA if buf size avpkt size av log avctx AVLOGWARNING packet size is not a multiple of 4 extra bytes at the end will be skipped n skip buf 0 last frame buf 1 buf 4 buf size 4 frame nb samples last frame c lastframelen MPCFRAMESIZE if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret av fast padded malloc c bits c buf size buf size if c bits return AVERRORENOMEM c dsp bswap buf uint32 t c bits const uint32 t buf buf size 2 init get bits gb c bits buf size 8 skip bits long gb skip for i 0 i c maxbands i for ch 0 ch 2 ch int t 4 if i t get vlc2 gb hdr vlc table MP C7 HDRBITS 1 5 if t 4 bands i res ch get bits gb 4 else bands i res ch av clip bands i 1 res ch t 0 17 if bands i res 0 bands i res 1 mb i if c MSS bands i msf get bits1 gb for i 0 i mb i for ch 0 ch 2 ch if bands i res ch bands i scfi ch get vlc2 gb scfi vlc table MP C7 SCFIBITS 1 for i 0 i mb i for ch 0 ch 2 ch if bands i res ch bands i scf idx ch 2 c old DSCF ch i bands i scf idx ch 0 get scale idx gb bands i scf idx ch 2 switch bands i scfi ch case 0 bands i scf idx ch 1 get scale idx gb bands i scf idx ch 0 bands i scf idx ch 2 get scale idx gb bands i scf idx ch 1 break case 1 bands i scf idx ch 1 get scale idx gb bands i scf idx ch 0 bands i scf idx ch 2 bands i scf idx ch 1 break case 2 bands i scf idx ch 1 bands i scf idx ch 0 bands i scf idx ch 2 get scale idx gb bands i scf idx ch 1 break case 3 bands i scf idx ch 2 bands i scf idx ch 1 bands i scf idx ch 0 break c old DSCF ch i bands i scf idx ch 2 memset c Q 0 sizeof c Q off 0 for i 0 i BANDS i off SAMPLESPERBAND for ch 0 ch 2 ch idx to quant c gb bands i res ch c Q ch off ff mpc dequantize and synth c mb int16 t frame extended data 2 bits used get bits count gb bits avail buf size 8 if last frame bits avail bits used bits used 32 bits avail av log avctx AVLOGERROR Error decoding frame used i of i bits n bits used bits avail return 1 if c frames to skip c frames to skip got frame ptr 0 return avpkt size got frame ptr 1 return avpkt size static int stp print mstp bpdu netdissect options ndo const struct stp bpdu stp bpdu u int length const u char ptr uint16 t v3len uint16 t len uint16 t msti u int offset ptr const u char stp bpdu NDPRINT ndo CIST Flags s length u bittok2str stp bpdu flag values none stp bpdu flags length if ndo ndo vflag return 1 NDTCHECK stp bpdu flags NDPRINT ndo n tport role s tok2str rstp obj port role values Unknown RSTPEXTRACTPORTROLE stp bpdu flags NDTCHECK stp bpdu root path cost NDPRINT ndo CIST root id s CIST ext pathcost u stp print bridge id const u char stp bpdu root id EXTRACT 32 BITS stp bpdu root path cost NDTCHECK stp bpdu bridge id NDPRINT ndo n t CIST regional root id s stp print bridge id const u char stp bpdu bridge id NDTCHECK stp bpdu port id NDPRINT ndo CIST port id 04x EXTRACT 16 BITS stp bpdu port id NDTCHECK stp bpdu forward delay NDPRINT ndo n tmessage age 2fs max age 2fs hello time 2fs forwarding delay 2fs float EXTRACT 16 BITS stp bpdu message age STPTIMEBASE float EXTRACT 16 BITS stp bpdu max age STPTIMEBASE float EXTRACT 16 BITS stp bpdu hello time STPTIMEBASE float EXTRACT 16 BITS stp bpdu forward delay STPTIMEBASENDTCHECK 16 BITS ptr MSTBPDUVE R3 LENOFFSETNDPRINT ndo n tv3len d EXTRACT 16 BITS ptr MSTBPDUVE R3 LENOFFSETNDTCHECK 32 BITS ptr MSTBPDUCONFIGDIGESTOFFSET 12 NDPRINT ndo MCID Name if fn printzp ndo ptr MSTBPDUCONFIGNAMEOFFSET 32 ndo ndo snapend goto trunc NDPRINT ndo rev u n t tdigest 08x 08x 08x 08x EXTRACT 16 BITS ptr MSTBPDUCONFIGNAMEOFFSET 32 EXTRACT 32 BITS ptr MSTBPDUCONFIGDIGESTOFFSETEXTRACT 32 BITS ptr MSTBPDUCONFIGDIGESTOFFSET 4 EXTRACT 32 BITS ptr MSTBPDUCONFIGDIGESTOFFSET 8 EXTRACT 32 BITS ptr MSTBPDUCONFIGDIGESTOFFSET 12 NDTCHECK 32 BITS ptr MSTBPDUCISTINTPATHCOSTOFFSETNDPRINT ndo CIST int root pathcost u EXTRACT 32 BITS ptr MSTBPDUCISTINTPATHCOSTOFFSETNDTCHECKBRIDGEID ptr MSTBPDUCISTBRIDGEIDOFFSETNDPRINT ndo n t CIST bridge id s stp print bridge id ptr MSTBPDUCISTBRIDGEIDOFFSETNDTCHECK ptr MSTBPDUCISTREMAINHOPSOFFSETNDPRINT ndo CIST remaining hops d ptr MSTBPDUCISTREMAINHOPSOFFSETNDTCHECK 16 BITS ptr MSTBPDUVE R3 LENOFFSET v3len EXTRACT 16 BITS ptr MSTBPDUVE R3 LENOFFSET if v3len MSTBPDUCONFIGINFOLENGTH len v3len MSTBPDUCONFIGINFOLENGTH offset MSTBPDUMSTIOFFSET while len MSTBPDUMSTILENGTHNDTCHEC K2 ptr offset MSTBPDUMSTILENGTH msti EXTRACT 16 BITS ptr offset MSTBPDUMSTIROOTPRIOOFFSET msti msti 0x0 FFFNDPRINT ndo n t MSTI d Flags s port role s msti bittok2str stp bpdu flag values none ptr offset tok2str rstp obj port role values Unknown RSTPEXTRACTPORTROLE ptr offset NDPRINT ndo n t t MSTI regional root id s pathcost u stp print bridge id ptr offset MSTBPDUMSTIROOTPRIOOFFSETEXTRACT 32 BITS ptr offset MSTBPDUMSTIROOTPATHCOSTOFFSETNDPRINT ndo n t t MSTI bridge prio d port prio d hops d ptr offset MSTBPDUMSTIBRIDGEPRIOOFFSET 4 ptr offset MSTBPDUMSTIPORTPRIOOFFSET 4 ptr offset MSTBPDUMSTIREMAINHOPSOFFSET len MSTBPDUMSTILENGTH offset MSTBPDUMSTILENGTH return 1 trunc return 0 static int testit struct test case struct tc int retval wordexp t we sav we char dummy int bzzzt 0 int start offs 0 int i if tc env setenv var tc env 1 else unsetenv var if tc ifs setenv IFS tc ifs 1 else unsetenv IFS sav we we wordc 99 sav we we wordv dummy sav we we offs 3 we sav we printf Test d s tests tc words if tc flags WRDENOCMD registered forks 0 if tc flags WRDEAPPEND if wordexp pre1 pre2 we tc flags WRDEAPPEND 0 printf FAILED setup n return 1 retval wordexp tc words we tc flags if tc flags WRDENOCMD registered forks 0 printf FAILED fork called for WRDENOCMD n return 1 if tc flags WRDEDOOFFS start offs sav we we offs if retval tc retval retval 0 we we wordc tc wordc bzzzt 1 else if retval 0 for i 0 i start offs i if we we wordv i NULL bzzzt 1 break for i 0 i we we wordc i if we we wordv i start offs NULL strcmp tc wordv i we we wordv i start offs 0 bzzzt 1 break if bzzzt printf FAILED n printf Test words s need retval d wordc Zd n tc words tc retval tc wordc if start offs 0 printf preceded by d NUL Ls n start offs printf Got retval d wordc Zd retval we we wordc if retval 0 retval WRDENOSPACE for i 0 i we we wordc start offs i if we we wordv i NULL printf NULL else printf s we we wordv i printf n else if retval 0 retval WRDENOSPACE we we wordc sav we we wordc we we wordv sav we we wordv we we offs sav we we offs bzzzt 1 printf FAILED to restore wordexp t members n else printf OK n if retval 0 retval WRDENOSPACE wordfree we return bzzzt int ff MPV common frame size change Mpeg Enc Context s int i err 0 if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i else free duplicate context s if err free context frame s 0 return err if s picture for i 0 i MAXPICTURECOUNT i s picture i needs realloc 1 s last picture ptr s next picture ptr s current picture ptr NULL if s codec id AVCODECIDMPE G2 VIDEO s progressive sequence s mb height s height 31 32 2 else if s codec id AVCODECID H264 s mb height s height 15 16 if s width s height av image check size s width s height 0 s avctx return AVERRORINVALIDDATA if err init context frame s goto fail s thread context 0 s if s width s height int nb slices s slice context count if nb slices 1 for i 1 i nb slices i s thread context i av malloc sizeof Mpeg Enc Context memcpy s thread context i s sizeof Mpeg Enc Context for i 0 i nb slices i if init duplicate context s thread context i 0 goto fail s thread context i start mb y s mb height i nb slices 2 nb slices s thread context i end mb y s mb height i 1 nb slices 2 nb slices else if init duplicate context s 0 goto fail s start mb y 0 s end mb y s mb height s slice context count nb slices return 0 fail ff MPV common end s return err static int bmv aud decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int blocks 0 total blocks i int ret int16 t output samples int scale 2 total blocks buf if buf size total blocks 65 1 av log avctx AVLOGERROR expected d bytes got d n total blocks 65 1 buf size return AVERRORINVALIDDATA frame nb samples total blocks 32 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret output samples int16 t frame data 0 for blocks 0 blocks total blocks blocks uint8 t code buf code code 1 code 7 scale 0 bmv aud mults code 0x F scale 1 bmv aud mults code 4 for i 0 i 32 i output samples av clip int16 scale 0 int8 t buf 5 output samples av clip int16 scale 1 int8 t buf 5 got frame ptr 1 return buf size static void rv34 pred mv b R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mb pos s mb x s mb y s mb stride int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 0 C 2 0 int has A 0 has B 0 has C 0 int mx my int i j Picture cur pic s current picture ptr const int mask dir MBTYPE L1 MBTYPE L0 int type cur pic mb type mb pos if r avail cache 6 1 type mask A 0 cur pic motion val dir mv pos 1 0 A 1 cur pic motion val dir mv pos 1 1 has A 1 if r avail cache 6 4 type mask B 0 cur pic motion val dir mv pos s b8 stride 0 B 1 cur pic motion val dir mv pos s b8 stride 1 has B 1 if r avail cache 6 4 r avail cache 6 2 type mask C 0 cur pic motion val dir mv pos s b8 stride 2 0 C 1 cur pic motion val dir mv pos s b8 stride 2 1 has C 1 else if s mb x 1 s mb width r avail cache 6 5 type mask C 0 cur pic motion val dir mv pos s b8 stride 1 0 C 1 cur pic motion val dir mv pos s b8 stride 1 1 has C 1 rv34 pred b vector ABC has A has B has C mx my mx r dmv dir 0 my r dmv dir 1 for j 0 j 2 j for i 0 i 2 i cur pic motion val dir mv pos i j s b8 stride 0 mx cur pic motion val dir mv pos i j s b8 stride 1 my if block type R V34 MBBBACKWARD block type R V34 MBBFORWARDZER O8x2 cur pic motion val dir mv pos s b8 stride int jbig2 decode halftone region Jbig2 Ctx ctx Jbig2 Segment segment Jbig2 Halftone Region Params params const byte data const size t size Jbig2 Image image Jbig2 Arith Cx GB stats uint32 t HBPP uint32 t HNUMPATS uint8 t GI Jbig2 Image HSKIPNULL Jbig2 Pattern Dict HPATS int i uint32 t mg ng int32 t x y uint8 t gray val memset image data params HDEFPIXEL image stride image height if params HENABLESKIP 1 jbig2 error ctx JBI G2 SEVERITYWARNING segment number unhandled option HENABLESKIPHPATS jbig2 decode ht region get hpats ctx segment if HPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number no pattern dictionary found skipping halftone image return 1 HNUMPATSHPATS n patterns HBPP 0 while HNUMPATS 1 HBPPGI jbig2 decode gray scale image ctx segment data size params HMMR params HGW params HGHHBPP params HENABLESKIPHSKIP params HTEMPLATEGB stats if GI jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to acquire gray scale image skipping halftone image return 1 for mg 0 mg params HGH mg for ng 0 ng params HGW ng x params HGX mg params HRY ng params HRX 8 y params HGY mg params HRX ng params HRY 8 gray val GI ng mg if gray val HNUMPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number gray scale image uses value d which larger than pattern dictionary gray val gray val HNUMPATS 1 jbig2 image compose ctx image HPATS patterns gray val x y params op for i 0 i params HGW i jbig2 free ctx allocator GI i jbig2 free ctx allocator GI return 0 void parse Extension Object proto tree tree tvbuff t tvb packet info pinfo gint p Offset const char sz Field Name static const int extobj mask hf opcua extobj mask binbodyflag hf opcua extobj mask xmlbodyflag NULL gint i Offset p Offset guint8 Encoding Mask guint32 Type Id proto tree extobj tree proto item ti guint opcua nested count extobj tree proto tree add subtree format tree tvb p Offset 1 ett opcua extensionobject ti s Extension Object sz Field Name opcua nested count GPOINTERTOUINT p get proto data pinfo pool pinfo proto opcua 0 if opcua nested count MAXNESTINGDEPTH expert add info pinfo ti ei nesting depth return p add proto data pinfo pool pinfo proto opcua 0 GUINTTOPOINTER opcua nested count Type Id get Extension Object Type tvb i Offset parse Expanded Node Id extobj tree tvb pinfo i Offset Type Id Encoding Mask tvb get guint8 tvb i Offset proto tree add bitmask extobj tree tvb i Offset hf opcua extobj mask ett opcua extensionobject encodingmask extobj mask ENCLITTLEENDIAN i Offset if Encoding Mask EXTOBJENCODINGMASKBINBODYFLAG dispatch Extension Object Type extobj tree tvb pinfo i Offset Type Id proto item set end ti tvb i Offset p Offset i Offset kadm5 ret t kadm5 modify policy internal void server handle kadm5 policy ent t entry long mask kadm5 server handle t handle server handle krb5 tl data tl osa policy ent t p int ret size t len CHECKHANDLE server handle if entry kadm5 policy ent t NULL entry policy NULL return EINVAL if strlen entry policy 0 return KAD M5 BADPOLICY if mask KAD M5 POLICY return KAD M5 BADMASK if mask KAD M5 POLICYALLOWEDKEYSALTS entry allowed keysalts NULL ret validate allowed keysalts entry allowed keysalts if ret return ret if mask KAD M5 POLICYTLDATA tl entry tl data while tl NULL if tl tl data type 256 return KAD M5 BADTLTYPE tl tl tl data next ret krb5 db get policy handle context entry policy p if ret KR B5 KDBNOENTRY return KAD M5 UNKPOLICY else if ret return ret if mask KAD M5 PWMAXLIFE p pw max life entry pw max life if mask KAD M5 PWMINLIFE if entry pw min life p pw max life p pw max life 0 krb5 db free policy handle context p return KAD M5 BADMINPASSLIFE p pw min life entry pw min life if mask KAD M5 PWMINLENGTH if entry pw min length MINPWLENGTH krb5 db free policy handle context p return KAD M5 BADLENGTH p pw min length entry pw min length if mask KAD M5 PWMINCLASSES if entry pw min classes MAXPWCLASSES entry pw min classes MINPWCLASSES krb5 db free policy handle context p return KAD M5 BADCLASS p pw min classes entry pw min classes if mask KAD M5 PWHISTORYNUM if entry pw history num MINPWHISTORY krb5 db free policy handle context p return KAD M5 BADHISTORY p pw history num entry pw history num if mask KAD M5 REFCOUNT p policy refcnt entry policy refcnt if handle api version KAD M5 APIVERSION 3 if mask KAD M5 PWMAXFAILURE p pw max fail entry pw max fail if mask KAD M5 PWFAILURECOUNTINTERVAL p pw failcnt interval entry pw failcnt interval if mask KAD M5 PWLOCKOUTDURATION p pw lockout duration entry pw lockout duration if handle api version KAD M5 APIVERSION 4 if mask KAD M5 POLICYATTRIBUTES p attributes entry attributes if mask KAD M5 POLICYMAXLIFE p max life entry max life if mask KAD M5 POLICYMAXRLIFE p max renewable life entry max renewable life if mask KAD M5 POLICYALLOWEDKEYSALTS krb5 db free handle context p allowed keysalts p allowed keysalts NULL if entry allowed keysalts NULL len strlen entry allowed keysalts 1 p allowed keysalts krb5 db alloc handle context NULL len if p allowed keysalts NULL ret ENOMEM goto cleanup memcpy p allowed keysalts entry allowed keysalts len if mask KAD M5 POLICYTLDATA for tl entry tl data tl NULL tl tl tl data next ret krb5 db update tl data handle context p n tl data p tl data tl if ret goto cleanup ret krb5 db put policy handle context p cleanup krb5 db free policy handle context p return ret static int escape124 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Escape124 Context s avctx priv data Get Bit Context gb unsigned frame flags frame size unsigned i unsigned superblock index cb index 1 superblock col index 0 superblocks per row avctx width 8 skip 1 uint16 t old frame data new frame data unsigned old stride new stride AV Frame new frame 0 init get bits gb buf buf size 8 if can safely read gb 64 return 1 frame flags get bits long gb 32 frame size get bits long gb 32 if frame flags 0x114 frame flags 0x7800000 av log NULLAVLOGDEBUG Skipping frame n got frame 1 AV Frame data s frame return frame size for i 0 i 3 i if frame flags 1 17 i unsigned cb depth cb size if i 2 cb size get bits long gb 20 cb depth av log2 cb size 1 1 else cb depth get bits gb 4 if i 0 cb size 1 cb depth else cb size s num superblocks cb depth av free s codebooks i blocks s codebooks i unpack codebook gb cb depth cb size if s codebooks i blocks return 1 new frame reference 3 if ff get buffer avctx new frame av log avctx AVLOGERROR get buffer failed n return 1 new frame data uint16 t new frame data 0 new stride new frame linesize 0 2 old frame data uint16 t s frame data 0 old stride s frame linesize 0 2 for superblock index 0 superblock index s num superblocks superblock index Macro Block mb Super Block sb unsigned multi mask 0 if skip 1 skip decode skip count gb if skip copy superblock new frame data new stride old frame data old stride else copy superblock sb pixels 8 old frame data old stride while can safely read gb 1 get bits1 gb unsigned mask mb decode macroblock s gb cb index superblock index mask get bits gb 16 multi mask mask for i 0 i 16 i if mask mask matrix i insert mb into sb sb mb i if can safely read gb 1 get bits1 gb unsigned inv mask get bits gb 4 for i 0 i 4 i if inv mask 1 i multi mask 0x F i 4 else multi mask get bits gb 4 i 4 for i 0 i 16 i if multi mask mask matrix i if can safely read gb 1 break mb decode macroblock s gb cb index superblock index insert mb into sb sb mb i else if frame flags 1 16 while can safely read gb 1 get bits1 gb mb decode macroblock s gb cb index superblock index insert mb into sb sb mb get bits gb 4 copy superblock new frame data new stride sb pixels 8 superblock col index new frame data 8 if old frame data old frame data 8 if superblock col index superblocks per row new frame data new stride 8 superblocks per row 8 if old frame data old frame data old stride 8 superblocks per row 8 superblock col index 0 skip av log NULLAVLOGDEBUG Escape sizes i i i n frame size buf size get bits count gb 8 if s frame data 0 avctx release buffer avctx s frame AV Frame data s frame new frame got frame 1 return frame size static void reconnect To DB Archive Handle AH const char dbname if Restoring To DBAH Reconnect To Server AH dbname NULL else PQ Exp Buffer qry create PQ Exp Buffer append PQ Exp Buffer qry connect s n n dbname fmt Id dbname ahprintf AH s qry data destroy PQ Exp Buffer qry if AH curr User free AH curr User AH curr User NULL if AH curr Schema free AH curr Schema AH curr Schema NULL if AH curr Tablespace free AH curr Tablespace AH curr Tablespace NULLAH curr With Oids 1 do Set Fixed Output State static void find mv refs idx const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int block int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const MODEINFO prev mi cm error resilient mode cm prev mi cm prev mi grid visible mi row xd mi stride mi col NULL const MBMODEINFO const prev mbmi prev mi prev mi mbmi NULL const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col block else if candidate ref frame 1 ref frame ADDMVREFLIST get sub block mv candidate mi 1 mv ref col block for i MVREFNEIGHBOURS i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 else if candidate ref frame 1 ref frame ADDMVREFLIST candidate mv 1 if prev mbmi if prev mbmi ref frame 0 ref frame ADDMVREFLIST prev mbmi mv 0 else if prev mbmi ref frame 1 ref frame ADDMVREFLIST prev mbmi mv 1 if different ref found for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate if prev mbmi IFDIFFREFFRAMEADDMV prev mbmi Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd static int aes ccm ctrl EVPCIPHERCTX c int type int arg void ptr EVPAESCCMCTX cctx EVPCDATAEVPAESCCMCTX c switch type case EVPCTRLINIT cctx key set 0 cctx iv set 0 cctx L 8 cctx M 12 cctx tag set 0 cctx len set 0 cctx tls aad len 1 return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx tls aad len arg uint16 t len EVPCIPHERCTX buf noconst c arg 2 8 EVPCIPHERCTX buf noconst c arg 1 if len EVPCCMTLSEXPLICITIVLEN return 0 len EVPCCMTLSEXPLICITIVLEN if EVPCIPHERCTX encrypting c if len cctx M return 0 len cctx MEVPCIPHERCTX buf noconst c arg 2 len 8 EVPCIPHERCTX buf noconst c arg 1 len 0xff return cctx M case EVPCTRLCCMSETIVFIXED if arg EVPCCMTLSFIXEDIVLEN return 0 memcpy EVPCIPHERCTX iv noconst c ptr arg return 1 case EVPCTRLAEADSETIVLEN arg 15 arg case EVPCTRLCCMSETL if arg 2 arg 8 return 0 cctx L arg return 1 case EVPCTRLAEADSETTAG if arg 1 arg 4 arg 16 return 0 if EVPCIPHERCTX encrypting c ptr return 0 if ptr cctx tag set 1 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx M arg return 1 case EVPCTRLAEADGETTAG if EVPCIPHERCTX encrypting c cctx tag set return 0 if CRYPTO ccm128 tag cctx ccm ptr size t arg return 0 cctx tag set 0 cctx iv set 0 cctx len set 0 return 1 case EVPCTRLCOPYEVPCIPHERCTX out ptr EVPAESCCMCTX cctx out EVPCDATAEVPAESCCMCTX out if cctx ccm key if cctx ccm key cctx ks return 0 cctx out ccm key cctx out ks return 1 default return 1 int ff mpeg4 set direct mv Mpeg Enc Context s int mx int my const int mb index s mb x s mb y s mb stride const int colocated mb type s next picture mb type mb index uint16 t time pp uint16 t time pb int i if IS 8 X8 colocated mb type s mv type MVTYPE 8 X8 for i 0 i 4 i ff mpeg4 set one direct mv s mx my i return MBTYPEDIREC T2 MBTYPE 8x8 MBTYPE L0 L1 else if ISINTERLACED colocated mb type s mv type MVTYPEFIELD for i 0 i 2 i int field select s next picture ref index 0 4 mb index 2 i s field select 0 i field select s field select 1 i i if s top field first time pp s pp field time field select i time pb s pb field time field select i else time pp s pp field time field select i time pb s pb field time field select i s mv 0 i 0 s p field mv table i 0 mb index 0 time pb time pp mx s mv 0 i 1 s p field mv table i 0 mb index 1 time pb time pp my s mv 1 i 0 mx s mv 0 i 0 s p field mv table i 0 mb index 0 s p field mv table i 0 mb index 0 time pb time pp time pp s mv 1 i 1 my s mv 0 i 1 s p field mv table i 0 mb index 1 s p field mv table i 0 mb index 1 time pb time pp time pp return MBTYPEDIREC T2 MBTYPE 16x8 MBTYPE L0 L1 MBTYPEINTERLACED else ff mpeg4 set one direct mv s mx my 0 s mv 0 1 0 s mv 0 2 0 s mv 0 3 0 s mv 0 0 0 s mv 0 1 1 s mv 0 2 1 s mv 0 3 1 s mv 0 0 1 s mv 1 1 0 s mv 1 2 0 s mv 1 3 0 s mv 1 0 0 s mv 1 1 1 s mv 1 2 1 s mv 1 3 1 s mv 1 0 1 if s avctx workaround bugs FFBUGDIRECTBLOCKSIZE s quarter sample s mv type MVTYPE 16 X16 else s mv type MVTYPE 8 X8 return MBTYPEDIREC T2 MBTYPE 16x16 MBTYPE L0 L1 static void tokenize b int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct tokenize b args const args arg V P9 COMP cpi args cpi MACROBLOCKD xd args xd TOKENEXTRA tp args tp uint8 t token cache 32 32 struct macroblock plane p cpi mb plane plane struct macroblockd plane pd xd plane plane MBMODEINFO mbmi xd mi 0 mbmi int pt int c TOKENEXTRA t tp int eob p eobs block const PLANETYPE type pd plane type const int16 t qcoeff BLOCKOFFSET p qcoeff block const int segment id mbmi segment id const int16 t scan nb const scan order so const int ref is inter block mbmi unsigned int const counts COEFFCONTEXTSENTROPYTOKENS cpi coef counts tx size type ref vp9 prob const coef probs COEFFCONTEXTSUNCONSTRAINEDNODES cpi common fc coef probs tx size type ref unsigned int const eob branch COEFFCONTEXTS cpi common counts eob branch tx size type ref const uint8 t const band get band translate tx size const int seg eob get tx eob cpi common seg segment id tx size int aoff loff txfrm block to raster xy plane bsize tx size block aoff loff pt get entropy context tx size pd above context aoff pd left context loff so get scan xd tx size type block scan so scan nb so neighbors c 0 while c eob int v 0 int skip eob 0 v qcoeff scan c while v add token no extra t coef probs band c pt ZEROTOKEN skip eob counts band c pt eob branch band c pt skip eob skip eob 1 token cache scan c 0 c pt get coef context nb token cache c v qcoeff scan c add token t coef probs band c pt vp9 dct value tokens ptr v extra uint8 t vp9 dct value tokens ptr v token uint8 t skip eob counts band c pt eob branch band c pt skip eob token cache scan c vp9 pt energy class vp9 dct value tokens ptr v token c pt get coef context nb token cache c if c seg eob add token no extra t coef probs band c pt EOBTOKEN 0 counts band c pt eob branch band c pt tp t vp9 set contexts xd pd plane bsize tx size c 0 aoff loff static void rv30 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int loc lim cur lim left lim 0 top lim 0 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if mb x left lim rv30 loop filt lim s current picture ptr f qscale table mb pos 1 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize 4 mb x for i mb x i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if i r deblock coefs mb pos 1 1 ij 3 loc lim left lim else if i r deblock coefs mb pos 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter Y 1 s linesize loc lim for k 0 k 2 k int cur cbp left cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if mb x left cbp r cbp chroma mb pos 1 k 4 0x F for j 0 j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize 4 mb x for i mb x i 2 i C 4 int ij i j 1 loc lim 0 if cur cbp 1 ij loc lim cur lim else if i left cbp 1 ij 1 loc lim left lim else if i cur cbp 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter C 1 s uvlinesize loc lim mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if row top lim rv30 loop filt lim s current picture ptr f qscale table mb pos s mb stride for j 4 row j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if j r deblock coefs mb pos s mb stride 1 ij 12 loc lim top lim else if j r deblock coefs mb pos 1 ij 4 loc lim cur lim if loc lim rv30 weak loop filter Y s linesize 1 loc lim for k 0 k 2 k int cur cbp top cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if row top cbp r cbp chroma mb pos s mb stride k 4 0x F for j 4 row j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize for i 0 i 2 i C 4 int ij i j 1 loc lim 0 if r cbp chroma mb pos 1 ij loc lim cur lim else if j top cbp 1 ij 2 loc lim top lim else if j cur cbp 1 ij 2 loc lim cur lim if loc lim rv30 weak loop filter C s uvlinesize 1 loc lim static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt MDEC Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size Thread Frame frame f data int i ret if ret ff thread get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret frame f pict type AVPICTURETYPEI frame f key frame 1 av fast malloc a bitstream buffer a bitstream buffer size buf size FFINPUTBUFFERPADDINGSIZE if a bitstream buffer return AVERRORENOMEM for i 0 i buf size i 2 a bitstream buffer i buf i 1 a bitstream buffer i 1 buf i init get bits a gb a bitstream buffer buf size 8 skip bits a gb 32 a qscale get bits a gb 16 a version get bits a gb 16 a last dc 0 a last dc 1 a last dc 2 128 for a mb x 0 a mb x a mb width a mb x for a mb y 0 a mb y a mb height a mb y if ret decode mb a a block 0 return ret idct put a frame f a mb x a mb y got frame 1 return get bits count a gb 31 32 4 double histogram selectivity Variable Stat Data vardata Fmgr Info opproc Datum constval bool varonleft int min hist size int n skip int hist size double result Datum values int nvalues Assert n skip 0 Assert min hist size 2 n skip if Heap Tuple Is Valid vardata stats Tuple get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid NULL values nvalues NULLNULL hist size nvalues if nvalues min hist size int nmatch 0 int i for i n skip i nvalues n skip i if varonleft Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values i constval Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID constval values i nmatch result double nmatch double nvalues 2 n skip else result 1 free attstatsslot vardata atttype values nvalues NULL 0 else hist size 0 result 1 return result static int userauth pubkey struct ssh ssh Authctxt authctxt ssh authctxt struct passwd pw authctxt pw struct sshbuf b struct sshkey key NULL char pkalg userstyle NULL key s NULL ca s NULL u char pkblob sig have sig size t blen slen int r pktype int authenticated 0 struct sshauthopt authopts NULL if authctxt valid debug2 s disabled because of invalid user func return 0 if r sshpkt get u8 ssh have sig 0 r sshpkt get cstring ssh pkalg NULL 0 r sshpkt get string ssh pkblob blen 0 fatal s parse request failed s func ssh err r pktype sshkey type from name pkalg if pktype KEYUNSPEC verbose s unsupported public key algorithm s func pkalg goto done if r sshkey from blob pkblob blen key 0 error s could not parse key s func ssh err r goto done if key NULL error s cannot decode key s func pkalg goto done if key type pktype error s type mismatch for decoded key received d expected d func key type pktype goto done if sshkey type plain key type KEYRSA ssh compat SSHBUGRSASIGM D5 0 logit Refusing RSA key because client uses unsafe signature scheme goto done if auth2 key already used authctxt key logit refusing previously used s key sshkey type key goto done if match pattern list pkalg options pubkey key types 0 1 logit s key type s not in Pubkey Accepted Key Types func sshkey ssh name key goto done key s format key key if sshkey is cert key ca s format key key cert signature key if have sig debug3 s have s signature for s s s func pkalg key s ca s NULLCA ca s NULL ca s if r sshpkt get string ssh sig slen 0 r sshpkt get end ssh 0 fatal s s func ssh err r if b sshbuf new NULL fatal s sshbuf new failed func if ssh compat SSHOLDSESSIONID if r sshbuf put b session id2 session id2 len 0 fatal s sshbuf put session id s func ssh err r else if r sshbuf put string b session id2 session id2 len 0 fatal s sshbuf put string session id s func ssh err r xasprintf userstyle s s s authctxt user authctxt style authctxt style authctxt style if r sshbuf put u8 b SS H2 MSGUSERAUTHREQUEST 0 r sshbuf put cstring b userstyle 0 r sshbuf put cstring b authctxt service 0 r sshbuf put cstring b publickey 0 r sshbuf put u8 b have sig 0 r sshbuf put cstring b pkalg 0 r sshbuf put string b pkblob blen 0 fatal s build packet failed s func ssh err r if PRIVSEP user key allowed ssh pw key 1 authopts PRIVSEP sshkey verify key sig slen sshbuf ptr b sshbuf len b ssh compat SSHBUGSIGTYPE 0 pkalg NULL ssh compat 0 authenticated 1 sshbuf free b free sig auth2 record key authctxt authenticated key else debug s test pkalg s pkblob s s s func pkalg key s ca s NULLCA ca s NULL ca s if r sshpkt get end ssh 0 fatal s s func ssh err r if PRIVSEP user key allowed ssh pw key 0 NULL if r sshpkt start ssh SS H2 MSGUSERAUTHPKOK 0 r sshpkt put cstring ssh pkalg 0 r sshpkt put string ssh pkblob blen 0 r sshpkt send ssh 0 r ssh packet write wait ssh 0 fatal s s func ssh err r authctxt postponed 1 done if authenticated 1 auth activate options ssh authopts 0 debug s key options inconsistent with existing func authenticated 0 debug2 s authenticated d pkalg s func authenticated pkalg sshauthopt free authopts sshkey free key free userstyle free pkalg free pkblob free key s free ca s return authenticated static int selinux setprocattr struct task struct p char name void value size t size struct task security struct tsec struct cred new u32 sid 0 ptsid int error char str value if current p return EACCES if strcmp name exec error current has perm p PROCESSSETEXEC else if strcmp name fscreate error current has perm p PROCESSSETFSCREATE else if strcmp name keycreate error current has perm p PROCESSSETKEYCREATE else if strcmp name sockcreate error current has perm p PROCESSSETSOCKCREATE else if strcmp name current error current has perm p PROCESSSETCURRENT else error EINVAL if error return error if size str 0 str 0 n if str size 1 n str size 1 0 size error security context to sid value size sid GFPKERNEL if error EINVAL strcmp name fscreate if capable CAPMACADMIN struct audit buffer ab size t audit size if str size 1 0 audit size size 1 else audit size size ab audit log start current audit context GFPATOMICAUDITSELINUXERR audit log format ab op fscreate invalid context audit log n untrustedstring ab value audit size audit log end ab return error error security context to sid force value size sid if error return error new prepare creds if new return ENOMEM tsec new security if strcmp name exec tsec exec sid sid else if strcmp name fscreate tsec create sid sid else if strcmp name keycreate error may create key sid p if error goto abort change tsec keycreate sid sid else if strcmp name sockcreate tsec sockcreate sid sid else if strcmp name current error EINVAL if sid 0 goto abort change error EPERM if current is single threaded error security bounded transition tsec sid sid if error goto abort change error avc has perm tsec sid sid SECCLASSPROCESSPROCESSDYNTRANSITIONNULL if error goto abort change ptsid ptrace parent sid p if ptsid 0 error avc has perm ptsid sid SECCLASSPROCESSPROCESSPTRACENULL if error goto abort change tsec sid sid else error EINVAL goto abort change commit creds new return size abort change abort creds new return error static size t read uncompressed header V P9 Decoder pbi struct vp9 read bit buffer rb V P9 COMMON const cm pbi common size t sz int i cm last frame type cm frame type if vp9 rb read literal rb 2 V P9 FRAMEMARKER vpx internal error cm error VPXCODECUNSUPBITSTREAM Invalid frame marker cm profile vp9 read profile rb if cm profile MAXPROFILES vpx internal error cm error VPXCODECUNSUPBITSTREAM Unsupported bitstream profile cm show existing frame vp9 rb read bit rb if cm show existing frame const int frame to show cm ref frame map vp9 rb read literal rb 3 if frame to show 0 cm frame bufs frame to show ref count 1 vpx internal error cm error VPXCODECUNSUPBITSTREAM Buffer d does not contain a decoded frame frame to show ref cnt fb cm frame bufs cm new fb idx frame to show pbi refresh frame flags 0 cm lf filter level 0 cm show frame 1 return 0 cm frame type FRAMETYPE vp9 rb read bit rb cm show frame vp9 rb read bit rb cm error resilient mode vp9 rb read bit rb if cm frame type KEYFRAME if vp9 read sync code rb vpx internal error cm error VPXCODECUNSUPBITSTREAM Invalid frame sync code read bitdepth colorspace sampling cm rb pbi refresh frame flags 1 REFFRAMES 1 for i 0 i REFSPERFRAME i cm frame refs i idx 1 cm frame refs i buf NULL setup frame size cm rb pbi need resync 0 else cm intra only cm show frame 0 vp9 rb read bit rb cm reset frame context cm error resilient mode vp9 rb read literal rb 2 if cm intra only if vp9 read sync code rb vpx internal error cm error VPXCODECUNSUPBITSTREAM Invalid frame sync code if cm profile PROFILE 0 read bitdepth colorspace sampling cm rb else cm color space BT 601 cm subsampling y cm subsampling x 1 pbi refresh frame flags vp9 rb read literal rb REFFRAMES setup frame size cm rb pbi need resync 0 else pbi refresh frame flags vp9 rb read literal rb REFFRAMES for i 0 i REFSPERFRAME i const int ref vp9 rb read literal rb REFFRAMESLO G2 const int idx cm ref frame map ref Ref Buffer const ref frame cm frame refs i ref frame idx idx ref frame buf cm frame bufs idx buf cm ref frame sign bias LASTFRAME i vp9 rb read bit rb setup frame size with refs cm rb cm allow high precision mv vp9 rb read bit rb cm interp filter read interp filter rb for i 0 i REFSPERFRAME i Ref Buffer const ref buf cm frame refs i if pbi need resync vpx internal error cm error VPXCODECCORRUPTFRAME Keyframe intra only frame required to reset decoder state if cm error resilient mode cm refresh frame context vp9 rb read bit rb cm frame parallel decoding mode vp9 rb read bit rb else cm refresh frame context 0 cm frame parallel decoding mode 1 cm frame context idx vp9 rb read literal rb FRAMECONTEXTSLO G2 if frame is intra only cm cm error resilient mode vp9 setup past independence cm setup loopfilter cm lf rb setup quantization cm pbi mb rb setup segmentation cm seg rb setup tile info cm rb sz vp9 rb read literal rb 16 if sz 0 vpx internal error cm error VPXCODECCORRUPTFRAME Invalid header size return sz static void fill decode caches H264 Context h int mb type int topleft xy top xy topright xy left xy LEFTMBS int topleft type top type topright type left type LEFTMBS const uint8 t left block h left block int i uint8 t nnz uint8 t nnz cache topleft xy h topleft mb xy top xy h top mb xy topright xy h topright mb xy left xy LTOP h left mb xy LTOP left xy LBOT h left mb xy LBOT topleft type h topleft type top type h top type topright type h topright type left type LTOP h left type LTOP left type LBOT h left type LBOT if ISSKIP mb type if ISINTRA mb type int type mask h pps constrained intra pred ISINTRA 1 1 h topleft samples available h top samples available h left samples available 0x FFFF h topright samples available 0x EEEA if top type type mask h topleft samples available 0x B3 FF h top samples available 0x33 FF h topright samples available 0x26 EA if ISINTERLACED mb type ISINTERLACED left type LTOP if ISINTERLACED mb type if left type LTOP type mask h topleft samples available 0x DFFF h left samples available 0x5 FFF if left type LBOT type mask h topleft samples available 0x F F5 F h left samples available 0x F F5 F else int left typei h cur pic f mb type left xy LTOP h mb stride assert left xy LTOP left xy LBOT if left typei type mask left type LTOP type mask h topleft samples available 0x D F5 F h left samples available 0x5 F5 F else if left type LTOP type mask h topleft samples available 0x D F5 F h left samples available 0x5 F5 F if topleft type type mask h topleft samples available 0x7 FFF if topright type type mask h topright samples available 0x FBFF if ISINTR A4x4 mb type if ISINTR A4x4 top type AVCOP Y32 h intra4x4 pred mode cache 4 8 0 h intra4x4 pred mode h mb2br xy top xy else h intra4x4 pred mode cache 4 8 0 h intra4x4 pred mode cache 5 8 0 h intra4x4 pred mode cache 6 8 0 h intra4x4 pred mode cache 7 8 0 2 3 top type type mask for i 0 i 2 i if ISINTR A4x4 left type LEFT i int8 t mode h intra4x4 pred mode h mb2br xy left xy LEFT i h intra4x4 pred mode cache 3 8 1 2 8 i mode 6 left block 0 2 i h intra4x4 pred mode cache 3 8 2 2 8 i mode 6 left block 1 2 i else h intra4x4 pred mode cache 3 8 1 2 8 i h intra4x4 pred mode cache 3 8 2 2 8 i 2 3 left type LEFT i type mask nnz cache h non zero count cache if top type nnz h non zero count top xy AVCOP Y32 nnz cache 4 8 0 nnz 4 3 if h chroma y shift AVCOP Y32 nnz cache 4 8 5 nnz 4 7 AVCOP Y32 nnz cache 4 8 10 nnz 4 11 else AVCOP Y32 nnz cache 4 8 5 nnz 4 5 AVCOP Y32 nnz cache 4 8 10 nnz 4 9 else uint32 t top empty CABACISINTRA mb type 0 0x40404040 AVW N32 A nnz cache 4 8 0 top empty AVW N32 A nnz cache 4 8 5 top empty AVW N32 A nnz cache 4 8 10 top empty for i 0 i 2 i if left type LEFT i nnz h non zero count left xy LEFT i nnz cache 3 8 1 2 8 i nnz left block 8 0 2 i nnz cache 3 8 2 2 8 i nnz left block 8 1 2 i if CHROM A444 nnz cache 3 8 6 2 8 i nnz left block 8 0 2 i 4 4 nnz cache 3 8 7 2 8 i nnz left block 8 1 2 i 4 4 nnz cache 3 8 11 2 8 i nnz left block 8 0 2 i 8 4 nnz cache 3 8 12 2 8 i nnz left block 8 1 2 i 8 4 else if CHROM A422 nnz cache 3 8 6 2 8 i nnz left block 8 0 2 i 2 4 4 nnz cache 3 8 7 2 8 i nnz left block 8 1 2 i 2 4 4 nnz cache 3 8 11 2 8 i nnz left block 8 0 2 i 2 8 4 nnz cache 3 8 12 2 8 i nnz left block 8 1 2 i 2 8 4 else nnz cache 3 8 6 8 i nnz left block 8 4 2 i nnz cache 3 8 11 8 i nnz left block 8 5 2 i else nnz cache 3 8 1 2 8 i nnz cache 3 8 2 2 8 i nnz cache 3 8 6 2 8 i nnz cache 3 8 7 2 8 i nnz cache 3 8 11 2 8 i nnz cache 3 8 12 2 8 i CABACISINTRA mb type 0 64 if CABAC if top type h top cbp h cbp table top xy else h top cbp ISINTRA mb type 0x7 CF 0x00 F if left type LTOP h left cbp h cbp table left xy LTOP 0x7 F0 h cbp table left xy LTOP left block 0 1 2 h cbp table left xy LBOT left block 2 1 2 2 else h left cbp ISINTRA mb type 0x7 CF 0x00 F if ISINTER mb type ISDIRECT mb type h direct spatial mv pred int list int b stride h b stride for list 0 list h list count list int8 t ref cache h ref cache list scan8 0 int8 t ref h cur pic f ref index list int16 t mv cache 2 h mv cache list scan8 0 int16 t mv 2 h cur pic f motion val list if USESLIST mb type list continue assert ISDIRECT mb type h direct spatial mv pred if USESLIST top type list const int b xy h mb2b xy top xy 3 b stride AVCOP Y128 mv cache 0 1 8 mv b xy 0 ref cache 0 1 8 ref cache 1 1 8 ref 4 top xy 2 ref cache 2 1 8 ref cache 3 1 8 ref 4 top xy 3 else AVZER O128 mv cache 0 1 8 AVW N32 A ref cache 0 1 8 top type LISTNOTUSEDPARTNOTAVAILABLE 0x FF 0x01010101u if mb type MBTYPE 16x8 MBTYPE 8x8 for i 0 i 2 i int cache idx 1 i 2 8 if USESLIST left type LEFT i list const int b xy h mb2b xy left xy LEFT i 3 const int b8 xy 4 left xy LEFT i 1 AVCOP Y32 mv cache cache idx mv b xy b stride left block 0 i 2 AVCOP Y32 mv cache cache idx 8 mv b xy b stride left block 1 i 2 ref cache cache idx ref b8 xy left block 0 i 2 1 ref cache cache idx 8 ref b8 xy left block 1 i 2 1 else AVZER O32 mv cache cache idx AVZER O32 mv cache cache idx 8 ref cache cache idx ref cache cache idx 8 left type LEFT i LISTNOTUSEDPARTNOTAVAILABLE else if USESLIST left type LTOP list const int b xy h mb2b xy left xy LTOP 3 const int b8 xy 4 left xy LTOP 1 AVCOP Y32 mv cache 1 mv b xy b stride left block 0 ref cache 1 ref b8 xy left block 0 1 else AVZER O32 mv cache 1 ref cache 1 left type LTOPLISTNOTUSEDPARTNOTAVAILABLE if USESLIST topright type list const int b xy h mb2b xy topright xy 3 b stride AVCOP Y32 mv cache 4 1 8 mv b xy ref cache 4 1 8 ref 4 topright xy 2 else AVZER O32 mv cache 4 1 8 ref cache 4 1 8 topright type LISTNOTUSEDPARTNOTAVAILABLE if ref cache 4 1 8 0 if USESLIST topleft type list const int b xy h mb2b xy topleft xy 3 b stride h topleft partition 2 b stride const int b8 xy 4 topleft xy 1 h topleft partition 2 AVCOP Y32 mv cache 1 1 8 mv b xy ref cache 1 1 8 ref b8 xy else AVZER O32 mv cache 1 1 8 ref cache 1 1 8 topleft type LISTNOTUSEDPARTNOTAVAILABLE if mb type MBTYPESKIPMBTYPEDIREC T2 FRAMEMBAFF continue if mb type MBTYPESKIPMBTYPEDIREC T2 uint8 t mvd cache 2 h mvd cache list scan8 0 uint8 t mvd 2 h mvd table list ref cache 2 8 0 ref cache 2 8 2 PARTNOTAVAILABLEAVZER O32 mv cache 2 8 0 AVZER O32 mv cache 2 8 2 if CABAC if USESLIST top type list const int b xy h mb2br xy top xy AVCOP Y64 mvd cache 0 1 8 mvd b xy 0 else AVZER O64 mvd cache 0 1 8 if USESLIST left type LTOP list const int b xy h mb2br xy left xy LTOP 6 AVCOP Y16 mvd cache 1 0 8 mvd b xy left block 0 AVCOP Y16 mvd cache 1 1 8 mvd b xy left block 1 else AVZER O16 mvd cache 1 0 8 AVZER O16 mvd cache 1 1 8 if USESLIST left type LBOT list const int b xy h mb2br xy left xy LBOT 6 AVCOP Y16 mvd cache 1 2 8 mvd b xy left block 2 AVCOP Y16 mvd cache 1 3 8 mvd b xy left block 3 else AVZER O16 mvd cache 1 2 8 AVZER O16 mvd cache 1 3 8 AVZER O16 mvd cache 2 8 0 AVZER O16 mvd cache 2 8 2 if h slice type nos AVPICTURETYPEB uint8 t direct cache h direct cache scan8 0 uint8 t direct table h direct table fill rectangle direct cache 4 4 8 MBTYPE 16x16 1 1 if ISDIRECT top type AVW N32 A direct cache 1 8 0x01010101u MBTYPEDIREC T2 1 else if IS 8 X8 top type int b8 xy 4 top xy direct cache 0 1 8 direct table b8 xy 2 direct cache 2 1 8 direct table b8 xy 3 else AVW N32 A direct cache 1 8 0x01010101 MBTYPE 16x16 1 if ISDIRECT left type LTOP direct cache 1 0 8 MBTYPEDIREC T2 1 else if IS 8 X8 left type LTOP direct cache 1 0 8 direct table 4 left xy LTOP 1 left block 0 1 else direct cache 1 0 8 MBTYPE 16x16 1 if ISDIRECT left type LBOT direct cache 1 2 8 MBTYPEDIREC T2 1 else if IS 8 X8 left type LBOT direct cache 1 2 8 direct table 4 left xy LBOT 1 left block 2 1 else direct cache 1 2 8 MBTYPE 16x16 1 if MBFIELD h ref cache list idx 1 h mv cache list idx 1 2 h mvd cache list idx 1 1 MAPMVS else h ref cache list idx 1 h mv cache list idx 1 1 h mvd cache list idx 1 1 MAPMVS undef MAP F2 static void render slice Vp3 Decode Context s int slice int x y i j fragment int16 t block s block int motion x 0xdeadbeef motion y 0xdeadbeef int motion halfpel index uint8 t motion source int plane first pixel if slice s c superblock height return for plane 0 plane 3 plane uint8 t output plane s current frame data plane s data offset plane uint8 t last plane s last frame data plane s data offset plane uint8 t golden plane s golden frame data plane s data offset plane int stride s current frame linesize plane int plane width s width plane s chroma x shift int plane height s height plane s chroma y shift int8 t motion val 2 s motion val plane int sb x sb y slice plane s chroma y shift int slice height sb y 1 plane s chroma y shift int slice width plane s c superblock width s y superblock width int fragment width s fragment width plane int fragment height s fragment height plane int fragment start s fragment start plane int do await plane HAVETHREADS s avctx active thread type FFTHREADFRAME if s flipped image stride stride if CONFIGGRAY plane s avctx flags CODECFLAGGRAY continue for sb y slice height sb y for sb x 0 sb x slice width sb x for j 0 j 16 j x 4 sb x hilbert offset j 0 y 4 sb y hilbert offset j 1 fragment y fragment width x i fragment start fragment if x fragment width y fragment height continue first pixel 8 y stride 8 x if do await s all fragments i coding method MODEINTRA await reference row s s all fragments i motion val fragment 1 16 y s chroma y shift if s all fragments i coding method MODECOPY if s all fragments i coding method MODEUSINGGOLDEN s all fragments i coding method MODEGOLDENMV motion source golden plane else motion source last plane motion source first pixel motion halfpel index 0 if s all fragments i coding method MODEINTRA s all fragments i coding method MODEUSINGGOLDEN int src x src y motion x motion val fragment 0 motion y motion val fragment 1 src x motion x 1 8 x src y motion y 1 8 y motion halfpel index motion x 0x01 motion source motion x 1 motion halfpel index motion y 0x01 1 motion source motion y 1 stride if src x 0 src y 0 src x 9 plane width src y 9 plane height uint8 t temp s edge emu buffer if stride 0 temp 8 stride s vdsp emulated edge mc temp motion source stride 9 9 src x src y plane width plane height motion source temp if s all fragments i coding method MODEINTRA if motion halfpel index 3 s dsp put no rnd pixels tab 1 motion halfpel index output plane first pixel motion source stride 8 else int d motion x motion y 31 s vp3dsp put no rnd pixels l2 output plane first pixel motion source d motion source stride 1 d stride 8 if s all fragments i coding method MODEINTRA int index index vp3 dequant s s all fragments i plane 0 block if index 63 continue s vp3dsp idct put output plane first pixel stride block else int index vp3 dequant s s all fragments i plane 1 block if index 63 continue if index 0 s vp3dsp idct add output plane first pixel stride block else s vp3dsp idct dc add output plane first pixel stride block else s dsp put pixels tab 1 0 output plane first pixel last plane first pixel stride 8 if s skip loop filter apply loop filter s plane 4 sb y sb y FFMIN 4 sb y 3 fragment height 1 vp3 draw horiz band s FFMIN 32 s chroma y shift slice 1 16 s height 16 static void store coding context MACROBLOCK x PICKMODECONTEXT ctx int mode index int64 t comp pred diff REFERENCEMODES const int64 t tx size diff TXMODES int64 t best filter diff SWITCHABLEFILTERCONTEXTS int skippable MACROBLOCKD const xd x e mbd ctx skip x skip ctx skippable skippable ctx best mode index mode index ctx mic xd mi 0 ctx single pred diff int comp pred diff SINGLEREFERENCE ctx comp pred diff int comp pred diff COMPOUNDREFERENCE ctx hybrid pred diff int comp pred diff REFERENCEMODESELECT vpx memcpy ctx tx rd diff tx size diff sizeof ctx tx rd diff vpx memcpy ctx best filter diff best filter diff sizeof best filter diff static int decode udvm multitype operand guint8 buff guint operand address guint16 value guint test bits guint bytecode guint offset operand address guint16 operand guint32 result guint8 temp data guint16 temp data16 guint16 memmory addr 0 value 0 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 0xc0 6 switch test bits case 0 operand buff operand address value operand offset break case 1 memmory addr bytecode 0x3f 2 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset break case 2 test bits bytecode 0xe0 5 if test bits 5 temp data buff operand address 0x1f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data value operand offset offset 2 else test bits bytecode 0xf0 4 if test bits 9 temp data buff operand address 0x0f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 61440 value operand offset offset 2 else test bits bytecode 0x08 3 if test bits 1 result 1 buff operand address 0x07 8 operand result 0xffff value operand offset else test bits bytecode 0x0e 1 if test bits 3 result 1 buff operand address 0x01 6 operand result 0xffff value operand offset else offset temp data16 buff operand address 1 0xffff 8 temp data16 temp data16 buff operand address 2 0xffff if bytecode 0x01 1 memmory addr temp data16 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 break case 3 test bits bytecode 0x20 5 if test bits 1 operand buff operand address 0x1f 65504 value operand offset else memmory addr buff operand address 0x1f memmory addr memmory addr 8 memmory addr memmory addr buff operand address 1 0xffff temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 default break return offset int ieee80211 radiotap iterator next struct ieee80211 radiotap iterator iterator while 1 int hit 0 int pad align size subns guint32 oui if iterator arg index 32 IEE E80211 RADIOTAPEXT iterator bitmap shifter 1 return ENOENT if iterator bitmap shifter 1 goto next entry switch iterator arg index 32 case IEE E80211 RADIOTAPRADIOTAPNAMESPACE case IEE E80211 RADIOTAPEXT align 1 size 0 break case IEE E80211 RADIOTAPVENDORNAMESPACE align 2 size 6 break default ifdef RADIOTAPSUPPORTOVERRIDES if find override iterator align size else endif if iterator current namespace iterator arg index iterator current namespace n bits if iterator current namespace radiotap ns return ENOENT align 0 else align iterator current namespace align size iterator arg index align size iterator current namespace align size iterator arg index size if align if iterator next ns data return EINVAL iterator arg iterator next ns data iterator current namespace NULL iterator next ns data NULL if ITERATORVALID iterator 0 return EINVAL goto next entry break pad int iterator arg unsigned char iterator rtheader align 1 if pad iterator arg align pad if iterator arg index 32 IEE E80211 RADIOTAPVENDORNAMESPACE int vnslen if ITERATORVALID iterator size return EINVAL oui iterator arg 16 iterator arg 1 8 iterator arg 2 subns iterator arg 3 find ns iterator oui subns vnslen get unaligned le16 iterator arg 4 iterator next ns data iterator arg size vnslen if iterator current namespace size vnslen iterator this arg index iterator arg index iterator this arg iterator arg iterator this arg size size iterator arg size if ITERATORVALID iterator 0 return EINVAL switch iterator arg index 32 case IEE E80211 RADIOTAPVENDORNAMESPACE iterator reset on ext 1 iterator is radiotap ns 0 iterator this arg index IEE E80211 RADIOTAPVENDORNAMESPACE if iterator current namespace hit 1 goto next entry case IEE E80211 RADIOTAPRADIOTAPNAMESPACE iterator reset on ext 1 iterator current namespace radiotap ns iterator is radiotap ns 1 goto next entry case IEE E80211 RADIOTAPEXT iterator bitmap shifter get unaligned le32 iterator next bitmap iterator next bitmap if iterator reset on ext iterator arg index 0 else iterator arg index iterator reset on ext 0 break default hit 1 next entry iterator bitmap shifter 1 iterator arg index if hit return 0 static void duplicate mode info in sb V P9 COMMON cm MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize const int block width num 8x8 blocks wide lookup bsize const int block height num 8x8 blocks high lookup bsize int i j for j 0 j block height j for i 0 i block width i if mi row j cm mi rows mi col i cm mi cols xd mi j xd mi stride i src mi xd mi 0 static void setup buffer inter V P9 COMP cpi MACROBLOCK x const Tile Info const tile MVREFERENCEFRAME ref frame BLOCKSIZE block size int mi row int mi col int mv frame nearest mv MAXREFFRAMES int mv frame near mv MAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE const V P9 COMMON cm cpi common const Y V12 BUFFERCONFIG yv12 get ref frame buffer cpi ref frame MACROBLOCKD const xd x e mbd MODEINFO const mi xd mi 0 src mi int mv const candidates mi mbmi ref mvs ref frame const struct scale factors const sf cm frame refs ref frame 1 sf vp9 setup pred block xd yv12 mb ref frame yv12 mi row mi col sf sf vp9 find mv refs cm xd tile mi ref frame candidates mi row mi col vp9 find best ref mvs xd cm allow high precision mv candidates frame nearest mv ref frame frame near mv ref frame if vp9 is scaled sf block size BLOCK 8 X8 vp9 mv pred cpi x yv12 mb ref frame 0 buf yv12 y stride ref frame block size static int dissect diameter base framed ipv6 prefix tvbuff t tvb packet info pinfo U proto tree tree void data diam sub dis t diam sub dis diam sub dis t data guint8 prefix len prefix len bytes proto tree add item tree hf framed ipv6 prefix reserved tvb 0 1 ENCBIGENDIAN proto tree add item tree hf framed ipv6 prefix length tvb 1 1 ENCBIGENDIAN prefix len tvb get guint8 tvb 1 prefix len bytes prefix len 8 if prefix len 8 prefix len bytes proto tree add item tree hf framed ipv6 prefix bytes tvb 2 prefix len bytes ENCNA if prefix len bytes 16 proto tree add item tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes ENCNA else struct e in6 addr value address addr memset value bytes 0 sizeof value tvb memcpy tvb guint8 value bytes 2 prefix len bytes value bytes prefix len bytes value bytes prefix len bytes 0xff prefix len 8 proto tree add ipv6 tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes value set address addr ATI Pv6 16 value bytes diam sub dis avp str wmem strdup printf wmem packet scope s u address to str wmem packet scope addr prefix len return prefix len bytes 2 static void draw char AV Codec Context avctx int c Ansi Context s avctx priv data int fg s fg int bg s bg if s attributes ATTRBOLD fg 8 if s attributes ATTRBLINK bg 8 if s attributes ATTRREVERSEFFSWAP int fg bg if s attributes ATTRCONCEALED fg bg ff draw pc font s frame data 0 s y s frame linesize 0 s x s frame linesize 0 s font s font height c fg bg s x FONTWIDTH if s x avctx width s x 0 hscroll avctx static void set partition range V P9 COMMON cm MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize BLOCKSIZE min bs BLOCKSIZE max bs int mi width num 8x8 blocks wide lookup bsize int mi height num 8x8 blocks high lookup bsize int idx idy MODEINFO mi MODEINFO prev mi cm prev mi grid visible mi row cm mi stride mi col BLOCKSIZE bs min size max size min size BLOCK 64 X64 max size BLOCK 4 X4 if prev mi for idy 0 idy mi height idy for idx 0 idx mi width idx mi prev mi idy cm mi stride idx bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd left available for idy 0 idy mi height idy mi xd mi idy cm mi stride 1 bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd up available for idx 0 idx mi width idx mi xd mi idx cm mi stride bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if min size max size min size min partition size min size max size max partition size max size min bs min size max bs max size static Asn1 Generic Decode Asn1 Der Sequence const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length parsed bytes numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SEQUENCE c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size node length d length if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL parsed bytes 0 seq index 0 while parsed bytes d length el max size max size d ptr buffer Asn1 Generic child Decode Asn1 Der Generic d ptr el max size depth seq index errcode if child NULL if errcode errcode 0 Der Free node return NULL break int ret Asn1 Sequence Append node child if ret 1 Der Free child break parsed bytes child length d ptr child length seq index return Asn1 Generic node static void main get appheader xd3 stream stream main file ifile main file output main file sfile uint8 t apphead usize t appheadsz int ret if option use appheader return ret xd3 get appheader stream apphead appheadsz if ret 0 return if appheadsz 0 char start char apphead char slash int place 0 char parsed 4 memset parsed 0 sizeof parsed while slash strchr start NULL slash 0 parsed place start start slash 1 parsed place start if place 2 place 4 main get appheader params output parsed 1 output ifile if place 4 main get appheader params sfile parsed 2 0 source ifile option use appheader 0 return int encode function char string struct filter op fop char str strdup string int ret ENOTFOUND char name args int nargs 0 i char dec args NULL char tok memset fop 0 sizeof struct filter op name ec strtok string tok args name strlen name 1 dec args decode args args nargs fop opcode FOPFUNC if strcmp name search if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCSEARCH fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name regex if nargs 2 int err regex t regex char errbuf 100 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCREGEX fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 err regcomp regex const char fop op func string REGEXTENDEDREGNOSUBREGICASE if err regerror err regex errbuf sizeof errbuf SCRIPTERROR s errbuf regfree regex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name pcre regex const char errbuf NULL int erroff if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func string strdup dec args 1 fop op func slen strlen fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else if nargs 3 fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func level 5 fop op func string strdup dec args 1 fop op func slen strlen fop op func string fop op func replace strdup dec args 2 fop op func rlen strlen fop op func replace ret ESUCCESS pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name replace if nargs 2 fop op func op FFUNCREPLACE fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string fop op func replace u char strdup dec args 1 fop op func rlen strescape char fop op func replace char fop op func replace ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name inject if nargs 1 fop op func op FFUNCINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name execinject if nargs 1 fop op func op FFUNCEXECINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name log if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCLOG fop op func string u char strdup dec args 1 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name drop if nargs 0 fop op func op FFUNCDROP ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name kill if nargs 0 fop op func op FFUNCKILL ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name msg if nargs 1 fop op func op FFUNCMSG fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exec if nargs 1 fop op func op FFUNCEXEC fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exit if nargs 0 fop opcode FOPEXIT ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name for i 0 i nargs i SAFEFREE dec args i SAFEFREE dec args SAFEFREE str return ret int main int argc char argv if argc 1 strcmp argv 1 verbose verbose 1 else if argc 1 strcmp argv 1 debug verbose debug 1 if gcry check version GCRYPTVERSION die version mismatch n gcry control GCRYCTLDISABLESECMEM 0 gcry control GCRYCTLENABLEQUICKRANDOM 0 if debug gcry control GCRYCTLSETDEBUGFLAGS 1u 0 gcry control GCRYCTLINITIALIZATIONFINISHED 0 set get point context alloc context param basic ec math basic ec math simplified twistededwards math show All tests completed Errors d n error count return error count 1 0 static void erase screen AV Codec Context avctx Ansi Context s avctx priv data int i for i 0 i avctx height i memset s frame data 0 i s frame linesize 0 DEFAULTBGCOLOR avctx width s x s y 0 enum Imap Auth Res imap auth cram md5 struct Imap Data idata const char method char ibuf LONGSTRING 2 obuf LONGSTRING unsigned char hmac response M D5 DIGESTLEN int len int rc if mutt bit isset idata capabilities ACRAMM D5 return IMAPAUTHUNAVAIL mutt message Authenticating CRAMM D5 if mutt account getlogin idata conn account 0 return IMAPAUTHFAILURE if mutt account getpass idata conn account 0 return IMAPAUTHFAILURE imap cmd start idata AUTHENTICATECRAMM D5 do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 Invalid response from server s n ibuf goto bail len mutt b64 decode obuf idata buf 2 sizeof obuf if len 1 mutt debug 1 Error decoding base64 response n goto bail obuf len 0 mutt debug 2 CRAM challenge s n obuf hmac md5 idata conn account pass obuf hmac response int off snprintf obuf sizeof obuf s idata conn account user mutt md5 toascii hmac response obuf off mutt debug 2 CRAM response s n obuf mutt b64 encode ibuf obuf strlen obuf sizeof ibuf 2 mutt str strcat ibuf sizeof ibuf r n mutt socket send idata conn ibuf do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDOK mutt debug 1 Error receiving server response n goto bail if imap code idata buf return IMAPAUTHSUCCESS bail mutt error CRAMM D5 authentication failed return int jbig2 decode halftone region Jbig2 Ctx ctx Jbig2 Segment segment Jbig2 Halftone Region Params params const byte data const size t size Jbig2 Image image Jbig2 Arith Cx GB stats uint32 t HBPP uint32 t HNUMPATS uint8 t GI Jbig2 Image HSKIPNULL Jbig2 Pattern Dict HPATS int i uint32 t mg ng int32 t x y uint8 t gray val memset image data params HDEFPIXEL image stride image height if params HENABLESKIP 1 jbig2 error ctx JBI G2 SEVERITYWARNING segment number unhandled option HENABLESKIPHPATS jbig2 decode ht region get hpats ctx segment if HPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number no pattern dictionary found skipping halftone image return 1 HNUMPATSHPATS n patterns HBPP 0 while HNUMPATS 1 HBPPGI jbig2 decode gray scale image ctx segment data size params HMMR params HGW params HGHHBPP params HENABLESKIPHSKIP params HTEMPLATEGB stats if GI jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to acquire gray scale image skipping halftone image return 1 for mg 0 mg params HGH mg for ng 0 ng params HGW ng x params HGX mg params HRY ng params HRX 8 y params HGY mg params HRX ng params HRY 8 gray val GI ng mg if gray val HNUMPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number gray scale image uses value d which larger than pattern dictionary gray val gray val HNUMPATS 1 jbig2 image compose ctx image HPATS patterns gray val x y params op for i 0 i params HGW i jbig2 free ctx allocator GI i jbig2 free ctx allocator GI return 0 static int ir2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ir2 Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p s picture int start ret if ret ff reget buffer avctx p 0 av log s avctx AVLOGERROR reget buffer failed n return ret start 48 if start buf size av log s avctx AVLOGERROR input buffer size too small d n buf size return AVERRORINVALIDDATA s decode delta buf 18 i buf size i buf i ff reverse buf i if s decode delta if ret ir2 decode plane s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret else if ret ir2 decode plane inter s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret if ret av frame ref picture s picture 0 return ret got frame 1 return buf size static int v410 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame pic data uint8 t src avpkt data uint16 t y u v uint32 t val int i j if avpkt size 4 avctx height avctx width av log avctx AVLOGERROR Insufficient input data n return AVERROREINVAL if ff get buffer avctx pic 0 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 for i 0 i avctx height i for j 0 j avctx width j val AVR L32 src u j val 2 0x3 FF y j val 12 0x3 FF v j val 22 src 4 y pic linesize 0 1 u pic linesize 1 1 v pic linesize 2 1 got frame 1 return avpkt size static int cine read header AV Format Context avctx AVIO Context pb avctx pb AV Stream st unsigned int version compression off Image Header off Setup off Image Offsets bi Bit Count length CFA int vflip char description uint64 t i st avformat new stream avctx NULL if st return AVERRORENOMEM st codecpar codec type AVMEDIATYPEVIDEO st codecpar codec id AVCODECIDRAWVIDEO st codecpar codec tag 0 avio skip pb 4 compression avio rl16 pb version avio rl16 pb if version 1 avpriv request sample avctx unknown version i version return AVERRORINVALIDDATA avio skip pb 12 st duration avio rl32 pb off Image Header avio rl32 pb off Setup avio rl32 pb off Image Offsets avio rl32 pb avio skip pb 8 avio seek pb off Image Header SEEKSET avio skip pb 4 st codecpar width avio rl32 pb st codecpar height avio rl32 pb if avio rl16 pb 1 return AVERRORINVALIDDATA bi Bit Count avio rl16 pb if bi Bit Count 8 bi Bit Count 16 bi Bit Count 24 bi Bit Count 48 avpriv request sample avctx unsupported bi Bit Count i bi Bit Count return AVERRORINVALIDDATA switch avio rl32 pb case BMPRGB vflip 0 break case 0x100 st codecpar codec tag MKTAGBIT 0 vflip 1 break default avpriv request sample avctx unknown bitmap compression return AVERRORINVALIDDATA avio skip pb 4 avio seek pb off Setup SEEKSET avio skip pb 140 if avio rl16 pb 0x5453 return AVERRORINVALIDDATA length avio rl16 pb if length 0x163 C avpriv request sample avctx short SETUP header return AVERRORINVALIDDATA avio skip pb 616 if avio rl32 pb vflip st codecpar extradata av strdup Bottom Up st codecpar extradata size 9 avio skip pb 4 avpriv set pts info st 64 1 avio rl32 pb avio skip pb 20 set metadata int st metadata camera version avio rl32 pb 0 set metadata int st metadata firmware version avio rl32 pb 0 set metadata int st metadata software version avio rl32 pb 0 set metadata int st metadata recording timezone avio rl32 pb 0 CFA avio rl32 pb set metadata int st metadata brightness avio rl32 pb 1 set metadata int st metadata contrast avio rl32 pb 1 set metadata int st metadata gamma avio rl32 pb 1 avio skip pb 12 16 set metadata float st metadata wbgain 0 r av int2float avio rl32 pb 1 set metadata float st metadata wbgain 0 b av int2float avio rl32 pb 1 avio skip pb 36 st codecpar bits per coded sample avio rl32 pb if compression CCRGB if bi Bit Count 8 st codecpar format AVPIXFMTGRA Y8 else if bi Bit Count 16 st codecpar format AVPIXFMTGRA Y16 LE else if bi Bit Count 24 st codecpar format AVPIXFMTBG R24 else if bi Bit Count 48 st codecpar format AVPIXFMTBG R48 LE else avpriv request sample avctx unsupported bi Bit Count i bi Bit Count return AVERRORINVALIDDATA else if compression CCUNINT switch CFA 0x FFFFFF case CFABAYER if bi Bit Count 8 st codecpar format AVPIXFMTBAYERGBR G8 else if bi Bit Count 16 st codecpar format AVPIXFMTBAYERGBR G16 LE else avpriv request sample avctx unsupported bi Bit Count i bi Bit Count return AVERRORINVALIDDATA break case CFABAYERFLIP if bi Bit Count 8 st codecpar format AVPIXFMTBAYERRGG B8 else if bi Bit Count 16 st codecpar format AVPIXFMTBAYERRGG B16 LE else avpriv request sample avctx unsupported bi Bit Count i bi Bit Count return AVERRORINVALIDDATA break default avpriv request sample avctx unsupported Color Field Array CFA i CFA 0x FFFFFF return AVERRORINVALIDDATA else avpriv request sample avctx unsupported compression i compression return AVERRORINVALIDDATA avio skip pb 668 set metadata int st metadata shutter ns avio rl32 pb 0 avio skip pb 24 if description return AVERRORENOMEM i avio get str pb DESCRIPTIONSIZE description DESCRIPTIONSIZE 1 if i DESCRIPTIONSIZE avio skip pb DESCRIPTIONSIZE i if description 0 av dict set st metadata description description AVDICTDONTSTRDUPVAL else av free description avio skip pb 1176 set metadata int st metadata enable crop avio rl32 pb 1 set metadata int st metadata crop left avio rl32 pb 1 set metadata int st metadata crop top avio rl32 pb 1 set metadata int st metadata crop right avio rl32 pb 1 set metadata int st metadata crop bottom avio rl32 pb 1 avio seek pb off Image Offsets SEEKSET for i 0 i st duration i if avio feof pb return AVERRORINVALIDDATA av add index entry st avio rl64 pb i 0 0 AVINDEXKEYFRAME return 0 int vp9 receive raw frame V P9 COMP cpi unsigned int frame flags Y V12 BUFFERCONFIG sd int64 t time stamp int64 t end time V P9 COMMON cm cpi common struct vpx usec timer timer int res 0 const int subsampling x sd uv width sd y width const int subsampling y sd uv height sd y height check initial width cpi subsampling x subsampling y vpx usec timer start timer else endif res vp9 lookahead push cpi lookahead sd time stamp end time frame flags if res res 1 vpx usec timer mark timer cpi time receive data vpx usec timer elapsed timer if cm profile PROFILE 0 cm profile PROFILE 2 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM Non 4 2 0 color space requires profile 1 or 3 res 1 if cm profile PROFILE 1 cm profile PROFILE 3 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM 4 2 0 color space requires profile 0 or 2 res 1 return res static void setup frame size with refs V P9 COMMON cm struct vp9 read bit buffer rb int width height int found 0 i int has valid ref frame 0 for i 0 i REFSPERFRAME i if vp9 rb read bit rb Y V12 BUFFERCONFIG const buf cm frame refs i buf width buf y crop width height buf y crop height if buf corrupted vpx internal error cm error VPXCODECCORRUPTFRAME Frame reference is corrupt found 1 break if found vp9 read frame size rb width height if width 0 height 0 vpx internal error cm error VPXCODECCORRUPTFRAME Invalid frame size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i has valid ref frame valid ref frame size ref frame buf y crop width ref frame buf y crop height width height if has valid ref frame vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has invalid size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i if valid ref frame img fmt ref frame buf bit depth ref frame buf uv crop width ref frame buf y crop width ref frame buf uv crop height ref frame buf y crop height cm bit depth cm subsampling x cm subsampling y vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has incompatible color space resize context buffers cm width height setup display size cm rb if vp9 realloc frame buffer get frame new buffer cm cm width cm height cm subsampling x cm subsampling y if CONFIGV P9 HIGHBITDEPTH cm use highbitdepth endif V P9 DECBORDERINPIXELS cm frame bufs cm new fb idx raw frame buffer cm get fb cb cm cb priv vpx internal error cm error VPXCODECMEMERROR Failed to allocate frame buffer cm frame bufs cm new fb idx buf bit depth unsigned int cm bit depth static int get buffer AV Codec Context avctx Picture pic SV Q3 Context s avctx priv data H264 Context h s h const int big mb num h mb stride h mb height 1 1 const int mb array size h mb stride h mb height const int b4 stride h mb width 4 1 const int b4 array size b4 stride h mb height 4 int ret if pic motion val buf 0 int i pic mb type buf av buffer allocz big mb num h mb stride sizeof uint32 t if pic mb type buf return AVERRORENOMEM pic mb type uint32 t pic mb type buf data 2 h mb stride 1 for i 0 i 2 i pic motion val buf i av buffer allocz 2 b4 array size 4 sizeof int16 t pic ref index buf i av buffer allocz 4 mb array size if pic motion val buf i pic ref index buf i ret AVERRORENOMEM goto fail pic motion val i int16 t 2 pic motion val buf i data 4 pic ref index i pic ref index buf i data pic f motion subsample log2 2 pic reference h pict type AVPICTURETYPEB ret ff get buffer avctx pic f pic reference AVGETBUFFERFLAGREF 0 if ret 0 goto fail if h edge emu buffer h edge emu buffer av mallocz pic f linesize 0 17 if h edge emu buffer return AVERRORENOMEM h linesize pic f linesize 0 h uvlinesize pic f linesize 1 return 0 fail free picture avctx pic return ret int uwsgi php init void struct uwsgi string list pset uphp set struct uwsgi string list append config uphp append config while append config uwsgi php append config append config value append config append config next while pset uwsgi php set pset value pset pset next if uphp dump config uwsgi log PHP custom config n n uwsgi log s n uwsgi sapi module ini entries uwsgi log end of PHP custom config n if uphp docroot char orig docroot uphp docroot uphp docroot uwsgi expand path uphp docroot strlen uphp docroot NULL if uphp docroot uwsgi log unable to set php docroot to s n orig docroot exit 1 uwsgi log PHP document root set to s n uphp docroot uphp docroot len strlen uphp docroot if uphp sapi name uwsgi sapi module name uphp sapi name uwsgi sapi module startup uwsgi sapi module uwsgi log PHP s initialized n PHPVERSION return 0 void configure buffer updates V P9 COMP cpi TWOPASS const twopass cpi twopass cpi rc is src frame alt ref 0 switch twopass gf group update type twopass gf group index case KFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 1 break case LFUPDATE cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 break case GFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 0 break case OVERLAYUPDATE cpi refresh last frame 0 cpi refresh golden frame 1 cpi refresh alt ref frame 0 cpi rc is src frame alt ref 1 break case ARFUPDATE cpi refresh last frame 0 cpi refresh golden frame 0 cpi refresh alt ref frame 1 break default assert 0 break if is two pass svc cpi if cpi svc temporal layer id 0 cpi refresh last frame 0 cpi refresh golden frame 0 if cpi svc layer context cpi svc spatial layer id gold ref idx 0 cpi refresh golden frame 0 if cpi alt ref source NULL cpi refresh alt ref frame 0 extern int as mysql job start mysql conn t mysql conn struct job record job ptr int rc SLURMSUCCESS char nodes NULL jname NULL node inx NULL int track steps 0 char block id NULL partition NULL char gres req NULL gres alloc NULL char temp bit BUFSIZE char query NULL int reinit 0 time t begin time check time start time submit time uint32 t wckeyid 0 uint32 t job state int node cnt 0 uint32 t array task id job ptr array job id job ptr array task id NOVAL uint64 t job db inx job ptr db index job array struct t array recs job ptr array recs if job ptr details job ptr details submit time job ptr resize time error as mysql job start Not inputing this job it has no submit time return SLURMERROR if check connection mysql conn SLURMSUCCESS return ESLURMDBCONNECTION debug2 as mysql slurmdb job start called job state job ptr job state if job ptr resize time begin time job ptr resize time submit time job ptr resize time start time job ptr resize time else begin time job ptr details begin time submit time job ptr details submit time start time job ptr start time if job ptr state reason WAITARRAYTASKLIMIT begin time INFINITE if ISJOBRESIZING job ptr if job ptr db index error We don t have a db index for job u this should only happen when resizing jobs and the database interface was down job ptr job id job ptr db index get db index mysql conn job ptr details submit time job ptr job id job ptr assoc id if job ptr db index as mysql job complete mysql conn job ptr job state JOBRESIZING job ptr db index 0 job state JOBSTATEBASE if start time check time start time else if begin time check time begin time else check time submit time slurm mutex lock rollup lock if check time global last rollup MYSQLRES result NULLMYSQLROW row query xstrdup printf select job db inx from s s where id job u and time submit ld and time eligible ld and time start ld mysql conn cluster name job table job ptr job id submit time begin time start time if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query if result mysql db query ret mysql conn query 0 xfree query slurm mutex unlock rollup lock return SLURMERROR xfree query if row mysql fetch row result mysql free result result debug4 revieved an update for a job u already known about job ptr job id slurm mutex unlock rollup lock goto no rollup change mysql free result result if job ptr start time debug Need to reroll usage from s Job u from s started then and we are just now hearing about it slurm ctime2 check time job ptr job id mysql conn cluster name else if begin time debug Need to reroll usage from s Job u from s became eligible then and we are just now hearing about it slurm ctime2 check time job ptr job id mysql conn cluster name else debug Need to reroll usage from s Job u from s was submitted then and we are just now hearing about it slurm ctime2 check time job ptr job id mysql conn cluster name global last rollup check time slurm mutex unlock rollup lock query xstrdup printf update s s set hourly rollup ld daily rollup ld monthly rollup ld mysql conn cluster name last ran table check time check time check time if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query rc mysql db query mysql conn query xfree query else slurm mutex unlock rollup lock no rollup change if job ptr name job ptr name 0 jname slurm add slash to quotes job ptr name else jname xstrdup allocation track steps 1 if job ptr nodes job ptr nodes 0 nodes job ptr nodes else nodes None assigned if job ptr batch flag track steps 1 if slurmdbd conf block id xstrdup job ptr comment node cnt job ptr total nodes node inx job ptr network else if job ptr node bitmap node inx bit fmt temp bit sizeof temp bit job ptr node bitmap select g select jobinfo get job ptr select jobinfo SELECTJOBDATANODECNT node cnt if job ptr assoc id job ptr db index job ptr wckey wckeyid get wckeyid mysql conn job ptr wckey job ptr user id mysql conn cluster name job ptr assoc id if ISJOBPENDING job ptr job ptr part ptr partition slurm add slash to quotes job ptr part ptr name else if job ptr partition partition slurm add slash to quotes job ptr partition if job ptr gres req gres req slurm add slash to quotes job ptr gres req if job ptr gres alloc gres alloc slurm add slash to quotes job ptr gres alloc if job ptr db index query xstrdup printf insert into s s id job mod time id array job id array task id assoc id qos id user id group nodelist id resv timelimit time eligible time submit time start job name track steps state priority cpus req nodes alloc mem req mysql conn cluster name job table if wckeyid xstrcat query id wckey if job ptr account xstrcat query account if partition xstrcat query partition if block id xstrcat query id block if job ptr wckey xstrcat query wckey if node inx xstrcat query node inx if gres req xstrcat query gres req if gres alloc xstrcat query gres alloc if array recs array recs task id str xstrcat query array task str array max tasks array task pending else xstrcat query array task str array task pending if job ptr tres alloc str xstrcat query tres alloc if job ptr tres req str xstrcat query tres req xstrfmtcat query values u UNIXTIMESTAMP u u u u u u s u u ld ld ld s u u u u u PR Iu64 job ptr job id job ptr array job id array task id job ptr assoc id job ptr qos id job ptr user id job ptr group id nodes job ptr resv id job ptr time limit begin time submit time start time jname track steps job state job ptr priority job ptr details min cpus node cnt job ptr details pn min memory if wckeyid xstrfmtcat query u wckeyid if job ptr account xstrfmtcat query s job ptr account if partition xstrfmtcat query s partition if block id xstrfmtcat query s block id if job ptr wckey xstrfmtcat query s job ptr wckey if node inx xstrfmtcat query s node inx if gres req xstrfmtcat query s gres req if gres alloc xstrfmtcat query s gres alloc if array recs array recs task id str xstrfmtcat query s u u array recs task id str array recs max run tasks array recs task cnt else xstrcat query NULL 0 if job ptr tres alloc str xstrfmtcat query s job ptr tres alloc str if job ptr tres req str xstrfmtcat query s job ptr tres req str xstrfmtcat query on duplicate key update job db inx LASTINSERTID job db inx id user u id group u nodelist s id resv u timelimit u time submit ld time eligible ld time start ld mod time UNIXTIMESTAMP job name s track steps u id qos u state greatest state u priority u cpus req u nodes alloc u mem req PR Iu64 id array job u id array task u job ptr user id job ptr group id nodes job ptr resv id job ptr time limit submit time begin time start time jname track steps job ptr qos id job state job ptr priority job ptr details min cpus node cnt job ptr details pn min memory job ptr array job id array task id if wckeyid xstrfmtcat query id wckey u wckeyid if job ptr account xstrfmtcat query account s job ptr account if partition xstrfmtcat query partition s partition if block id xstrfmtcat query id block s block id if job ptr wckey xstrfmtcat query wckey s job ptr wckey if node inx xstrfmtcat query node inx s node inx if gres req xstrfmtcat query gres req s gres req if gres alloc xstrfmtcat query gres alloc s gres alloc if array recs array recs task id str xstrfmtcat query array task str s array max tasks u array task pending u array recs task id str array recs max run tasks array recs task cnt else xstrfmtcat query array task str NULL array task pending 0 if job ptr tres alloc str xstrfmtcat query tres alloc s job ptr tres alloc str if job ptr tres req str xstrfmtcat query tres req s job ptr tres req str if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query try again if job ptr db index mysql db insert ret id mysql conn query if reinit error It looks like the storage has gone away trying to reconnect check connection mysql conn reinit 1 goto try again else rc SLURMERROR else query xstrdup printf update s s set nodelist s mysql conn cluster name job table nodes if wckeyid xstrfmtcat query id wckey u wckeyid if job ptr account xstrfmtcat query account s job ptr account if partition xstrfmtcat query partition s partition if block id xstrfmtcat query id block s block id if job ptr wckey xstrfmtcat query wckey s job ptr wckey if node inx xstrfmtcat query node inx s node inx if gres req xstrfmtcat query gres req s gres req if gres alloc xstrfmtcat query gres alloc s gres alloc if array recs array recs task id str xstrfmtcat query array task str s array max tasks u array task pending u array recs task id str array recs max run tasks array recs task cnt else xstrfmtcat query array task str NULL array task pending 0 if job ptr tres alloc str xstrfmtcat query tres alloc s job ptr tres alloc str if job ptr tres req str xstrfmtcat query tres req s job ptr tres req str xstrfmtcat query time start ld job name s state u nodes alloc u id qos u id assoc u id resv u timelimit u mem req PR Iu64 id array job u id array task u time eligible ld mod time UNIXTIMESTAMP where job db inx PR Iu64 start time jname job state node cnt job ptr qos id job ptr assoc id job ptr resv id job ptr time limit job ptr details pn min memory job ptr array job id array task id begin time job ptr db index if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query rc mysql db query mysql conn query xfree block id xfree partition xfree gres req xfree gres alloc xfree jname xfree query if ISJOBRESIZING job ptr if ISJOBSUSPENDED job ptr as mysql suspend mysql conn job db inx job ptr return rc static void txfm rd in plane MACROBLOCK x int rate int64 t distortion int skippable int64 t sse int64 t ref best rd int plane BLOCKSIZE bsize TXSIZE tx size int use fast coef casting MACROBLOCKD const xd x e mbd const struct macroblockd plane const pd xd plane plane struct rdcost block args args vp9 zero args args x x args best rd ref best rd args use fast coef costing use fast coef casting if plane 0 xd mi 0 mbmi tx size tx size vp9 get entropy contexts bsize tx size pd args t above args t left args so get scan xd tx size pd plane type 0 vp9 foreach transformed block in plane xd bsize plane block rd txfm args if args skip rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 else distortion args this dist rate args this rate sse args this sse skippable vp9 is skippable in plane x bsize plane static int aes ccm ctrl EVPCIPHERCTX c int type int arg void ptr EVPAESCCMCTX cctx EVPCDATAEVPAESCCMCTX c switch type case EVPCTRLINIT cctx key set 0 cctx iv set 0 cctx L 8 cctx M 12 cctx tag set 0 cctx len set 0 cctx tls aad len 1 return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx tls aad len arg uint16 t len EVPCIPHERCTX buf noconst c arg 2 8 EVPCIPHERCTX buf noconst c arg 1 if len EVPCCMTLSEXPLICITIVLEN return 0 len EVPCCMTLSEXPLICITIVLEN if EVPCIPHERCTX encrypting c if len cctx M return 0 len cctx MEVPCIPHERCTX buf noconst c arg 2 len 8 EVPCIPHERCTX buf noconst c arg 1 len 0xff return cctx M case EVPCTRLCCMSETIVFIXED if arg EVPCCMTLSFIXEDIVLEN return 0 memcpy EVPCIPHERCTX iv noconst c ptr arg return 1 case EVPCTRLAEADSETIVLEN arg 15 arg case EVPCTRLCCMSETL if arg 2 arg 8 return 0 cctx L arg return 1 case EVPCTRLAEADSETTAG if arg 1 arg 4 arg 16 return 0 if EVPCIPHERCTX encrypting c ptr return 0 if ptr cctx tag set 1 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx M arg return 1 case EVPCTRLAEADGETTAG if EVPCIPHERCTX encrypting c cctx tag set return 0 if CRYPTO ccm128 tag cctx ccm ptr size t arg return 0 cctx tag set 0 cctx iv set 0 cctx len set 0 return 1 case EVPCTRLCOPYEVPCIPHERCTX out ptr EVPAESCCMCTX cctx out EVPCDATAEVPAESCCMCTX out if cctx ccm key if cctx ccm key cctx ks return 0 cctx out ccm key cctx out ks return 1 default return 1 Spline Char PS Char String To Splines uint8 type1 int len struct pscontext context struct pschars subrs struct pschars gsubrs const char name int is type2 context is type2 real stack 50 int sp 0 v real transient 32 Spline Char ret Spline Char Create 2 Spline Point List cur NULL oldcur NULL Ref Char r1 r2 rlast NULLD Base Point current real dx dy dx2 dy2 dx3 dy3 dx4 dy4 dx5 dy5 dx6 dy6 Spline Point pt struct substate unsigned char type1 int len int subnum pcstack 11 int pcsp 0 Stem Info hint hp real pops 30 int popsp 0 int base polarity real coord struct pschars s int hint cnt 0 Stem Info activeh NULL activev NULL sameh Hint Mask pending hm NULL Hint Mask counters 96 int cp 0 real unblended 2 Mm Max int last was b1 false old last was b1 if is type2 context instance count 1 memset unblended 0 sizeof unblended ret name copy name ret unicodeenc 1 ret width int16 0x8000 if name NULL name unnamed ret manualhints true current x current y 0 while len 0 if sp 48 Log Error Stack got too big in s n name sp 48 base 0 len if v type1 32 if v 246 stack sp v 139 else if v 250 stack sp v 247 256 type1 108 len else if v 254 stack sp v 251 256 type1 108 len else if len 4 Log Error Not enough data d 4 len len 0 break int val type1 24 type1 1 16 type1 2 8 type1 3 stack sp val type1 4 len 4 if is type2 stack sp 1 val 16 mant 65536 else if v 28 stack sp short type1 0 8 type1 1 type1 2 len 2 else if v 12 old last was b1 last was b1 last was b1 false v type1 len switch v case 0 if is type2 Log Error s s dotsection operator is deprecated for Type2 n name sp 0 break case 1 if sp 6 Log Error Stack underflow on vstem3 in s n name if is type2 Log Error s s vstem3 operator is not supported for Type2 n name sameh NULL if is type2 sameh Same H ret vstem stack 0 ret lsidebearing stack 1 unblended 0 hint Hint New stack 0 ret lsidebearing stack 1 hint hintnumber sameh NULL sameh hintnumber hint cnt if activev NULL activev hp hint else for hp activev hp next NULL hp hp next hp next hint hp hint sameh NULL if is type2 sameh Same H ret vstem stack 2 ret lsidebearing stack 3 unblended 0 hp next Hint New stack 2 ret lsidebearing stack 3 hp next hintnumber sameh NULL sameh hintnumber hint cnt if is type2 sameh Same H ret vstem stack 4 ret lsidebearing stack 5 unblended 0 hp next next Hint New stack 4 ret lsidebearing stack 5 hp next next hintnumber sameh NULL sameh hintnumber hint cnt if is type2 hp next next hintnumber 96 if pending hm NULL pending hm chunkalloc sizeof Hint Mask pending hm hint hintnumber 3 0x80 hint hintnumber 0x7 pending hm hint next hintnumber 3 0x80 hint next hintnumber 0x7 pending hm hint next next hintnumber 3 0x80 hint next next hintnumber 0x7 hp hp next next sp 0 break case 2 if sp 6 Log Error Stack underflow on hstem3 in s n name if is type2 Log Error s s vstem3 operator is not supported for Type2 n name sameh NULL if is type2 sameh Same H ret hstem stack 0 stack 1 unblended 0 hint Hint New stack 0 stack 1 hint hintnumber sameh NULL sameh hintnumber hint cnt if activeh NULL activeh hp hint else for hp activeh hp next NULL hp hp next hp next hint hp hint sameh NULL if is type2 sameh Same H ret hstem stack 2 stack 3 unblended 0 hp next Hint New stack 2 stack 3 hp next hintnumber sameh NULL sameh hintnumber hint cnt sameh NULL if is type2 sameh Same H ret hstem stack 4 stack 5 unblended 0 hp next next Hint New stack 4 stack 5 hp next next hintnumber sameh NULL sameh hintnumber hint cnt if is type2 hp next next hintnumber 96 if pending hm NULL pending hm chunkalloc sizeof Hint Mask pending hm hint hintnumber 3 0x80 hint hintnumber 0x7 pending hm hint next hintnumber 3 0x80 hint next hintnumber 0x7 pending hm hint next next hintnumber 3 0x80 hint next next hintnumber 0x7 hp hp next next sp 0 break case 6 seac if sp 5 Log Error Stack underflow on seac in s n name if is type2 if v 6 Log Error s s SEAC operator is invalid for Type2 n name else Log Error s s SEAC like endchar operator is deprecated for Type2 n name r1 Ref Char Create r2 Ref Char Create r2 transform 0 1 r2 transform 3 1 r2 transform 4 stack 1 stack 0 ret lsidebearing r2 transform 5 stack 2 r1 transform 0 1 r1 transform 3 1 r1 adobe enc stack 3 r2 adobe enc stack 4 if stack 3 0 stack 3 256 stack 4 0 stack 4 256 Log Error Reference encoding out of bounds in s n name r1 adobe enc 0 r2 adobe enc 0 r1 next r2 if rlast NULL rlast next r1 else ret layers ly fore refs r1 ret changedsincelasthinted true rlast r2 sp 0 break case 7 if sp 4 Log Error Stack underflow on sbw in s n name if is type2 Log Error s s sbw operator is not supported for Type2 n name ret lsidebearing stack 0 ret width stack 2 sp 0 break case 5 case 9 case 14 case 26 if sp 1 Log Error Stack underflow on unary operator in s n name switch v case 5 stack sp 1 stack sp 1 0 break case 9 if stack sp 1 0 stack sp 1 stack sp 1 break case 14 stack sp 1 stack sp 1 break case 26 stack sp 1 sqrt stack sp 1 break default break break case 3 case 4 case 10 case 11 case 12 case 15 case 24 if sp 2 Log Error Stack underflow on binary operator in s n name else switch v case 3 stack sp 2 stack sp 1 0 stack sp 2 0 break case 4 stack sp 2 stack sp 1 0 stack sp 2 0 break case 10 stack sp 2 stack sp 1 break case 11 stack sp 2 stack sp 1 break case 12 stack sp 2 stack sp 1 break case 24 stack sp 2 stack sp 1 break case 15 stack sp 2 stack sp 1 stack sp 2 break default break sp break case 22 if sp 4 Log Error Stack underflow on ifelse in s n name else if stack sp 2 stack sp 1 stack sp 4 stack sp 3 sp 3 break case 23 do stack sp rand RANDMAX 1 while stack sp 0 stack sp 1 sp break case 16 if is type2 Log Error Type2 fonts do not support the Type1 callothersubrs operator if sp 2 sp 2 stack sp 2 Log Error Stack underflow on callothersubr in s n name sp 0 else int tot stack sp 2 i k j popsp 0 for k sp 3 k sp 2 tot k pops popsp stack k switch int stack sp 1 case 3 ret manualhints false ret hstem Hints Append ret hstem activeh activeh NULL ret vstem Hints Append ret vstem activev activev NULL break case 1 is type2 false if cur NULL oldcur cur cur next NULL else Log Error Bad flex subroutine in s n name break case 2 break case 0 if oldcur NULL Spline Point List spl oldcur next if spl NULL spl next NULL spl next next NULL spl next next next NULL spl next next next next NULL spl next next next next next NULL spl next next next next next next NULL Base Point old nextcp mid prevcp mid mid nextcp end prevcp end old nextcp spl next first me mid prevcp spl next next first me mid spl next next next first me mid nextcp spl next next next next first me end prevcp spl next next next next next first me end spl next next next next next next first me cur oldcur if cur NULL cur first NULL cur first cur last cur first next NULL cur last nextcp old nextcp cur last nonextcp false pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt prevcp mid prevcp pt me mid pt nextcp mid nextcp Check Make cur last pt Spline Make3 cur last pt cur last pt pt chunkalloc sizeof Spline Point pt prevcp end prevcp pt me end pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt else Log Error No previous point on path in curveto from flex 0 in s n name else pt chunkalloc sizeof Spline Point pt me x pops 1 pt me y pops 0 pt noprevcp true pt nonextcp true Spline Point List Free oldcur next oldcur next NULL spl NULL cur oldcur if cur NULL cur first NULL cur first cur last cur first next NULL Check Make cur last pt Spline Make3 cur last pt cur last pt else Log Error No previous point on path in lineto from flex 0 in s n name popsp cur next NULL Spline Point Lists Free spl oldcur NULL else Log Error Bad flex subroutine in s n name is type2 context is type2 break case 14 case 15 case 16 case 17 case 18 int cnt stack sp 1 13 if cnt 5 cnt 6 if context instance count 0 Log Error Attempt to use a multiple master subroutine in a non mm font in s n name else if tot cnt context instance count Log Error Multiple master subroutine called with the wrong number of arguments in s n name else if cnt 1 is type2 if sp 2 tot 1 old last was b1 stack 0 Blend unblended 1 context unblended 0 0 stack 0 for i 1 i context instance count i unblended 0 i 0 else memcpy unblended unblended 1 context instance count sizeof real for j 0 j context instance count j unblended 1 j stack sp 2 tot j else if cnt 2 is type2 unblended 0 0 stack sp 2 tot unblended 1 0 stack sp 2 tot 1 for i 0 i 2 i for j 1 j context instance count j unblended i j stack sp 2 tot 2 i context instance count 1 j 1 popsp 0 for i 0 i cnt i double sum stack sp 2 tot i for j 1 j context instance count j sum context blend values j stack sp 2 tot cnt i context instance count 1 j 1 pops cnt 1 popsp sum break sp k 1 break case 20 if sp 2 Log Error Too few items on stack for put in s n name else if stack sp 1 0 stack sp 1 32 Log Error Reference to transient memory out of bounds in put in s n name else transient int stack sp 1 stack sp 2 sp 2 break case 21 if sp 1 Log Error Too few items on stack for get in s n name else if stack sp 1 0 stack sp 1 32 Log Error Reference to transient memory out of bounds in put in s n name else stack sp 1 transient int stack sp 1 break case 17 if popsp 0 Log Error Pop stack underflow on pop in s n name else stack sp pops popsp break case 18 if sp 0 sp break case 27 if sp 1 stack sp stack sp 1 sp break case 28 if sp 2 real temp stack sp 1 stack sp 1 stack sp 2 stack sp 2 temp break case 29 if sp 1 int index stack sp if index 0 sp index 1 Log Error Index out of range in s n name else stack sp stack sp index 1 sp break case 30 if sp 2 int j stack sp 1 N stack sp 2 if N sp j N j 0 N 0 Log Error roll out of range in s n name else if j 0 N 0 else real temp malloc N sizeof real int i for i 0 i N i temp i stack sp N i for i 0 i N i stack sp N i temp i j N free temp break case 33 if is type2 Log Error Type2 fonts do not support the Type1 setcurrentpoint operator if sp 2 Log Error Stack underflow on setcurrentpoint in s n name else current x stack 0 current y stack 1 sp 0 break case 34 case 35 case 36 case 37 dy dy3 dy4 dy5 dy6 0 dx stack base if v 34 dy stack base dx2 stack base dy2 stack base dx3 stack base if v 34 v 36 dy3 stack base dx4 stack base if v 34 v 36 dy4 stack base dx5 stack base if v 34 dy5 dy2 else dy5 stack base switch v real xt yt case 35 dx6 stack base dy6 stack base break case 34 dx6 stack base break case 36 dx6 stack base dy6 dy dy2 dy5 break case 37 xt dx dx2 dx3 dx4 dx5 yt dy dy2 dy3 dy4 dy5 if xt 0 xt xt if yt 0 yt yt if xt yt dx6 stack base dy6 dy dy2 dy3 dy4 dy5 else dy6 stack base dx6 dx dx2 dx3 dx4 dx5 break if cur NULL cur first NULL cur first cur last cur first next NULL current x rint current x dx 1024 1024 current y rint current y dy 1024 1024 cur last nextcp x current x cur last nextcp y current y cur last nonextcp false current x rint current x dx2 1024 1024 current y rint current y dy2 1024 1024 pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt prevcp x current x pt prevcp y current y current x rint current x dx3 1024 1024 current y rint current y dy3 1024 1024 pt me x current x pt me y current y pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt current x rint current x dx4 1024 1024 current y rint current y dy4 1024 1024 cur last nextcp x current x cur last nextcp y current y cur last nonextcp false current x rint current x dx5 1024 1024 current y rint current y dy5 1024 1024 pt chunkalloc sizeof Spline Point pt prevcp x current x pt prevcp y current y current x rint current x dx6 1024 1024 current y rint current y dy6 1024 1024 pt me x current x pt me y current y pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt else Log Error No previous point on path in flex operator in s n name sp 0 break default Log Error Uninterpreted opcode 12 d in s n v name break else last was b1 false switch v case 1 case 18 base 0 if sp 1 ret width int16 0x8000 ret width stack 0 if sp 1 base 1 if sp base 2 Log Error Stack underflow on hstem in s n name coord 0 hp NULL if activeh NULL for hp activeh hp next NULL hp hp next while sp base 2 sameh NULL if is type2 sameh Same H ret hstem stack base coord stack base 1 unblended context instance count hint Hint New stack base coord stack base 1 hint hintnumber sameh NULL sameh hintnumber hint cnt if is type2 context instance count 0 hint u unblended chunkalloc sizeof real 2 Mm Max memcpy hint u unblended unblended sizeof real 2 Mm Max if activeh NULL activeh hint else hp next hint hp hint if is type2 hint hintnumber 96 if pending hm NULL pending hm chunkalloc sizeof Hint Mask pending hm hint hintnumber 3 0x80 hint hintnumber 0x7 base 2 coord hint start hint width sp 0 break case 19 case 20 case 3 case 23 base 0 if cur NULL v 3 v 23 if sp 1 is type2 ret width int16 0x8000 ret width stack 0 if sp 1 base 1 if sp base 2 v 19 v 20 Log Error Stack underflow on vstem in s n name coord ret lsidebearing hp NULL if activev NULL for hp activev hp next NULL hp hp next while sp base 2 sameh NULL if is type2 sameh Same H ret vstem stack base coord stack base 1 unblended context instance count hint Hint New stack base coord stack base 1 hint hintnumber sameh NULL sameh hintnumber hint cnt if is type2 context instance count 0 hint u unblended chunkalloc sizeof real 2 Mm Max memcpy hint u unblended unblended sizeof real 2 Mm Max if is type2 hint hintnumber 96 if pending hm NULL pending hm chunkalloc sizeof Hint Mask pending hm hint hintnumber 3 0x80 hint hintnumber 0x7 if activev NULL activev hint else hp next hint hp hint base 2 coord hint start hint width sp 0 if v 19 v 20 int bytes hint cnt 7 8 if bytes sizeof Hint Mask bytes sizeof Hint Mask if v 19 ret hstem Hints Append ret hstem activeh activeh NULL ret vstem Hints Append ret vstem activev activev NULL if pending hm NULL pending hm chunkalloc sizeof Hint Mask memcpy pending hm type1 bytes else if cp sizeof counters sizeof counters 0 counters cp chunkalloc sizeof Hint Mask memcpy counters cp type1 bytes cp if bytes hint cnt 8 int mask 0xff hint cnt 7 if type1 bytes 1 mask Log Error Hint mask or counter mask with too many hints in s n name type1 bytes len bytes break case 14 if sp 1 is type2 ret width int16 0x8000 ret width stack 0 if context painttype 2 closepath cur is type2 pcsp 0 if sp 4 stack 4 stack 3 stack 3 stack 2 stack 2 stack 1 stack 1 stack 0 stack 0 0 sp 5 goto seac else if sp 5 stack 0 0 goto seac goto done break case 13 if sp 2 Log Error Stack underflow on hsbw in s n name ret lsidebearing stack 0 current x stack 0 ret width stack 1 sp 0 break case 9 sp 0 closepath cur is type2 break case 21 case 22 case 4 if is type2 if v 21 sp 3 v 21 sp 2 ret width int16 0x8000 ret width stack 0 if v 21 sp 2 stack 0 stack sp 2 stack 1 stack sp 1 sp 2 else if v 21 sp 1 stack 0 stack sp 1 sp 1 if context painttype 2 closepath cur true case 5 case 6 case 7 polarity 0 base 0 while base sp dx dy 0 if v 5 v 21 if sp base 2 Log Error Stack underflow on rlineto rmoveto in s n name break dx stack base dy stack base else if v 6 polarity 1 v 7 polarity 1 v 22 if sp base Log Error Stack underflow on hlineto hmoveto in s n name break dx stack base else if sp base Log Error Stack underflow on vlineto vmoveto in s n name break dy stack base polarity current x rint current x dx 1024 1024 current y rint current y dy 1024 1024 pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt me x current x pt me y current y pt noprevcp true pt nonextcp true if v 4 v 21 v 22 if cur NULL cur first cur last cur first prev NULL is type2 cur first me x current x cur first me y current y Spline Point Free pt else Spline Point List spl chunkalloc sizeof Spline Point List spl first spl last pt if cur NULL cur next spl else ret layers ly fore splines spl cur spl break else if cur NULL cur first NULL cur first cur last cur first next NULL Check Make cur last pt Spline Make3 cur last pt cur last pt else Log Error No previous point on path in lineto in s n name if is type2 break sp 0 break case 25 base 0 while sp base 6 current x rint current x stack base 1024 1024 current y rint current y stack base 1024 1024 if cur NULL pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt me x current x pt me y current y pt noprevcp true pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt case 24 case 8 case 31 case 30 case 27 case 26 polarity 0 while sp base 2 dx dy dx2 dy2 dx3 dy3 0 if v 8 v 25 v 24 if sp 6 base Log Error Stack underflow on rrcurveto in s n name base sp else dx stack base dy stack base dx2 stack base dy2 stack base dx3 stack base dy3 stack base else if v 27 if sp 4 base Log Error Stack underflow on hhcurveto in s n name base sp else if sp base 1 dy stack base dx stack base dx2 stack base dy2 stack base dx3 stack base else if v 26 if sp 4 base Log Error Stack underflow on hhcurveto in s n name base sp else if sp base 1 dx stack base dy stack base dx2 stack base dy2 stack base dy3 stack base else if v 31 polarity 1 v 30 polarity 1 if sp 4 base Log Error Stack underflow on hvcurveto in s n name base sp else dx stack base dx2 stack base dy2 stack base dy3 stack base if sp base 1 dx3 stack base else if sp 4 base Log Error Stack underflow on vhcurveto in s n name base sp else dy stack base dx2 stack base dy2 stack base dx3 stack base if sp base 1 dy3 stack base polarity if cur NULL cur first NULL cur first cur last cur first next NULL current x rint current x dx 1024 1024 current y rint current y dy 1024 1024 cur last nextcp x current x cur last nextcp y current y cur last nonextcp false current x rint current x dx2 1024 1024 current y rint current y dy2 1024 1024 pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt prevcp x current x pt prevcp y current y current x rint current x dx3 1024 1024 current y rint current y dy3 1024 1024 pt me x current x pt me y current y pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt else Log Error No previous point on path in curveto in s n name if v 24 current x rint current x stack base 1024 1024 current y rint current y stack base 1024 1024 if cur NULL pt chunkalloc sizeof Spline Point pt hintmask pending hm pending hm NULL pt me x current x pt me y current y pt noprevcp true pt nonextcp true Check Make cur last pt Spline Make3 cur last pt cur last pt sp 0 break case 29 case 10 if sp 1 Log Error Stack underflow on callsubr in s n name break else if pcsp 10 Log Error Too many subroutine calls in s n name break s subrs if v 29 s gsubrs if s NULL stack sp 1 s bias if s NULL stack sp 1 s cnt stack sp 1 0 s values int stack sp 1 NULL Log Error Subroutine number out of bounds in s n name else pcstack pcsp type1 type1 pcstack pcsp len len pcstack pcsp subnum stack sp 1 pcsp type1 s values int stack sp 1 len s lens int stack sp 1 if sp 0 sp 0 break case 11 if pcsp 1 Log Error return when not in subroutine in s n name else pcsp type1 pcstack pcsp type1 len pcstack pcsp len break case 16 int cnt i j if context instance count 0 Log Error Attempt to use a multiple master subroutine in a non mm font n else if sp 1 sp context instance count stack sp 1 1 Log Error Too few items on stack for blend in s n name else if context blend warn Log Error Use of obsolete blend operator n context blend warn true cnt stack sp 1 sp context instance count stack sp 1 1 for i 0 i cnt i for j 1 j context instance count j stack sp i context blend values j stack sp cnt i context instance count 1 j 1 sp cnt break default Log Error Uninterpreted opcode d in s n v name break done if pcsp 0 Log Error end of subroutine reached with no return in s n name SC Categorize Points ret ret hstem Hints Append ret hstem activeh activeh NULL ret vstem Hints Append ret vstem activev activev NULL if cp 0 int i ret countermasks malloc cp sizeof Hint Mask ret countermask cnt cp for i 0 i cp i memcpy ret countermasks i counters i sizeof Hint Mask chunkfree counters i sizeof Hint Mask if is type2 context painttype for cur ret layers ly fore splines cur NULL cur cur next if cur first prev NULL Check Make cur last cur first Spline Make3 cur last cur first cur last cur first for cur ret layers ly fore splines cur NULL cur cur next Spline Set Reverse cur if ret hstem NULL ret vstem NULL ret manualhints false if is type2 context instance count 0 Unblend Free ret hstem Unblend Free ret vstem ret hstem Hint Cleanup ret hstem true context instance count ret vstem Hint Cleanup ret vstem true context instance count SC Guess H Hint Instances List ret ly fore SC Guess V Hint Instances List ret ly fore ret hconflicts Stem List Any Conflicts ret hstem ret vconflicts Stem List Any Conflicts ret vstem if context instance count 1 ret hconflicts ret vconflicts SC Clear Hint Masks ret ly fore false Hints Renumber ret if name NULL strcmp name notdef 0 ret widthset true return ret static void evhttp handle request struct evhttp request req void arg struct evhttp http arg struct evhttp cb cb NULL event debug s req uri s func req uri if req uri NULL event debug s bad request func if req evcon state EVCONDISCONNECTED evhttp connection fail req evcon EVCONHTTPEOF else event debug s sending error func evhttp send error req HTTPBADREQUEST Bad Request return if cb evhttp dispatch callback http callbacks req NULL cb cb req cb cbarg return if http gencb http gencb req http gencbarg return else struct evbuffer buf evbuffer new evhttp response code req HTTPNOTFOUND Not Found evbuffer add printf buf ERRFORMAT escaped html free escaped html evhttp send page req buf evbuffer free buf static int txd decode frame AV Codec Context avctx void data int got frame AV Packet avpkt TXD Context const s avctx priv data Get Byte Context gb AV Frame picture data AV Frame const p s picture unsigned int version w h d3d format depth stride flags unsigned int y v uint8 t ptr uint32 t pal int ret bytestream2 init gb avpkt data avpkt size version bytestream2 get le32 gb bytestream2 skip gb 72 d3d format bytestream2 get le32 gb w bytestream2 get le16 gb h bytestream2 get le16 gb depth bytestream2 get byte gb bytestream2 skip gb 2 flags bytestream2 get byte gb if version 8 version 9 av log avctx AVLOGERROR texture data version i is unsupported n version return AVERRORPATCHWELCOME if depth 8 avctx pix fmt AVPIXFMTPA L8 else if depth 16 depth 32 avctx pix fmt AVPIXFMTRG B32 else av log avctx AVLOGERROR depth of i is unsupported n depth return AVERRORPATCHWELCOME if p data 0 avctx release buffer avctx p if ret av image check size w h 0 avctx 0 return ret if w avctx width h avctx height avcodec set dimensions avctx w h if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI ptr p data 0 stride p linesize 0 if depth 8 pal uint32 t p data 1 for y 0 y 256 y v bytestream2 get be32 gb pal y v 8 v 24 bytestream2 skip gb 4 for y 0 y h y bytestream2 get buffer gb ptr w ptr stride else if depth 16 bytestream2 skip gb 4 switch d3d format case 0 if flags 1 goto unsupported case FF S3 TCDX T1 ff decode dxt1 gb ptr w h stride break case FF S3 TCDX T3 ff decode dxt3 gb ptr w h stride break default goto unsupported else if depth 32 switch d3d format case 0x15 case 0x16 for y 0 y h y bytestream2 get buffer gb ptr w 4 ptr stride break default goto unsupported picture s picture got frame 1 return avpkt size unsupported av log avctx AVLOGERROR unsupported d3d format 08x n d3d format return static int vorbis decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size vorbis context vc avctx priv data AV Frame frame data Get Bit Context gb vc gb float channel ptrs 255 int i len ret av dlog NULL packet length d n buf size frame nb samples vc blocksize 1 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if vc audio channels 8 for i 0 i vc audio channels i channel ptrs i float frame extended data i else for i 0 i vc audio channels i int ch ff vorbis channel layout offsets vc audio channels 1 i channel ptrs ch float frame extended data i init get bits gb buf buf size 8 if len vorbis parse audio packet vc channel ptrs 0 return len if vc first frame vc first frame 1 got frame ptr 0 return buf size av dlog NULL parsed d bytes d bits returned d samples ch bits n get bits count gb 8 get bits count gb 8 len frame nb samples len got frame ptr 1 return buf size static int isoent gen joliet identifier struct archive write a struct isoent isoent struct idr idr struct iso9660 iso9660 struct isoent np unsigned char p size t l int r size t ffmax parent len static const struct archive rb tree ops rb ops isoent cmp node joliet isoent cmp key joliet if isoent children cnt 0 return 0 iso9660 a format data if iso9660 opt joliet OPTJOLIETLONGNAME ffmax 206 else ffmax 128 r idr start a idr isoent children cnt int ffmax 6 2 rb ops if r 0 return r parent len 1 for np isoent np parent np np np parent parent len np mb len 1 for np isoent children first np NULL np np chnext unsigned char dot int ext off noff weight size t lt if l np file basename utf16 length ffmax l ffmax p malloc l 1 2 if p NULL archive set error a archive ENOMEM Can t allocate memory return ARCHIVEFATAL memcpy p np file basename utf16 s l p l 0 p l 1 0 np identifier char p lt l dot p l weight 0 while lt 0 if joliet allowed char p 0 p 1 archive be16enc p 0x005 F else if p 0 0 p 1 0x2 E dot p p 2 lt 2 ext off int dot unsigned char np identifier np ext off ext off np ext len int l ext off np id len int l if np file basename utf16 length ffmax if archive strncpy l iso9660 mbs const char np identifier l iso9660 sconv from utf16be 0 errno ENOMEM archive set error a archive errno No memory return ARCHIVEFATAL np mb len int iso9660 mbs length if np mb len int np file basename length weight np mb len else np mb len int np file basename length if parent len 240 np mb len 240 parent len np mb len 240 archive set error a archive ARCHIVEERRNOMISC The regulation of Joliet extensions A length of a full pathname of s is longer than 240 bytes p d b d archive entry pathname np file entry int parent len int np mb len return ARCHIVEFATAL if l ffmax noff ext off 6 else if l ffmax 2 noff ext off 4 else if l ffmax 4 noff ext off 2 else noff ext off idr register idr np weight noff idr resolve idr idr set num beutf16 return void ff MPV common defaults Mpeg Enc Context s s y dc scale table s c dc scale table ff mpeg1 dc scale table s chroma qscale table ff default chroma qscale table s progressive frame 1 s progressive sequence 1 s picture structure PICTFRAME s coded picture number 0 s picture number 0 s input picture number 0 s picture in gop number 0 s f code 1 s b code 1 s picture range start 0 s picture range end MAXPICTURECOUNT s slice context count 1 static uint dump events for db char db char query buff QUERYLENGTH char db name buff NAMELEN 2 3 name buff NAMELEN 2 3 char event name char delimiter QUERYLENGTHFILE sql file md result file MYSQLRES event res event list res MYSQLROW row event list row char db cl name MYCSNAMESIZE int db cl altered FALSEDBUGENTER dump events for db DBUGPRINT enter db s db mysql real escape string mysql db name buff db ulong strlen db print comment sql file 0 n n Dumping events for database s n n db if lock tables mysql query mysql LOCKTABLES mysql event READ if mysql query with error report mysql event list res show events DBUGRETURN 0 strcpy delimiter if mysql num rows event list res 0 if opt xml fputs t events n sql file else fprintf sql file n if fetch db collation db name buff db cl name sizeof db cl name DBUGRETURN 1 if switch character set results mysql binary DBUGRETURN 1 while event list row mysql fetch row event list res NULL event name quote name event list row 1 name buff 0 DBUGPRINT info retrieving CREATEEVENT for s name buff my snprintf query buff sizeof query buff SHOWCREATEEVENT s event name if mysql query with error report mysql event res query buff DBUGRETURN 1 while row mysql fetch row event res NULL if opt xml print xml row sql file event event res row Create Event continue if strlen row 3 0 char query str if opt drop fprintf sql file s n event name delimiter if create delimiter row 3 delimiter sizeof delimiter NULL fprintf stderr s Warning Can t create delimiter for event s n my progname short event name DBUGRETURN 1 fprintf sql file DELIMITER s n delimiter if mysql num fields event res 7 if switch db collation sql file db name buff delimiter db cl name row 6 db cl altered DBUGRETURN 1 switch cs variables sql file delimiter row 4 row 4 row 5 else fprintf sql file n WARNING old server version The following dump may be incomplete n n switch sql mode sql file delimiter row 1 switch time zone sql file delimiter row 2 query str cover definer clause row 3 strlen row 3 CSTRINGWITHLEN 50117 CSTRINGWITHLEN 50106 CSTRINGWITHLENEVENT fprintf sql file s n const char query str NULL query str row 3 const char delimiter my free query str restore time zone sql file delimiter restore sql mode sql file delimiter if mysql num fields event res 7 restore cs variables sql file delimiter if db cl altered if restore db collation sql file db name buff delimiter db cl name DBUGRETURN 1 mysql free result event res if opt xml fputs t events n sql file check io sql file else fprintf sql file DELIMITER n fprintf sql file n if switch character set results mysql default charset DBUGRETURN 1 mysql free result event list res if lock tables void mysql query with error report mysql 0 UNLOCKTABLESDBUGRETURN 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Indeo3 Decode Context ctx avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data int res res decode frame headers ctx avctx buf buf size if res 0 return res if res got frame 0 return buf size if ctx frame flags BSNONREF avctx skip frame AVDISCARDNONREF return 0 if ctx frame flags BSKEYFRAME avctx skip frame AVDISCARDNONKEY return 0 ctx buf sel ctx frame flags BSBUFFER 1 if res decode plane ctx avctx ctx planes ctx y data ptr ctx y data size 40 return res if res decode plane ctx avctx ctx planes 1 ctx u data ptr ctx u data size 10 return res if res decode plane ctx avctx ctx planes 2 ctx v data ptr ctx v data size 10 return res if res ff get buffer avctx frame 0 0 av log ctx avctx AVLOGERROR get buffer failed n return res output plane ctx planes 0 ctx buf sel frame data 0 frame linesize 0 avctx height output plane ctx planes 1 ctx buf sel frame data 1 frame linesize 1 avctx height 3 2 output plane ctx planes 2 ctx buf sel frame data 2 frame linesize 2 avctx height 3 2 got frame 1 return buf size static int ra144 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size static const uint8 t sizes LPCORDER 6 5 5 4 4 3 3 3 3 2 unsigned int refl rms NBLOCKS uint16 t block coefs NBLOCKSLPCORDER unsigned int lpc refl LPCORDER int i j int ret int16 t samples unsigned int energy R A144 Context ractx avctx priv data Get Bit Context gb frame nb samples NBLOCKSBLOCKSIZE if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 if buf size FRAMESIZE av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size got frame ptr 0 return buf size init get bits gb buf FRAMESIZE 8 for i 0 i LPCORDER i lpc refl i ff lpc refl cb i get bits gb sizes i ff eval coefs ractx lpc coef 0 lpc refl ractx lpc refl rms 0 ff rms lpc refl energy ff energy tab get bits gb 5 refl rms 0 ff interp ractx block coefs 0 1 1 ractx old energy refl rms 1 ff interp ractx block coefs 1 2 energy ractx old energy ff t sqrt energy ractx old energy 12 refl rms 2 ff interp ractx block coefs 2 3 0 energy refl rms 3 ff rescale rms ractx lpc refl rms 0 energy ff int to int16 block coefs 3 ractx lpc coef 0 for i 0 i NBLOCKS i do output subblock ractx block coefs i refl rms i gb for j 0 j BLOCKSIZE j samples av clip int16 ractx curr sblock j 10 2 ractx old energy energy ractx lpc refl rms 1 ractx lpc refl rms 0 FFSWAP unsigned int ractx lpc coef 0 ractx lpc coef 1 got frame ptr 1 return static void txfm rd in plane MACROBLOCK x int rate int64 t distortion int skippable int64 t sse int64 t ref best rd int plane BLOCKSIZE bsize TXSIZE tx size int use fast coef casting MACROBLOCKD const xd x e mbd const struct macroblockd plane const pd xd plane plane struct rdcost block args args vp9 zero args args x x args best rd ref best rd args use fast coef costing use fast coef casting if plane 0 xd mi 0 mbmi tx size tx size vp9 get entropy contexts bsize tx size pd args t above args t left args so get scan xd tx size pd plane type 0 vp9 foreach transformed block in plane xd bsize plane block rd txfm args if args skip rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 else distortion args this dist rate args this rate sse args this sse skippable vp9 is skippable in plane x bsize plane static void evhttp handle request struct evhttp request req void arg struct evhttp http arg struct evhttp cb cb NULL event debug s req uri s func req uri if req uri NULL event debug s bad request func if req evcon state EVCONDISCONNECTED evhttp connection fail req evcon EVCONHTTPEOF else event debug s sending error func evhttp send error req HTTPBADREQUEST Bad Request return if cb evhttp dispatch callback http callbacks req NULL cb cb req cb cbarg return if http gencb http gencb req http gencbarg return else struct evbuffer buf evbuffer new evhttp response code req HTTPNOTFOUND Not Found evbuffer add printf buf ERRFORMAT escaped html free escaped html evhttp send page req buf evbuffer free buf static V P9 DENOISERDECISION perform motion compensation V P9 DENOISER denoiser MACROBLOCK mb BLOCKSIZE bs int increase denoising int mi row int mi col PICKMODECONTEXT ctx int motion magnitude int mv col mv row int sse diff ctx zeromv sse ctx newmv sse MVREFERENCEFRAME frame MACROBLOCKD filter mbd mb e mbd MBMODEINFO mbmi filter mbd mi 0 mbmi MBMODEINFO saved mbmi int i j struct buf 2d saved dst MAXMBPLANE struct buf 2d saved pre MAXMBPLANE 2 saved mbmi mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j saved pre i j filter mbd plane i pre j saved dst i filter mbd plane i dst mv col ctx best sse mv as mv col mv row ctx best sse mv as mv row motion magnitude mv row mv row mv col mv col frame ctx best reference frame if frame INTRAFRAME sse diff sse diff thresh bs increase denoising mv row mv col mbmi ref frame 0 ctx best reference frame mbmi mode ctx best sse inter mode mbmi mv 0 ctx best sse mv else frame ctx best zeromv reference frame mbmi ref frame 0 ctx best zeromv reference frame mbmi mode ZEROMV mbmi mv 0 as int 0 ctx best sse inter mode ZEROMV ctx best sse mv as int 0 ctx newmv sse ctx zeromv sse for j 0 j 2 j filter mbd plane 0 pre j buf block start denoiser running avg y frame y buffer denoiser running avg y frame y stride mi row mi col filter mbd plane 0 pre j stride denoiser running avg y frame y stride filter mbd plane 1 pre j buf block start denoiser running avg y frame u buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 1 pre j stride denoiser running avg y frame uv stride filter mbd plane 2 pre j buf block start denoiser running avg y frame v buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 2 pre j stride denoiser running avg y frame uv stride filter mbd plane 0 dst buf block start denoiser mc running avg y y buffer denoiser mc running avg y y stride mi row mi col filter mbd plane 0 dst stride denoiser mc running avg y y stride filter mbd plane 1 dst buf block start denoiser mc running avg y u buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 1 dst stride denoiser mc running avg y uv stride filter mbd plane 2 dst buf block start denoiser mc running avg y v buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 2 dst stride denoiser mc running avg y uv stride vp9 build inter predictors sby filter mbd mv row mv col bs mbmi saved mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j filter mbd plane i pre j saved pre i j filter mbd plane i dst saved dst i mv row ctx best sse mv as mv row mv col ctx best sse mv as mv col if ctx newmv sse sse thresh bs increase denoising return COPYBLOCK if mv row mv row mv col mv col noise motion thresh bs increase denoising return COPYBLOCK return void ff MPV frame end Mpeg Enc Context s int i if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s else if s er error count s encoding s avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU s unrestricted mv s current picture f reference s intra only s flags CODECFLAGEMUEDGE const AV Pix Fmt Descriptor desc av pix fmt desc get s avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h s dsp draw edges s current picture f data 0 s linesize s h edge pos s v edge pos EDGEWIDTHEDGEWIDTHEDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 1 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 2 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM emms c s last pict type s pict type s last lambda for s pict type s current picture ptr f quality if s pict type AVPICTURETYPEB s last non b pict type s pict type i MAXPICTURECOUNT i if s picture i f data 0 s current picture f data 0 s picture i s current picture break assert i MAXPICTURECOUNT for i 0 i s picture count i if s picture i f data 0 s picture i f reference free frame buffer s s picture i int vp9 receive compressed data V P9 Decoder pbi size t size const uint8 t psource V P9 COMMON const cm pbi common const uint8 t source psource int retcode 0 cm error error code VPXCODECOK if size 0 if cm frame refs 0 idx INTMAX cm frame refs 0 buf corrupted 1 if cm new fb idx 0 cm frame bufs cm new fb idx ref count 0 cm release fb cb cm cb priv cm frame bufs cm new fb idx raw frame buffer cm new fb idx get free fb cm if setjmp cm error jmp pbi need resync 1 cm error setjmp 0 vp9 clear system state if cm frame refs 0 idx INTMAX cm frame refs 0 buf NULL cm frame refs 0 buf corrupted 1 if cm new fb idx 0 cm frame bufs cm new fb idx ref count 0 cm frame bufs cm new fb idx ref count return 1 cm error setjmp 1 vp9 decode frame pbi source source size psource swap frame buffers pbi vp9 clear system state cm last width cm width cm last height cm height if cm show existing frame cm last show frame cm show frame if cm show frame if cm show existing frame vp9 swap mi and prev mi cm cm current video frame pbi ready for new data 0 cm error setjmp 0 return retcode static int64 t handle inter mode V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int64 t txfm cache int rate2 int64 t distortion int skippable int rate y int64 t distortion y int rate uv int64 t distortion uv int disable skip int mv mode mv MAXREFFRAMES int mi row int mi col int mv single newmv MAXREFFRAMESINTERPFILTER single filter MAXREFFRAMES int single skippable MAXREFFRAMES int64 t psse const int64 t ref best rd V P9 COMMON cm cpi common RDOPT rd opt cpi rd MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi const int is comp pred has second ref mbmi const int this mode mbmi mode int mv frame mv mode mv this mode int i int refs 2 mbmi ref frame 0 mbmi ref frame 1 0 0 mbmi ref frame 1 int mv cur mv 2 int64 t this rd 0 DECLAREALIGNEDARRAY 16 uint8 t tmp buf MAXMBPLANE 64 64 int pred exists 0 int intpel mv int64 t rd tmp rd best rd IN T64 MAX int best needs copy 0 uint8 t orig dst MAXMBPLANE int orig dst stride MAXMBPLANE int rs 0 INTERPFILTER best filter SWITCHABLE uint8 t skip txfm MAXMBPLANE 2 0 int64 t bsse MAXMBPLANE 2 0 int bsl mi width log2 lookup bsize int pred filter search cpi sf cb pred filter search mi row mi col bsl get chessboard index cm current video frame 0x1 0 if pred filter search INTERPFILTER af SWITCHABLE lf SWITCHABLE if xd up available af xd mi xd mi stride mbmi interp filter if xd left available lf xd mi 1 mbmi interp filter if this mode NEWMV af lf best filter af if is comp pred if frame mv refs 0 as int INVALIDMV frame mv refs 1 as int INVALIDMV return IN T64 MAX if cpi sf adaptive mode search if single filter this mode refs 0 single filter this mode refs 1 best filter single filter this mode refs 0 if this mode NEWMV int rate mv if is comp pred frame mv refs 0 as int single newmv refs 0 as int frame mv refs 1 as int single newmv refs 1 as int if cpi sf comp inter joint search thresh bsize joint motion search cpi x bsize frame mv mi row mi col single newmv rate mv else rate mv vp9 mv bit cost frame mv refs 0 as mv mbmi ref mvs refs 0 0 as mv x nmvjointcost x mvcost MVCOSTWEIGHT rate mv vp9 mv bit cost frame mv refs 1 as mv mbmi ref mvs refs 1 0 as mv x nmvjointcost x mvcost MVCOSTWEIGHT rate2 rate mv else int mv tmp mv single motion search cpi x bsize mi row mi col tmp mv rate mv if tmp mv as int INVALIDMV return IN T64 MAX rate2 rate mv frame mv refs 0 as int xd mi 0 bmi 0 as mv 0 as int tmp mv as int single newmv refs 0 as int tmp mv as int for i 0 i is comp pred 1 i cur mv i frame mv refs i if this mode NEWMV clamp mv2 cur mv i as mv xd if mv check bounds x cur mv i as mv return IN T64 MAX mbmi mv i as int cur mv i as int for i 0 i MAXMBPLANE i orig dst i xd plane i dst buf orig dst stride i xd plane i dst stride rate2 cost mv ref cpi this mode mbmi mode context refs 0 if RDCOST x rdmult x rddiv rate2 0 ref best rd mbmi mode NEARESTMV return IN T64 MAX pred exists 0 intpel mv mv has subpel mbmi mv 0 as mv if is comp pred intpel mv mv has subpel mbmi mv 1 as mv rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR if x source variance cpi sf disable filter search var thresh best filter EIGHTTAP else if best filter SWITCHABLE int newbest int tmp rate sum 0 int64 t tmp dist sum 0 for i 0 i SWITCHABLEFILTERS i int j int64 t rs rd mbmi interp filter i rs vp9 get switchable rate cpi rs rd RDCOST x rdmult x rddiv rs 0 if i 0 intpel mv rd RDCOST x rdmult x rddiv tmp rate sum tmp dist sum rd opt filter cache i rd rd opt filter cache SWITCHABLEFILTERSMIN rd opt filter cache SWITCHABLEFILTERS rd rs rd if cm interp filter SWITCHABLE rd rs rd rd opt mask filter MAX rd opt mask filter rd else int rate sum 0 int64 t dist sum 0 if i 0 cpi sf adaptive interp filter search cpi sf interp filter search mask 1 i rate sum INTMAX dist sum IN T64 MAX continue if cm interp filter SWITCHABLE i best needs copy cm interp filter SWITCHABLE cm interp filter mbmi interp filter i 0 intpel mv restore dst buf xd orig dst orig dst stride else for j 0 j MAXMBPLANE j xd plane j dst buf tmp buf j 64 64 xd plane j dst stride 64 vp9 build inter predictors sb xd mi row mi col bsize model rd for sb cpi bsize x xd rate sum dist sum rd RDCOST x rdmult x rddiv rate sum dist sum rd opt filter cache i rd rd opt filter cache SWITCHABLEFILTERSMIN rd opt filter cache SWITCHABLEFILTERS rd rs rd if cm interp filter SWITCHABLE rd rs rd rd opt mask filter MAX rd opt mask filter rd if i 0 intpel mv tmp rate sum rate sum tmp dist sum dist sum if i 0 cpi sf use rd breakout ref best rd IN T64 MAX if rd 2 ref best rd restore dst buf xd orig dst orig dst stride return IN T64 MAX newbest i 0 rd best rd if newbest best rd rd best filter mbmi interp filter if cm interp filter SWITCHABLE i intpel mv best needs copy best needs copy vpx memcpy skip txfm x skip txfm sizeof skip txfm vpx memcpy bsse x bsse sizeof bsse if cm interp filter SWITCHABLE newbest cm interp filter SWITCHABLE cm interp filter mbmi interp filter pred exists 1 tmp rd best rd restore dst buf xd orig dst orig dst stride mbmi interp filter cm interp filter SWITCHABLE cm interp filter best filter rs cm interp filter SWITCHABLE vp9 get switchable rate cpi 0 if pred exists if best needs copy for i 0 i MAXMBPLANE i xd plane i dst buf tmp buf i 64 64 xd plane i dst stride 64 rd tmp rd RDCOST x rdmult x rddiv rs 0 else int tmp rate int64 t tmp dist vp9 build inter predictors sb xd mi row mi col bsize model rd for sb cpi bsize x xd tmp rate tmp dist rd RDCOST x rdmult x rddiv rs tmp rate tmp dist vpx memcpy skip txfm x skip txfm sizeof skip txfm vpx memcpy bsse x bsse sizeof bsse if is comp pred single filter this mode refs 0 mbmi interp filter if cpi sf adaptive mode search if is comp pred if single skippable this mode refs 0 single skippable this mode refs 1 vpx memset skip txfm 1 sizeof skip txfm if cpi sf use rd breakout ref best rd IN T64 MAX if rd 2 ref best rd restore dst buf xd orig dst orig dst stride return IN T64 MAX if cm interp filter SWITCHABLE rate2 rs if is comp pred if cpi allow encode breakout rd encode breakout test cpi x bsize rate2 distortion distortion uv disable skip vpx memcpy x skip txfm skip txfm sizeof skip txfm vpx memcpy x bsse bsse sizeof bsse if x skip int skippable y skippable uv int64 t sseuv IN T64 MAX int64 t rdcosty IN T64 MAX vp9 subtract plane x bsize 0 super block yrd cpi x rate y distortion y skippable y psse bsize txfm cache ref best rd if rate y INTMAX rate2 INTMAX distortion IN T64 MAX restore dst buf xd orig dst orig dst stride return IN T64 MAX rate2 rate y distortion distortion y rdcosty RDCOST x rdmult x rddiv rate2 distortion rdcosty MIN rdcosty RDCOST x rdmult x rddiv 0 psse super block uvrd cpi x rate uv distortion uv skippable uv sseuv bsize ref best rd rdcosty if rate uv INTMAX rate2 INTMAX distortion IN T64 MAX restore dst buf xd orig dst orig dst stride return IN T64 MAX psse sseuv rate2 rate uv distortion distortion uv skippable skippable y skippable uv if is comp pred single skippable this mode refs 0 skippable restore dst buf xd orig dst orig dst stride return this rd static Asn1 Generic Decode Asn1 Der Set const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node Asn1 Generic child d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SET node data NULL c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL seq index 0 el max size max size d ptr buffer child Decode Asn1 Der Generic d ptr el max size depth seq index errcode node data child return Asn1 Generic node static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cam Studio Context c avctx priv data AV Frame picture data int ret if buf size 2 av log avctx AVLOGERROR coded frame too small n return AVERRORINVALIDDATA if ret ff get buffer avctx picture 0 0 av log avctx AVLOGERROR get buffer failed n return ret switch buf 0 1 7 case 0 int outlen c decomp size inlen buf size 2 if av lzo1x decode c decomp buf outlen buf 2 inlen av log avctx AVLOGERROR error during lzo decompression n break case 1 if uncompress c decomp buf dlen buf 2 buf size 2 ZOK av log avctx AVLOGERROR error during zlib decompression n break return AVERRORENOSYS default av log avctx AVLOGERROR unknown compression n return AVERRORINVALIDDATA if buf 0 1 picture pict type AVPICTURETYPEI picture key frame 1 switch c bpp case 16 copy frame 16 picture c decomp buf c linelen c height break case 32 copy frame 32 picture c decomp buf c linelen c height break default copy frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height else picture pict type AVPICTURETYPEP picture key frame 0 switch c bpp case 16 add frame 16 picture c decomp buf c linelen c height break case 32 add frame 32 picture c decomp buf c linelen c height break default add frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height got frame 1 return buf size static int lag decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Lagarith Context l avctx priv data AV Frame const p l picture uint8 t frametype 0 uint32 t offset gu 0 offset bv 0 offset ry 9 uint32 t offs 4 uint8 t srcs 4 dst int i j planes 3 AV Frame picture data if p data 0 ff thread release buffer avctx p p reference 0 p key frame 1 frametype buf 0 offset gu AVR L32 buf 1 offset bv AVR L32 buf 5 switch frametype case FRAMESOLIDRGBA avctx pix fmt AVPIXFMTRG B32 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 dst p data 0 for j 0 j avctx height j for i 0 i avctx width i AVW N32 dst i 4 offset gu dst p linesize 0 break case FRAMEARITHRGBA avctx pix fmt AVPIXFMTRG B32 planes 4 offset ry 4 offs 3 AVR L32 buf 9 case FRAMEARITHRG B24 case FRAMEURG B24 if frametype FRAMEARITHRG B24 frametype FRAMEURG B24 avctx pix fmt AVPIXFMTRG B24 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 offs 0 offset bv offs 1 offset gu offs 2 offset ry if l rgb planes l rgb stride FFALIGN avctx width 16 l rgb planes av malloc l rgb stride avctx height planes 1 if l rgb planes av log avctx AVLOGERROR cannot allocate temporary buffer n return AVERRORENOMEM for i 0 i planes i srcs i l rgb planes i 1 l rgb stride avctx height l rgb stride if offset ry buf size offset gu buf size offset bv buf size planes 4 offs 3 buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA for i 0 i planes i lag decode arith plane l srcs i avctx width avctx height l rgb stride buf offs i buf size offs i dst p data 0 for i 0 i planes i srcs i l rgb planes i l rgb stride avctx height for j 0 j avctx height j for i 0 i avctx width i uint8 t r g b a r srcs 0 i g srcs 1 i b srcs 2 i r g b g if frametype FRAMEARITHRGBA a srcs 3 i AVW N32 dst i 4 MKBETAG a r g b else dst i 3 0 r dst i 3 1 g dst i 3 2 b dst p linesize 0 for i 0 i planes i srcs i l rgb stride break case FRAMEARITHYU Y2 avctx pix fmt AVPIXFMTYU V422 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 1 avctx width 2 avctx height p linesize 1 buf offset gu buf size offset gu lag decode arith plane l p data 2 avctx width 2 avctx height p linesize 2 buf offset bv buf size offset bv break case FRAMEARITHY V12 avctx pix fmt AVPIXFMTYU V420 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf offset gu buf size offset gu lag decode arith plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf offset bv buf size offset bv break default av log avctx AVLOGERROR Unsupported Lagarith frame type x n frametype return 1 picture p got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint32 t src const uint32 t avpkt data AV Frame pic avctx coded frame int width avctx width int y 0 uint16 t ydst udst vdst yend int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 8 3 av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA if avpkt size avctx width avctx height 8 3 av log ask for sample avctx Probably padded data n pic reference 0 if ret ff get buffer avctx pic 0 return ret ydst uint16 t pic data 0 udst uint16 t pic data 1 vdst uint16 t pic data 2 yend ydst width pic pict type AVPICTURETYPEI pic key frame 1 for uint32 t v av be2ne32 src udst v 16 0x FF C0 ydst v 6 0x FF C0 vdst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 6 0x FF C0 ydst v 4 0x FF C0 v av be2ne32 src vdst v 16 0x FF C0 ydst v 6 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 vdst v 6 0x FF C0 ydst v 4 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break got frame 1 AV Frame data avctx coded frame return avpkt size static void slurm rpc allocate resources slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESS slurm msg t response msg DEFTIMERS job desc msg t job desc msg job desc msg t msg data resource allocation response msg t alloc msg slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info int immediate job desc msg immediate bool do unlock false bool reject job false struct job record job ptr NULL uint16 t port slurm addr t resp addr char err msg NULL job submit user msg NULLSTARTTIMER if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if uid job desc msg user id validate slurm user uid error code ESLURMUSERIDMISSING error Security violation RESOURCEALLOCATE from uid d uid debug2 sched Processing RPCREQUESTRESOURCEALLOCATION from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTRESOURCEALLOCATE lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg error code ESLURMRESERVATIONBUSY error attempt to nest ALPS allocation on s d by uid d job desc msg alloc node job desc msg alloc sid uid int zrestore i ctx t i ctx p os ptr op osp alloc save t asave bool last vm save t vmsave int code restore check operand op asave idmemory if code 0 return code if debug2m u imemory u vmrestore 0x lx id lu n ulong alloc save client data asave ulong op value saveid if IVALIDATEBEFORERESTORE ivalidate clean spaces i ctx p osp int code if code restore check stack i ctx p o stack asave false 0 code restore check stack i ctx p e stack asave true 0 code restore check stack i ctx p d stack asave false 0 osp return code restore fix stack i ctx p o stack asave false restore fix stack i ctx p e stack asave true restore fix stack i ctx p d stack asave false do vmsave alloc save client data alloc save current idmemory gs grestoreall for restore igs vmsave gsave vmsave gsave 0 code alloc restore step in idmemory asave if code 0 return code last code while last uint space icurrent space ialloc set space idmemory avm local ifree object vmsave zrestore ialloc set space idmemory space dict set top if IVALIDATEAFTERRESTORE ivalidate clean spaces i ctx p i ctx p Lock File Permissions false return 0 static void kq init struct event base base int i kq struct kqop kqueueop if evutil getenv EVENTNOKQUEUE return NULL if kqueueop calloc 1 sizeof struct kqop return NULL if kq kqueue 1 event warn kqueue free kqueueop return NULL kqueueop kq kq kqueueop pid getpid kqueueop changes malloc NEVENT sizeof struct kevent if kqueueop changes NULL free kqueueop return NULL kqueueop events malloc NEVENT sizeof struct kevent if kqueueop events NULL free kqueueop changes free kqueueop return NULL kqueueop nevents NEVENT for i 0 i NSIG i TAILQINIT kqueueop evsigevents i memset kqueueop changes 0 0 sizeof kqueueop changes 0 kqueueop changes 0 ident 1 kqueueop changes 0 filter EVFILTREAD kqueueop changes 0 flags EVADD if kevent kq kqueueop changes 1 kqueueop events NEVENTNULL 1 kqueueop events 0 ident 1 kqueueop events 0 flags EVERROR event warn s detected broken kqueue not using func free kqueueop changes free kqueueop events free kqueueop close kq return NULL return kqueueop int ff rv34 decode frame AV Codec Context avctx void data int got picture ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size R V34 Dec Context r avctx priv data Mpeg Enc Context s r s AV Frame pict data Slice Info si int i int slice count const uint8 t slices hdr NULL int last 0 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got picture ptr 1 return 0 if avctx slice count slice count buf 1 slices hdr buf 4 buf 8 slice count buf size 1 8 slice count else slice count avctx slice count if get slice offset avctx slices hdr 0 0 get slice offset avctx slices hdr 0 buf size av log avctx AVLOGERROR Slice offset is invalid n return AVERRORINVALIDDATA init get bits s gb buf get slice offset avctx slices hdr 0 buf size get slice offset avctx slices hdr 0 8 if r parse slice header r r s gb si 0 si start av log avctx AVLOGERROR First slice header is incorrect n return AVERRORINVALIDDATA if s last picture ptr s last picture ptr f data 0 si type AVPICTURETYPEB av log avctx AVLOGERROR Invalid decoder state B frame without reference data n return AVERRORINVALIDDATA if avctx skip frame AVDISCARDNONREF si type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY si type AVPICTURETYPEI avctx skip frame AVDISCARDALL return avpkt size if si start 0 if s mb num left 0 av log avctx AVLOGERROR New frame but still d MB left s mb num left ff er frame end s er ff MPV frame end s if s width si width s height si height int err av log s avctx AVLOGWARNING Changing dimensions to dx d n si width si height s width si width s height si height avcodec set dimensions s avctx s width s height if err ff MPV common frame size change s 0 return err if err rv34 decoder realloc r 0 return err s pict type si type si type AVPICTURETYPEI if ff MPV frame start s s avctx 0 return 1 ff mpeg er frame start s if r tmp b block base int i r tmp b block base av malloc s linesize 48 for i 0 i 2 i r tmp b block y i r tmp b block base i 16 s linesize for i 0 i 4 i r tmp b block uv i r tmp b block base 32 s linesize i 1 8 s uvlinesize i 1 16 r cur pts si pts if s pict type AVPICTURETYPEB r last pts r next pts r next pts r cur pts else int refdist GETPTSDIFF r next pts r last pts int dist0 GETPTSDIFF r cur pts r last pts int dist1 GETPTSDIFF r next pts r cur pts if refdist r mv weight1 r mv weight2 r weight1 r weight2 8192 r scaled weight 0 else r mv weight1 dist0 14 refdist r mv weight2 dist1 14 refdist if r mv weight1 r mv weight2 511 r weight1 r mv weight1 r weight2 r mv weight2 r scaled weight 0 else r weight1 r mv weight1 9 r weight2 r mv weight2 9 r scaled weight 1 s mb x s mb y 0 ff thread finish setup s avctx else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log s avctx AVLOGERROR Decoder needs full frames in frame multithreading mode start MB is d n si start return AVERRORINVALIDDATA for i 0 i slice count i int offset get slice offset avctx slices hdr i int size if i 1 slice count size buf size offset else size get slice offset avctx slices hdr i 1 offset if offset 0 offset buf size av log avctx AVLOGERROR Slice offset is invalid n break r si end s mb width s mb height s mb num left r s mb x r s mb y r s mb width r si start if i 1 slice count if get slice offset avctx slices hdr i 1 0 get slice offset avctx slices hdr i 1 buf size av log avctx AVLOGERROR Slice offset is invalid n break init get bits s gb buf get slice offset avctx slices hdr i 1 buf size get slice offset avctx slices hdr i 1 8 if r parse slice header r r s gb si 0 if i 2 slice count size get slice offset avctx slices hdr i 2 offset else size buf size offset else r si end si start if size 0 size buf size offset av log avctx AVLOGERROR Slice size is invalid n break last rv34 decode slice r r si end buf offset size if last break if s current picture ptr if last if r loop filter r loop filter r s mb height 1 got picture ptr finish frame avctx pict else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log avctx AVLOGINFO marking unfished frame as finished n ff er frame end s er ff MPV frame end s s mb num left 0 ff thread report progress s current picture ptr f INTMAX 0 return AVERRORINVALIDDATA return avpkt size static int mjpegb decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size M Jpeg Decode Context s avctx priv data const uint8 t buf end buf ptr Get Bit Context hgb uint32 t dqt offs dht offs sof offs sos offs second field offs uint32 t field size sod offs int ret buf ptr buf buf end buf buf size read header s restart interval 0 s restart count 0 s mjpb skiptosod 0 if buf end buf ptr 1 28 return AVERRORINVALIDDATA init get bits hgb buf ptr buf end buf ptr 8 skip bits hgb 32 if get bits long hgb 32 MKBETAG m j p g av log avctx AVLOGWARNING not mjpeg b bad fourcc n return AVERRORINVALIDDATA field size get bits long hgb 32 av log avctx AVLOGDEBUG field size 0x x n field size skip bits hgb 32 second field offs read offs avctx hgb buf end buf ptr second field offs is d and size is d n av log avctx AVLOGDEBUG second field offs 0x x n second field offs dqt offs read offs avctx hgb buf end buf ptr dqt is d and size is d n av log avctx AVLOGDEBUG dqt offs 0x x n dqt offs if dqt offs init get bits s gb buf ptr dqt offs buf end buf ptr dqt offs 8 s start code DQT if ff mjpeg decode dqt s 0 avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA dht offs read offs avctx hgb buf end buf ptr dht is d and size is d n av log avctx AVLOGDEBUG dht offs 0x x n dht offs if dht offs init get bits s gb buf ptr dht offs buf end buf ptr dht offs 8 s start code DHT ff mjpeg decode dht s sof offs read offs avctx hgb buf end buf ptr sof is d and size is d n av log avctx AVLOGDEBUG sof offs 0x x n sof offs if sof offs init get bits s gb buf ptr sof offs buf end buf ptr sof offs 8 s start code SO F0 if ff mjpeg decode sof s 0 return 1 sos offs read offs avctx hgb buf end buf ptr sos is d and size is d n av log avctx AVLOGDEBUG sos offs 0x x n sos offs sod offs read offs avctx hgb buf end buf ptr sof is d and size is d n av log avctx AVLOGDEBUG sod offs 0x x n sod offs if sos offs init get bits s gb buf ptr sos offs 8 FFMIN field size buf end buf ptr sos offs s mjpb skiptosod sod offs sos offs show bits s gb 16 s start code SOS if ff mjpeg decode sos s NULLNULL 0 avctx err recognition AVEFEXPLODE return AVERRORINVALIDDATA if s interlaced s bottom field 1 if s bottom field s interlace polarity second field offs buf ptr buf second field offs second field offs 0 goto read header if ret av frame ref data s picture ptr 0 return ret got frame 1 if s lossless avctx debug FFDEBUGQP av log avctx AVLOGDEBUGQP d n FFMA X3 s qscale 0 s qscale 1 s qscale 2 return buf size static int rv34 decode inter macroblock R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s Get Bit Context gb s gb uint8 t dst s dest 0 int16 t ptr s block 0 int mb pos s mb x s mb y s mb stride int cbp cbp2 int q dc q ac has ac int i j int dist memset r avail cache 0 sizeof r avail cache fill rectangle r avail cache 6 2 2 4 1 4 dist s mb x s resync mb x s mb y s resync mb y s mb width if s mb x dist r avail cache 5 r avail cache 9 s current picture ptr f mb type mb pos 1 if dist s mb width r avail cache 2 r avail cache 3 s current picture ptr f mb type mb pos s mb stride if s mb x 1 s mb width dist s mb width 1 r avail cache 4 s current picture ptr f mb type mb pos s mb stride 1 if s mb x dist s mb width r avail cache 1 s current picture ptr f mb type mb pos s mb stride 1 s qscale r si quant cbp cbp2 rv34 decode inter mb header r intra types r cbp luma mb pos cbp r cbp chroma mb pos cbp 16 r deblock coefs mb pos rv34 set deblock coef r r cbp luma mb pos s current picture ptr f qscale table mb pos s qscale if cbp 1 return 1 if ISINTRA s current picture ptr f mb type mb pos if r is16 rv34 output i16x16 r intra types cbp else rv34 output intra r intra types cbp return 0 if r is16 LOCALALIGNED 16 int16 t block16 16 memset block16 0 16 sizeof block16 q dc rv34 qscale tab r luma dc quant p s qscale q ac rv34 qscale tab s qscale if rv34 decode block block16 gb r cur vlcs 3 0 q dc q dc q ac r rdsp rv34 inv transform block16 else r rdsp rv34 inv transform dc block16 q ac rv34 qscale tab s qscale for j 0 j 4 j for i 0 i 4 i cbp 1 int dc block16 i j 4 if cbp 1 has ac rv34 decode block ptr gb r cur vlcs r luma vlc 0 q ac q ac q ac else has ac 0 if has ac ptr 0 dc r rdsp rv34 idct add dst 4 i s linesize ptr else r rdsp rv34 idct dc add dst 4 i s linesize dc dst 4 s linesize r cur vlcs choose vlc set r si quant r si vlc set 1 else q ac rv34 qscale tab s qscale for j 0 j 4 j for i 0 i 4 i cbp 1 if cbp 1 continue rv34 process block r dst 4 i s linesize r luma vlc 0 q ac q ac dst 4 s linesize q dc rv34 qscale tab rv34 chroma quant 1 s qscale q ac rv34 qscale tab rv34 chroma quant 0 s qscale for j 1 j 3 j dst s dest j for i 0 i 4 i cbp 1 uint8 t pdst if cbp 1 continue pdst dst i 1 4 i 2 2 s uvlinesize rv34 process block r pdst s uvlinesize r chroma vlc 1 q dc q ac return 0 int MD C2 Update MD C2 CTX c const unsigned char in size t len size t i j i c num if i 0 if i len MD C2 BLOCK memcpy c data i in len c num int len return 1 else j MD C2 BLOCK i memcpy c data i in j len j in j c num 0 mdc2 body c c data 0 MD C2 BLOCK i len size t MD C2 BLOCK 1 if i 0 mdc2 body c in i j len i if j 0 memcpy c data 0 in i j c num int j return 1 void vp8 mbpost proc across ip c unsigned char src int pitch int rows int cols int flimit int r c i unsigned char s src unsigned char d 16 for r 0 r rows r int sumsq 0 int sum 0 for i 8 i 0 i s i s 0 for i cols i cols 17 i s i s cols 1 for i 8 i 6 i sumsq s i s i sum s i d i 8 0 for c 0 c cols 8 c int x s c 7 s c 8 int y s c 7 s c 8 sum x sumsq x y d c 15 s c if sumsq 15 sum sum flimit d c 15 8 sum s c 4 s c 8 d c 8 15 s pitch static int setup resv limits slurmdb reservation rec t resv char cols char vals char extra if resv assocs int start 0 int len strlen resv assocs 1 if strchr resv assocs int i 0 i2 0 char assocs xmalloc sizeof char len while i len if resv assocs i resv assocs i 1 i 2 while i len i if resv assocs i break continue assocs i2 resv assocs i xfree resv assocs len i2 1 resv assocs assocs assocs NULL if resv assocs 0 start 1 if resv assocs len resv assocs len 0 xstrcat cols assoclist xstrfmtcat vals s resv assocs start xstrfmtcat extra assoclist s resv assocs start if resv flags NOVAL xstrcat cols flags xstrfmtcat vals u resv flags xstrfmtcat extra flags u resv flags if resv name char tmp char slurm add slash to quotes resv name xstrcat cols resv name xstrfmtcat vals s tmp char xstrfmtcat extra resv name s tmp char xfree tmp char if resv nodes xstrcat cols nodelist xstrfmtcat vals s resv nodes xstrfmtcat extra nodelist s resv nodes if resv node inx xstrcat cols node inx xstrfmtcat vals s resv node inx xstrfmtcat extra node inx s resv node inx if resv time end xstrcat cols time end xstrfmtcat vals ld resv time end xstrfmtcat extra time end ld resv time end if resv time start xstrcat cols time start xstrfmtcat vals ld resv time start xstrfmtcat extra time start ld resv time start if resv tres str xstrcat cols tres xstrfmtcat vals s resv tres str xstrfmtcat extra tres s resv tres str return static void alloc mode context V P9 COMMON cm int num 4x4 blk PICKMODECONTEXT ctx const int num blk num 4x4 blk 4 4 num 4x4 blk const int num pix num blk 4 int i k ctx num 4x4 blk num blk CHECKMEMERROR cm ctx zcoeff blk vpx calloc num 4x4 blk sizeof uint8 t for i 0 i MAXMBPLANE i for k 0 k 3 k CHECKMEMERROR cm ctx coeff i k vpx memalign 16 num pix sizeof ctx coeff i k CHECKMEMERROR cm ctx qcoeff i k vpx memalign 16 num pix sizeof ctx qcoeff i k CHECKMEMERROR cm ctx dqcoeff i k vpx memalign 16 num pix sizeof ctx dqcoeff i k CHECKMEMERROR cm ctx eobs i k vpx memalign 16 num pix sizeof ctx eobs i k ctx coeff pbuf i k ctx coeff i k ctx qcoeff pbuf i k ctx qcoeff i k ctx dqcoeff pbuf i k ctx dqcoeff i k ctx eobs pbuf i k ctx eobs i k static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Anm Context s avctx priv data const int buf size avpkt size uint8 t dst dst end int count ret if ret avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret dst s frame data 0 dst end s frame data 0 s frame linesize 0 avctx height bytestream2 init s gb avpkt data buf size if bytestream2 get byte s gb 0x42 av log ask for sample avctx unknown record type n return buf size if bytestream2 get byte s gb av log ask for sample avctx padding bytes not supported n return buf size bytestream2 skip s gb 2 s x 0 do count type 0x7 F type 7 if count if OP type NULL s gb 1 count break else if type int pixel count bytestream2 get byte s gb pixel bytestream2 get byte s gb if OPNULL pixel count break else int pixel type bytestream2 get le16 s gb count type 0x3 FFF type 14 if count if type 0 break if type 2 av log ask for sample avctx unknown opcode return AVERRORPATCHWELCOME continue pixel type 3 bytestream2 get byte s gb 1 if type 1 count 0x4000 if OP type 2 s gb NULL pixel count break while bytestream2 get bytes left s gb 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Indeo3 Decode Context ctx avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data int res res decode frame headers ctx avctx buf buf size if res 0 return res if res got frame 0 return buf size if ctx frame flags BSNONREF avctx skip frame AVDISCARDNONREF return 0 if ctx frame flags BSKEYFRAME avctx skip frame AVDISCARDNONKEY return 0 ctx buf sel ctx frame flags BSBUFFER 1 if res decode plane ctx avctx ctx planes ctx y data ptr ctx y data size 40 return res if res decode plane ctx avctx ctx planes 1 ctx u data ptr ctx u data size 10 return res if res decode plane ctx avctx ctx planes 2 ctx v data ptr ctx v data size 10 return res if res ff get buffer avctx frame 0 0 av log ctx avctx AVLOGERROR get buffer failed n return res output plane ctx planes 0 ctx buf sel frame data 0 frame linesize 0 avctx height output plane ctx planes 1 ctx buf sel frame data 1 frame linesize 1 avctx height 3 2 output plane ctx planes 2 ctx buf sel frame data 2 frame linesize 2 avctx height 3 2 got frame 1 return buf size int test sqr BIO bp BNCTX ctx BIGNUM a c d e int i BN init a BN init c BN init d BN init e for i 0 i num0 i BN bntest rand a 40 i 10 0 0 a neg rand neg BN sqr c a ctx if bp NULL if results BN print bp a BIO puts bp BN print bp a BIO puts bp BN print bp c BIO puts bp n BN div d e c a ctx BN sub d d a if BN is zero d BN is zero e fprintf stderr Square test failed n return 0 BN free a BN free c BN free d BN free e return 1 int ff h263 decode mb Mpeg Enc Context s int16 t block 6 64 int cbpc cbpy i cbp pred x pred y mx my dquant int16 t mot val const int xy s mb x s mb y s mb stride int cbpb 0 pb mv count 0 assert s h263 pred if s pict type AVPICTURETYPEP do if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped s obmc s loop filter goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc damaged at d d n s mb x s mb y return 1 while cbpc 20 s dsp clear blocks s block 0 dquant cbpc 8 s mb intra cbpc 4 0 if s mb intra goto intra if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s s mv dir MVDIRFORWARD if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 0 0 mx s mv 0 0 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 s mv type MVTYPE 8 X8 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my else if s pict type AVPICTURETYPEB int mb type const int stride s b8 stride int16 t mot val0 s current picture motion val 0 2 s mb x s mb y stride int16 t mot val1 s current picture motion val 1 2 s mb x s mb y stride mot val0 0 mot val0 2 mot val0 0 2 stride mot val0 2 2 stride mot val0 1 mot val0 3 mot val0 1 2 stride mot val0 3 2 stride mot val1 0 mot val1 2 mot val1 0 2 stride mot val1 2 2 stride mot val1 1 mot val1 3 mot val1 1 2 stride mot val1 3 2 stride 0 do mb type get vlc2 s gb h263 mbtype b vlc table H263 MBTYPEBVLCBITS 2 if mb type 0 av log s avctx AVLOGERROR b mb type damaged at d d n s mb x s mb y return 1 mb type h263 mb type b map mb type while mb type s mb intra ISINTRA mb type if HASCBP mb type s dsp clear blocks s block 0 cbpc get vlc2 s gb cbpc b vlc table CBPCBVLCBITS 1 if s mb intra dquant ISQUANT mb type goto intra cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERROR b cbpy damaged at d d n s mb x s mb y return 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 else cbp 0 assert s mb intra if ISQUANT mb type h263 decode dquant s if ISDIRECT mb type s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT mb type ff mpeg4 set direct mv s 0 0 else s mv dir 0 s mv type MVTYPE 16 X16 if USESLIST mb type 0 int16 t mot val ff h263 pred motion s 0 0 mx my s mv dir MVDIRFORWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 0 0 0 mx s mv 0 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my if USESLIST mb type 1 int16 t mot val ff h263 pred motion s 0 1 mx my s mv dir MVDIRBACKWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 1 0 0 mx s mv 1 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my s current picture mb type xy mb type else do cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERRORI cbpc damaged at d d n s mb x s mb y return 1 while cbpc 8 s dsp clear blocks s block 0 dquant cbpc 4 s mb intra 1 intra s current picture mb type xy MBTYPEINTRA if s h263 aic s ac pred get bits1 s gb if s ac pred s current picture mb type xy MBTYPEINTRAMBTYPEACPRED s h263 aic dir get bits1 s gb else s ac pred 0 if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy damaged at d d n s mb x s mb y return 1 cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s pb mv count s pb frame while pb mv count ff h263 decode motion s 0 1 ff h263 decode motion s 0 1 for i 0 i 6 i if h263 decode block s block i i cbp 32 0 return 1 cbp cbp if s pb frame h263 skip b part s cbpb 0 return 1 if s obmc s mb intra if s pict type AVPICTURETYPEP s mb x 1 s mb width s mb num left 1 preview obmc s end int v show bits s gb 16 if get bits left s gb 16 v 16 get bits left s gb if v 0 return SLICEEND return static int lag decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Lagarith Context l avctx priv data AV Frame const p l picture uint8 t frametype 0 uint32 t offset gu 0 offset bv 0 offset ry 9 uint32 t offs 4 uint8 t srcs 4 dst int i j planes 3 AV Frame picture data if p data 0 ff thread release buffer avctx p p reference 0 p key frame 1 frametype buf 0 offset gu AVR L32 buf 1 offset bv AVR L32 buf 5 switch frametype case FRAMESOLIDRGBA avctx pix fmt AVPIXFMTRG B32 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 dst p data 0 for j 0 j avctx height j for i 0 i avctx width i AVW N32 dst i 4 offset gu dst p linesize 0 break case FRAMEARITHRGBA avctx pix fmt AVPIXFMTRG B32 planes 4 offset ry 4 offs 3 AVR L32 buf 9 case FRAMEARITHRG B24 case FRAMEURG B24 if frametype FRAMEARITHRG B24 frametype FRAMEURG B24 avctx pix fmt AVPIXFMTRG B24 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 offs 0 offset bv offs 1 offset gu offs 2 offset ry if l rgb planes l rgb stride FFALIGN avctx width 16 l rgb planes av malloc l rgb stride avctx height planes 1 if l rgb planes av log avctx AVLOGERROR cannot allocate temporary buffer n return AVERRORENOMEM for i 0 i planes i srcs i l rgb planes i 1 l rgb stride avctx height l rgb stride if offset ry buf size offset gu buf size offset bv buf size planes 4 offs 3 buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA for i 0 i planes i lag decode arith plane l srcs i avctx width avctx height l rgb stride buf offs i buf size offs i dst p data 0 for i 0 i planes i srcs i l rgb planes i l rgb stride avctx height for j 0 j avctx height j for i 0 i avctx width i uint8 t r g b a r srcs 0 i g srcs 1 i b srcs 2 i r g b g if frametype FRAMEARITHRGBA a srcs 3 i AVW N32 dst i 4 MKBETAG a r g b else dst i 3 0 r dst i 3 1 g dst i 3 2 b dst p linesize 0 for i 0 i planes i srcs i l rgb stride break case FRAMEARITHYU Y2 avctx pix fmt AVPIXFMTYU V422 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 1 avctx width 2 avctx height p linesize 1 buf offset gu buf size offset gu lag decode arith plane l p data 2 avctx width 2 avctx height p linesize 2 buf offset bv buf size offset bv break case FRAMEARITHY V12 avctx pix fmt AVPIXFMTYU V420 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf offset gu buf size offset gu lag decode arith plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf offset bv buf size offset bv break default av log avctx AVLOGERROR Unsupported Lagarith frame type x n frametype return 1 picture p got frame 1 return buf size static void append LDML Extension As Keywords const char ldmlext Extension List Entry append To char buf int32 t buf Size U Bool posix Variant U Error Code status const char p Tag const char p Kwds U Bool variant Exists posix Variant Extension List Entry kwd First NULL Extension List Entry kwd next Kwd Attribute List Entry attr First NULL Attribute List Entry attr next Attr int32 t len int32 t buf Idx 0 char attr Buf ULOCKEYWORDANDVALUESCAPACITY int32 t attr Buf Idx 0 posix Variant FALSE p Tag ldmlext p Kwds NULL while p Tag for len 0 p Tag len p Tag len SEP len if ultag is Unicode Locale Key p Tag len p Kwds p Tag break attr Attribute List Entry uprv malloc sizeof Attribute List Entry if attr NULL status UMEMORYALLOCATIONERROR goto cleanup if len int32 t sizeof attr Buf attr Buf Idx uprv memcpy attr Buf attr Buf Idx p Tag len attr Buf attr Buf Idx len 0 attr attribute attr Buf attr Buf Idx attr Buf Idx len 1 else status UILLEGALARGUMENTERROR goto cleanup if add Attribute To List attr First attr status UILLEGALARGUMENTERROR uprv free attr goto cleanup p Tag len if p Tag p Tag if attr First if attr Buf Idx buf Size status UILLEGALARGUMENTERROR goto cleanup kwd Extension List Entry uprv malloc sizeof Extension List Entry if kwd NULL status UMEMORYALLOCATIONERROR goto cleanup kwd key LOCALEATTRIBUTEKEY kwd value buf attr attr First while attr NULL next Attr attr next if attr attr First buf buf Idx SEP buf Idx len uprv strlen attr attribute uprv memcpy buf buf Idx attr attribute len buf Idx len attr next Attr buf buf Idx 0 buf Idx if add Extension To List kwd First kwd FALSE status UILLEGALARGUMENTERROR uprv free kwd goto cleanup attr attr First while attr NULL next Attr attr next uprv free attr attr next Attr attr First NULL if p Kwds const char p Bcp Key NULL const char p Bcp Type NULL int32 t bcp Key Len 0 int32 t bcp Type Len 0 U Bool is Done FALSE p Tag p Kwds while is Done const char p Next Bcp Key NULL int32 t next Bcp Key Len 0 U Bool emit Keyword FALSE if p Tag for len 0 p Tag len p Tag len SEP len if ultag is Unicode Locale Key p Tag len if p Bcp Key emit Keyword TRUE p Next Bcp Key p Tag next Bcp Key Len len else p Bcp Key p Tag bcp Key Len len else UASSERT p Bcp Key NULL if p Bcp Type bcp Type Len len 1 else p Bcp Type p Tag bcp Type Len len p Tag len if p Tag p Tag else emit Keyword TRUE is Done TRUE if emit Keyword const char p Key NULL const char p Type NULL char bcp Key Buf 9 UASSERT p Bcp Key NULL if bcp Key Len int32 t sizeof bcp Key Buf status UILLEGALARGUMENTERROR goto cleanup uprv strncpy bcp Key Buf p Bcp Key bcp Key Len bcp Key Buf bcp Key Len 0 p Key uloc to Legacy Key bcp Key Buf if p Key NULL status UILLEGALARGUMENTERROR goto cleanup if p Key bcp Key Buf TC String to Lower Case bcp Key Buf if buf Size buf Idx 1 bcp Key Len uprv memcpy buf buf Idx bcp Key Buf bcp Key Len p Key buf buf Idx buf Idx bcp Key Len buf buf Idx 0 buf Idx else status UBUFFEROVERFLOWERROR goto cleanup if p Bcp Type char bcp Type Buf 128 if bcp Type Len int32 t sizeof bcp Type Buf status UILLEGALARGUMENTERROR goto cleanup uprv strncpy bcp Type Buf p Bcp Type bcp Type Len bcp Type Buf bcp Type Len 0 p Type uloc to Legacy Type p Key bcp Type Buf if p Type NULL status UILLEGALARGUMENTERROR goto cleanup if p Type bcp Type Buf TC String to Lower Case bcp Type Buf if buf Size buf Idx 1 bcp Type Len uprv memcpy buf buf Idx bcp Type Buf bcp Type Len p Type buf buf Idx buf Idx bcp Type Len buf buf Idx 0 buf Idx else status UBUFFEROVERFLOWERROR goto cleanup else p Type LOCALETYPEYES if variant Exists uprv strcmp p Key POSIXKEY uprv strcmp p Type POSIXVALUE posix Variant TRUE else kwd Extension List Entry uprv malloc sizeof Extension List Entry if kwd NULL status UMEMORYALLOCATIONERROR goto cleanup kwd key p Key kwd value p Type if add Extension To List kwd First kwd FALSE status UILLEGALARGUMENTERROR uprv free kwd goto cleanup p Bcp Key p Next Bcp Key bcp Key Len p Next Bcp Key NULL next Bcp Key Len 0 p Bcp Type NULL bcp Type Len 0 kwd kwd First while kwd NULL next Kwd kwd next add Extension To List append To kwd FALSE kwd next Kwd return cleanup attr attr First while attr NULL next Attr attr next uprv free attr attr next Attr kwd kwd First while kwd NULL next Kwd kwd next uprv free kwd kwd next Kwd static void fill mode info sb V P9 COMMON cm MACROBLOCK x int mi row int mi col BLOCKSIZE bsize BLOCKSIZE subsize PCTREE pc tree MACROBLOCKD xd x e mbd int bsl b width log2 bsize hbs 1 bsl 4 PARTITIONTYPE partition pc tree partitioning assert bsize BLOCK 8 X8 if mi row cm mi rows mi col cm mi cols return switch partition case PARTITIONNONE set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree none mic duplicate mode info in sb cm xd mi row mi col bsize break case PARTITIONVERT set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree vertical 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi col hbs cm mi cols set modeinfo offsets cm xd mi row mi col hbs xd mi 0 src mi pc tree vertical 1 mic duplicate mode info in sb cm xd mi row mi col hbs bsize break case PARTITIONHORZ set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree horizontal 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi row hbs cm mi rows set modeinfo offsets cm xd mi row hbs mi col xd mi 0 src mi pc tree horizontal 1 mic duplicate mode info in sb cm xd mi row hbs mi col bsize break case PARTITIONSPLITBLOCKSIZE subsubsize get subsize subsize PARTITIONSPLIT fill mode info sb cm x mi row mi col subsize subsubsize pc tree split 0 fill mode info sb cm x mi row mi col hbs subsize subsubsize pc tree split 1 fill mode info sb cm x mi row hbs mi col subsize subsubsize pc tree split 2 fill mode info sb cm x mi row hbs mi col hbs subsize subsubsize pc tree split 3 break default break static void print mi data V P9 COMMON cm FILE file const char descriptor size t member offset int mi row mi col int mi index 0 MODEINFO mi NULL int rows cm mi rows int cols cm mi cols char prefix descriptor 0 log frame info cm descriptor file mi index 0 for mi row 0 mi row rows mi row fprintf file c prefix for mi col 0 mi col cols mi col fprintf file 2d int char mi mi index mbmi member offset mi index fprintf file n mi index 8 fprintf file n static int vc1 decode p mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int val int first block 1 int dst idx off int pred flag int block cbp 0 pat block tt 0 int idx mbmode 0 mquant v pq idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 v mb type 0 s block index i 1 dst idx i 2 val cbp 5 i 1 v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if idx mbmode 5 dmv x dmv y pred flag 0 if idx mbmode 1 get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v 0 dmv x dmv y 1 v range x v range y v mb type 0 pred flag 0 vc1 mc 1mv v 0 mb has coeffs idx mbmode 2 else v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x dmv y pred flag 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v i dmv x dmv y 0 v range x v range y v mb type 0 pred flag 0 vc1 mc 4mv luma v i 0 else if i 4 vc1 mc 4mv chroma v 0 mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 if s mb x s mb width 1 memmove v is intra base v is intra sizeof v is intra base 0 s mb stride return 0 kadm5 ret t kadm5 create principal 3 void server handle kadm5 principal ent t entry long mask int n ks tuple krb5 key salt tuple ks tuple char password krb5 db entry kdb osa princ ent rec adb kadm5 policy ent rec polent krb5 boolean have polent FALSE krb5 int32 now krb5 tl data tl data tail unsigned int ret kadm5 server handle t handle server handle krb5 keyblock act mkey krb5 kvno act kvno int new n ks tuple 0 krb5 key salt tuple new ks tuple NULLCHECKHANDLE server handle krb5 clear error message handle context check 1 6 dummy entry mask n ks tuple ks tuple password if entry NULL return EINVAL if mask KAD M5 PRINCIPAL mask KAD M5 MODNAME mask KAD M5 MODTIME mask KAD M5 LASTPWDCHANGE mask KAD M5 MKVNO mask KAD M5 AUXATTRIBUTES mask KAD M5 LASTSUCCESS mask KAD M5 LASTFAILED mask KAD M5 FAILAUTHCOUNT return KAD M5 BADMASK if mask KAD M5 KEYDATA entry n key data 0 return KAD M5 BADMASK if mask KAD M5 POLICY entry policy NULL return KAD M5 BADMASK if mask KAD M5 POLICY mask KAD M5 POLICYCLR return KAD M5 BADMASK if mask ALLPRINCMASK return KAD M5 BADMASK ret kdb get entry handle entry principal kdb adb switch ret case KAD M5 UNKPRINC break case 0 kdb free entry handle kdb adb return KAD M5 DUP default return ret kdb krb5 db alloc handle context NULL sizeof kdb if kdb NULL return ENOMEM memset kdb 0 sizeof kdb memset adb 0 sizeof osa princ ent rec if mask KAD M5 POLICY ret get policy handle entry policy polent have polent if ret goto cleanup if password ret passwd check handle password have polent polent NULL entry principal if ret goto cleanup if ret krb5 timeofday handle context now goto cleanup kdb magic KR B5 KDBMAGICNUMBER kdb len KR B5 KDB V1 BASELENGTH if mask KAD M5 ATTRIBUTES kdb attributes entry attributes else kdb attributes handle params flags if mask KAD M5 MAXLIFE kdb max life entry max life else kdb max life handle params max life if mask KAD M5 MAXRLIFE kdb max renewable life entry max renewable life else kdb max renewable life handle params max rlife if mask KAD M5 PRINCEXPIRETIME kdb expiration entry princ expire time else kdb expiration handle params expiration kdb pw expiration 0 if have polent if polent pw max life kdb pw expiration now polent pw max life else kdb pw expiration 0 if mask KAD M5 PWEXPIRATION kdb pw expiration entry pw expiration kdb last success 0 kdb last failed 0 kdb fail auth count 0 if ret kadm5 copy principal handle context entry principal kdb princ goto cleanup if ret krb5 dbe update last pwd change handle context kdb now goto cleanup if mask KAD M5 TLDATA for tl data tail entry tl data tl data tail tl data tail tl data tail tl data next ret krb5 dbe update tl data handle context kdb tl data tail if ret goto cleanup ret apply keysalt policy handle entry policy n ks tuple ks tuple new n ks tuple new ks tuple if ret goto cleanup ret kdb get active mkey handle act kvno act mkey if ret goto cleanup if mask KAD M5 KEYDATA assert entry n key data 0 else if password ret krb5 dbe cpw handle context act mkey new ks tuple new n ks tuple password mask KAD M5 KVNO entry kvno 1 FALSE kdb else ret krb5 dbe crk handle context master keyblock new ks tuple new n ks tuple FALSE kdb if ret goto cleanup ret krb5 dbe update mkvno handle context kdb act kvno if ret goto cleanup ret k5 kadm5 hook create handle context handle hook handles KAD M5 HOOKSTAGEPRECOMMIT entry mask new n ks tuple new ks tuple password if ret goto cleanup adb admin history kvno INITIALHISTKVNO if mask KAD M5 POLICY adb aux attributes KAD M5 POLICY adb policy entry policy kdb mask mask KAD M5 KEYDATAKAD M5 PRINCIPAL ret kdb put entry handle kdb adb void k5 kadm5 hook create handle context handle hook handles KAD M5 HOOKSTAGEPOSTCOMMIT entry mask new n ks tuple new ks tuple password cleanup free new ks tuple krb5 db free principal handle context kdb if have polent void kadm5 free policy ent handle lhandle polent return ret static int ir2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ir2 Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p s picture int start ret if ret ff reget buffer avctx p 0 av log s avctx AVLOGERROR reget buffer failed n return ret start 48 if start buf size av log s avctx AVLOGERROR input buffer size too small d n buf size return AVERRORINVALIDDATA s decode delta buf 18 i buf size i buf i ff reverse buf i if s decode delta if ret ir2 decode plane s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret else if ret ir2 decode plane inter s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret if ret av frame ref picture s picture 0 return ret got frame 1 return buf size static int rv34 decode intra macroblock R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s int cbp dist int mb pos s mb x s mb y s mb stride memset r avail cache 0 sizeof r avail cache fill rectangle r avail cache 6 2 2 4 1 4 dist s mb x s resync mb x s mb y s resync mb y s mb width if s mb x dist r avail cache 5 r avail cache 9 s current picture ptr mb type mb pos 1 if dist s mb width r avail cache 2 r avail cache 3 s current picture ptr mb type mb pos s mb stride if s mb x 1 s mb width dist s mb width 1 r avail cache 4 s current picture ptr mb type mb pos s mb stride 1 if s mb x dist s mb width r avail cache 1 s current picture ptr mb type mb pos s mb stride 1 s qscale r si quant cbp rv34 decode intra mb header r intra types r cbp luma mb pos cbp r cbp chroma mb pos cbp 16 r deblock coefs mb pos 0x FFFF s current picture ptr qscale table mb pos s qscale if cbp 1 return 1 if r is16 rv34 output i16x16 r intra types cbp return 0 rv34 output intra r intra types cbp return 0 static inline int rawv6 rcv skb struct sock sk struct sk buff skb if raw6 sk sk checksum sk sk filter skb checksum complete skb atomic inc sk sk drops kfree skb skb return NETRXDROP if sock queue rcv skb sk skb 0 kfree skb skb return NETRXDROP return 0 static void cookedprint int datatype int length const char data int status int quiet FILE fp char name char value char output raw int fmt l fp lfp sockaddr u hval u long uval int narr size t len l fp lfparr 8 char b 12 char bn 2 MAXVARLEN char bv 2 MAXVALLENUNUSEDARG datatype if quiet fprintf fp status 04x s n status statustoa datatype status startoutput while nextvar length data name value fmt varfmt name output raw 0 switch fmt case PADDING output raw break case TS if decodets value lfp output raw else output fp name prettydate lfp break case HA case NA if decodenetnum value hval output raw else if fmt HA output fp name nntohost hval else output fp name stoa hval break case RF if decodenetnum value hval if ISREFCLOCKADR hval output fp name refnumtoa hval else output fp name stoa hval else if strlen value 4 output fp name value else output raw break case LP if decodeuint value uval uval 3 output raw else b 0 0x2 uval 1 0 b 1 0x1 uval 1 0 b 2 0 output fp name b break case OC if decodeuint value uval output raw else snprintf b sizeof b 03lo uval output fp name b break case AR if decodearr value narr lfparr output raw else outputarr fp name narr lfparr break case FX if decodeuint value uval output raw else output fp name tstflags uval break default fprintf stderr Internal error in cookedprint s s fmt d n name value fmt output raw break if output raw 0 atoascii name MAXVARLEN bn sizeof bn if output raw atoascii value MAXVALLEN bv sizeof bv 1 len strlen bv bv len output raw bv len 1 0 else atoascii value MAXVALLEN bv sizeof bv output fp bn bv endoutput fp static V P9 DENOISERDECISION perform motion compensation V P9 DENOISER denoiser MACROBLOCK mb BLOCKSIZE bs int increase denoising int mi row int mi col PICKMODECONTEXT ctx int motion magnitude int mv col mv row int sse diff ctx zeromv sse ctx newmv sse MVREFERENCEFRAME frame MACROBLOCKD filter mbd mb e mbd MBMODEINFO mbmi filter mbd mi 0 mbmi MBMODEINFO saved mbmi int i j struct buf 2d saved dst MAXMBPLANE struct buf 2d saved pre MAXMBPLANE 2 saved mbmi mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j saved pre i j filter mbd plane i pre j saved dst i filter mbd plane i dst mv col ctx best sse mv as mv col mv row ctx best sse mv as mv row motion magnitude mv row mv row mv col mv col frame ctx best reference frame if frame INTRAFRAME sse diff sse diff thresh bs increase denoising mv row mv col mbmi ref frame 0 ctx best reference frame mbmi mode ctx best sse inter mode mbmi mv 0 ctx best sse mv else frame ctx best zeromv reference frame mbmi ref frame 0 ctx best zeromv reference frame mbmi mode ZEROMV mbmi mv 0 as int 0 ctx best sse inter mode ZEROMV ctx best sse mv as int 0 ctx newmv sse ctx zeromv sse for j 0 j 2 j filter mbd plane 0 pre j buf block start denoiser running avg y frame y buffer denoiser running avg y frame y stride mi row mi col filter mbd plane 0 pre j stride denoiser running avg y frame y stride filter mbd plane 1 pre j buf block start denoiser running avg y frame u buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 1 pre j stride denoiser running avg y frame uv stride filter mbd plane 2 pre j buf block start denoiser running avg y frame v buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 2 pre j stride denoiser running avg y frame uv stride filter mbd plane 0 dst buf block start denoiser mc running avg y y buffer denoiser mc running avg y y stride mi row mi col filter mbd plane 0 dst stride denoiser mc running avg y y stride filter mbd plane 1 dst buf block start denoiser mc running avg y u buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 1 dst stride denoiser mc running avg y uv stride filter mbd plane 2 dst buf block start denoiser mc running avg y v buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 2 dst stride denoiser mc running avg y uv stride vp9 build inter predictors sby filter mbd mv row mv col bs mbmi saved mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j filter mbd plane i pre j saved pre i j filter mbd plane i dst saved dst i mv row ctx best sse mv as mv row mv col ctx best sse mv as mv col if ctx newmv sse sse thresh bs increase denoising return COPYBLOCK if mv row mv row mv col mv col noise motion thresh bs increase denoising return COPYBLOCK return static double eqjoinsel inner Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL Form pg statistic stats2 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid get opcode operator if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple stats2 Form pg statistic GETSTRUCT vardata2 stats Tuple if statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double nullfrac2 stats2 stanullfrac double matchprodfreq matchfreq1 matchfreq2 unmatchfreq1 unmatchfreq2 otherfreq1 otherfreq2 totalsel1 totalsel2 int i nmatches fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 nvalues2 sizeof bool matchprodfreq 0 0 nmatches 0 for i 0 i nvalues1 i int j for j 0 j nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true matchprodfreq numbers1 i numbers2 j nmatches break CLAMPPROBABILITY matchprodfreq matchfreq1 unmatchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i else unmatchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 CLAMPPROBABILITY unmatchfreq1 matchfreq2 unmatchfreq2 0 0 for i 0 i nvalues2 i if hasmatch2 i matchfreq2 numbers2 i else unmatchfreq2 numbers2 i CLAMPPROBABILITY matchfreq2 CLAMPPROBABILITY unmatchfreq2 pfree hasmatch1 pfree hasmatch2 otherfreq1 1 0 nullfrac1 matchfreq1 unmatchfreq1 otherfreq2 1 0 nullfrac2 matchfreq2 unmatchfreq2 CLAMPPROBABILITY otherfreq1 CLAMPPROBABILITY otherfreq2 totalsel1 matchprodfreq if nd2 nvalues2 totalsel1 unmatchfreq1 otherfreq2 nd2 nvalues2 if nd2 nmatches totalsel1 otherfreq1 otherfreq2 unmatchfreq2 nd2 nmatches totalsel2 matchprodfreq if nd1 nvalues1 totalsel2 unmatchfreq2 otherfreq1 nd1 nvalues1 if nd1 nmatches totalsel2 otherfreq2 otherfreq1 unmatchfreq1 nd1 nmatches selec totalsel1 totalsel2 totalsel1 totalsel2 else double nullfrac1 stats1 stats1 stanullfrac 0 0 double nullfrac2 stats2 stats2 stanullfrac 0 0 selec 1 0 nullfrac1 1 0 nullfrac2 if nd1 nd2 selec nd1 else selec nd2 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static void vc1 mc 1mv V C1 Context v int dir Mpeg Enc Context s v s DSP Context dsp v s dsp H264 Chroma Context h264chroma v h264chroma uint8 t src Y src U src V int dxy mx my uvmx uvmy src x src y uvsrc x uvsrc y int off off uv int v edge pos s v edge pos v field mode if v field mode v ref field type dir 1 v cur field type 1 v s last picture f data 0 return mx s mv dir 0 0 my s mv dir 0 1 if s pict type AVPICTURETYPEP s current picture f motion val 1 s block index 0 v blocks off 0 mx s current picture f motion val 1 s block index 0 v blocks off 1 my uvmx mx mx 3 3 1 uvmy my my 3 3 1 v luma mv s mb x 0 uvmx v luma mv s mb x 1 uvmy if v field mode v cur field type v ref field type dir my my 2 4 v cur field type uvmy uvmy 2 4 v cur field type if v fastuvmc v fcm ILACEFRAME uvmx uvmx uvmx 0 uvmx 1 uvmx 1 uvmy uvmy uvmy 0 uvmy 1 uvmy 1 if v field mode if dir if v cur field type v ref field type dir v cur field type src Y s current picture f data 0 src U s current picture f data 1 src V s current picture f data 2 else src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 else if dir src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 src x s mb x 16 mx 2 src y s mb y 16 my 2 uvsrc x s mb x 8 uvmx 2 uvsrc y s mb y 8 uvmy 2 if v profile PROFILEADVANCED src x av clip src x 16 s mb width 16 src y av clip src y 16 s mb height 16 uvsrc x av clip uvsrc x 8 s mb width 8 uvsrc y av clip uvsrc y 8 s mb height 8 else src x av clip src x 17 s avctx coded width src y av clip src y 18 s avctx coded height 1 uvsrc x av clip uvsrc x 8 s avctx coded width 1 uvsrc y av clip uvsrc y 8 s avctx coded height 1 src Y src y s linesize src x src U uvsrc y s uvlinesize uvsrc x src V uvsrc y s uvlinesize uvsrc x if v field mode v ref field type dir src Y s current picture ptr f linesize 0 src U s current picture ptr f linesize 1 src V s current picture ptr f linesize 2 if s flags CODECFLAGGRAY src U s edge emu buffer 18 s linesize src V s edge emu buffer 18 s linesize if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 22 v edge pos 22 unsigned src x s mspel s h edge pos mx 3 16 s mspel 3 unsigned src y 1 v edge pos my 3 16 3 uint8 t uvbuf s edge emu buffer 19 s linesize src Y s mspel 1 s linesize s vdsp emulated edge mc s edge emu buffer src Y s linesize 17 s mspel 2 17 s mspel 2 src x s mspel src y s mspel s h edge pos v edge pos src Y s edge emu buffer s vdsp emulated edge mc uvbuf src U s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 s vdsp emulated edge mc uvbuf 16 src V s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 src U uvbuf src V uvbuf 16 if v rangeredfrm int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i src i 128 1 128 src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i src i 128 1 128 src2 i src2 i 128 1 128 src s uvlinesize src2 s uvlinesize if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i v luty src i src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i v lutuv src i src2 i v lutuv src2 i src s uvlinesize src2 s uvlinesize src Y s mspel 1 s linesize if v field mode v cur field type off s current picture ptr f linesize 0 off uv s current picture ptr f linesize 1 else off 0 off uv 0 if s mspel dxy my 3 2 mx 3 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 src Y 8 s linesize v rnd src Y s linesize 8 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize 8 src Y 8 s linesize v rnd else dxy my 2 mx 2 1 if v rnd dsp put pixels tab 0 dxy s dest 0 off src Y s linesize 16 else dsp put no rnd pixels tab 0 dxy s dest 0 off src Y s linesize 16 if s flags CODECFLAGGRAY return uvmx uvmx 3 1 uvmy uvmy 3 1 if v rnd h264chroma put h264 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy h264chroma put h264 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy else v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy static int rc pick q and bounds two pass const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality cpi twopass active worst quality int q if frame is intra only cm vp9 is upper layer key frame cpi if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc active worst quality if cm width cm height 352 288 q adj factor 0 25 q adj factor 0 05 0 001 double cpi twopass kf zeromotion pct q val vp9 convert qindex to q active best quality active best quality vp9 compute qdelta rc q val q val q adj factor else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q else active best quality get gf active quality rc q else if oxcf rc mode VPXQ active best quality cq level else active best quality inter minq active worst quality if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality const GFGROUP const gf group cpi twopass gf group const double rate factor deltas RATEFACTORLEVELS 1 00 1 00 1 50 1 75 2 00 const double rate factor rate factor deltas gf group rf level gf group index int qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality rate factor top index active worst quality qdelta top index top index bottom index top index bottom index q active best quality static int tgv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Tgv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int chunk type ret chunk type AVR L32 buf 0 buf EAPREAMBLESIZE if chunk type k VGTTAG int pal count i if buf 12 buf end av log avctx AVLOGWARNING truncated header n return AVERRORINVALIDDATA s width AVR L16 buf 0 s height AVR L16 buf 2 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height av freep s frame buffer av frame unref s last frame pal count AVR L16 buf 6 buf 12 for i 0 i pal count i AVPALETTECOUNT buf 2 buf end i s palette i AVR B24 buf buf 3 if ret av image check size s width s height 0 avctx 0 return ret if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 return ret memcpy frame data 1 s palette AVPALETTESIZE if chunk type k VGTTAG int y frame key frame 1 frame pict type AVPICTURETYPEI if s frame buffer s frame buffer av malloc s width s height return AVERRORENOMEM if unpack buf buf end s frame buffer s avctx width s avctx height 0 av log avctx AVLOGWARNING truncated intra frame n return AVERRORINVALIDDATA for y 0 y s height y memcpy frame data 0 y frame linesize 0 s frame buffer y s width s width else if s last frame data 0 av log avctx AVLOGWARNING inter frame without corresponding intra frame n return buf size frame key frame 0 frame pict type AVPICTURETYPEP if tgv decode inter s frame buf buf end 0 av log avctx AVLOGWARNING truncated inter frame n return AVERRORINVALIDDATA av frame unref s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size static void evhttp handle request struct evhttp request req void arg struct evhttp http arg struct evhttp cb cb NULL event debug s req uri s func req uri if req uri NULL event debug s bad request func if req evcon state EVCONDISCONNECTED evhttp connection fail req evcon EVCONHTTPEOF else event debug s sending error func evhttp send error req HTTPBADREQUEST Bad Request return if cb evhttp dispatch callback http callbacks req NULL cb cb req cb cbarg return if http gencb http gencb req http gencbarg return else struct evbuffer buf evbuffer new evhttp response code req HTTPNOTFOUND Not Found evbuffer add printf buf ERRFORMAT escaped html free escaped html evhttp send page req buf evbuffer free buf static inline int vc1 pred dc Mpeg Enc Context s int overlap int pq int n int a avail int c avail int16 t dc val ptr int dir ptr int a b c wrap pred int16 t dc val int mb pos s mb x s mb y s mb stride int q1 q2 0 int dqscale index wrap s block wrap n dc val s dc val 0 s block index n c dc val 1 b dc val 1 wrap a dc val wrap q1 s current picture qscale table mb pos dqscale index s y dc scale table q1 1 if dqscale index 0 return 0 if c avail n 1 n 3 q2 s current picture qscale table mb pos 1 if q2 q2 q1 c c s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail n 2 n 3 q2 s current picture qscale table mb pos s mb stride if q2 q2 q1 a a s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail n 3 int off mb pos if n 1 off if n 2 off s mb stride q2 s current picture qscale table off if q2 q2 q1 b b s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail if abs a b abs b c pred c dir ptr 1 else pred a dir ptr 0 else if a avail pred a dir ptr 0 else if c avail pred c dir ptr 1 else pred 0 dir ptr 1 dc val ptr dc val 0 return pred static void decode flush AV Codec Context avctx Kgv Context const c avctx priv data av frame unref c prev static void update reference segmentation map V P9 COMP cpi V P9 COMMON const cm cpi common MODEINFO mi 8x8 ptr cm mi grid visible uint8 t cache ptr cm last frame seg map int row col for row 0 row cm mi rows row MODEINFO mi 8x8 mi 8x8 ptr uint8 t cache cache ptr for col 0 col cm mi cols col mi 8x8 cache cache 0 mi 8x8 0 mbmi segment id mi 8x8 ptr cm mi stride cache ptr cm mi cols static int get delta struct rev info revs struct remote lock lock int i struct commit commit struct object list p objects int count 0 while commit get revision revs NULL p process tree commit tree p commit object flags LOCAL if commit object flags UNINTERESTING count add send request commit object lock for i 0 i revs pending nr i struct object array entry entry revs pending objects i struct object obj entry item const char name entry name if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN p add one object obj p continue if obj type OBJTREE p process tree struct tree obj p continue if obj type OBJBLOB p process blob struct blob obj p continue die unknown pending object s s oid to hex obj oid name while objects if objects item flags UNINTERESTING count add send request objects item lock objects objects next return count void vp9 print modes and motion vectors V P9 COMMON cm const char file int mi row int mi col int mi index 0 FILE mvs fopen file a MODEINFO mi NULL int rows cm mi rows int cols cm mi cols print mi data cm mvs Partitions offsetof MBMODEINFO sb type print mi data cm mvs Modes offsetof MBMODEINFO mode print mi data cm mvs Skips offsetof MBMODEINFO skip print mi data cm mvs Ref frame offsetof MBMODEINFO ref frame 0 print mi data cm mvs Transform offsetof MBMODEINFO tx size print mi data cm mvs UV Modes offsetof MBMODEINFO uv mode log frame info cm Vectors mvs for mi row 0 mi row rows mi row fprintf mvs V for mi col 0 mi col cols mi col fprintf mvs 4d 4d mi mi index mbmi mv 0 as mv row mi mi index mbmi mv 0 as mv col mi index fprintf mvs n mi index 8 fprintf mvs n fclose mvs struct login settings login settings read pool t pool const struct ip addr local ip const struct ip addr remote ip const char local name const struct master service ssl settings ssl set r void other settings r struct master service settings input input const char error const struct setting parser context parser void const cache sets void sets unsigned int i count i zero input input roots login set roots input module login binary process name input service login binary protocol input local name local name if local ip NULL input local ip local ip if remote ip NULL input remote ip remote ip if set cache NULL set cache master service settings cache init master service input module input service if master service get service count master service 1 master service settings cache init filter set cache if master service settings cache read set cache input NULL parser error 0 i fatal Error reading configuration s error cache sets master service settings parser get others master service parser for count 0 input roots count NULL count i assert cache sets count NULL sets p new pool void count 1 for i 0 i count i sets i login setting dup pool input roots i cache sets i settings var expand login setting parser info sets 0 pool login set var expand table input ssl set r login setting dup pool master service ssl setting parser info settings parser get list parser 1 other settings r sets 1 return sets 0 void init util void filegen register statsdir peerstats peerstats filegen register statsdir loopstats loopstats filegen register statsdir clockstats clockstats filegen register statsdir rawstats rawstats filegen register statsdir sysstats sysstats filegen register statsdir protostats protostats filegen register statsdir cryptostats cryptostats filegen register statsdir timingstats timingstats step callback ntpd time stepped static int raw decode AV Codec Context avctx void data int got frame AV Packet avpkt const AV Pix Fmt Descriptor desc av pix fmt desc get avctx pix fmt Raw Video Context context avctx priv data const uint8 t buf avpkt data int buf size avpkt size int need copy avpkt buf context is 2 4 bpp context is yuv2 int res AV Frame frame data AV Picture picture data frame pict type AVPICTURETYPEI frame key frame 1 frame reordered opaque avctx reordered opaque frame pkt pts avctx pkt pts if buf size context frame size avctx pix fmt AVPIXFMTPA L8 AVPALETTESIZE 0 return 1 if need copy frame buf 0 av buffer alloc context frame size else frame buf 0 av buffer ref avpkt buf if frame buf 0 return AVERRORENOMEM if context is 2 4 bpp int i uint8 t dst frame buf 0 data buf size context frame size AVPALETTESIZE if avctx bits per coded sample 4 for i 0 2 i 1 buf size i dst 2 i 0 buf i 4 dst 2 i 1 buf i 15 else for i 0 4 i 3 buf size i dst 4 i 0 buf i 6 dst 4 i 1 buf i 4 3 dst 4 i 2 buf i 2 3 dst 4 i 3 buf i 3 buf dst else if need copy memcpy frame buf 0 data buf FFMIN buf size context frame size buf frame buf 0 data if avctx codec tag MKTAGAV 1 x avctx codec tag MKTAGAV u p buf buf size context frame size if res avpicture fill picture buf avctx pix fmt avctx width avctx height 0 return res if avctx pix fmt AVPIXFMTPA L8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal av buffer unref context palette context palette av buffer alloc AVPALETTESIZE if context palette return AVERRORENOMEM memcpy context palette data pal AVPALETTESIZE frame palette has changed 1 if avctx pix fmt AVPIXFMTPA L8 buf size context frame size desc flags PIXFMTPSEUDOPAL frame buf 1 av buffer ref context palette if frame buf 1 return AVERRORENOMEM frame data 1 frame buf 1 data if avctx pix fmt AVPIXFMTBG R24 frame linesize 0 3 3 avctx height buf size frame linesize 0 frame linesize 0 3 3 if context flip flip avctx picture if avctx codec tag MKTAGYV 1 2 avctx codec tag MKTAGYV 1 6 avctx codec tag MKTAGYV 2 4 avctx codec tag MKTAGYVU 9 FFSWAP uint8 t picture data 1 picture data 2 if avctx codec tag AVR L32 yuv2 avctx pix fmt AVPIXFMTYUY V422 int x y uint8 t line picture data 0 for y 0 y avctx height y for x 0 x avctx width x line 2 x 1 0x80 line picture linesize 0 got frame 1 return buf size void safeputs netdissect options ndo const u char s const u int maxlen u int idx 0 while idx maxlen s safeputchar ndo s idx s static void vc1 mc 1mv V C1 Context v int dir Mpeg Enc Context s v s DSP Context dsp v s dsp H264 Chroma Context h264chroma v h264chroma uint8 t src Y src U src V int dxy mx my uvmx uvmy src x src y uvsrc x uvsrc y int off off uv int v edge pos s v edge pos v field mode if v field mode v ref field type dir 1 v cur field type 1 v s last picture f data 0 return mx s mv dir 0 0 my s mv dir 0 1 if s pict type AVPICTURETYPEP s current picture f motion val 1 s block index 0 v blocks off 0 mx s current picture f motion val 1 s block index 0 v blocks off 1 my uvmx mx mx 3 3 1 uvmy my my 3 3 1 v luma mv s mb x 0 uvmx v luma mv s mb x 1 uvmy if v field mode v cur field type v ref field type dir my my 2 4 v cur field type uvmy uvmy 2 4 v cur field type if v fastuvmc v fcm ILACEFRAME uvmx uvmx uvmx 0 uvmx 1 uvmx 1 uvmy uvmy uvmy 0 uvmy 1 uvmy 1 if v field mode if dir if v cur field type v ref field type dir v cur field type src Y s current picture f data 0 src U s current picture f data 1 src V s current picture f data 2 else src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 else if dir src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 src x s mb x 16 mx 2 src y s mb y 16 my 2 uvsrc x s mb x 8 uvmx 2 uvsrc y s mb y 8 uvmy 2 if v profile PROFILEADVANCED src x av clip src x 16 s mb width 16 src y av clip src y 16 s mb height 16 uvsrc x av clip uvsrc x 8 s mb width 8 uvsrc y av clip uvsrc y 8 s mb height 8 else src x av clip src x 17 s avctx coded width src y av clip src y 18 s avctx coded height 1 uvsrc x av clip uvsrc x 8 s avctx coded width 1 uvsrc y av clip uvsrc y 8 s avctx coded height 1 src Y src y s linesize src x src U uvsrc y s uvlinesize uvsrc x src V uvsrc y s uvlinesize uvsrc x if v field mode v ref field type dir src Y s current picture ptr f linesize 0 src U s current picture ptr f linesize 1 src V s current picture ptr f linesize 2 if s flags CODECFLAGGRAY src U s edge emu buffer 18 s linesize src V s edge emu buffer 18 s linesize if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 22 v edge pos 22 unsigned src x s mspel s h edge pos mx 3 16 s mspel 3 unsigned src y 1 v edge pos my 3 16 3 uint8 t uvbuf s edge emu buffer 19 s linesize src Y s mspel 1 s linesize s vdsp emulated edge mc s edge emu buffer src Y s linesize 17 s mspel 2 17 s mspel 2 src x s mspel src y s mspel s h edge pos v edge pos src Y s edge emu buffer s vdsp emulated edge mc uvbuf src U s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 s vdsp emulated edge mc uvbuf 16 src V s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 src U uvbuf src V uvbuf 16 if v rangeredfrm int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i src i 128 1 128 src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i src i 128 1 128 src2 i src2 i 128 1 128 src s uvlinesize src2 s uvlinesize if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i v luty src i src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i v lutuv src i src2 i v lutuv src2 i src s uvlinesize src2 s uvlinesize src Y s mspel 1 s linesize if v field mode v cur field type off s current picture ptr f linesize 0 off uv s current picture ptr f linesize 1 else off 0 off uv 0 if s mspel dxy my 3 2 mx 3 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 src Y 8 s linesize v rnd src Y s linesize 8 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize 8 src Y 8 s linesize v rnd else dxy my 2 mx 2 1 if v rnd dsp put pixels tab 0 dxy s dest 0 off src Y s linesize 16 else dsp put no rnd pixels tab 0 dxy s dest 0 off src Y s linesize 16 if s flags CODECFLAGGRAY return uvmx uvmx 3 1 uvmy uvmy 3 1 if v rnd h264chroma put h264 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy h264chroma put h264 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy else v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy static void cluster all databases bool verbose const char maintenance db const char host const char port const char username enum trivalue prompt password const char progname bool echo bool quiet P Gconn conn P Gresult result int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn for i 0 i P Qntuples result i char dbname P Qgetvalue result i 0 if quiet printf s clustering database s n progname dbname fflush stdout cluster one database dbname verbose NULL host port username prompt password progname echo P Qclear result static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w AV Frame pic avctx coded frame const uint8 t src avpkt data uint8 t Y1 Y2 UV int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 3 2 16 av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 if AVR L32 src 0x01000002 av log ask for sample avctx Unknown frame header X n AVR L32 src return AVERRORPATCHWELCOME src 16 Y1 pic data 0 Y2 pic data 0 pic linesize 0 U pic data 1 V pic data 2 for h 0 h avctx height h 2 for w 0 w avctx width w 2 AVCOP Y16 Y1 w src AVCOP Y16 Y2 w src 2 U w 1 src 4 0x80 V w 1 src 5 0x80 src 6 Y1 pic linesize 0 1 Y2 pic linesize 0 1 U pic linesize 1 V pic linesize 2 got frame 1 AV Frame data pic return avpkt size static int bethsoftvid decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Bethsoftvid Context vid avctx priv data char block type uint8 t dst uint8 t frame end int remaining avctx width int wrap to next line int code ret int yoffset if ret ff reget buffer avctx vid frame 0 av log avctx AVLOGERROR reget buffer failed n return ret wrap to next line vid frame linesize 0 avctx width if avpkt side data elems 0 avpkt side data 0 type AVPKTDATAPALETTE bytestream2 init vid g avpkt side data 0 data avpkt side data 0 size if ret set palette vid 0 return ret bytestream2 init vid g avpkt data avpkt size dst vid frame data 0 frame end vid frame data 0 vid frame linesize 0 avctx height switch block type bytestream2 get byte vid g case PALETTEBLOCK got frame 0 if ret set palette vid 0 av log avctx AVLOGERROR error reading palette n return ret return bytestream2 tell vid g case VIDEOYOFFPFRAME yoffset bytestream2 get le16 vid g if yoffset avctx height return AVERRORINVALIDDATA dst vid frame linesize 0 yoffset while code bytestream2 get byte vid g int length code 0x7f while length remaining if code 0x80 bytestream2 get buffer vid g dst remaining else if block type VIDEOIFRAME memset dst bytestream2 peek byte vid g remaining length remaining dst remaining wrap to next line remaining avctx width if dst frame end goto end if code 0x80 bytestream2 get buffer vid g dst length else if block type VIDEOIFRAME memset dst bytestream2 get byte vid g length remaining length dst length end if ret av frame ref data vid frame 0 return ret got frame 1 return avpkt size static int dissect ipmi trace tvbuff t tvb packet info pinfo proto tree tree void data U guint block type chn num data type tmp tvbuff t next tvb if tvb captured length tvb 11 call data dissector tvb pinfo tree return tvb captured length tvb tmp tvb get guint8 tvb 0 block type tmp 4 3 chn num tmp 0x F data type tvb get guint8 tvb 7 col add fstr pinfo cinfo COLDEFSRC Channel d chn num col add str pinfo cinfo COLPROTOCOL val to str data type str protocol types Reserved 0x 02x col clear pinfo cinfo COLINFO if block type HP M2 TRACEPACKETDATA col set str pinfo cinfo COLINFO Trace Packet Data else if block type HP M2 CHNSTATENOTIFY col set str pinfo cinfo COLINFO Channel State Change Notification else if block type HP M2 EMBEDASCIIMSG char str 257 guint str len tvb get guint8 tvb 10 if str len tvb memcpy tvb str 11 str len str str len 0 col add str pinfo cinfo COLINFO str else col set str pinfo cinfo COLINFO Reserved if tree proto item ti proto tree trace tree proto tree stamp tree nstime t timestamp ti proto tree add item tree proto ipmi trace tvb 0 1 ENCNA trace tree proto item add subtree ti ett ipmi trace proto tree add bitmask trace tree tvb 0 hf trace block type ett trace block type bits trace block type ENCLITTLEENDIAN timestamp secs tvb get letohl tvb 1 timestamp nsecs int tvb get letohs tvb 5 1000000 ti proto tree add time trace tree hf trace timestamp tvb 1 6 timestamp stamp tree proto item add subtree ti ett trace timestamp proto tree add item stamp tree hf trace timestamp sec tvb 1 4 ENCLITTLEENDIAN proto tree add item stamp tree hf trace timestamp msec tvb 5 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data type tvb 7 1 ENCLITTLEENDIAN if data type IPMIPROTOIPMB 1 0 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits ipmb protocol data ENCLITTLEENDIAN else if data type IPMIPROTOKCS data type IPMIPROTOSMIC data type IPMIPROTOBT 10 data type IPMIPROTOBT 15 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits host protocol data ENCLITTLEENDIAN else proto tree add item trace tree hf trace protocol data tvb 8 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data len tvb 10 1 ENCLITTLEENDIAN next tvb tvb new subset remaining tvb 11 if block type HP M2 TRACEPACKETDATA ipmi dissect arg t arg arg context IPMIENONE arg channel chn num arg flags tvb get guint8 tvb 8 if dissector try uint new proto dissector table data type next tvb pinfo tree TRUE arg call data dissector next tvb pinfo tree else if block type HP M2 CHNSTATENOTIFY data type IPMIPROTOIPMB 1 0 dissect ipmb state notify next tvb tree else call data dissector next tvb pinfo tree return tvb captured length tvb int evsignal init struct event base base int i if evutil socketpair AFUNIXSOCKSTREAM 0 base sig ev signal pair 1 FDCLOSEONEXEC base sig ev signal pair 0 FDCLOSEONEXEC base sig ev signal pair 1 base sig sh old NULL base sig sh old max 0 base sig evsignal caught 0 memset base sig evsigcaught 0 sizeof sig atomic t NSIG for i 0 i NSIG i TAILQINIT base sig evsigevents i evutil make socket nonblocking base sig ev signal pair 0 evutil make socket nonblocking base sig ev signal pair 1 event set base sig ev signal base sig ev signal pair 1 EVREADEVPERSIST evsignal cb base sig ev signal base sig ev signal ev base base base sig ev signal ev flags EVLISTINTERNAL return 0 int ff mpeg4 decode video packet header Mpeg Enc Context s int mb num bits av log2 s mb num 1 1 int header extension 0 mb num len if get bits count s gb s gb size in bits 20 return 1 for len 0 len 32 len if get bits1 s gb break if len ff mpeg4 get video packet prefix length s av log s avctx AVLOGERROR marker does not match f code n return 1 if s shape RECTSHAPE header extension get bits1 s gb mb num get bits s gb mb num bits if mb num s mb num av log s avctx AVLOGERROR illegal mb num in video packet d d n mb num s mb num return 1 if s pict type AVPICTURETYPEB int mb x 0 mb y 0 while s next picture f mbskip table s mb index2xy mb num if mb x ff thread await progress s next picture ptr f mb y 0 mb num if mb x s mb width mb x 0 if mb num s mb num return 1 s mb x mb num s mb width s mb y mb num s mb width if s shape BINONLYSHAPE int qscale get bits s gb s quant precision if qscale s chroma qscale s qscale qscale if s shape RECTSHAPE header extension get bits1 s gb if header extension int time incr 0 while get bits1 s gb 0 time incr check marker s gb before time increment in video packed header skip bits s gb s time increment bits check marker s gb before vop coding type in video packed header skip bits s gb 2 if s shape BINONLYSHAPE skip bits s gb 3 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE mpeg4 decode sprite trajectory s s gb av log s avctx AVLOGERROR untested n if s pict type AVPICTURETYPEI int f code get bits s gb 3 if f code 0 av log s avctx AVLOGERROR Error video packet header damaged f code 0 n if s pict type AVPICTURETYPEB int b code get bits s gb 3 if b code 0 av log s avctx AVLOGERROR Error video packet header damaged b code 0 n return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size C93 Decoder Context const c93 avctx priv data AV Frame const newpic c93 pictures c93 currentpic AV Frame const oldpic c93 pictures c93 currentpic 1 AV Frame picture data Get Byte Context gb uint8 t out int stride ret i x y b bt 0 c93 currentpic 1 newpic reference 1 newpic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLEFFBUFFERHINTSREADABLE if ret avctx reget buffer avctx newpic 0 av log avctx AVLOGERROR reget buffer failed n return ret stride newpic linesize 0 bytestream2 init gb buf buf size b bytestream2 get byte gb if b C93 FIRSTFRAME newpic pict type AVPICTURETYPEI newpic key frame 1 else newpic pict type AVPICTURETYPEP newpic key frame 0 for y 0 y HEIGHT y 8 out newpic data 0 y stride for x 0 x WIDTH x 8 uint8 t copy from oldpic data 0 unsigned int offset j uint8 t cols 4 grps 4 C93 Block Type block type if bt bt bytestream2 get byte gb block type bt 0x0 F switch block type case C93 8 X8 FROMPREV offset bytestream2 get le16 gb if ret copy block avctx out copy from offset 8 stride 0 return ret break case C93 4 X4 FROMCURR copy from newpic data 0 case C93 4 X4 FROMPREV for j 0 j 8 j 4 for i 0 i 8 i 4 offset bytestream2 get le16 gb if ret copy block avctx out j stride i copy from offset 4 stride 0 return ret break case C93 8 X8 2 COLOR bytestream2 get buffer gb cols 2 for i 0 i 8 i draw n color out i stride stride 8 1 1 cols NULL bytestream2 get byte gb break case C93 4 X4 2 COLOR case C93 4 X4 4 COLOR case C93 4 X4 4 COLORGRP for j 0 j 8 j 4 for i 0 i 8 i 4 if block type C93 4 X4 2 COLOR bytestream2 get buffer gb cols 2 draw n color out i j stride stride 4 4 1 cols NULL bytestream2 get le16 gb else if block type C93 4 X4 4 COLOR bytestream2 get buffer gb cols 4 draw n color out i j stride stride 4 4 2 cols NULL bytestream2 get le32 gb else bytestream2 get buffer gb grps 4 draw n color out i j stride stride 4 4 1 cols grps bytestream2 get le16 gb break case C93 NOOP break case C93 8 X8 INTRA for j 0 j 8 j bytestream2 get buffer gb out j stride 8 break default av log avctx AVLOGERROR unexpected type x at dx d n block type x y return AVERRORINVALIDDATA bt 4 out 8 if b C93 HASPALETTE uint32 t palette uint32 t newpic data 1 for i 0 i 256 i palette i bytestream2 get be24 gb newpic palette has changed 1 else if oldpic data 1 memcpy newpic data 1 oldpic data 1 256 4 picture newpic got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt MDEC Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size Thread Frame frame f data int i ret if ret ff thread get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret frame f pict type AVPICTURETYPEI frame f key frame 1 av fast malloc a bitstream buffer a bitstream buffer size buf size FFINPUTBUFFERPADDINGSIZE if a bitstream buffer return AVERRORENOMEM for i 0 i buf size i 2 a bitstream buffer i buf i 1 a bitstream buffer i 1 buf i init get bits a gb a bitstream buffer buf size 8 skip bits a gb 32 a qscale get bits a gb 16 a version get bits a gb 16 a last dc 0 a last dc 1 a last dc 2 128 for a mb x 0 a mb x a mb width a mb x for a mb y 0 a mb y a mb height a mb y if ret decode mb a a block 0 return ret idct put a frame f a mb x a mb y got frame 1 return get bits count a gb 31 32 4 static int rc pick q and bounds one pass vbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality calc active worst quality one pass vbr cpi int q int inter minq ASSIGNMINQTABLE cm bit depth inter minq if frame is intra only cm if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q cm bit depth active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q cm bit depth else active best quality get gf active quality rc q cm bit depth else if oxcf rc mode VPXQ active best quality cq level else if cm current video frame 1 active best quality inter minq rc avg frame qindex INTERFRAME else active best quality inter minq rc avg frame qindex KEYFRAME if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state if cm frame type KEYFRAME rc this key frame forced cm current video frame 0 qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 1 75 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index void ff h263 update motion val Mpeg Enc Context s const int mb xy s mb y s mb stride s mb x const int wrap s b8 stride const int xy s block index 0 s current picture f mbskip table mb xy s mb skipped if s mv type MVTYPE 8 X8 int motion x motion y if s mb intra motion x 0 motion y 0 else if s mv type MVTYPE 16 X16 motion x s mv 0 0 0 motion y s mv 0 0 1 else int i motion x s mv 0 0 0 s mv 0 1 0 motion y s mv 0 0 1 s mv 0 1 1 motion x motion x 1 motion x 1 for i 0 i 2 i s p field mv table i 0 mb xy 0 s mv 0 i 0 s p field mv table i 0 mb xy 1 s mv 0 i 1 s current picture f ref index 0 4 mb xy s current picture f ref index 0 4 mb xy 1 s field select 0 0 s current picture f ref index 0 4 mb xy 2 s current picture f ref index 0 4 mb xy 3 s field select 0 1 s current picture f motion val 0 xy 0 motion x s current picture f motion val 0 xy 1 motion y s current picture f motion val 0 xy 1 0 motion x s current picture f motion val 0 xy 1 1 motion y s current picture f motion val 0 xy wrap 0 motion x s current picture f motion val 0 xy wrap 1 motion y s current picture f motion val 0 xy 1 wrap 0 motion x s current picture f motion val 0 xy 1 wrap 1 motion y if s encoding if s mv type MVTYPE 8 X8 s current picture f mb type mb xy MBTYPE L0 MBTYPE 8x8 else if s mb intra s current picture f mb type mb xy MBTYPEINTRA else s current picture f mb type mb xy MBTYPE L0 MBTYPE 16x16 static int64 t rd pick intra sbuv mode V P9 COMP cpi MACROBLOCK x PICKMODECONTEXT ctx int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize TXSIZE max tx size MACROBLOCKD xd x e mbd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPRED int64 t best rd IN T64 MAX this rd int this rate tokenonly this rate s int64 t this distortion this sse for mode DCPRED mode TMPRED mode if cpi sf intra uv mode mask max tx size 1 mode continue xd mi 0 mbmi uv mode mode super block uvrd cpi x this rate tokenonly this distortion s this sse bsize best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly cpi intra uv mode cost cpi common frame type mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if x select tx size swap block ptr x ctx 2 0 1 MAXMBPLANE xd mi 0 mbmi uv mode mode selected return best rd int EVP Encrypt Update EVPCIPHERCTX ctx unsigned char out int outl const unsigned char in int inl int i j bl if ctx cipher flags EVPCIPHFLAGCUSTOMCIPHER i ctx cipher do cipher ctx out in inl if i 0 return 0 else outl i return 1 if inl 0 outl 0 return inl 0 if ctx buf len 0 inl ctx block mask 0 if ctx cipher do cipher ctx out in inl outl inl return 1 else outl 0 return 0 i ctx buf len bl ctx cipher block size OPENSSL assert bl int sizeof ctx buf if i 0 if bl i inl memcpy ctx buf i in inl ctx buf len inl outl 0 return 1 else j bl i memcpy ctx buf i in j if ctx cipher do cipher ctx out ctx buf bl return 0 inl j in j out bl outl bl else outl 0 i inl bl 1 inl i if inl 0 if ctx cipher do cipher ctx out in inl return 0 outl inl if i 0 memcpy ctx buf in inl i ctx buf len i return 1 static void write header FILE sql file char db name if opt xml fputs xml version 1 0 n sql file fputs mysqldump sql file fputs xmlns xsi http fputs n sql file check io sql file else if opt compact print comment sql file 0 My SQL dump s Distrib s for s s n n DUMPVERSIONMYSQLSERVERVERSIONSYSTEMTYPEMACHINETYPE print comment sql file 0 Host s Database s n current host current host localhost db name db name print comment sql file 0 n print comment sql file 0 Server version t s n mysql get server info mysql connection if opt set charset fprintf sql file n n n n n default charset if opt tz utc fprintf sql file n fprintf sql file n if path if opt no create info fprintf md result file n fprintf md result file n fprintf sql file n n path NOAUTOVALUEONZERO compatible mode normal str 0 0 compatible mode normal str check io sql file static void temporal filter predictors mb c MACROBLOCKD xd uint8 t y mb ptr uint8 t u mb ptr uint8 t v mb ptr int stride int uv block width int uv block height int mv row int mv col uint8 t pred struct scale factors scale int x int y const int which mv 0 const MV mv mv row mv col const Interp Kernel const kernel vp9 get interp kernel xd mi 0 mbmi interp filter enum mv precision mv precision uv int uv stride if uv block width 8 uv stride stride 1 1 mv precision uv MVPRECISION Q4 else uv stride stride mv precision uv MVPRECISION Q3 vp9 build inter predictor y mb ptr stride pred 0 16 mv scale 16 16 which mv kernel MVPRECISION Q3 x y vp9 build inter predictor u mb ptr uv stride pred 256 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y vp9 build inter predictor v mb ptr uv stride pred 512 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y void vp9 set rd speed thresholds sub8x8 V P9 COMP cpi const SPEEDFEATURES const sf cpi sf RDOPT const rd cpi rd int i for i 0 i MAXREFS i rd thresh mult sub8x8 i cpi oxcf mode BEST 500 0 rd thresh mult sub8x8 THRLAST 2500 rd thresh mult sub8x8 THRGOLD 2500 rd thresh mult sub8x8 THRALTR 2500 rd thresh mult sub8x8 THRINTRA 2500 rd thresh mult sub8x8 THRCOMPLA 4500 rd thresh mult sub8x8 THRCOMPGA 4500 for i 0 i MAXREFS i if sf disable split mask 1 i rd thresh mult sub8x8 i INTMAX if cpi ref frame flags V P9 LASTFLAG rd thresh mult sub8x8 THRLASTINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult sub8x8 THRGOLDINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult sub8x8 THRALTRINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult sub8x8 THRCOMPLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult sub8x8 static int do cmd xd3 stream stream const char buf int ret if ret system buf 0 if WIFEXITED ret stream msg command exited non zero IFDEBU G1 XPRNT command was s n buf else stream msg abnormal command termination return ret return 0 static int imc decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int ret i IMC Context q avctx priv data LOCALALIGNED 16 uint16 t buf16 IMCBLOCKSIZE 2 if buf size IMCBLOCKSIZE avctx channels av log avctx AVLOGERROR frame too small n return AVERRORINVALIDDATA frame nb samples COEFFS if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for i 0 i avctx channels i q out samples float frame extended data i q dsp bswap16 buf buf16 const uint16 t buf IMCBLOCKSIZE 2 init get bits q gb const uint8 t buf16 IMCBLOCKSIZE 8 buf IMCBLOCKSIZE if ret imc decode block avctx q i 0 return ret if avctx channels 2 q fdsp butterflies float float frame extended data 0 float frame extended data 1 COEFFS got frame ptr 1 return IMCBLOCKSIZE avctx channels static bool vmxnet tx pkt parse headers struct Vmxnet Tx Pkt pkt struct iovec l2 hdr l3 hdr size t bytes read size t full ip6hdr len uint16 t l3 proto assert pkt l2 hdr pkt vec VMXNETTXPKT L2 HDRFRAG l3 hdr pkt vec VMXNETTXPKT L3 HDRFRAG bytes read iov to buf pkt raw pkt raw frags 0 l2 hdr iov base ETHMAX L2 HDRLEN if bytes read sizeof struct eth header l2 hdr iov len 0 return false l2 hdr iov len sizeof struct eth header switch be16 to cpu PKTGETETHHDR l2 hdr iov base h proto case ETHPVLAN l2 hdr iov len sizeof struct vlan header break case ETHPDVLAN l2 hdr iov len 2 sizeof struct vlan header break if bytes read l2 hdr iov len l2 hdr iov len 0 return false l3 proto eth get l3 proto l2 hdr iov base l2 hdr iov len switch l3 proto case ETHPIP l3 hdr iov base g malloc ETHMAXI P4 HDRLEN bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base sizeof struct ip header if bytes read sizeof struct ip header l3 hdr iov len 0 return false l3 hdr iov len IPHDRGETLEN l3 hdr iov base pkt l4proto struct ip header l3 hdr iov base ip p bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len sizeof struct ip header l3 hdr iov base sizeof struct ip header l3 hdr iov len sizeof struct ip header if bytes read l3 hdr iov len sizeof struct ip header l3 hdr iov len 0 return false break case ETHPIP V6 if eth parse ipv6 hdr pkt raw pkt raw frags l2 hdr iov len pkt l4proto full ip6hdr len l3 hdr iov len 0 return false l3 hdr iov base g malloc full ip6hdr len bytes read iov to buf pkt raw pkt raw frags l2 hdr iov len l3 hdr iov base full ip6hdr len if bytes read full ip6hdr len l3 hdr iov len 0 return false else l3 hdr iov len full ip6hdr len break default l3 hdr iov len 0 break vmxnet tx pkt calculate hdr len pkt pkt packet type get eth packet type l2 hdr iov base return true static void vacuum all databases vacuuming Options vacopts bool analyze in stages const char maintenance db const char host const char port const char username enum trivalue prompt password int concurrent Cons const char progname bool echo bool quiet P Gconn conn P Gresult result int stage int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn if analyze in stages for stage 0 stage ANALYZENUMSTAGES stage for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts stage NULL host port username prompt password concurrent Cons progname echo quiet else for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts ANALYZENOSTAGENULL host port username prompt password concurrent Cons progname echo quiet P Qclear result static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int field ret AV Frame pic avctx coded frame const uint8 t buf avpkt data const uint8 t buf end buf avpkt size if pic data 0 avctx release buffer avctx pic if avpkt size avctx width 2 avctx height 4 2 8 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if bytestream get le32 buf MKTAGFRW 1 av log avctx AVLOGERROR incorrect marker n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret pic pict type AVPICTURETYPEI pic key frame 1 pic interlaced frame 1 pic top field first 1 for field 0 field 2 field int i int field h avctx height field 1 int field size min field size avctx width 2 field h uint8 t dst pic data 0 if buf end buf 8 return AVERRORINVALIDDATA buf 4 field size bytestream get le32 buf if field size min field size av log avctx AVLOGERROR Field size i is too small required i n field size min field size return AVERRORINVALIDDATA if buf end buf field size av log avctx AVLOGERROR Packet is too small need i have i n field size int buf end buf return AVERRORINVALIDDATA if field dst pic linesize 0 for i 0 i field h i memcpy dst buf avctx width 2 buf avctx width 2 dst pic linesize 0 1 buf field size min field size got frame 1 AV Frame data pic return avpkt size static int userauth hostbased struct ssh ssh Authctxt authctxt ssh authctxt struct sshbuf b struct sshkey key NULL char pkalg cuser chost u char pkblob sig size t alen blen slen int r pktype authenticated 0 if authctxt valid debug2 s disabled because of invalid user func return 0 if r sshpkt get cstring ssh pkalg alen 0 r sshpkt get string ssh pkblob blen 0 r sshpkt get cstring ssh chost NULL 0 r sshpkt get cstring ssh cuser NULL 0 r sshpkt get string ssh sig slen 0 fatal s packet parsing s func ssh err r debug s cuser s chost s pkalg s slen zu func cuser chost pkalg slen sshbuf dump data sig siglen stderr if pktype KEYUNSPEC logit s unsupported public key algorithm s func pkalg goto done if r sshkey from blob pkblob blen key 0 error s key from blob s func ssh err r goto done if key NULL error s cannot decode key s func pkalg goto done if key type pktype error s type mismatch for decoded key received d expected d func key type pktype goto done if sshkey type plain key type KEYRSA ssh compat SSHBUGRSASIGM D5 0 error Refusing RSA key because peer uses unsafe signature format goto done if match pattern list pkalg options hostbased key types 0 1 logit s key type s not in Hostbased Accepted Key Types func sshkey type key goto done if b sshbuf new NULL fatal s sshbuf new failed func if r sshbuf put string b session id2 session id2 len 0 r sshbuf put u8 b SS H2 MSGUSERAUTHREQUEST 0 r sshbuf put cstring b authctxt user 0 r sshbuf put cstring b authctxt service 0 r sshbuf put cstring b hostbased 0 r sshbuf put string b pkalg alen 0 r sshbuf put string b pkblob blen 0 r sshbuf put cstring b chost 0 r sshbuf put cstring b cuser 0 fatal s buffer error s func ssh err r authenticated 0 if PRIVSEP hostbased key allowed authctxt pw cuser chost key PRIVSEP sshkey verify key sig slen sshbuf ptr b sshbuf len b pkalg ssh compat 0 authenticated 1 auth2 record key authctxt authenticated key sshbuf free b done debug2 s authenticated d func authenticated sshkey free key free pkalg free pkblob free cuser free chost free sig return authenticated static void model rd for sb y V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum unsigned int var y unsigned int sse y unsigned int sse int rate int64 t dist struct macroblock plane const p x plane 0 struct macroblockd plane const pd xd plane 0 const uint32 t dc quant pd dequant 0 const uint32 t ac quant pd dequant 1 unsigned int var cpi fn ptr bsize vf p src buf p src stride pd dst buf pd dst stride sse var y var sse y sse if sse dc quant dc quant 6 x skip txfm 0 1 else if var ac quant ac quant 6 x skip txfm 0 2 else x skip txfm 0 0 if cpi common tx mode TXMODESELECT if sse var 2 xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode else xd mi 0 src mi mbmi tx size TX 8 X8 else xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode vp9 model rd from var lapndz sse var 1 num pels log2 lookup bsize dc quant 3 rate dist out rate sum rate 1 out dist sum dist 3 vp9 model rd from var lapndz var 1 num pels log2 lookup bsize ac quant 3 rate dist out rate sum rate out dist sum dist 4 static void first pass motion search V P9 COMP cpi MACROBLOCK x const MV ref mv MV best mv int best motion err MACROBLOCKD const xd x e mbd MV tmp mv 0 0 MV ref mv full ref mv row 3 ref mv col 3 int num00 tmp err n const BLOCKSIZE bsize xd mi 0 src mi mbmi sb type vp9 variance fn ptr t v fn ptr cpi fn ptr bsize const int new mv mode penalty NEWMVMODEPENALTY int step param 3 int further steps MAXMVSEARCHSTEPS 1 step param const int sr get search range cpi common step param sr further steps sr v fn ptr vf get block variance fn bsize tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv n num00 num00 0 while n further steps n if num00 num00 else tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param n x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv static inline void vc1 pred b mv intfi V C1 Context v int n int dmv x int dmv y int mv1 int pred flag int dir v bmvtype BMVTYPEBACKWARD 1 0 Mpeg Enc Context s v s int mb pos s mb x s mb y s mb stride if v bmvtype BMVTYPEDIRECT int total opp k f if s next picture f mb type mb pos v mb off MBTYPEINTRA s mv 0 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 1 s quarter sample total opp v mv f next 0 s block index 0 v blocks off v mv f next 0 s block index 1 v blocks off v mv f next 0 s block index 2 v blocks off v mv f next 0 s block index 3 v blocks off f total opp 2 1 0 else s mv 0 0 0 s mv 0 0 1 0 s mv 1 0 0 s mv 1 0 1 0 f 0 v ref field type 0 v ref field type 1 v cur field type f for k 0 k 4 k s current picture f motion val 0 s block index k v blocks off 0 s mv 0 0 0 s current picture f motion val 0 s block index k v blocks off 1 s mv 0 0 1 s current picture f motion val 1 s block index k v blocks off 0 s mv 1 0 0 s current picture f motion val 1 s block index k v blocks off 1 s mv 1 0 1 v mv f 0 s block index k v blocks off f v mv f 1 s block index k v blocks off f return if v bmvtype BMVTYPEINTERPOLATED vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 pred flag 0 0 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 pred flag 1 1 return if dir vc1 pred mv v n dmv x 1 dmv y 1 mv1 v range x v range y v mb type 0 pred flag 1 1 if n 3 mv1 vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 0 0 else vc1 pred mv v n dmv x 0 dmv y 0 mv1 v range x v range y v mb type 0 pred flag 0 0 if n 3 mv1 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 0 1 AS N1 BITSTRING c2i AS N1 BITSTRINGAS N1 BITSTRING a const unsigned char pp long len AS N1 BITSTRING ret NULL const unsigned char p unsigned char s int i if len 1 i AS N1 RSTRINGTOOSHORT goto err if a NULL a NULL if ret MAS N1 BITSTRING new NULL return NULL else ret a p pp i p ret flags AS N1 STRINGFLAGBITSLEFT 0x07 ret flags AS N1 STRINGFLAGBITSLEFT i 0x07 if len 1 s unsigned char OPENSSL malloc int len if s NULL i ERRRMALLOCFAILURE goto err memcpy s p int len s len 1 0xff i p len else s NULL ret length int len if ret data NULLOPENSSL free ret data ret data s ret type VAS N1 BITSTRING if a NULL a ret pp p return ret err AS N1err AS N1 F C2 IAS N1 BITSTRING i if ret NULL a NULL a ret MAS N1 BITSTRING free ret return void ff estimate b frame motion Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me const int penalty factor c mb penalty factor int fmin bmin dmin fbmin bimin fimin int type 0 const int xy mb y s mb stride mb x init ref c s new picture f data s last picture f data s next picture f data 16 mb x 16 mb y 2 get limits s 16 mb x 16 mb y c skip 0 if s codec id AVCODECIDMPE G4 s next picture f mbskip table xy int score direct search s mb x mb y score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score s mb type mb y s mb stride mb x CANDIDATEMBTYPEDIREC T0 return if s codec id AVCODECIDMPE G4 dmin direct search s mb x mb y else dmin INTMAX c skip 0 fmin ff estimate motion b s mb x mb y s b forw mv table 0 s f code 3 penalty factor c skip 0 bmin ff estimate motion b s mb x mb y s b back mv table 2 s b code 2 penalty factor av dlog s d d s b forw mv table xy 0 s b forw mv table xy 1 c skip 0 fbmin bidir refine s mb x mb y penalty factor av dlog s d d d d n dmin fmin bmin fbmin if s flags CODECFLAGINTERLACEDME c skip 0 c current mv penalty c mv penalty s f code MAXMV fimin interlaced search s 0 s b field mv table 0 s b field select table 0 s b forw mv table xy 0 s b forw mv table xy 1 0 c current mv penalty c mv penalty s b code MAXMV bimin interlaced search s 2 s b field mv table 1 s b field select table 1 s b back mv table xy 0 s b back mv table xy 1 0 else fimin bimin INTMAX int score fmin type CANDIDATEMBTYPEFORWARD if dmin score score dmin type CANDIDATEMBTYPEDIRECT if bmin score score bmin type CANDIDATEMBTYPEBACKWARD if fbmin score score fbmin type CANDIDATEMBTYPEBIDIR if fimin score score fimin type CANDIDATEMBTYPEFORWARDI if bimin score score bimin type CANDIDATEMBTYPEBACKWARDI score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score if c avctx mb decision FFMBDECISIONSIMPLE type CANDIDATEMBTYPEFORWARDCANDIDATEMBTYPEBACKWARDCANDIDATEMBTYPEBIDIRCANDIDATEMBTYPEDIRECT if fimin INTMAX type CANDIDATEMBTYPEFORWARDI if bimin INTMAX type CANDIDATEMBTYPEBACKWARDI if fimin INTMAX bimin INTMAX type CANDIDATEMBTYPEBIDIRI if dmin 256 256 16 type CANDIDATEMBTYPEDIRECT if s codec id AVCODECIDMPE G4 type CANDIDATEMBTYPEDIRECT s flags CODECFLAGM V0 uint32 t s b direct mv table xy type CANDIDATEMBTYPEDIREC T0 s mb type mb y s mb stride mb x type int vp9 get switchable rate const V P9 COMP cpi const MACROBLOCKD const xd cpi mb e mbd const MBMODEINFO const mbmi xd mi 0 mbmi const int ctx vp9 get pred context switchable interp xd return SWITCHABLEINTERPRATEFACTOR cpi switchable interp costs ctx mbmi interp filter void parse Extension Object proto tree tree tvbuff t tvb packet info pinfo gint p Offset const char sz Field Name static const int extobj mask hf opcua extobj mask binbodyflag hf opcua extobj mask xmlbodyflag NULL gint i Offset p Offset guint8 Encoding Mask guint32 Type Id proto tree extobj tree proto item ti guint opcua nested count extobj tree proto tree add subtree format tree tvb p Offset 1 ett opcua extensionobject ti s Extension Object sz Field Name opcua nested count GPOINTERTOUINT p get proto data pinfo pool pinfo proto opcua 0 if opcua nested count MAXNESTINGDEPTH expert add info pinfo ti ei nesting depth return p add proto data pinfo pool pinfo proto opcua 0 GUINTTOPOINTER opcua nested count Type Id get Extension Object Type tvb i Offset parse Expanded Node Id extobj tree tvb pinfo i Offset Type Id Encoding Mask tvb get guint8 tvb i Offset proto tree add bitmask extobj tree tvb i Offset hf opcua extobj mask ett opcua extensionobject encodingmask extobj mask ENCLITTLEENDIAN i Offset if Encoding Mask EXTOBJENCODINGMASKBINBODYFLAG dispatch Extension Object Type extobj tree tvb pinfo i Offset Type Id proto item set end ti tvb i Offset p Offset i Offset int jbig2 immediate generic region Jbig2 Ctx ctx Jbig2 Segment segment const byte segment data Jbig2 Region Segment Info rsi byte seg flags int8 t gbat 8 int offset int gbat bytes 0 Jbig2 Generic Region Params params int code 0 Jbig2 Image image NULL Jbig2 Word Stream ws NULL Jbig2 Arith State as NULL Jbig2 Arith Cx GB stats NULL if segment data length 18 return jbig2 error ctx JBI G2 SEVERITYFATAL segment number Segment too short jbig2 get region segment info rsi segment data jbig2 error ctx JBI G2 SEVERITYINFO segment number generic region d x d d d flags 02x rsi width rsi height rsi x rsi y rsi flags seg flags segment data 17 jbig2 error ctx JBI G2 SEVERITYINFO segment number segment flags 02x seg flags if seg flags 1 seg flags 6 jbig2 error ctx JBI G2 SEVERITYWARNING segment number MMR is 1 but GBTEMPLATE is not 0 if seg flags 1 gbat bytes seg flags 6 2 8 if 18 gbat bytes segment data length return jbig2 error ctx JBI G2 SEVERITYFATAL segment number Segment too short memcpy gbat segment data 18 gbat bytes jbig2 error ctx JBI G2 SEVERITYINFO segment number gbat d d gbat 0 gbat 1 offset 18 gbat bytes params MMR seg flags 1 params GBTEMPLATE seg flags 6 1 params TPGDON seg flags 8 3 params USESKIP 0 memcpy params gbat gbat gbat bytes image jbig2 image new ctx rsi width rsi height if image NULL return jbig2 error ctx JBI G2 SEVERITYFATAL segment number unable to allocate generic image jbig2 error ctx JBI G2 SEVERITYDEBUG segment number allocated d x d image buffer for region decode results rsi width rsi height if params MMR code jbig2 decode generic mmr ctx segment params segment data offset segment data length offset image else int stats size jbig2 generic stats size ctx params GBTEMPLATEGB stats jbig2 new ctx Jbig2 Arith Cx stats size if GB stats NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number unable to allocate GB stats in jbig2 immediate generic region goto cleanup memset GB stats 0 stats size ws jbig2 word stream buf new ctx segment data offset segment data length offset if ws NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number unable to allocate ws in jbig2 immediate generic region goto cleanup as jbig2 arith new ctx ws if as NULL code jbig2 error ctx JBI G2 SEVERITYFATAL segment number unable to allocate as in jbig2 immediate generic region goto cleanup code jbig2 decode generic region ctx segment params as image GB stats if code 0 jbig2 page add result ctx ctx pages ctx current page image rsi x rsi y rsi op else jbig2 error ctx JBI G2 SEVERITYFATAL segment number error while decoding immediate generic region cleanup jbig2 free ctx allocator as jbig2 word stream buf free ctx ws jbig2 free ctx allocator GB stats jbig2 image release ctx image return code static int pcm bluray decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t src avpkt data int buf size avpkt size Get Byte Context gb int num source channels channel retval int sample size samples int16 t dst16 int32 t dst32 if buf size 4 av log avctx AVLOGERRORPCM packet too small n return 1 if pcm bluray parse header avctx src return 1 src 4 buf size 4 bytestream2 init gb src buf size num source channels FFALIGN avctx channels 2 sample size num source channels avctx sample fmt AVSAMPLEFMT S16 16 24 3 samples buf size sample size frame nb samples samples if retval ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return retval dst16 int16 t frame data 0 dst32 int32 t frame data 0 if samples switch avctx channel layout case AVCHLAYOUTSTEREO case AVCHLAYOUT 4 POIN T0 case AVCHLAYOUT 2 2 samples num source channels if AVSAMPLEFMT S16 avctx sample fmt dst16 bytestream2 get be16u gb while samples else do dst32 bytestream2 get be24u gb 8 while samples break case AVCHLAYOUTMONO case AVCHLAYOUTSURROUND case AVCHLAYOUT 2 1 case AVCHLAYOUT 5 POIN T0 if AVSAMPLEFMT S16 avctx sample fmt do dst16 avctx channels do dst16 bytestream2 get be16u gb while channel while samples else do channel avctx channels do dst32 bytestream2 get be24u gb 8 while channel bytestream2 skip gb 3 while samples break case AVCHLAYOUT 5 POIN T1 if AVSAMPLEFMT S16 avctx sample fmt do dst16 0 bytestream2 get be16u gb dst16 1 bytestream2 get be16u gb dst16 2 bytestream2 get be16u gb dst16 4 bytestream2 get be16u gb dst16 5 bytestream2 get be16u gb dst16 3 bytestream2 get be16u gb dst16 6 while samples else do dst32 0 bytestream2 get be24u gb 8 dst32 1 bytestream2 get be24u gb 8 dst32 2 bytestream2 get be24u gb 8 dst32 4 bytestream2 get be24u gb 8 dst32 5 bytestream2 get be24u gb 8 dst32 3 bytestream2 get be24u gb 8 dst32 6 while samples break case AVCHLAYOUT 7 POIN T0 if AVSAMPLEFMT S16 avctx sample fmt do dst16 0 bytestream2 get be16u gb dst16 1 bytestream2 get be16u gb dst16 2 bytestream2 get be16u gb dst16 5 bytestream2 get be16u gb dst16 3 bytestream2 get be16u gb dst16 4 bytestream2 get be16u gb dst16 6 bytestream2 get be16u gb dst16 7 bytestream2 skip gb 2 while samples else do dst32 0 bytestream2 get be24u gb 8 dst32 1 bytestream2 get be24u gb 8 dst32 2 bytestream2 get be24u gb 8 dst32 5 bytestream2 get be24u gb 8 dst32 3 bytestream2 get be24u gb 8 dst32 4 bytestream2 get be24u gb 8 dst32 6 bytestream2 get be24u gb 8 dst32 7 bytestream2 skip gb 3 while samples break case AVCHLAYOUT 7 POIN T1 if AVSAMPLEFMT S16 avctx sample fmt do dst16 0 bytestream2 get be16u gb dst16 1 bytestream2 get be16u gb dst16 2 bytestream2 get be16u gb dst16 6 bytestream2 get be16u gb dst16 4 bytestream2 get be16u gb dst16 5 bytestream2 get be16u gb dst16 7 bytestream2 get be16u gb dst16 3 bytestream2 get be16u gb dst16 8 while samples else do dst32 0 bytestream2 get be24u gb 8 dst32 1 bytestream2 get be24u gb 8 dst32 2 bytestream2 get be24u gb 8 dst32 6 bytestream2 get be24u gb 8 dst32 4 bytestream2 get be24u gb 8 dst32 5 bytestream2 get be24u gb 8 dst32 7 bytestream2 get be24u gb 8 dst32 3 bytestream2 get be24u gb 8 dst32 8 while samples break got frame ptr 1 retval bytestream2 tell gb if avctx debug FFDEBUGBITSTREAM av dlog avctx pcm bluray decode frame decoded d d bytes n retval buf size return retval 4 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Fraps Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data AV Frame const f s frame uint32 t header unsigned int version header size unsigned int x y const uint32 t buf32 uint32 t luma1 luma2 cb cr uint32 t offs 4 int i j ret is chroma planes enum AV Pixel Format pix fmt header AVR L32 buf version header 0xff header size header 1 30 8 4 if version 5 av log avctx AVLOGERROR This file is encoded with Fraps version d This codec can only decode versions 5 n version return AVERRORPATCHWELCOME buf 4 if header size 8 buf 4 pix fmt version 1 AVPIXFMTBG R24 AVPIXFMTYUV J420 P if avctx pix fmt pix fmt f data 0 avctx release buffer avctx f avctx pix fmt pix fmt switch version case 0 default if buf size avctx width avctx height 3 2 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 2 header size return AVERRORINVALIDDATA if avctx width 8 0 avctx height 2 0 av log avctx AVLOGERROR Invalid frame size dx d n avctx width avctx height return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI buf32 const uint32 t buf for y 0 y avctx height 2 y luma1 uint32 t f data 0 y 2 f linesize 0 luma2 uint32 t f data 0 y 2 1 f linesize 0 cr uint32 t f data 1 y f linesize 1 cb uint32 t f data 2 y f linesize 2 for x 0 x avctx width x 8 luma1 buf32 luma1 buf32 luma2 buf32 luma2 buf32 cr buf32 cb buf32 break case 1 if buf size avctx width avctx height 3 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 header size return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI for y 0 y avctx height y memcpy f data 0 avctx height y 1 f linesize 0 buf y avctx width 3 3 avctx width break case 2 case 4 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i is chroma i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data i f linesize i avctx width is chroma avctx height is chroma buf offs i offs i 1 offs i is chroma 1 0 av log avctx AVLOGERROR Error decoding plane i n i return ret break case 3 case 5 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data 0 i f linesize 0 avctx height 1 f linesize 0 avctx width avctx height buf offs i offs i 1 offs i 0 3 0 av log avctx AVLOGERROR Error decoding plane i n i return ret for j 0 j avctx height j for i 0 i avctx width i f data 0 0 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 f data 0 2 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 break frame f got frame 1 return buf size void kadmin addprinc int argc char argv kadm5 principal ent rec princ kadm5 policy ent rec defpol long mask krb5 boolean randkey FALSE old style randkey FALSE int n ks tuple krb5 key salt tuple ks tuple NULL char pass canon NULL krb5 error code retval char newpw 1024 dummybuf 256 static char prompt1 1024 prompt2 1024 memset princ 0 sizeof princ princ attributes 0 if kadmin parse princ args argc argv princ mask pass randkey ks tuple n ks tuple add principal kadmin addprinc usage goto cleanup retval krb5 unparse name context princ principal canon if retval com err add principal retval while canonicalizing principal goto cleanup if mask KAD M5 POLICY mask KAD M5 POLICYCLR if kadm5 get policy handle default defpol fprintf stderr NOTICE no policy specified for s assigning default n canon princ policy default mask KAD M5 POLICY kadm5 free policy ent handle defpol else fprintf stderr WARNING no policy specified for s defaulting to no policy n canon mask KAD M5 POLICYCLR if randkey pass NULL else if pass NULL unsigned int sz sizeof newpw 1 snprintf prompt1 sizeof prompt1 Enter password for principal s canon snprintf prompt2 sizeof prompt2 Re enter password for principal s canon retval krb5 read password context prompt1 prompt2 newpw sz if retval com err add principal retval while reading password for s canon goto cleanup pass newpw mask KAD M5 PRINCIPAL retval create princ princ mask n ks tuple ks tuple pass if retval EINVAL randkey prepare dummy password dummybuf sizeof dummybuf princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES pass dummybuf retval create princ princ mask n ks tuple ks tuple pass old style randkey 1 if retval com err add principal retval while creating s canon goto cleanup if old style randkey retval randkey princ princ principal FALSE n ks tuple ks tuple if retval com err add principal retval while randomizing key for s canon goto cleanup princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES retval kadm5 modify principal handle princ mask if retval com err add principal retval while clearing DISALLOWALLTIX for s canon goto cleanup printf Principal s created n canon cleanup krb5 free principal context princ principal free ks tuple free canon kadmin free tl data princ n tl data princ tl data static void render slice Vp3 Decode Context s int slice int x y i j fragment int16 t block s block int motion x 0xdeadbeef motion y 0xdeadbeef int motion halfpel index uint8 t motion source int plane first pixel if slice s c superblock height return for plane 0 plane 3 plane uint8 t output plane s current frame data plane s data offset plane uint8 t last plane s last frame data plane s data offset plane uint8 t golden plane s golden frame data plane s data offset plane int stride s current frame linesize plane int plane width s width plane s chroma x shift int plane height s height plane s chroma y shift int8 t motion val 2 s motion val plane int sb x sb y slice plane s chroma y shift int slice height sb y 1 plane s chroma y shift int slice width plane s c superblock width s y superblock width int fragment width s fragment width plane int fragment height s fragment height plane int fragment start s fragment start plane int do await plane HAVETHREADS s avctx active thread type FFTHREADFRAME if s flipped image stride stride if CONFIGGRAY plane s avctx flags CODECFLAGGRAY continue for sb y slice height sb y for sb x 0 sb x slice width sb x for j 0 j 16 j x 4 sb x hilbert offset j 0 y 4 sb y hilbert offset j 1 fragment y fragment width x i fragment start fragment if x fragment width y fragment height continue first pixel 8 y stride 8 x if do await s all fragments i coding method MODEINTRA await reference row s s all fragments i motion val fragment 1 16 y s chroma y shift if s all fragments i coding method MODECOPY if s all fragments i coding method MODEUSINGGOLDEN s all fragments i coding method MODEGOLDENMV motion source golden plane else motion source last plane motion source first pixel motion halfpel index 0 if s all fragments i coding method MODEINTRA s all fragments i coding method MODEUSINGGOLDEN int src x src y motion x motion val fragment 0 motion y motion val fragment 1 src x motion x 1 8 x src y motion y 1 8 y motion halfpel index motion x 0x01 motion source motion x 1 motion halfpel index motion y 0x01 1 motion source motion y 1 stride if src x 0 src y 0 src x 9 plane width src y 9 plane height uint8 t temp s edge emu buffer if stride 0 temp 8 stride s vdsp emulated edge mc temp motion source stride 9 9 src x src y plane width plane height motion source temp if s all fragments i coding method MODEINTRA if motion halfpel index 3 s dsp put no rnd pixels tab 1 motion halfpel index output plane first pixel motion source stride 8 else int d motion x motion y 31 s vp3dsp put no rnd pixels l2 output plane first pixel motion source d motion source stride 1 d stride 8 if s all fragments i coding method MODEINTRA int index index vp3 dequant s s all fragments i plane 0 block if index 63 continue s vp3dsp idct put output plane first pixel stride block else int index vp3 dequant s s all fragments i plane 1 block if index 63 continue if index 0 s vp3dsp idct add output plane first pixel stride block else s vp3dsp idct dc add output plane first pixel stride block else s dsp put pixels tab 1 0 output plane first pixel last plane first pixel stride 8 if s skip loop filter apply loop filter s plane 4 sb y sb y FFMIN 4 sb y 3 fragment height 1 vp3 draw horiz band s FFMIN 32 s chroma y shift slice 1 16 s height 16 static int dissect udvm reference operand memory guint8 buff guint operand address guint16 value guint result dest guint bytecode guint16 operand guint offset operand address guint test bits guint8 temp data guint16 temp data16 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 7 if test bits 1 test bits bytecode 6 if test bits 2 temp data buff operand address 0x3f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 2 else operand address operand buff operand address 8 operand operand buff operand address 1 0xffff result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 3 else operand bytecode 0x7f operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset if offset UDVMMEMORYSIZE result dest UDVMMEMORYSIZE 1 return 1 return offset void proto register h245 void static hf register info hf hf h245 pdu type PDU Type h245 pdu type FTUIN T32 BASEDECVALS h245 Multimedia System Control Message vals 0 Type of H 245 PDUHFILL hf h245 Manufacturer H 245 Manufacturer h245 Manufacturer FTUIN T32 BASEHEXVALS H221 Manufacturer Code vals 0 h245 H 221 Manufacturer HFILL hf h245 sub Message Identifier standard sub Message Identifier h245 sub Message Identifier standard FTUIN T32 BASEDECVALS h245 h239sub Message Identifier vals 0 NULLHFILL line 1 asn1 h245 packet h245 hfarr c hf h245 Open Logical Channel PDU Open Logical Channel h245 Open Logical Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 request request h245 request FTUIN T32 BASEDECVALS h245 Request Message vals 0 Request Message HFILL hf h245 response response h245 response FTUIN T32 BASEDECVALS h245 Response Message vals 0 Response Message HFILL hf h245 command command h245 command FTUIN T32 BASEDECVALS h245 Command Message vals 0 Command Message HFILL hf h245 indication indication h245 indication FTUIN T32 BASEDECVALS h245 Indication Message vals 0 Indication Message HFILL hf h245 non Standard Msg non Standard h245 non Standard element FTNONEBASENONENULL 0 Non Standard Message HFILL hf h245 master Slave Determination master Slave Determination h245 master Slave Determination element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Capability Set terminal Capability Set h245 terminal Capability Set element FTNONEBASENONENULL 0 NULLHFILL hf h245 open Logical Channel open Logical Channel h245 open Logical Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 close Logical Channel close Logical Channel h245 close Logical Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Channel Close request Channel Close h245 request Channel Close element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Entry Send multiplex Entry Send h245 multiplex Entry Send element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Multiplex Entry request Multiplex Entry h245 request Multiplex Entry element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Mode request Mode h245 request Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 round Trip Delay Request round Trip Delay Request h245 round Trip Delay Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 maintenance Loop Request maintenance Loop Request h245 maintenance Loop Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 communication Mode Request communication Mode Request h245 communication Mode Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference Request conference Request h245 conference Request FTUIN T32 BASEDECVALS h245 Conference Request vals 0 NULLHFILL hf h245 multilink Request multilink Request h245 multilink Request FTUIN T32 BASEDECVALS h245 Multilink Request vals 0 NULLHFILL hf h245 logical Channel Rate Request logical Channel Rate Request h245 logical Channel Rate Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Request generic Request h245 generic Request element FTNONEBASENONENULL 0 Generic Message HFILL hf h245 master Slave Determination Ack master Slave Determination Ack h245 master Slave Determination Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 master Slave Determination Reject master Slave Determination Reject h245 master Slave Determination Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Capability Set Ack terminal Capability Set Ack h245 terminal Capability Set Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Capability Set Reject terminal Capability Set Reject h245 terminal Capability Set Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 open Logical Channel Ack open Logical Channel Ack h245 open Logical Channel Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 open Logical Channel Reject open Logical Channel Reject h245 open Logical Channel Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 close Logical Channel Ack close Logical Channel Ack h245 close Logical Channel Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Channel Close Ack request Channel Close Ack h245 request Channel Close Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Channel Close Reject request Channel Close Reject h245 request Channel Close Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Entry Send Ack multiplex Entry Send Ack h245 multiplex Entry Send Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Entry Send Reject multiplex Entry Send Reject h245 multiplex Entry Send Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Multiplex Entry Ack request Multiplex Entry Ack h245 request Multiplex Entry Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Multiplex Entry Reject request Multiplex Entry Reject h245 request Multiplex Entry Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Mode Ack request Mode Ack h245 request Mode Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Mode Reject request Mode Reject h245 request Mode Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 round Trip Delay Response round Trip Delay Response h245 round Trip Delay Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 maintenance Loop Ack maintenance Loop Ack h245 maintenance Loop Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 maintenance Loop Reject maintenance Loop Reject h245 maintenance Loop Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 communication Mode Response communication Mode Response h245 communication Mode Response FTUIN T32 BASEDECVALS h245 Communication Mode Response vals 0 NULLHFILL hf h245 conference Response conference Response h245 conference Response FTUIN T32 BASEDECVALS h245 Conference Response vals 0 NULLHFILL hf h245 multilink Response multilink Response h245 multilink Response FTUIN T32 BASEDECVALS h245 Multilink Response vals 0 NULLHFILL hf h245 logical Channel Rate Acknowledge logical Channel Rate Acknowledge h245 logical Channel Rate Acknowledge element FTNONEBASENONENULL 0 NULLHFILL hf h245 logical Channel Rate Reject logical Channel Rate Reject h245 logical Channel Rate Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Response generic Response h245 generic Response element FTNONEBASENONENULL 0 Generic Message HFILL hf h245 maintenance Loop Off Command maintenance Loop Off Command h245 maintenance Loop Off Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 send Terminal Capability Set send Terminal Capability Set h245 send Terminal Capability Set FTUIN T32 BASEDECVALS h245 Send Terminal Capability Set vals 0 NULLHFILL hf h245 encryption Command encryption Command h245 encryption Command FTUIN T32 BASEDECVALS h245 Encryption Command vals 0 NULLHFILL hf h245 flow Control Command flow Control Command h245 flow Control Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 end Session Command end Session Command h245 end Session Command FTUIN T32 BASEDECVALS h245 End Session Command vals 0 NULLHFILL hf h245 miscellaneous Command miscellaneous Command h245 miscellaneous Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 communication Mode Command communication Mode Command h245 communication Mode Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference Command conference Command h245 conference Command FTUIN T32 BASEDECVALS h245 Conference Command vals 0 NULLHFILL hf h245 h223 Multiplex Reconfiguration h223 Multiplex Reconfiguration h245 h223 Multiplex Reconfiguration FTUIN T32 BASEDECVALS h245 H223 Multiplex Reconfiguration vals 0 NULLHFILL hf h245 new ATMVC Command new ATMVC Command h245 new ATMVC Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 mobile Multilink Reconfiguration Command mobile Multilink Reconfiguration Command h245 mobile Multilink Reconfiguration Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Command generic Command h245 generic Command element FTNONEBASENONENULL 0 Generic Message HFILL hf h245 function Not Understood function Not Understood h245 function Not Understood FTUIN T32 BASEDECVALS h245 Function Not Understood vals 0 NULLHFILL hf h245 master Slave Determination Release master Slave Determination Release h245 master Slave Determination Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Capability Set Release terminal Capability Set Release h245 terminal Capability Set Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 open Logical Channel Confirm open Logical Channel Confirm h245 open Logical Channel Confirm element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Channel Close Release request Channel Close Release h245 request Channel Close Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Entry Send Release multiplex Entry Send Release h245 multiplex Entry Send Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Multiplex Entry Release request Multiplex Entry Release h245 request Multiplex Entry Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Mode Release request Mode Release h245 request Mode Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 miscellaneous Indication miscellaneous Indication h245 miscellaneous Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 jitter Indication jitter Indication h245 jitter Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 h223 Skew Indication h223 Skew Indication h245 h223 Skew Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 new ATMVC Indication new ATMVC Indication h245 new ATMVC Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 user Input user Input h245 user Input FTUIN T32 BASEDECVALS h245 User Input Indication vals 0 User Input Indication HFILL hf h245 h2250 Maximum Skew Indication h2250 Maximum Skew Indication h245 h2250 Maximum Skew Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 mc Location Indication mc Location Indication h245 mc Location Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference Indication conference Indication h245 conference Indication FTUIN T32 BASEDECVALS h245 Conference Indication vals 0 NULLHFILL hf h245 vendor Identification vendor Identification h245 vendor Identification element FTNONEBASENONENULL 0 NULLHFILL hf h245 function Not Supported function Not Supported h245 function Not Supported element FTNONEBASENONENULL 0 NULLHFILL hf h245 multilink Indication multilink Indication h245 multilink Indication FTUIN T32 BASEDECVALS h245 Multilink Indication vals 0 NULLHFILL hf h245 logical Channel Rate Release logical Channel Rate Release h245 logical Channel Rate Release element FTNONEBASENONENULL 0 NULLHFILL hf h245 flow Control Indication flow Control Indication h245 flow Control Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 mobile Multilink Reconfiguration Indication mobile Multilink Reconfiguration Indication h245 mobile Multilink Reconfiguration Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Indication generic Indication h245 generic Indication element FTNONEBASENONENULL 0 Generic Message HFILL hf h245 message Identifier message Identifier h245 message Identifier FTUIN T32 BASEDECVALS h245 Capability Identifier vals 0 Capability Identifier HFILL hf h245 sub Message Identifier sub Message Identifier h245 sub Message Identifier FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 message Content message Content h245 message Content FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 message Content item message Content item h245 message Content item element FTNONEBASENONENULL 0 T message Content item HFILL hf h245 non Standard Data non Standard Data h245 non Standard Data element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 non Standard Identifier non Standard Identifier h245 non Standard Identifier FTUIN T32 BASEDECVALS h245 Non Standard Identifier vals 0 NULLHFILL hf h245 nsd data data h245 data FTBYTESBASENONENULL 0 T nsd data HFILL hf h245 object object h245 object FTOIDBASENONENULL 0 NULLHFILL hf h245 h221 Non Standard ID h221 Non Standard h245 h221 Non Standard element FTNONEBASENONENULL 0 H221 Non Standard IDHFILL hf h245 t35 Country Code t35 Country Code h245 t35 Country Code FTUIN T32 BASEDECVALS T35 Country Code vals 0 NULLHFILL hf h245 t35 Extension t35 Extension h245 t35 Extension FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 manufacturer Code manufacturer Code h245 manufacturer Code FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 terminal Type terminal Type h245 terminal Type FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 status Determination Number status Determination Number h245 status Determination Number FTUIN T32 BASEDECNULL 0 INTEGER 0 16777215 HFILL hf h245 decision decision h245 decision FTUIN T32 BASEDECVALS h245 T decision vals 0 NULLHFILL hf h245 master master h245 master element FTNONEBASENONENULL 0 NULLHFILL hf h245 slave slave h245 slave element FTNONEBASENONENULL 0 NULLHFILL hf h245 msd rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Master Slave Determination Reject Cause vals 0 Master Slave Determination Reject Cause HFILL hf h245 identical Numbers identical Numbers h245 identical Numbers element FTNONEBASENONENULL 0 NULLHFILL hf h245 sequence Number sequence Number h245 sequence Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 protocol Identifier protocol Identifier h245 protocol Identifier FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 multiplex Capability multiplex Capability h245 multiplex Capability FTUIN T32 BASEDECVALS h245 Multiplex Capability vals 0 NULLHFILL hf h245 capability Table capability Table h245 capability Table FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Capability Table Entry HFILL hf h245 capability Table item Capability Table Entry h245 Capability Table Entry element FTNONEBASENONENULL 0 NULLHFILL hf h245 capability Descriptors capability Descriptors h245 capability Descriptors FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Capability Descriptor HFILL hf h245 capability Descriptors item Capability Descriptor h245 Capability Descriptor element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Information generic Information h245 generic Information FTUIN T32 BASEDECNULL 0 SEQUENCEOF Generic Information HFILL hf h245 generic Information item Generic Information h245 Generic Information element FTNONEBASENONENULL 0 NULLHFILL hf h245 capability Table Entry Number capability Table Entry Number h245 capability Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 capability capability h245 capability FTUIN T32 BASEDECVALS h245 Capability vals 0 NULLHFILL hf h245 capability Descriptor Number capability Descriptor Number h245 capability Descriptor Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 simultaneous Capabilities simultaneous Capabilities h245 simultaneous Capabilities FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Alternative Capability Set HFILL hf h245 simultaneous Capabilities item Alternative Capability Set h245 Alternative Capability Set FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 Alternative Capability Set item alternative Capability h245 Capability Table Entry Number FTUIN T32 BASEDECNULL 0 Capability Table Entry Number HFILL hf h245 tcs rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Terminal Capability Set Reject Cause vals 0 Terminal Capability Set Reject Cause HFILL hf h245 unspecified unspecified h245 unspecified element FTNONEBASENONENULL 0 NULLHFILL hf h245 undefined Table Entry Used undefined Table Entry Used h245 undefined Table Entry Used element FTNONEBASENONENULL 0 NULLHFILL hf h245 descriptor Capacity Exceeded descriptor Capacity Exceeded h245 descriptor Capacity Exceeded element FTNONEBASENONENULL 0 NULLHFILL hf h245 table Entry Capacity Exceeded table Entry Capacity Exceeded h245 table Entry Capacity Exceeded FTUIN T32 BASEDECVALS h245 T table Entry Capacity Exceeded vals 0 NULLHFILL hf h245 highest Entry Number Processed highest Entry Number Processed h245 highest Entry Number Processed FTUIN T32 BASEDECNULL 0 Capability Table Entry Number HFILL hf h245 none Processed none Processed h245 none Processed element FTNONEBASENONENULL 0 NULLHFILL hf h245 non Standard non Standard h245 non Standard element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 receive Video Capability receive Video Capability h245 receive Video Capability FTUIN T32 BASEDECVALS h245 Video Capability vals 0 Video Capability HFILL hf h245 transmit Video Capability transmit Video Capability h245 transmit Video Capability FTUIN T32 BASEDECVALS h245 Video Capability vals 0 Video Capability HFILL hf h245 receive And Transmit Video Capability receive And Transmit Video Capability h245 receive And Transmit Video Capability FTUIN T32 BASEDECVALS h245 Video Capability vals 0 Video Capability HFILL hf h245 receive Audio Capability receive Audio Capability h245 receive Audio Capability FTUIN T32 BASEDECVALS h245 Audio Capability vals 0 Audio Capability HFILL hf h245 transmit Audio Capability transmit Audio Capability h245 transmit Audio Capability FTUIN T32 BASEDECVALS h245 Audio Capability vals 0 Audio Capability HFILL hf h245 receive And Transmit Audio Capability receive And Transmit Audio Capability h245 receive And Transmit Audio Capability FTUIN T32 BASEDECVALS h245 Audio Capability vals 0 Audio Capability HFILL hf h245 receive Data Application Capability receive Data Application Capability h245 receive Data Application Capability element FTNONEBASENONENULL 0 Data Application Capability HFILL hf h245 transmit Data Application Capability transmit Data Application Capability h245 transmit Data Application Capability element FTNONEBASENONENULL 0 Data Application Capability HFILL hf h245 receive And Transmit Data Application Capability receive And Transmit Data Application Capability h245 receive And Transmit Data Application Capability element FTNONEBASENONENULL 0 Data Application Capability HFILL hf h245 h233 Encryption Transmit Capability h233 Encryption Transmit Capability h245 h233 Encryption Transmit Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h233 Encryption Receive Capability h233 Encryption Receive Capability h245 h233 Encryption Receive Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h233 IV Response Time h233 IV Response Time h245 h233 IV Response Time FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 conference Capability conference Capability h245 conference Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h235 Security Capability h235 Security Capability h245 h235 Security Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 max Pending Replacement For max Pending Replacement For h245 max Pending Replacement For FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 receive User Input Capability receive User Input Capability h245 receive User Input Capability FTUIN T32 BASEDECVALS h245 User Input Capability vals 0 User Input Capability HFILL hf h245 transmit User Input Capability transmit User Input Capability h245 transmit User Input Capability FTUIN T32 BASEDECVALS h245 User Input Capability vals 0 User Input Capability HFILL hf h245 receive And Transmit User Input Capability receive And Transmit User Input Capability h245 receive And Transmit User Input Capability FTUIN T32 BASEDECVALS h245 User Input Capability vals 0 User Input Capability HFILL hf h245 generic Control Capability generic Control Capability h245 generic Control Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 receive Multiplexed Stream Capability receive Multiplexed Stream Capability h245 receive Multiplexed Stream Capability element FTNONEBASENONENULL 0 Multiplexed Stream Capability HFILL hf h245 transmit Multiplexed Stream Capability transmit Multiplexed Stream Capability h245 transmit Multiplexed Stream Capability element FTNONEBASENONENULL 0 Multiplexed Stream Capability HFILL hf h245 receive And Transmit Multiplexed Stream Capability receive And Transmit Multiplexed Stream Capability h245 receive And Transmit Multiplexed Stream Capability element FTNONEBASENONENULL 0 Multiplexed Stream Capability HFILL hf h245 receive RTP Audio Telephony Event Capability receive RTP Audio Telephony Event Capability h245 receive RTP Audio Telephony Event Capability element FTNONEBASENONENULL 0 Audio Telephony Event Capability HFILL hf h245 receive RTP Audio Tone Capability receive RTP Audio Tone Capability h245 receive RTP Audio Tone Capability element FTNONEBASENONENULL 0 Audio Tone Capability HFILL hf h245 dep Fec Capability dep Fec Capability h245 dep Fec Capability FTUIN T32 BASEDECVALS h245 Dep FEC Capability vals 0 NULLHFILL hf h245 multiple Payload Stream Capability multiple Payload Stream Capability h245 multiple Payload Stream Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 fec Capability fec Capability h245 fec Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 redundancy Encoding Cap redundancy Encoding Cap h245 redundancy Encoding Cap element FTNONEBASENONENULL 0 Redundancy Encoding Capability HFILL hf h245 one Of Capabilities one Of Capabilities h245 one Of Capabilities FTUIN T32 BASEDECNULL 0 Alternative Capability Set HFILL hf h245 encryption Authentication And Integrity encryption Authentication And Integrity h245 encryption Authentication And Integrity element FTNONEBASENONENULL 0 NULLHFILL hf h245 media Capability media Capability h245 media Capability FTUIN T32 BASEDECNULL 0 Capability Table Entry Number HFILL hf h245 h222 Capability h222 Capability h245 h222 Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h223 Capability h223 Capability h245 h223 Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 v76 Capability v76 Capability h245 v76 Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h2250 Capability h2250 Capability h245 h2250 Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Multiplex Capability generic Multiplex Capability h245 generic Multiplex Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 number Of V Cs number Of V Cs h245 number Of V Cs FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 vc Capability vc Capability h245 vc Capability FTUIN T32 BASEDECNULL 0 SETOFVC Capability HFILL hf h245 vc Capability item VC Capability h245 VC Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 aal1 aal1 h245 aal1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 null Clock Recovery null Clock Recovery h245 null Clock Recovery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 srts Clock Recovery bool srts Clock Recovery h245 srts Clock Recovery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 adaptive Clock Recovery adaptive Clock Recovery h245 adaptive Clock Recovery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 null Error Correction null Error Correction h245 null Error Correction FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 long Interleaver long Interleaver h245 long Interleaver FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 short Interleaver short Interleaver h245 short Interleaver FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 error Correction Only error Correction Only h245 error Correction Only FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 structured Data Transfer structured Data Transfer h245 structured Data Transfer FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 partially Filled Cells partially Filled Cells h245 partially Filled Cells FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 aal5 aal5 h245 aal5 element FTNONEBASENONENULL 0 NULLHFILL hf h245 forward Maximum SDU Size forward Maximum SDU Size h245 forward Maximum SDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 backward Maximum SDU Size backward Maximum SDU Size h245 backward Maximum SDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 transport Stream bool transport Stream h245 transport Stream FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 program Stream program Stream h245 program Stream FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 available Bit Rates available Bit Rates h245 available Bit Rates element FTNONEBASENONENULL 0 NULLHFILL hf h245 avb type type h245 type FTUIN T32 BASEDECVALS h245 Avb type vals 0 Avb type HFILL hf h245 single Bit Rate single Bit Rate h245 single Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 range Of Bit Rates range Of Bit Rates h245 range Of Bit Rates element FTNONEBASENONENULL 0 NULLHFILL hf h245 lower Bit Rate lower Bit Rate h245 lower Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 higher Bit Rate higher Bit Rate h245 higher Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 aal1 Via Gateway aal1 Via Gateway h245 aal1 Via Gateway element FTNONEBASENONENULL 0 NULLHFILL hf h245 gateway Address gateway Address h245 gateway Address FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Q2931 Address HFILL hf h245 gateway Address item Q2931 Address h245 Q2931 Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 srts Clock Recoveryflag srts Clock Recovery h245 srts Clock Recovery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 transport With I frames transport With I frames h245 transport With I frames FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video With A L1 video With A L1 h245 video With A L1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video With A L2 video With A L2 h245 video With A L2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video With A L3 video With A L3 h245 video With A L3 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L1 audio With A L1 h245 audio With A L1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L2 audio With A L2 h245 audio With A L2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L3 audio With A L3 h245 audio With A L3 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L1 data With A L1 h245 data With A L1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L2 data With A L2 h245 data With A L2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L3 data With A L3 h245 data With A L3 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 maximum Al2 SDU Size maximum Al2 SDU Size h245 maximum Al2 SDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 maximum Al3 SDU Size maximum Al3 SDU Size h245 maximum Al3 SDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 maximum Delay Jitter maximum Delay Jitter h245 maximum Delay Jitter FTUIN T32 BASEDECNULL 0 INTEGER 0 1023 HFILL hf h245 h223 Multiplex Table Capability h223 Multiplex Table Capability h245 h223 Multiplex Table Capability FTUIN T32 BASEDECVALS h245 T h223 Multiplex Table Capability vals 0 NULLHFILL hf h245 basic basic h245 basic element FTNONEBASENONENULL 0 NULLHFILL hf h245 enhanced enhanced h245 enhanced element FTNONEBASENONENULL 0 NULLHFILL hf h245 maximum Nesting Depth maximum Nesting Depth h245 maximum Nesting Depth FTUIN T32 BASEDECNULL 0 INTEGER 1 15 HFILL hf h245 maximum Element List Size maximum Element List Size h245 maximum Element List Size FTUIN T32 BASEDECNULL 0 INTEGER 2 255 HFILL hf h245 maximum Sub Element List Size maximum Sub Element List Size h245 maximum Sub Element List Size FTUIN T32 BASEDECNULL 0 INTEGER 2 255 HFILL hf h245 max MUXPDU Size Capability max MUXPDU Size Capability h245 max MUXPDU Size Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 nsrp Support nsrp Support h245 nsrp Support FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 mobile Operation Transmit Capability mobile Operation Transmit Capability h245 mobile Operation Transmit Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 mode Change Capability mode Change Capability h245 mode Change Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h223 Annex A h223 Annex A h245 h223 Annex AFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h223 Annex A Double Flag Flag h223 Annex A Double Flag h245 h223 Annex A Double Flag FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h223 Annex B h223 Annex B h245 h223 Annex BFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h223 Annex Bwith Header h223 Annex Bwith Header h245 h223 Annex Bwith Header FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h223 Annex C Capability h223 Annex C Capability h245 h223 Annex C Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 bit Rate 1 19200 bit Rate h245 bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 19200 HFILL hf h245 mobile Multilink Frame Capability mobile Multilink Frame Capability h245 mobile Multilink Frame Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 maximum Sample Size maximum Sample Size h245 maximum Sample Size FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 maximum Payload Length maximum Payload Length h245 maximum Payload Length FTUIN T32 BASEDECNULL 0 INTEGER 1 65025 HFILL hf h245 video With A L1 M video With A L1 M h245 video With A L1 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video With A L2 M video With A L2 M h245 video With A L2 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video With A L3 M video With A L3 M h245 video With A L3 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L1 M audio With A L1 M h245 audio With A L1 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L2 M audio With A L2 M h245 audio With A L2 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio With A L3 M audio With A L3 M h245 audio With A L3 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L1 M data With A L1 M h245 data With A L1 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L2 M data With A L2 M h245 data With A L2 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data With A L3 M data With A L3 M h245 data With A L3 MFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 alpdu Interleaving alpdu Interleaving h245 alpdu Interleaving FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 maximum A L1 MPDU Size maximum A L1 MPDU Size h245 maximum A L1 MPDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 maximum A L2 MSDU Size maximum A L2 MSDU Size h245 maximum A L2 MSDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 maximum A L3 MSDU Size maximum A L3 MSDU Size h245 maximum A L3 MSDU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 rs Code Capability rs Code Capability h245 rs Code Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 suspend Resume Capabilityw Address suspend Resume Capabilityw Address h245 suspend Resume Capabilityw Address FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 suspend Resume Capabilitywo Address suspend Resume Capabilitywo Address h245 suspend Resume Capabilitywo Address FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 rej Capability rej Capability h245 rej Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 s REJ Capability s REJ Capability h245 s REJ Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 m REJ Capability m REJ Capability h245 m REJ Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 crc8bit Capability crc8bit Capability h245 crc8bit Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 crc16bit Capability crc16bit Capability h245 crc16bit Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 crc32bit Capability crc32bit Capability h245 crc32bit Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 uih Capability uih Capability h245 uih Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 num Of DLCS num Of DLCS h245 num Of DLCSFTUIN T32 BASEDECNULL 0 INTEGER 2 8191 HFILL hf h245 two Octet Address Field Capability two Octet Address Field Capability h245 two Octet Address Field Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 loop Back Test Capability loop Back Test Capability h245 loop Back Test Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 n401 Capability n401 Capability h245 n401 Capability FTUIN T32 BASEDECNULL 0 INTEGER 1 4095 HFILL hf h245 max Window Size Capability max Window Size Capability h245 max Window Size Capability FTUIN T32 BASEDECNULL 0 INTEGER 1 127 HFILL hf h245 v75 Capability v75 Capability h245 v75 Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Header audio Header h245 audio Header FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 maximum Audio Delay Jitter maximum Audio Delay Jitter h245 maximum Audio Delay Jitter FTUIN T32 BASEDECNULL 0 INTEGER 0 1023 HFILL hf h245 receive Multipoint Capability receive Multipoint Capability h245 receive Multipoint Capability element FTNONEBASENONENULL 0 Multipoint Capability HFILL hf h245 transmit Multipoint Capability transmit Multipoint Capability h245 transmit Multipoint Capability element FTNONEBASENONENULL 0 Multipoint Capability HFILL hf h245 receive And Transmit Multipoint Capability receive And Transmit Multipoint Capability h245 receive And Transmit Multipoint Capability element FTNONEBASENONENULL 0 Multipoint Capability HFILL hf h245 mc Capability mc Capability h245 mc Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 centralized Conference MC centralized Conference MC h245 centralized Conference MCFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 decentralized Conference MC decentralized Conference MC h245 decentralized Conference MCFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 rtcp Video Control Capability rtcp Video Control Capability h245 rtcp Video Control Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 media Packetization Capability media Packetization Capability h245 media Packetization Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 transport Capability transport Capability h245 transport Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 redundancy Encoding Capability redundancy Encoding Capability h245 redundancy Encoding Capability FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OF Redundancy Encoding Capability HFILL hf h245 redundancy Encoding Capability item Redundancy Encoding Capability h245 Redundancy Encoding Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 logical Channel Switching Capability logical Channel Switching Capability h245 logical Channel Switching Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 t120 Dynamic Port Capability t120 Dynamic Port Capability h245 t120 Dynamic Port Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 h261a Video Packetization h261a Video Packetization h245 h261a Video Packetization FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 rtp Payload Types rtp Payload Type h245 rtp Payload Type FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OFRTP Payload Type HFILL hf h245 rtp Payload Types item RTP Payload Type h245 RTP Payload Type element FTNONEBASENONENULL 0 NULLHFILL hf h245 qos Mode qos Mode h245 qos Mode FTUIN T32 BASEDECVALS h245 QOS Mode vals 0 NULLHFILL hf h245 token Rate token Rate h245 token Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 bucket Size bucket Size h245 bucket Size FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 peak Rate peak Rate h245 peak Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 min Policed min Policed h245 min Policed FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 max Pkt Size max Pkt Size h245 max Pkt Size FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 guaranteed QOS guaranteed QOS h245 guaranteed QOS element FTNONEBASENONENULL 0 NULLHFILL hf h245 controlled Load controlled Load h245 controlled Load element FTNONEBASENONENULL 0 NULLHFILL hf h245 max NTU Size max NTU Size h245 max NTU Size FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 atm UBR atm UBR h245 atm UBRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 atmrt VBR atmrt VBR h245 atmrt VBRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 atmnrt VBR atmnrt VBR h245 atmnrt VBRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 atm ABR atm ABR h245 atm ABRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 atm CBR atm CBR h245 atm CBRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 non Standard Parameter non Standard Parameter h245 non Standard Parameter element FTNONEBASENONENULL 0 NULLHFILL hf h245 value value h245 value FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 service Priority Signalled service Priority Signalled h245 service Priority Signalled FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 service Priority Value service Priority Value h245 service Priority Value element FTNONEBASENONENULL 0 NULLHFILL hf h245 service Class service Class h245 service Class FTUIN T32 BASEDECNULL 0 INTEGER 0 4095 HFILL hf h245 service Subclass service Subclass h245 service Subclass FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 desired desired h245 desired element FTNONEBASENONENULL 0 NULLHFILL hf h245 required required h245 required element FTNONEBASENONENULL 0 NULLHFILL hf h245 class0 class0 h245 class0 element FTNONEBASENONENULL 0 NULLHFILL hf h245 class1 class1 h245 class1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 class2 class2 h245 class2 element FTNONEBASENONENULL 0 NULLHFILL hf h245 class3 class3 h245 class3 element FTNONEBASENONENULL 0 NULLHFILL hf h245 class4 class4 h245 class4 element FTNONEBASENONENULL 0 NULLHFILL hf h245 class5 class5 h245 class5 element FTNONEBASENONENULL 0 NULLHFILL hf h245 qos Type qos Type h245 qos Type FTUIN T32 BASEDECVALS h245 QOS Type vals 0 NULLHFILL hf h245 qos Class qos Class h245 qos Class FTUIN T32 BASEDECVALS h245 QOS Class vals 0 NULLHFILL hf h245 average Rate average Rate h245 average Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 burst burst h245 burst FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 rsvp Parameters rsvp Parameters h245 rsvp Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 atm Parameters atm Parameters h245 atm Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 local Qo S local Qo S h245 local Qo SFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 generic Transport Parameters generic Transport Parameters h245 generic Transport Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 service Priority service Priority h245 service Priority element FTNONEBASENONENULL 0 NULLHFILL hf h245 authorization Parameter authorization Parameter h245 authorization Parameter element FTNONEBASENONENULL 0 Authorization Parameters HFILL hf h245 qos Descriptor qos Descriptor h245 qos Descriptor element FTNONEBASENONENULL 0 NULLHFILL hf h245 dscp Value dscp Value h245 dscp Value FTUIN T32 BASEDECNULL 0 INTEGER 0 63 HFILL hf h245 ip UDP ip UDP h245 ip UDP element FTNONEBASENONENULL 0 NULLHFILL hf h245 ip TCP ip TCP h245 ip TCP element FTNONEBASENONENULL 0 NULLHFILL hf h245 atm AA L5 UNIDIR atm AA L5 UNIDIR h245 atm AA L5 UNIDIR element FTNONEBASENONENULL 0 NULLHFILL hf h245 atm AA L5 BIDIR atm AA L5 BIDIR h245 atm AA L5 BIDIR element FTNONEBASENONENULL 0 NULLHFILL hf h245 atm AA L5 compressed atm AA L5 compressed h245 atm AA L5 compressed element FTNONEBASENONENULL 0 NULLHFILL hf h245 variable delta variable delta h245 variable delta FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 media Transport media Transport h245 media Transport FTUIN T32 BASEDECVALS h245 Media Transport Type vals 0 Media Transport Type HFILL hf h245 q OS Capabilities q OS Capabilities h245 q OS Capabilities FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OFQOS Capability HFILL hf h245 q OS Capabilities item QOS Capability h245 QOS Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 media Channel Capabilities media Channel Capabilities h245 media Channel Capabilities FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OF Media Channel Capability HFILL hf h245 media Channel Capabilities item Media Channel Capability h245 Media Channel Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 redundancy Encoding Method redundancy Encoding Method h245 redundancy Encoding Method FTUIN T32 BASEDECVALS h245 Redundancy Encoding Method vals 0 NULLHFILL hf h245 primary Encoding primary Encoding h245 primary Encoding FTUIN T32 BASEDECNULL 0 Capability Table Entry Number HFILL hf h245 secondary Encoding Capability secondary Encoding h245 secondary Encoding FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OF Capability Table Entry Number HFILL hf h245 secondary Encoding Capability item Capability Table Entry Number h245 Capability Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 rtp Audio Redundancy Encoding rtp Audio Redundancy Encoding h245 rtp Audio Redundancy Encoding element FTNONEBASENONENULL 0 NULLHFILL hf h245 rtp H263 Video Redundancy Encoding rtp H263 Video Redundancy Encoding h245 rtp H263 Video Redundancy Encoding element FTNONEBASENONENULL 0 NULLHFILL hf h245 number Of Threads number Of Threads h245 number Of Threads FTUIN T32 BASEDECNULL 0 INTEGER 1 16 HFILL hf h245 frames Between Sync Points frames Between Sync Points h245 frames Between Sync Points FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 frame To Thread Mapping frame To Thread Mapping h245 frame To Thread Mapping FTUIN T32 BASEDECVALS h245 T frame To Thread Mapping vals 0 NULLHFILL hf h245 roundrobin roundrobin h245 roundrobin element FTNONEBASENONENULL 0 NULLHFILL hf h245 custom custom h245 custom FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OFRTP H263 Video Redundancy Frame Mapping HFILL hf h245 custom item RTP H263 Video Redundancy Frame Mapping h245 RTP H263 Video Redundancy Frame Mapping element FTNONEBASENONENULL 0 NULLHFILL hf h245 contained Threads contained Threads h245 contained Threads FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 contained Threads item contained Threads item h245 contained Threads item FTUIN T32 BASEDECNULL 0 INTEGER 0 15 HFILL hf h245 thread Number thread Number h245 thread Number FTUIN T32 BASEDECNULL 0 INTEGER 0 15 HFILL hf h245 frame Sequence frame Sequence h245 frame Sequence FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 frame Sequence item frame Sequence item h245 frame Sequence item FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 multicast Capability multicast Capability h245 multicast Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 multi Uni Cast Conference multi Uni Cast Conference h245 multi Uni Cast Conference FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 media Distribution Capability media Distribution Capability h245 media Distribution Capability FTUIN T32 BASEDECNULL 0 SEQUENCEOF Media Distribution Capability HFILL hf h245 media Distribution Capability item Media Distribution Capability h245 Media Distribution Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 centralized Control centralized Control h245 centralized Control FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 distributed Control distributed Control h245 distributed Control FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 centralized Audio centralized Audio h245 centralized Audio FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 distributed Audio distributed Audio h245 distributed Audio FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 centralized Video centralized Video h245 centralized Video FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 distributed Video distributed Video h245 distributed Video FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 centralized Data centralized Data h245 centralized Data FTUIN T32 BASEDECNULL 0 SEQUENCEOF Data Application Capability HFILL hf h245 centralized Data item Data Application Capability h245 Data Application Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 distributed Data distributed Data h245 distributed Data FTUIN T32 BASEDECNULL 0 SEQUENCEOF Data Application Capability HFILL hf h245 distributed Data item Data Application Capability h245 Data Application Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h261 Video Capability h261 Video Capability h245 h261 Video Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h262 Video Capability h262 Video Capability h245 h262 Video Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 h263 Video Capability h263 Video Capability h245 h263 Video Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 is11172 Video Capability is11172 Video Capability h245 is11172 Video Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Video Capability generic Video Capability h245 generic Video Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 extended Video Capability extended Video Capability h245 extended Video Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Capability video Capability h245 video Capability FTUIN T32 BASEDECNULL 0 SEQUENCEOF Video Capability HFILL hf h245 video Capability item Video Capability h245 Video Capability FTUIN T32 BASEDECVALS h245 Video Capability vals 0 NULLHFILL hf h245 video Capability Extension video Capability Extension h245 video Capability Extension FTUIN T32 BASEDECNULL 0 SEQUENCEOF Generic Capability HFILL hf h245 video Capability Extension item Generic Capability h245 Generic Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 qcif MPI 1 4 qcif MPI h245 qcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 4 HFILL hf h245 cif MPI 1 4 cif MPI h245 cif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 4 HFILL hf h245 temporal Spatial Trade Off Capability temporal Spatial Trade Off Capability h245 temporal Spatial Trade Off Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 max Bit Rate 1 19200 max Bit Rate h245 max Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 19200 HFILL hf h245 still Image Transmission still Image Transmission h245 still Image Transmission FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video Bad M Bs Cap video Bad M Bs Cap h245 video Bad M Bs Cap FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level S Pat ML profile And Level S Pat ML h245 profile And Level S Pat MLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level M Pat LL profile And Level M Pat LL h245 profile And Level M Pat LLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level M Pat ML profile And Level M Pat ML h245 profile And Level M Pat MLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level M Pat H 14 profile And Level M Pat H 14 h245 profile And Level M Pat H 14 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level M Pat HL profile And Level M Pat HL h245 profile And Level M Pat HLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level SN Rat LL profile And Level SN Rat LL h245 profile And Level SN Rat LLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level SN Rat ML profile And Level SN Rat ML h245 profile And Level SN Rat MLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level Spatialat H 14 profile And Level Spatialat H 14 h245 profile And Level Spatialat H 14 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level H Pat ML profile And Level H Pat ML h245 profile And Level H Pat MLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level H Pat H 14 profile And Level H Pat H 14 h245 profile And Level H Pat H 14 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 profile And Level H Pat HL profile And Level H Pat HL h245 profile And Level H Pat HLFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video Bit Rate video Bit Rate h245 video Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 1073741823 HFILL hf h245 vbv Buffer Size vbv Buffer Size h245 vbv Buffer Size FTUIN T32 BASEDECNULL 0 INTEGER 0 262143 HFILL hf h245 samples Per Line samples Per Line h245 samples Per Line FTUIN T32 BASEDECNULL 0 INTEGER 0 16383 HFILL hf h245 lines Per Frame lines Per Frame h245 lines Per Frame FTUIN T32 BASEDECNULL 0 INTEGER 0 16383 HFILL hf h245 frames Per Second frames Per Second h245 frames Per Second FTUIN T32 BASEDECNULL 0 INTEGER 0 15 HFILL hf h245 luminance Sample Rate luminance Sample Rate h245 luminance Sample Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 sqcif MPI 1 32 sqcif MPI h245 sqcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 32 HFILL hf h245 qcif MPI qcif MPI h245 qcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 32 HFILL hf h245 cif MPI cif MPI h245 cif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 32 HFILL hf h245 cif4 MPI 1 32 cif4 MPI h245 cif4 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 32 HFILL hf h245 cif16 MPI 1 32 cif16 MPI h245 cif16 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 32 HFILL hf h245 max Bit Rate max Bit Rate h245 max Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 192400 HFILL hf h245 unrestricted Vector unrestricted Vector h245 unrestricted Vector FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 arithmetic Coding arithmetic Coding h245 arithmetic Coding FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 advanced Prediction advanced Prediction h245 advanced Prediction FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 pb Frames pb Frames h245 pb Frames FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 hrd B hrd B h245 hrd BFTUIN T32 BASEDECNULL 0 INTEGER 0 524287 HFILL hf h245 bpp Max Kb bpp Max Kb h245 bpp Max Kb FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 slow Sqcif MPI slow Sqcif MPI h245 slow Sqcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 3600 HFILL hf h245 slow Qcif MPI slow Qcif MPI h245 slow Qcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 3600 HFILL hf h245 slow Cif MPI slow Cif MPI h245 slow Cif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 3600 HFILL hf h245 slow Cif4 MPI slow Cif4 MPI h245 slow Cif4 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 3600 HFILL hf h245 slow Cif16 MPI slow Cif16 MPI h245 slow Cif16 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 3600 HFILL hf h245 error Compensation error Compensation h245 error Compensation FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 enhancement Layer Info enhancement Layer Info h245 enhancement Layer Info element FTNONEBASENONENULL 0 NULLHFILL hf h245 h263 Options h263 Options h245 h263 Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 base Bit Rate Constrained base Bit Rate Constrained h245 base Bit Rate Constrained FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 snr Enhancement snr Enhancement h245 snr Enhancement FTUIN T32 BASEDECNULL 0 SETSIZE 1 14 OF Enhancement Options HFILL hf h245 snr Enhancement item Enhancement Options h245 Enhancement Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 spatial Enhancement spatial Enhancement h245 spatial Enhancement FTUIN T32 BASEDECNULL 0 SETSIZE 1 14 OF Enhancement Options HFILL hf h245 spatial Enhancement item Enhancement Options h245 Enhancement Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 b Picture Enhancement b Picture Enhancement h245 b Picture Enhancement FTUIN T32 BASEDECNULL 0 SETSIZE 1 14 OFB Enhancement Parameters HFILL hf h245 b Picture Enhancement item B Enhancement Parameters h245 B Enhancement Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 enhancement Options enhancement Options h245 enhancement Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 number Of B Pictures number Of B Pictures h245 number Of B Pictures FTUIN T32 BASEDECNULL 0 INTEGER 1 64 HFILL hf h245 advanced Intra Coding Mode advanced Intra Coding Mode h245 advanced Intra Coding Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 deblocking Filter Mode deblocking Filter Mode h245 deblocking Filter Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 improved PB Frames Mode improved PB Frames Mode h245 improved PB Frames Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 unlimited Motion Vectors unlimited Motion Vectors h245 unlimited Motion Vectors FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 full Picture Freeze full Picture Freeze h245 full Picture Freeze FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 partial Picture Freeze And Release partial Picture Freeze And Release h245 partial Picture Freeze And Release FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 resizing Part Pic Freeze And Release resizing Part Pic Freeze And Release h245 resizing Part Pic Freeze And Release FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 full Picture Snapshot full Picture Snapshot h245 full Picture Snapshot FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 partial Picture Snapshot partial Picture Snapshot h245 partial Picture Snapshot FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video Segment Tagging video Segment Tagging h245 video Segment Tagging FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 progressive Refinement progressive Refinement h245 progressive Refinement FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dynamic Picture Resizing By Four dynamic Picture Resizing By Four h245 dynamic Picture Resizing By Four FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dynamic Picture Resizing Sixteenth Pel dynamic Picture Resizing Sixteenth Pel h245 dynamic Picture Resizing Sixteenth Pel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dynamic Warping Half Pel dynamic Warping Half Pel h245 dynamic Warping Half Pel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dynamic Warping Sixteenth Pel dynamic Warping Sixteenth Pel h245 dynamic Warping Sixteenth Pel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 independent Segment Decoding independent Segment Decoding h245 independent Segment Decoding FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 slices In Order Non Rect slices In Order Non Rect h245 slices In Order Non Rect FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 slices In Order Rect slices In Order Rect h245 slices In Order Rect FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 slices No Order Non Rect slices No Order Non Rect h245 slices No Order Non Rect FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 slices No Order Rect slices No Order Rect h245 slices No Order Rect FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 alternate Inter VLC Mode alternate Inter VLC Mode h245 alternate Inter VLC Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 modified Quantization Mode modified Quantization Mode h245 modified Quantization Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 reduced Resolution Update reduced Resolution Update h245 reduced Resolution Update FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 transparency Parameters transparency Parameters h245 transparency Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 separate Video Back Channel separate Video Back Channel h245 separate Video Back Channel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 ref Picture Selection ref Picture Selection h245 ref Picture Selection element FTNONEBASENONENULL 0 NULLHFILL hf h245 custom Picture Clock Frequency custom Picture Clock Frequency h245 custom Picture Clock Frequency FTUIN T32 BASEDECNULL 0 SETSIZE 1 16 OF Custom Picture Clock Frequency HFILL hf h245 custom Picture Clock Frequency item Custom Picture Clock Frequency h245 Custom Picture Clock Frequency element FTNONEBASENONENULL 0 NULLHFILL hf h245 custom Picture Format custom Picture Format h245 custom Picture Format FTUIN T32 BASEDECNULL 0 SETSIZE 1 16 OF Custom Picture Format HFILL hf h245 custom Picture Format item Custom Picture Format h245 Custom Picture Format element FTNONEBASENONENULL 0 NULLHFILL hf h245 mode Combos mode Combos h245 mode Combos FTUIN T32 BASEDECNULL 0 SETSIZE 1 16 OF H263 Video Mode Combos HFILL hf h245 mode Combos item H263 Video Mode Combos h245 H263 Video Mode Combos element FTNONEBASENONENULL 0 NULLHFILL hf h245 h263 Version3 Options h263 Version3 Options h245 h263 Version3 Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 presentation Order presentation Order h245 presentation Order FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 offset x offset x h245 offset x FTIN T32 BASEDECNULL 0 INTEGER M262144 262143 HFILL hf h245 offset y offset y h245 offset y FTIN T32 BASEDECNULL 0 INTEGER M262144 262143 HFILL hf h245 scale x scale x h245 scale x FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 scale y scale y h245 scale y FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 additional Picture Memory additional Picture Memory h245 additional Picture Memory element FTNONEBASENONENULL 0 NULLHFILL hf h245 sqcif Additional Picture Memory sqcif Additional Picture Memory h245 sqcif Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 qcif Additional Picture Memory qcif Additional Picture Memory h245 qcif Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 cif Additional Picture Memory cif Additional Picture Memory h245 cif Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 cif4 Additional Picture Memory cif4 Additional Picture Memory h245 cif4 Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 cif16 Additional Picture Memory cif16 Additional Picture Memory h245 cif16 Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 big Cpf Additional Picture Memory big Cpf Additional Picture Memory h245 big Cpf Additional Picture Memory FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 video Mux video Mux h245 video Mux FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video Back Channel Send video Back Channel Send h245 video Back Channel Send FTUIN T32 BASEDECVALS h245 T video Back Channel Send vals 0 NULLHFILL hf h245 none none h245 none element FTNONEBASENONENULL 0 NULLHFILL hf h245 ack Message Only ack Message Only h245 ack Message Only element FTNONEBASENONENULL 0 NULLHFILL hf h245 nack Message Only nack Message Only h245 nack Message Only element FTNONEBASENONENULL 0 NULLHFILL hf h245 ack Or Nack Message Only ack Or Nack Message Only h245 ack Or Nack Message Only element FTNONEBASENONENULL 0 NULLHFILL hf h245 ack And Nack Message ack And Nack Message h245 ack And Nack Message element FTNONEBASENONENULL 0 NULLHFILL hf h245 enhanced Reference Pic Select enhanced Reference Pic Select h245 enhanced Reference Pic Select element FTNONEBASENONENULL 0 NULLHFILL hf h245 sub Picture Removal Parameters sub Picture Removal Parameters h245 sub Picture Removal Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 mpu Horiz M Bs mpu Horiz M Bs h245 mpu Horiz M Bs FTUIN T32 BASEDECNULL 0 INTEGER 1 128 HFILL hf h245 mpu Vert M Bs mpu Vert M Bs h245 mpu Vert M Bs FTUIN T32 BASEDECNULL 0 INTEGER 1 72 HFILL hf h245 mpu Total Number mpu Total Number h245 mpu Total Number FTUIN T32 BASEDECNULL 0 INTEGER 1 65536 HFILL hf h245 clock Conversion Code clock Conversion Code h245 clock Conversion Code FTUIN T32 BASEDECNULL 0 INTEGER 1000 1001 HFILL hf h245 clock Divisor clock Divisor h245 clock Divisor FTUIN T32 BASEDECNULL 0 INTEGER 1 127 HFILL hf h245 sqcif MPI sqcif MPI h245 sqcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 qcif MPI 1 2048 qcif MPI h245 qcif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 cif MP I2 1 2048 cif MPI h245 cif MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 cif4 MPI cif4 MPI h245 cif4 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 cif16 MPI cif16 MPI h245 cif16 MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 max Custom Picture Width max Custom Picture Width h245 max Custom Picture Width FTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 max Custom Picture Height max Custom Picture Height h245 max Custom Picture Height FTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 min Custom Picture Width min Custom Picture Width h245 min Custom Picture Width FTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 min Custom Picture Height min Custom Picture Height h245 min Custom Picture Height FTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 m PI m PI h245 m PI element FTNONEBASENONENULL 0 NULLHFILL hf h245 standard MPI standard MPI h245 standard MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 31 HFILL hf h245 custom PCF custom PCF h245 custom PCFFTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 custom PCF item custom PCF item h245 custom PCF item element FTNONEBASENONENULL 0 NULLHFILL hf h245 custom MPI custom MPI h245 custom MPIFTUIN T32 BASEDECNULL 0 INTEGER 1 2048 HFILL hf h245 pixel Aspect Information pixel Aspect Information h245 pixel Aspect Information FTUIN T32 BASEDECVALS h245 T pixel Aspect Information vals 0 NULLHFILL hf h245 any Pixel Aspect Ratio any Pixel Aspect Ratio h245 any Pixel Aspect Ratio FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 pixel Aspect Code pixel Aspect Code h245 pixel Aspect Code FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 pixel Aspect Code item pixel Aspect Code item h245 pixel Aspect Code item FTUIN T32 BASEDECNULL 0 INTEGER 1 14 HFILL hf h245 extended PAR extended PAR h245 extended PARFTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 extended PAR item extended PAR item h245 extended PAR item element FTNONEBASENONENULL 0 NULLHFILL hf h245 width width h245 width FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 height height h245 height FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 h263 Video Uncoupled Modes h263 Video Uncoupled Modes h245 h263 Video Uncoupled Modes element FTNONEBASENONENULL 0 H263 Mode Combo Flags HFILL hf h245 h263 Video Coupled Modes h263 Video Coupled Modes h245 h263 Video Coupled Modes FTUIN T32 BASEDECNULL 0 SETSIZE 1 16 OF H263 Mode Combo Flags HFILL hf h245 h263 Video Coupled Modes item H263 Mode Combo Flags h245 H263 Mode Combo Flags element FTNONEBASENONENULL 0 NULLHFILL hf h245 reference Pic Select reference Pic Select h245 reference Pic Select FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 enhanced Reference Pic Select Bool enhanced Reference Pic Select h245 enhanced Reference Pic Select FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 data Partitioned Slices data Partitioned Slices h245 data Partitioned Slices FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 fixed Point IDC T0 fixed Point IDC T0 h245 fixed Point IDC T0 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 interlaced Fields interlaced Fields h245 interlaced Fields FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 current Picture Header Repetition current Picture Header Repetition h245 current Picture Header Repetition FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 previous Picture Header Repetition previous Picture Header Repetition h245 previous Picture Header Repetition FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 next Picture Header Repetition next Picture Header Repetition h245 next Picture Header Repetition FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 picture Number Boolean picture Number h245 picture Number FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 spare Reference Pictures spare Reference Pictures h245 spare Reference Pictures FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 constrained Bitstream constrained Bitstream h245 constrained Bitstream FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 picture Rate picture Rate h245 picture Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 15 HFILL hf h245 g711 Alaw64k g711 Alaw64k h245 g711 Alaw64k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g711 Alaw56k g711 Alaw56k h245 g711 Alaw56k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g711 Ulaw64k g711 Ulaw64k h245 g711 Ulaw64k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g711 Ulaw56k g711 Ulaw56k h245 g711 Ulaw56k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g722 64k g722 64k h245 g722 64k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g722 56k g722 56k h245 g722 56k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g722 48k g722 48k h245 g722 48k FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g7231 g7231 h245 g7231 element FTNONEBASENONENULL 0 NULLHFILL hf h245 max Al sdu Audio Frames max Al sdu Audio Frames h245 max Al sdu Audio Frames FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 silence Suppression silence Suppression h245 silence Suppression FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 g728 g728 h245 g728 FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g729 g729 h245 g729 FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g729 Annex A g729 Annex A h245 g729 Annex AFTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 is11172 Audio Capability is11172 Audio Capability h245 is11172 Audio Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 is13818 Audio Capability is13818 Audio Capability h245 is13818 Audio Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 g729w Annex B g729w Annex B h245 g729w Annex BFTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g729 Annex Aw Annex B g729 Annex Aw Annex B h245 g729 Annex Aw Annex BFTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 g7231 Annex C Capability g7231 Annex C Capability h245 g7231 Annex C Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 gsm Full Rate gsm Full Rate h245 gsm Full Rate element FTNONEBASENONENULL 0 GSM Audio Capability HFILL hf h245 gsm Half Rate gsm Half Rate h245 gsm Half Rate element FTNONEBASENONENULL 0 GSM Audio Capability HFILL hf h245 gsm Enhanced Full Rate gsm Enhanced Full Rate h245 gsm Enhanced Full Rate element FTNONEBASENONENULL 0 GSM Audio Capability HFILL hf h245 generic Audio Capability generic Audio Capability h245 generic Audio Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 g729 Extensions g729 Extensions h245 g729 Extensions element FTNONEBASENONENULL 0 NULLHFILL hf h245 vbd vbd h245 vbd element FTNONEBASENONENULL 0 VBD Capability HFILL hf h245 audio Telephony Event audio Telephony Event h245 audio Telephony Event element FTNONEBASENONENULL 0 No PT Audio Telephony Event Capability HFILL hf h245 audio Tone audio Tone h245 audio Tone element FTNONEBASENONENULL 0 No PT Audio Tone Capability HFILL hf h245 audio Unit audio Unit h245 audio Unit FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 annex A annex A h245 annex AFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex B annex B h245 annex BFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex D annex D h245 annex DFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex E annex E h245 annex EFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex F annex F h245 annex FFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex G annex G h245 annex GFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 annex H annex H h245 annex HFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 high Rate Mode0 high Rate Mode0 h245 high Rate Mode0 FTUIN T32 BASEDECNULL 0 INTEGER 27 78 HFILL hf h245 high Rate Mode1 high Rate Mode1 h245 high Rate Mode1 FTUIN T32 BASEDECNULL 0 INTEGER 27 78 HFILL hf h245 low Rate Mode0 low Rate Mode0 h245 low Rate Mode0 FTUIN T32 BASEDECNULL 0 INTEGER 23 66 HFILL hf h245 low Rate Mode1 low Rate Mode1 h245 low Rate Mode1 FTUIN T32 BASEDECNULL 0 INTEGER 23 66 HFILL hf h245 sid Mode0 sid Mode0 h245 sid Mode0 FTUIN T32 BASEDECNULL 0 INTEGER 6 17 HFILL hf h245 sid Mode1 sid Mode1 h245 sid Mode1 FTUIN T32 BASEDECNULL 0 INTEGER 6 17 HFILL hf h245 g723 Annex C Audio Mode g723 Annex C Audio Mode h245 g723 Annex C Audio Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Layer1 audio Layer1 h245 audio Layer1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Layer2 audio Layer2 h245 audio Layer2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Layer3 audio Layer3 h245 audio Layer3 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Sampling32k audio Sampling32k h245 audio Sampling32k FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Sampling44k1 audio Sampling44k1 h245 audio Sampling44k1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Sampling48k audio Sampling48k h245 audio Sampling48k FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 single Channel single Channel h245 single Channel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 two Channels two Channels h245 two Channels FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 bit Rate 1 448 bit Rate h245 bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 448 HFILL hf h245 audio Sampling16k audio Sampling16k h245 audio Sampling16k FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Sampling22k05 audio Sampling22k05 h245 audio Sampling22k05 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 audio Sampling24k audio Sampling24k h245 audio Sampling24k FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 three Channels2 1 three Channels2 1 h245 three Channels2 1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 three Channels3 0 three Channels3 0 h245 three Channels3 0 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 four Channels2 0 2 0 four Channels2 0 2 0 h245 four Channels2 0 2 0 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 four Channels2 2 four Channels2 2 h245 four Channels2 2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 four Channels3 1 four Channels3 1 h245 four Channels3 1 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 five Channels3 0 2 0 five Channels3 0 2 0 h245 five Channels3 0 2 0 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 five Channels3 2 five Channels3 2 h245 five Channels3 2 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 low Frequency Enhancement low Frequency Enhancement h245 low Frequency Enhancement FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 multilingual multilingual h245 multilingual FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 bit Rate2 1 1130 bit Rate h245 bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 1130 HFILL hf h245 audio Unit Size audio Unit Size h245 audio Unit Size FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 comfort Noise comfort Noise h245 comfort Noise FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 scrambled scrambled h245 scrambled FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 vbd cap type type h245 type FTUIN T32 BASEDECVALS h245 Audio Capability vals 0 Audio Capability HFILL hf h245 t120 t120 h245 t120 FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 dsm cc dsm cc h245 dsm cc FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 user Data user Data h245 user Data FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t84 t84 h245 t84 element FTNONEBASENONENULL 0 NULLHFILL hf h245 t84 Protocol t84 Protocol h245 t84 Protocol FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t84 Profile t84 Profile h245 t84 Profile FTUIN T32 BASEDECVALS h245 T84 Profile vals 0 NULLHFILL hf h245 t434 t434 h245 t434 FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 h224 h224 h245 h224 FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 nlpid Protocol nlpid Protocol h245 nlpid Protocol FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 nlpid Data nlpid Data h245 nlpid Data FTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 nlpid nlpid h245 nlpid element FTNONEBASENONENULL 0 NULLHFILL hf h245 dsvd Control dsvd Control h245 dsvd Control element FTNONEBASENONENULL 0 NULLHFILL hf h245 h222 Data Partitioning h222 Data Partitioning h245 h222 Data Partitioning FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t30fax t30fax h245 t30fax FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t140 t140 h245 t140 FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t38fax t38fax h245 t38fax element FTNONEBASENONENULL 0 NULLHFILL hf h245 t38 Fax Protocol t38 Fax Protocol h245 t38 Fax Protocol FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t38 Fax Profile t38 Fax Profile h245 t38 Fax Profile element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Data Capability generic Data Capability h245 generic Data Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 application application h245 application FTUIN T32 BASEDECVALS h245 Application vals 0 NULLHFILL hf h245 max Bit Rate2 0 4294967295 max Bit Rate h245 max Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 v14buffered v14buffered h245 v14buffered element FTNONEBASENONENULL 0 NULLHFILL hf h245 v42lapm v42lapm h245 v42lapm element FTNONEBASENONENULL 0 NULLHFILL hf h245 hdlc Frame Tunnelling hdlc Frame Tunnelling h245 hdlc Frame Tunnelling element FTNONEBASENONENULL 0 NULLHFILL hf h245 h310 Separate VC Stack h310 Separate VC Stack h245 h310 Separate VC Stack element FTNONEBASENONENULL 0 NULLHFILL hf h245 h310 Single VC Stack h310 Single VC Stack h245 h310 Single VC Stack element FTNONEBASENONENULL 0 NULLHFILL hf h245 transparent transparent h245 transparent element FTNONEBASENONENULL 0 NULLHFILL hf h245 segmentation And Reassembly segmentation And Reassembly h245 segmentation And Reassembly element FTNONEBASENONENULL 0 NULLHFILL hf h245 hdlc Frame Tunnelingw SAR hdlc Frame Tunnelingw SAR h245 hdlc Frame Tunnelingw SAR element FTNONEBASENONENULL 0 NULLHFILL hf h245 v120 v120 h245 v120 element FTNONEBASENONENULL 0 NULLHFILL hf h245 separate LAN Stack separate LAN Stack h245 separate LAN Stack element FTNONEBASENONENULL 0 NULLHFILL hf h245 v76w Compression v76w Compression h245 v76w Compression FTUIN T32 BASEDECVALS h245 T v76w Compression vals 0 NULLHFILL hf h245 transmit Compression transmit Compression h245 transmit Compression FTUIN T32 BASEDECVALS h245 Compression Type vals 0 Compression Type HFILL hf h245 receive Compression receive Compression h245 receive Compression FTUIN T32 BASEDECVALS h245 Compression Type vals 0 Compression Type HFILL hf h245 transmit And Receive Compression transmit And Receive Compression h245 transmit And Receive Compression FTUIN T32 BASEDECVALS h245 Compression Type vals 0 Compression Type HFILL hf h245 tcp tcp h245 tcp element FTNONEBASENONENULL 0 NULLHFILL hf h245 udp udp h245 udp element FTNONEBASENONENULL 0 NULLHFILL hf h245 v42bis v42bis h245 v42bis element FTNONEBASENONENULL 0 NULLHFILL hf h245 number Of Codewords number Of Codewords h245 number Of Codewords FTUIN T32 BASEDECNULL 0 INTEGER 1 65536 HFILL hf h245 maximum String Length maximum String Length h245 maximum String Length FTUIN T32 BASEDECNULL 0 INTEGER 1 256 HFILL hf h245 t84 Unrestricted t84 Unrestricted h245 t84 Unrestricted element FTNONEBASENONENULL 0 NULLHFILL hf h245 t84 Restricted t84 Restricted h245 t84 Restricted element FTNONEBASENONENULL 0 NULLHFILL hf h245 qcif bool qcif h245 qcif FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 cif bool cif h245 cif FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 ccir601 Seq ccir601 Seq h245 ccir601 Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 ccir601 Prog ccir601 Prog h245 ccir601 Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 hdtv Seq hdtv Seq h245 hdtv Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 hdtv Prog hdtv Prog h245 hdtv Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 g3 Facs M H200x100 g3 Facs M H200x100 h245 g3 Facs M H200x100 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 g3 Facs M H200x200 g3 Facs M H200x200 h245 g3 Facs M H200x200 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 g4 Facs MM R200x100 g4 Facs MM R200x100 h245 g4 Facs MM R200x100 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 g4 Facs MM R200x200 g4 Facs MM R200x200 h245 g4 Facs MM R200x200 FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 jbig200x200 Seq jbig200x200 Seq h245 jbig200x200 Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 jbig200x200 Prog jbig200x200 Prog h245 jbig200x200 Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 jbig300x300 Seq jbig300x300 Seq h245 jbig300x300 Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 jbig300x300 Prog jbig300x300 Prog h245 jbig300x300 Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dig Photo Low dig Photo Low h245 dig Photo Low FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dig Photo Med Seq dig Photo Med Seq h245 dig Photo Med Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dig Photo Med Prog dig Photo Med Prog h245 dig Photo Med Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dig Photo High Seq dig Photo High Seq h245 dig Photo High Seq FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 dig Photo High Prog dig Photo High Prog h245 dig Photo High Prog FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 fill Bit Removal fill Bit Removal h245 fill Bit Removal FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 transcoding JBIG transcoding JBIG h245 transcoding JBIGFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 transcoding MMR transcoding MMR h245 transcoding MMRFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 version version h245 version FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 t38 Fax Rate Management t38 Fax Rate Management h245 t38 Fax Rate Management FTUIN T32 BASEDECVALS h245 T38 Fax Rate Management vals 0 NULLHFILL hf h245 t38 Fax Udp Options t38 Fax Udp Options h245 t38 Fax Udp Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 t38 Fax Tcp Options t38 Fax Tcp Options h245 t38 Fax Tcp Options element FTNONEBASENONENULL 0 NULLHFILL hf h245 local TCF local TCF h245 local TCF element FTNONEBASENONENULL 0 NULLHFILL hf h245 transferred TCF transferred TCF h245 transferred TCF element FTNONEBASENONENULL 0 NULLHFILL hf h245 t38 Fax Max Buffer t38 Fax Max Buffer h245 t38 Fax Max Buffer FTIN T32 BASEDECNULL 0 INTEGERHFILL hf h245 t38 Fax Max Datagram t38 Fax Max Datagram h245 t38 Fax Max Datagram FTIN T32 BASEDECNULL 0 INTEGERHFILL hf h245 t38 Fax Udp EC t38 Fax Udp EC h245 t38 Fax Udp ECFTUIN T32 BASEDECVALS h245 T t38 Fax Udp EC vals 0 NULLHFILL hf h245 t38 UDPFEC t38 UDPFEC h245 t38 UDPFEC element FTNONEBASENONENULL 0 NULLHFILL hf h245 t38 UDP Redundancy t38 UDP Redundancy h245 t38 UDP Redundancy element FTNONEBASENONENULL 0 NULLHFILL hf h245 t38 TCP Bidirectional Mode t38 TCP Bidirectional Mode h245 t38 TCP Bidirectional Mode FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 encryption Capability encryption Capability h245 encryption Capability FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 authentication Capability authentication Capability h245 authentication Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 integrity Capability integrity Capability h245 integrity Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic H235 Security Capability generic H235 Security Capability h245 generic H235 Security Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 Encryption Capability item Media Encryption Algorithm h245 Media Encryption Algorithm FTUIN T32 BASEDECVALS h245 Media Encryption Algorithm vals 0 NULLHFILL hf h245 algorithm algorithm h245 algorithm FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 anti Spam Algorithm anti Spam Algorithm h245 anti Spam Algorithm FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 ui non Standard non Standard h245 non Standard FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 16 OF Non Standard Parameter HFILL hf h245 ui non Standard item Non Standard Parameter h245 Non Standard Parameter element FTNONEBASENONENULL 0 NULLHFILL hf h245 basic String basic String h245 basic String element FTNONEBASENONENULL 0 NULLHFILL hf h245 i A5 String i A5 String h245 i A5 String element FTNONEBASENONENULL 0 NULLHFILL hf h245 general String general String h245 general String element FTNONEBASENONENULL 0 NULLHFILL hf h245 dtmf dtmf h245 dtmf element FTNONEBASENONENULL 0 NULLHFILL hf h245 hookflash hookflash h245 hookflash element FTNONEBASENONENULL 0 NULLHFILL hf h245 extended Alphanumeric Flag extended Alphanumeric h245 extended Alphanumeric element FTNONEBASENONENULL 0 NULLHFILL hf h245 encrypted Basic String encrypted Basic String h245 encrypted Basic String element FTNONEBASENONENULL 0 NULLHFILL hf h245 encrypted I A5 String encrypted I A5 String h245 encrypted I A5 String element FTNONEBASENONENULL 0 NULLHFILL hf h245 encrypted General String encrypted General String h245 encrypted General String element FTNONEBASENONENULL 0 NULLHFILL hf h245 secure DTMF secure DTMF h245 secure DTMF element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic User Input Capability generic User Input Capability h245 generic User Input Capability element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 non Standard Params non Standard Data h245 non Standard Data FTUIN T32 BASEDECNULL 0 SEQUENCEOF Non Standard Parameter HFILL hf h245 non Standard Params item Non Standard Parameter h245 Non Standard Parameter element FTNONEBASENONENULL 0 NULLHFILL hf h245 chair Control Capability chair Control Capability h245 chair Control Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 video Indicate Mixing Capability video Indicate Mixing Capability h245 video Indicate Mixing Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 multipoint Visualization Capability multipoint Visualization Capability h245 multipoint Visualization Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 capability Identifier capability Identifier h245 capability Identifier FTUIN T32 BASEDECVALS h245 Capability Identifier vals 0 NULLHFILL hf h245 collapsing collapsing h245 collapsing FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 collapsing item collapsing item h245 collapsing item element FTNONEBASENONENULL 0 NULLHFILL hf h245 non Collapsing non Collapsing h245 non Collapsing FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 non Collapsing item non Collapsing item h245 non Collapsing item element FTNONEBASENONENULL 0 NULLHFILL hf h245 non Collapsing Raw non Collapsing Raw h245 non Collapsing Raw FTBYTESBASENONENULL 0 NULLHFILL hf h245 transport transport h245 transport FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 standard Oid standard h245 standard FTOIDBASENONENULL 0 T standard Oid HFILL hf h245 h221 Non Standard h221 Non Standard h245 h221 Non Standard element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 uuid uuid h245 uuid FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 16 HFILL hf h245 domain Based domain Based h245 domain Based FTSTRINGBASENONENULL 0 I A5 String SIZE 1 64 HFILL hf h245 parameter Identifier parameter Identifier h245 parameter Identifier FTUIN T32 BASEDECVALS h245 Parameter Identifier vals 0 NULLHFILL hf h245 parameter Value parameter Value h245 parameter Value FTUIN T32 BASEDECVALS h245 Parameter Value vals 0 NULLHFILL hf h245 supersedes supersedes h245 supersedes FTUIN T32 BASEDECNULL 0 SEQUENCEOF Parameter Identifier HFILL hf h245 supersedes item Parameter Identifier h245 Parameter Identifier FTUIN T32 BASEDECVALS h245 Parameter Identifier vals 0 NULLHFILL hf h245 standard standard h245 standard FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 logical logical h245 logical element FTNONEBASENONENULL 0 NULLHFILL hf h245 boolean Array boolean Array h245 boolean Array FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 unsigned Min unsigned Min h245 unsigned Min FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 unsigned Max unsigned Max h245 unsigned Max FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 unsigned32 Min unsigned32 Min h245 unsigned32 Min FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 unsigned32 Max unsigned32 Max h245 unsigned32 Max FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 octet String octet String h245 octet String FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 generic Parameters generic Parameter h245 generic Parameter FTUIN T32 BASEDECNULL 0 SEQUENCEOF Generic Parameter HFILL hf h245 generic Parameters item Generic Parameter h245 Generic Parameter element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Format multiplex Format h245 multiplex Format FTUIN T32 BASEDECVALS h245 Multiplex Format vals 0 NULLHFILL hf h245 control On Mux Stream control On Mux Stream h245 control On Mux Stream FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 capability On Mux Stream capability On Mux Stream h245 capability On Mux Stream FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Alternative Capability Set HFILL hf h245 capability On Mux Stream item Alternative Capability Set h245 Alternative Capability Set FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 dynamic RTP Payload Type dynamic RTP Payload Type h245 dynamic RTP Payload Type FTUIN T32 BASEDECNULL 0 INTEGER 96 127 HFILL hf h245 audio Telephone Event audio Telephone Event h245 audio Telephone Event FTSTRINGBASENONENULL 0 General String HFILL hf h245 capabilities capabilities h245 capabilities FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Alternative Capability Set HFILL hf h245 capabilities item Alternative Capability Set h245 Alternative Capability Set FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 fecc rfc2733 rfc2733 h245 rfc2733 element FTNONEBASENONENULL 0 FECC rfc2733 HFILL hf h245 redundancy Encoding Bool redundancy Encoding h245 redundancy Encoding FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 separate Stream Bool separate Stream h245 separate Stream element FTNONEBASENONENULL 0 T separate Stream Bool HFILL hf h245 separate Port separate Port h245 separate Port FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 same Port Bool same Port h245 same Port FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 protected Capability protected Capability h245 protected Capability FTUIN T32 BASEDECNULL 0 Capability Table Entry Number HFILL hf h245 fec Scheme fec Scheme h245 fec Scheme FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 rfc2733rfc2198 rfc2733rfc2198 h245 rfc2733rfc2198 FTUIN T32 BASEDECNULL 0 Max Redundancy HFILL hf h245 rfc2733sameport rfc2733sameport h245 rfc2733sameport FTUIN T32 BASEDECNULL 0 Max Redundancy HFILL hf h245 rfc2733diffport rfc2733diffport h245 rfc2733diffport FTUIN T32 BASEDECNULL 0 Max Redundancy HFILL hf h245 rfc2733 Format rfc2733 Format h245 rfc2733 Format FTUIN T32 BASEDECVALS h245 Rfc2733 Format vals 0 NULLHFILL hf h245 olc fw lcn forward Logical Channel Number h245 forward Logical Channel Number FTUIN T32 BASEDECNULL 0 OLC fw lcn HFILL hf h245 forward Logical Channel Parameters forward Logical Channel Parameters h245 forward Logical Channel Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 port Number port Number h245 port Number FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 data Type data Type h245 data Type FTUIN T32 BASEDECVALS h245 Data Type vals 0 NULLHFILL hf h245 olc forw multiplex Parameters multiplex Parameters h245 multiplex Parameters FTUIN T32 BASEDECVALS h245 OLC forw multiplex Parameters vals 0 OLC forw multiplex Parameters HFILL hf h245 h222 Logical Channel Parameters h222 Logical Channel Parameters h245 h222 Logical Channel Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 olc fw h223 params h223 Logical Channel Parameters h245 h223 Logical Channel Parameters element FTNONEBASENONENULL 0 OLC fw h223 params HFILL hf h245 v76 Logical Channel Parameters v76 Logical Channel Parameters h245 v76 Logical Channel Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 h2250 Logical Channel Parameters h2250 Logical Channel Parameters h245 h2250 Logical Channel Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 forward Logical Channel Dependency forward Logical Channel Dependency h245 forward Logical Channel Dependency FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 replacement For replacement For h245 replacement For FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 reverse Logical Channel Parameters reverse Logical Channel Parameters h245 reverse Logical Channel Parameters element FTNONEBASENONENULL 0 OLC reverse Logical Channel Parameters HFILL hf h245 olc rev multiplex Parameter multiplex Parameters h245 multiplex Parameters FTUIN T32 BASEDECVALS h245 OLC rev multiplex Parameters vals 0 OLC rev multiplex Parameters HFILL hf h245 olc rev h223 params h223 Logical Channel Parameters h245 h223 Logical Channel Parameters element FTNONEBASENONENULL 0 OLC rev h223 params HFILL hf h245 reverse Logical Channel Dependency reverse Logical Channel Dependency h245 reverse Logical Channel Dependency FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 separate Stack separate Stack h245 separate Stack element FTNONEBASENONENULL 0 Network Access Parameters HFILL hf h245 encryption Sync encryption Sync h245 encryption Sync element FTNONEBASENONENULL 0 NULLHFILL hf h245 distribution distribution h245 distribution FTUIN T32 BASEDECVALS h245 T distribution vals 0 NULLHFILL hf h245 unicast unicast h245 unicast element FTNONEBASENONENULL 0 NULLHFILL hf h245 multicast multicast h245 multicast element FTNONEBASENONENULL 0 NULLHFILL hf h245 network Address network Address h245 network Address FTUIN T32 BASEDECVALS h245 T network Address vals 0 NULLHFILL hf h245 q2931 Address q2931 Address h245 q2931 Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 e164 Address e164 Address h245 e164 Address FTSTRINGBASENONENULL 0 NULLHFILL hf h245 local Area Address local Area Address h245 local Area Address FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Transport Address HFILL hf h245 associate Conference associate Conference h245 associate Conference FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 external Reference external Reference h245 external Reference FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 255 HFILL hf h245 t120 Setup Procedure t120 Setup Procedure h245 t120 Setup Procedure FTUIN T32 BASEDECVALS h245 T t120 Setup Procedure vals 0 NULLHFILL hf h245 originate Call originate Call h245 originate Call element FTNONEBASENONENULL 0 NULLHFILL hf h245 wait For Call wait For Call h245 wait For Call element FTNONEBASENONENULL 0 NULLHFILL hf h245 issue Query issue Query h245 issue Query element FTNONEBASENONENULL 0 NULLHFILL hf h245 address address h245 address FTUIN T32 BASEDECVALS h245 T address vals 0 NULLHFILL hf h245 international Number international Number h245 international Number FTSTRINGBASENONENULL 0 Numeric String SIZE 1 16 HFILL hf h245 nsap Address nsap Address h245 nsap Address FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 20 HFILL hf h245 subaddress subaddress h245 subaddress FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 20 HFILL hf h245 audio Header Present audio Header Present h245 audio Header Present FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 null Data null Data h245 null Data element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Data video Data h245 video Data FTUIN T32 BASEDECVALS h245 Video Capability vals 0 Video Capability HFILL hf h245 audio Data audio Data h245 audio Data FTUIN T32 BASEDECVALS h245 Audio Capability vals 0 Audio Capability HFILL hf h245 data data h245 data element FTNONEBASENONENULL 0 Data Application Capability HFILL hf h245 encryption Data encryption Data h245 encryption Data FTUIN T32 BASEDECVALS h245 Encryption Mode vals 0 Encryption Mode HFILL hf h245 h235 Control h235 Control h245 h235 Control element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 h235 Media h235 Media h245 h235 Media element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplexed Stream multiplexed Stream h245 multiplexed Stream element FTNONEBASENONENULL 0 Multiplexed Stream Parameter HFILL hf h245 redundancy Encoding redundancy Encoding h245 redundancy Encoding element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiple Payload Stream multiple Payload Stream h245 multiple Payload Stream element FTNONEBASENONENULL 0 NULLHFILL hf h245 dep Fec dep Fec h245 dep Fec FTUIN T32 BASEDECVALS h245 Dep FEC Data vals 0 Dep FEC Data HFILL hf h245 fec fec h245 fec FTUIN T32 BASEDECVALS h245 FEC Data vals 0 FEC Data HFILL hf h245 media Type media Type h245 media Type FTUIN T32 BASEDECVALS h245 T media Type vals 0 NULLHFILL hf h245 resource ID resource ID h245 resource IDFTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 sub Channel ID sub Channel ID h245 sub Channel IDFTUIN T32 BASEDECNULL 0 INTEGER 0 8191 HFILL hf h245 pcr pid pcr pid h245 pcr pid FTUIN T32 BASEDECNULL 0 INTEGER 0 8191 HFILL hf h245 program Descriptors program Descriptors h245 program Descriptors FTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 stream Descriptors stream Descriptors h245 stream Descriptors FTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 adaptation Layer Type adaptation Layer Type h245 adaptation Layer Type FTUIN T32 BASEDECVALS h245 T adaptation Layer Type vals 0 NULLHFILL hf h245 h223 al type al1 Framed al1 Framed h245 al1 Framed element FTNONEBASENONENULL 0 T h223 al type al1 Framed HFILL hf h245 h223 al type al1 Not Framed al1 Not Framed h245 al1 Not Framed element FTNONEBASENONENULL 0 T h223 al type al1 Not Framed HFILL hf h245 h223 al type al2 Without Sequence Numbers al2 Without Sequence Numbers h245 al2 Without Sequence Numbers element FTNONEBASENONENULL 0 T h223 al type al2 Without Sequence Numbers HFILL hf h245 h223 al type al2 With Sequence Numbers al2 With Sequence Numbers h245 al2 With Sequence Numbers element FTNONEBASENONENULL 0 T h223 al type al2 With Sequence Numbers HFILL hf h245 control Field Octets control Field Octets h245 control Field Octets FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 al3 send Buffer Size send Buffer Size h245 send Buffer Size FTUIN T32 BASEDECNULL 0 T al3 send Buffer Size HFILL hf h245 h223 al type al3 al3 h245 al3 element FTNONEBASENONENULL 0 T h223 al type al3 HFILL hf h245 h223 al type al1 M al1 M h245 al1 M element FTNONEBASENONENULL 0 T h223 al type al1 MHFILL hf h245 h223 al type al2 M al2 M h245 al2 M element FTNONEBASENONENULL 0 T h223 al type al2 MHFILL hf h245 h223 al type al3 M al3 M h245 al3 M element FTNONEBASENONENULL 0 T h223 al type al3 MHFILL hf h245 h223 lc segmentable Flag segmentable Flag h245 segmentable Flag FTBOOLEANBASENONENULL 0 T h223 lc segmentable Flag HFILL hf h245 transfer Mode transfer Mode h245 transfer Mode FTUIN T32 BASEDECVALS h245 T transfer Mode vals 0 NULLHFILL hf h245 framed framed h245 framed element FTNONEBASENONENULL 0 NULLHFILL hf h245 unframed unframed h245 unframed element FTNONEBASENONENULL 0 NULLHFILL hf h245 a L1 Header FEC header FEC h245 header FECFTUIN T32 BASEDECVALS h245 A L1 Header FEC vals 0 A L1 Header FECHFILL hf h245 sebch16 7 sebch16 7 h245 sebch16 7 element FTNONEBASENONENULL 0 NULLHFILL hf h245 golay24 12 golay24 12 h245 golay24 12 element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc Length2 crc Length h245 crc Length FTUIN T32 BASEDECVALS h245 A L1 Crc Length vals 0 A L1 Crc Length HFILL hf h245 crc4bit crc4bit h245 crc4bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc12bit crc12bit h245 crc12bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc20bit crc20bit h245 crc20bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc28bit crc28bit h245 crc28bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc8bit crc8bit h245 crc8bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc16bit crc16bit h245 crc16bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc32bit crc32bit h245 crc32bit element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc Not Used crc Not Used h245 crc Not Used element FTNONEBASENONENULL 0 NULLHFILL hf h245 rcpc Code Rate rcpc Code Rate h245 rcpc Code Rate FTUIN T32 BASEDECNULL 0 INTEGER 8 32 HFILL hf h245 no Arq no Arq h245 no Arq element FTNONEBASENONENULL 0 NULLHFILL hf h245 type I Arq type I Arq h245 type I Arq element FTNONEBASENONENULL 0 H223 Annex C Arq Parameters HFILL hf h245 type II Arq type II Arq h245 type II Arq element FTNONEBASENONENULL 0 H223 Annex C Arq Parameters HFILL hf h245 arq Type arq Type h245 arq Type FTUIN T32 BASEDECVALS h245 Arq Type vals 0 NULLHFILL hf h245 alsdu Splitting alsdu Splitting h245 alsdu Splitting FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 rs Code Correction rs Code Correction h245 rs Code Correction FTUIN T32 BASEDECNULL 0 INTEGER 0 127 HFILL hf h245 a L2 Header FEC header FEC h245 header FECFTUIN T32 BASEDECVALS h245 A L2 Header FEC vals 0 A L2 Header FECHFILL hf h245 sebch16 5 sebch16 5 h245 sebch16 5 element FTNONEBASENONENULL 0 NULLHFILL hf h245 header Format header Format h245 header Format FTUIN T32 BASEDECVALS h245 T header Format vals 0 NULLHFILL hf h245 crlength2 crc Length h245 crc Length FTUIN T32 BASEDECVALS h245 A L3 Crc Length vals 0 A L3 Crc Length HFILL hf h245 number Of Retransmissions number Of Retransmissions h245 number Of Retransmissions FTUIN T32 BASEDECVALS h245 T number Of Retransmissions vals 0 NULLHFILL hf h245 finite finite h245 finite FTUIN T32 BASEDECNULL 0 INTEGER 0 16 HFILL hf h245 infinite infinite h245 infinite element FTNONEBASENONENULL 0 NULLHFILL hf h245 send Buffer Size send Buffer Size h245 send Buffer Size FTUIN T32 BASEDECNULL 0 INTEGER 0 16777215 HFILL hf h245 hdlc Parameters hdlc Parameters h245 hdlc Parameters element FTNONEBASENONENULL 0 V76 HDLC Parameters HFILL hf h245 suspend Resume suspend Resume h245 suspend Resume FTUIN T32 BASEDECVALS h245 T suspend Resume vals 0 NULLHFILL hf h245 no Suspend Resume no Suspend Resume h245 no Suspend Resume element FTNONEBASENONENULL 0 NULLHFILL hf h245 suspend Resumew Address suspend Resumew Address h245 suspend Resumew Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 suspend Resumewo Address suspend Resumewo Address h245 suspend Resumewo Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 u IH u IH h245 u IHFTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 v76 mode mode h245 mode FTUIN T32 BASEDECVALS h245 V76 LCP mode vals 0 V76 LCP mode HFILL hf h245 e RM e RM h245 e RM element FTNONEBASENONENULL 0 NULLHFILL hf h245 window Size window Size h245 window Size FTUIN T32 BASEDECNULL 0 INTEGER 1 127 HFILL hf h245 recovery recovery h245 recovery FTUIN T32 BASEDECVALS h245 T recovery vals 0 NULLHFILL hf h245 rej rej h245 rej element FTNONEBASENONENULL 0 NULLHFILL hf h245 s REJ s REJ h245 s REJ element FTNONEBASENONENULL 0 NULLHFILL hf h245 m SREJ m SREJ h245 m SREJ element FTNONEBASENONENULL 0 NULLHFILL hf h245 u NERM u NERM h245 u NERM element FTNONEBASENONENULL 0 NULLHFILL hf h245 v75 Parameters v75 Parameters h245 v75 Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 crc Length crc Length h245 crc Length FTUIN T32 BASEDECVALS h245 CRC Length vals 0 NULLHFILL hf h245 n401 n401 h245 n401 FTUIN T32 BASEDECNULL 0 INTEGER 1 4095 HFILL hf h245 loopback Test Procedure loopback Test Procedure h245 loopback Test Procedure FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 session ID 0 255 session ID h245 session IDFTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 associated Session ID associated Session ID h245 associated Session IDFTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 media Channel media Channel h245 media Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 NULLHFILL hf h245 media Guaranteed Delivery media Guaranteed Delivery h245 media Guaranteed Delivery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 media Control Channel media Control Channel h245 media Control Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 NULLHFILL hf h245 media Control Guaranteed Delivery media Control Guaranteed Delivery h245 media Control Guaranteed Delivery FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 destination destination h245 destination element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 media Packetization media Packetization h245 media Packetization FTUIN T32 BASEDECVALS h245 T media Packetization vals 0 NULLHFILL hf h245 h261a Video Packetization Flag h261a Video Packetization h245 h261a Video Packetization element FTNONEBASENONENULL 0 NULLHFILL hf h245 rtp Payload Type rtp Payload Type h245 rtp Payload Type element FTNONEBASENONENULL 0 NULLHFILL hf h245 source source h245 source element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 payload Descriptor payload Descriptor h245 payload Descriptor FTUIN T32 BASEDECVALS h245 T payload Descriptor vals 0 NULLHFILL hf h245 rfc number rfc number h245 rfc number FTUIN T32 BASEDECVALS h245 RFC number vals 0 NULLHFILL hf h245 oid oid h245 oid FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 rtp Payload Type 01 payload Type h245 payload Type FTUIN T32 BASEDECNULL 0 T rtp Payload Type HFILL hf h245 secondary Encoding secondary Encoding h245 secondary Encoding FTUIN T32 BASEDECVALS h245 Data Type vals 0 Data Type HFILL hf h245 rtp Redundancy Encoding rtp Redundancy Encoding h245 rtp Redundancy Encoding element FTNONEBASENONENULL 0 NULLHFILL hf h245 primary primary h245 primary element FTNONEBASENONENULL 0 Redundancy Encoding Element HFILL hf h245 secondary secondary h245 secondary FTUIN T32 BASEDECNULL 0 SEQUENCEOF Redundancy Encoding Element HFILL hf h245 secondary item Redundancy Encoding Element h245 Redundancy Encoding Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 payload Type payload Type h245 payload Type FTUIN T32 BASEDECNULL 0 INTEGER 0 127 HFILL hf h245 elements elements h245 elements FTUIN T32 BASEDECNULL 0 SEQUENCEOF Multiple Payload Stream Element HFILL hf h245 elements item Multiple Payload Stream Element h245 Multiple Payload Stream Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 dep rfc2733 rfc2733 h245 rfc2733 element FTNONEBASENONENULL 0 RF C2733 Data HFILL hf h245 fec data mode mode h245 mode FTUIN T32 BASEDECVALS h245 FE Cdata mode vals 0 FE Cdata mode HFILL hf h245 redundancy Encoding Flag redundancy Encoding h245 redundancy Encoding element FTNONEBASENONENULL 0 NULLHFILL hf h245 different Port different Port h245 different Port element FTNONEBASENONENULL 0 NULLHFILL hf h245 protected Session ID protected Session ID h245 protected Session IDFTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 protected Payload Type protected Payload Type h245 protected Payload Type FTUIN T32 BASEDECNULL 0 INTEGER 0 127 HFILL hf h245 same Port same Port h245 same Port element FTNONEBASENONENULL 0 NULLHFILL hf h245 separate Stream separate Stream h245 separate Stream FTUIN T32 BASEDECVALS h245 Dep Separate Stream vals 0 Dep Separate Stream HFILL hf h245 rfc2733 rfc2733 h245 rfc2733 element FTNONEBASENONENULL 0 NULLHFILL hf h245 pkt Mode pkt Mode h245 pkt Mode FTUIN T32 BASEDECVALS h245 T pkt Mode vals 0 NULLHFILL hf h245 rfc2198coding rfc2198coding h245 rfc2198coding element FTNONEBASENONENULL 0 NULLHFILL hf h245 mode rfc2733sameport rfc2733sameport h245 rfc2733sameport element FTNONEBASENONENULL 0 T mode rfc2733sameport HFILL hf h245 mode rfc2733diffport rfc2733diffport h245 rfc2733diffport element FTNONEBASENONENULL 0 T mode rfc2733diffport HFILL hf h245 protected Channel protected Channel h245 protected Channel FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 unicast Address unicast Address h245 unicast Address FTUIN T32 BASEDECVALS h245 Unicast Address vals 0 NULLHFILL hf h245 multicast Address multicast Address h245 multicast Address FTUIN T32 BASEDECVALS h245 Multicast Address vals 0 NULLHFILL hf h245 i P Address i P Address h245 i P Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 ip4 network network h245 network FTI Pv4 BASENONENULL 0 Ipv4 network HFILL hf h245 tsap Identifier tsap Identifier h245 tsap Identifier FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 i PX Address i PX Address h245 i PX Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 node node h245 node FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 6 HFILL hf h245 netnum netnum h245 netnum FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 4 HFILL hf h245 ipx tsap Identifier tsap Identifier h245 tsap Identifier FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 2 HFILL hf h245 i P6 Address i P6 Address h245 i P6 Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 ip6 network network h245 network FTI Pv6 BASENONENULL 0 OCTETSTRINGSIZE 16 HFILL hf h245 ipv6 tsap Identifier tsap Identifier h245 tsap Identifier FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 net Bios net Bios h245 net Bios FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 16 HFILL hf h245 i P Source Route Address i P Source Route Address h245 i P Source Route Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 routing routing h245 routing FTUIN T32 BASEDECVALS h245 T routing vals 0 NULLHFILL hf h245 strict strict h245 strict element FTNONEBASENONENULL 0 NULLHFILL hf h245 loose loose h245 loose element FTNONEBASENONENULL 0 NULLHFILL hf h245 network network h245 network FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 4 HFILL hf h245 i P Src Route tsap Identifier tsap Identifier h245 tsap Identifier FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 route route h245 route FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 route item route item h245 route item FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 4 HFILL hf h245 nsap nsap h245 nsap FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 20 HFILL hf h245 non Standard Address non Standard Address h245 non Standard Address element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 m IP Address i P Address h245 i P Address element FTNONEBASENONENULL 0 MIP Address HFILL hf h245 mip4 network network h245 network FTI Pv4 BASENONENULL 0 OCTETSTRINGSIZE 4 HFILL hf h245 multicast tsap Identifier tsap Identifier h245 tsap Identifier FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 m I P6 Address i P6 Address h245 i P6 Address element FTNONEBASENONENULL 0 MI P6 Address HFILL hf h245 mip6 network network h245 network FTI Pv6 BASENONENULL 0 OCTETSTRINGSIZE 16 HFILL hf h245 multicast I Pv6 tsap Identifier tsap Identifier h245 tsap Identifier FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 synch Flag synch Flag h245 synch Flag FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 h235 Key h235 Key h245 h235 Key FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 65535 HFILL hf h245 escrowentry escrowentry h245 escrowentry FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OF Escrow Data HFILL hf h245 escrowentry item Escrow Data h245 Escrow Data element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Parameter generic Parameter h245 generic Parameter element FTNONEBASENONENULL 0 NULLHFILL hf h245 escrow ID escrow ID h245 escrow IDFTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 escrow Value escrow Value h245 escrow Value FTBYTESBASENONENULL 0 BITSTRINGSIZE 1 65535 HFILL hf h245 olc ack fw lcn forward Logical Channel Number h245 forward Logical Channel Number FTUIN T32 BASEDECNULL 0 OLC ack fw lcn HFILL hf h245 olc ack reverse Logical Channel Parameters reverse Logical Channel Parameters h245 reverse Logical Channel Parameters element FTNONEBASENONENULL 0 OLC ack reverse Logical Channel Parameters HFILL hf h245 reverse Logical Channel Number reverse Logical Channel Number h245 reverse Logical Channel Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 olc ack multiplex Parameters multiplex Parameters h245 multiplex Parameters FTUIN T32 BASEDECVALS h245 T olc ack multiplex Parameters vals 0 T olc ack multiplex Parameters HFILL hf h245 forward Multiplex Ack Parameters forward Multiplex Ack Parameters h245 forward Multiplex Ack Parameters FTUIN T32 BASEDECVALS h245 T forward Multiplex Ack Parameters vals 0 NULLHFILL hf h245 h2250 Logical Channel Ack Parameters h2250 Logical Channel Ack Parameters h245 h2250 Logical Channel Ack Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 forward Logical Channel Number forward Logical Channel Number h245 forward Logical Channel Number FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 olc rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Open Logical Channel Reject Cause vals 0 Open Logical Channel Reject Cause HFILL hf h245 unsuitable Reverse Parameters unsuitable Reverse Parameters h245 unsuitable Reverse Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 data Type Not Supported data Type Not Supported h245 data Type Not Supported element FTNONEBASENONENULL 0 NULLHFILL hf h245 data Type Not Available data Type Not Available h245 data Type Not Available element FTNONEBASENONENULL 0 NULLHFILL hf h245 unknown Data Type unknown Data Type h245 unknown Data Type element FTNONEBASENONENULL 0 NULLHFILL hf h245 data Type AL Combination Not Supported data Type AL Combination Not Supported h245 data Type AL Combination Not Supported element FTNONEBASENONENULL 0 NULLHFILL hf h245 multicast Channel Not Allowed multicast Channel Not Allowed h245 multicast Channel Not Allowed element FTNONEBASENONENULL 0 NULLHFILL hf h245 insufficient Bandwidth insufficient Bandwidth h245 insufficient Bandwidth element FTNONEBASENONENULL 0 NULLHFILL hf h245 separate Stack Establishment Failed separate Stack Establishment Failed h245 separate Stack Establishment Failed element FTNONEBASENONENULL 0 NULLHFILL hf h245 invalid Session ID invalid Session ID h245 invalid Session ID element FTNONEBASENONENULL 0 NULLHFILL hf h245 master Slave Conflict master Slave Conflict h245 master Slave Conflict element FTNONEBASENONENULL 0 NULLHFILL hf h245 wait For Communication Mode wait For Communication Mode h245 wait For Communication Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 invalid Dependent Channel invalid Dependent Channel h245 invalid Dependent Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 replacement For Rejected replacement For Rejected h245 replacement For Rejected element FTNONEBASENONENULL 0 NULLHFILL hf h245 security Denied security Denied h245 security Denied element FTNONEBASENONENULL 0 NULLHFILL hf h245 qo S Control Not Supported qo S Control Not Supported h245 qo S Control Not Supported element FTNONEBASENONENULL 0 NULLHFILL hf h245 session ID session ID h245 session IDFTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 ack media Channel media Channel h245 media Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Ack media Channel HFILL hf h245 ack media Control Channel media Control Channel h245 media Control Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Ack media Control Channel HFILL hf h245 flow Control To Zero flow Control To Zero h245 flow Control To Zero FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 c LC source source h245 source FTUIN T32 BASEDECVALS h245 T c LC source vals 0 T c LC source HFILL hf h245 user user h245 user element FTNONEBASENONENULL 0 NULLHFILL hf h245 lcse lcse h245 lcse element FTNONEBASENONENULL 0 NULLHFILL hf h245 clc reason reason h245 reason FTUIN T32 BASEDECVALS h245 Clc reason vals 0 Clc reason HFILL hf h245 unknown unknown h245 unknown element FTNONEBASENONENULL 0 NULLHFILL hf h245 reopen reopen h245 reopen element FTNONEBASENONENULL 0 NULLHFILL hf h245 reservation Failure reservation Failure h245 reservation Failure element FTNONEBASENONENULL 0 NULLHFILL hf h245 network Error Code network Error Code h245 network Error Code FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 qos Capability qos Capability h245 qos Capability element FTNONEBASENONENULL 0 NULLHFILL hf h245 reason reason h245 reason FTUIN T32 BASEDECVALS h245 T reason vals 0 NULLHFILL hf h245 normal normal h245 normal element FTNONEBASENONENULL 0 NULLHFILL hf h245 req chan clos rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Request Channel Close Reject Cause vals 0 Request Channel Close Reject Cause HFILL hf h245 multiplex Entry Descriptors multiplex Entry Descriptors h245 multiplex Entry Descriptors FTUIN T32 BASEDECNULL 0 SETSIZE 1 15 OF Multiplex Entry Descriptor HFILL hf h245 multiplex Entry Descriptors item Multiplex Entry Descriptor h245 Multiplex Entry Descriptor element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Table Entry Number multiplex Table Entry Number h245 multiplex Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 element List element List h245 element List FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 element List item Multiplex Element h245 Multiplex Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 me type type h245 type FTUIN T32 BASEDECVALS h245 Me type vals 0 Me type HFILL hf h245 logical Channel Num logical Channel Number h245 logical Channel Number FTUIN T32 BASEDECNULL 0 T logical Channel Num HFILL hf h245 sub Element List sub Element List h245 sub Element List FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 sub Element List item Multiplex Element h245 Multiplex Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 me repeat Count repeat Count h245 repeat Count FTUIN T32 BASEDECVALS h245 ME repeat Count vals 0 ME repeat Count HFILL hf h245 me repeat Count finite finite h245 finite FTUIN T32 BASEDECNULL 0 ME finite Repeat Count HFILL hf h245 until Closing Flag until Closing Flag h245 until Closing Flag element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Table Entry Numbers multiplex Table Entry Number h245 multiplex Table Entry Number FTUIN T32 BASEDECNULL 0 SETSIZE 1 15 OF Multiplex Table Entry Number HFILL hf h245 multiplex Table Entry Numbers item Multiplex Table Entry Number h245 Multiplex Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 send Rejection Descriptions rejection Descriptions h245 rejection Descriptions FTUIN T32 BASEDECNULL 0 SETSIZE 1 15 OF Multiplex Entry Rejection Descriptions HFILL hf h245 send Rejection Descriptions item Multiplex Entry Rejection Descriptions h245 Multiplex Entry Rejection Descriptions element FTNONEBASENONENULL 0 NULLHFILL hf h245 mux rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Multiplex Entry Rejection Descriptions Cause vals 0 Multiplex Entry Rejection Descriptions Cause HFILL hf h245 unspecified Cause unspecified Cause h245 unspecified Cause element FTNONEBASENONENULL 0 NULLHFILL hf h245 descriptor Too Complex descriptor Too Complex h245 descriptor Too Complex element FTNONEBASENONENULL 0 NULLHFILL hf h245 entry Numbers entry Numbers h245 entry Numbers FTUIN T32 BASEDECNULL 0 SETSIZE 1 15 OF Multiplex Table Entry Number HFILL hf h245 entry Numbers item Multiplex Table Entry Number h245 Multiplex Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 rejection Descriptions rejection Descriptions h245 rejection Descriptions FTUIN T32 BASEDECNULL 0 SETSIZE 1 15 OF Request Multiplex Entry Rejection Descriptions HFILL hf h245 rejection Descriptions item Request Multiplex Entry Rejection Descriptions h245 Request Multiplex Entry Rejection Descriptions element FTNONEBASENONENULL 0 NULLHFILL hf h245 req mux rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Request Multiplex Entry Rejection Descriptions Cause vals 0 Request Multiplex Entry Rejection Descriptions Cause HFILL hf h245 requested Modes requested Modes h245 requested Modes FTUIN T32 BASEDECNULL 0 SEQUENCESIZE 1 256 OF Mode Description HFILL hf h245 requested Modes item Mode Description h245 Mode Description FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 req mode ack response response h245 response FTUIN T32 BASEDECVALS h245 Req mode ack response vals 0 Req mode ack response HFILL hf h245 will Transmit Most Preferred Mode will Transmit Most Preferred Mode h245 will Transmit Most Preferred Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 will Transmit Less Preferred Mode will Transmit Less Preferred Mode h245 will Transmit Less Preferred Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 req rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Request Mode Reject Cause vals 0 Request Mode Reject Cause HFILL hf h245 mode Unavailable mode Unavailable h245 mode Unavailable element FTNONEBASENONENULL 0 NULLHFILL hf h245 multipoint Constraint multipoint Constraint h245 multipoint Constraint element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Denied request Denied h245 request Denied element FTNONEBASENONENULL 0 NULLHFILL hf h245 Mode Description item Mode Element h245 Mode Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Mode video Mode h245 video Mode FTUIN T32 BASEDECVALS h245 Video Mode vals 0 NULLHFILL hf h245 audio Mode audio Mode h245 audio Mode FTUIN T32 BASEDECVALS h245 Audio Mode vals 0 NULLHFILL hf h245 data Mode data Mode h245 data Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 encryption Mode encryption Mode h245 encryption Mode FTUIN T32 BASEDECVALS h245 Encryption Mode vals 0 NULLHFILL hf h245 h235 Mode h235 Mode h245 h235 Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplexed Stream Mode multiplexed Stream Mode h245 multiplexed Stream Mode element FTNONEBASENONENULL 0 Multiplexed Stream Parameter HFILL hf h245 redundancy Encoding DT Mode redundancy Encoding DT Mode h245 redundancy Encoding DT Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiple Payload Stream Mode multiple Payload Stream Mode h245 multiple Payload Stream Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 dep Fec Mode dep Fec Mode h245 dep Fec Mode FTUIN T32 BASEDECVALS h245 Dep FEC Mode vals 0 NULLHFILL hf h245 fec Mode fec Mode h245 fec Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 type type h245 type FTUIN T32 BASEDECVALS h245 Mode Element Type vals 0 Mode Element Type HFILL hf h245 h223 Mode Parameters h223 Mode Parameters h245 h223 Mode Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 v76 Mode Parameters v76 Mode Parameters h245 v76 Mode Parameters FTUIN T32 BASEDECVALS h245 V76 Mode Parameters vals 0 NULLHFILL hf h245 h2250 Mode Parameters h2250 Mode Parameters h245 h2250 Mode Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Mode Parameters generic Mode Parameters h245 generic Mode Parameters element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 multiplexed Stream Mode Parameters multiplexed Stream Mode Parameters h245 multiplexed Stream Mode Parameters element FTNONEBASENONENULL 0 NULLHFILL hf h245 logical Channel Number logical Channel Number h245 logical Channel Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 media Mode media Mode h245 media Mode FTUIN T32 BASEDECVALS h245 T media Mode vals 0 NULLHFILL hf h245 prmary dtmode primary h245 primary element FTNONEBASENONENULL 0 Redundancy Encoding DT Mode Element HFILL hf h245 secondary DTM secondary h245 secondary FTUIN T32 BASEDECNULL 0 SEQUENCEOF Redundancy Encoding DT Mode Element HFILL hf h245 secondary DTM item Redundancy Encoding DT Mode Element h245 Redundancy Encoding DT Mode Element element FTNONEBASENONENULL 0 NULLHFILL hf h245 re type type h245 type FTUIN T32 BASEDECVALS h245 Re type vals 0 Re type HFILL hf h245 mpsm Elements elements h245 elements FTUIN T32 BASEDECNULL 0 SEQUENCEOF Multiple Payload Stream Element Mode HFILL hf h245 mpsm Elements item Multiple Payload Stream Element Mode h245 Multiple Payload Stream Element Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 rfc2733 Mode rfc2733 Mode h245 rfc2733 Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 fec mode mode h245 mode FTUIN T32 BASEDECVALS h245 FEC mode vals 0 FEC mode HFILL hf h245 protected Element protected Element h245 protected Element FTUIN T32 BASEDECVALS h245 Mode Element Type vals 0 Mode Element Type HFILL hf h245 adaptation Layer adaptation Layer Type h245 adaptation Layer Type FTUIN T32 BASEDECVALS h245 Adaptation Layer Type vals 0 NULLHFILL hf h245 al1 Framed al1 Framed h245 al1 Framed element FTNONEBASENONENULL 0 NULLHFILL hf h245 al1 Not Framed al1 Not Framed h245 al1 Not Framed element FTNONEBASENONENULL 0 NULLHFILL hf h245 al2 Without Sequence Numbers al2 Without Sequence Numbers h245 al2 Without Sequence Numbers element FTNONEBASENONENULL 0 NULLHFILL hf h245 al2 With Sequence Numbers al2 With Sequence Numbers h245 al2 With Sequence Numbers element FTNONEBASENONENULL 0 NULLHFILL hf h245 al3 al3 h245 al3 element FTNONEBASENONENULL 0 NULLHFILL hf h245 al1 M al1 M h245 al1 M element FTNONEBASENONENULL 0 H223 A L1 M Parameters HFILL hf h245 al2 M al2 M h245 al2 M element FTNONEBASENONENULL 0 H223 A L2 M Parameters HFILL hf h245 al3 M al3 M h245 al3 M element FTNONEBASENONENULL 0 H223 A L3 M Parameters HFILL hf h245 segmentable Flag segmentable Flag h245 segmentable Flag FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 redundancy Encoding Mode redundancy Encoding Mode h245 redundancy Encoding Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 secondary Encoding Mode secondary Encoding h245 secondary Encoding FTUIN T32 BASEDECVALS h245 T secondary Encoding Mode vals 0 T secondary Encoding Mode HFILL hf h245 h261 Video Mode h261 Video Mode h245 h261 Video Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 h262 Video Mode h262 Video Mode h245 h262 Video Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 h263 Video Mode h263 Video Mode h245 h263 Video Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 is11172 Video Mode is11172 Video Mode h245 is11172 Video Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Video Mode generic Video Mode h245 generic Video Mode element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 h261 resolution resolution h245 resolution FTUIN T32 BASEDECVALS h245 H261 Resolution vals 0 H261 Resolution HFILL hf h245 qcif qcif h245 qcif element FTNONEBASENONENULL 0 NULLHFILL hf h245 cif cif h245 cif element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level profile And Level h245 profile And Level FTUIN T32 BASEDECVALS h245 T profile And Level vals 0 NULLHFILL hf h245 profile And Level S Pat ML Mode profile And Level S Pat ML h245 profile And Level S Pat ML element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level M Pat LL Mode profile And Level M Pat LL h245 profile And Level M Pat LL element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level M Pat ML Mode profile And Level M Pat ML h245 profile And Level M Pat ML element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level M Pat H 14 Mode profile And Level M Pat H 14 h245 profile And Level M Pat H 14 element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level M Pat HL Mode profile And Level M Pat HL h245 profile And Level M Pat HL element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level SN Rat LL Mode profile And Level SN Rat LL h245 profile And Level SN Rat LL element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level SN Rat ML Mode profile And Level SN Rat ML h245 profile And Level SN Rat ML element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level Spatialat H 14 Mode profile And Level Spatialat H 14 h245 profile And Level Spatialat H 14 element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level H Pat ML Mode profile And Level H Pat ML h245 profile And Level H Pat ML element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level H Pat H 14 Mode profile And Level H Pat H 14 h245 profile And Level H Pat H 14 element FTNONEBASENONENULL 0 NULLHFILL hf h245 profile And Level H Pat HL Mode profile And Level H Pat HL h245 profile And Level H Pat HL element FTNONEBASENONENULL 0 NULLHFILL hf h245 h263 resolution resolution h245 resolution FTUIN T32 BASEDECVALS h245 H263 Resolution vals 0 H263 Resolution HFILL hf h245 sqcif sqcif h245 sqcif element FTNONEBASENONENULL 0 NULLHFILL hf h245 cif4 cif4 h245 cif4 element FTNONEBASENONENULL 0 NULLHFILL hf h245 cif16 cif16 h245 cif16 element FTNONEBASENONENULL 0 NULLHFILL hf h245 custom res custom h245 custom element FTNONEBASENONENULL 0 NULLHFILL hf h245 g711 Alaw64k mode g711 Alaw64k h245 g711 Alaw64k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g711 Alaw56k mode g711 Alaw56k h245 g711 Alaw56k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g711 Ulaw64k mode g711 Ulaw64k h245 g711 Ulaw64k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g711 Ulaw56k mode g711 Ulaw56k h245 g711 Ulaw56k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g722 64k mode g722 64k h245 g722 64k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g722 56k mode g722 56k h245 g722 56k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g722 48k mode g722 48k h245 g722 48k element FTNONEBASENONENULL 0 NULLHFILL hf h245 g728 mode g728 h245 g728 element FTNONEBASENONENULL 0 NULLHFILL hf h245 g729 mode g729 h245 g729 element FTNONEBASENONENULL 0 NULLHFILL hf h245 g729 Annex A mode g729 Annex A h245 g729 Annex A element FTNONEBASENONENULL 0 NULLHFILL hf h245 g7231 mode g7231 h245 g7231 FTUIN T32 BASEDECVALS h245 Mode g7231 vals 0 Mode g7231 HFILL hf h245 no Silence Suppression Low Rate no Silence Suppression Low Rate h245 no Silence Suppression Low Rate element FTNONEBASENONENULL 0 NULLHFILL hf h245 no Silence Suppression High Rate no Silence Suppression High Rate h245 no Silence Suppression High Rate element FTNONEBASENONENULL 0 NULLHFILL hf h245 silence Suppression Low Rate silence Suppression Low Rate h245 silence Suppression Low Rate element FTNONEBASENONENULL 0 NULLHFILL hf h245 silence Suppression High Rate silence Suppression High Rate h245 silence Suppression High Rate element FTNONEBASENONENULL 0 NULLHFILL hf h245 is11172 Audio Mode is11172 Audio Mode h245 is11172 Audio Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 is13818 Audio Mode is13818 Audio Mode h245 is13818 Audio Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 g7231 Annex C Mode g7231 Annex C Mode h245 g7231 Annex C Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 generic Audio Mode generic Audio Mode h245 generic Audio Mode element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 vbd mode vbd h245 vbd element FTNONEBASENONENULL 0 VBD Mode HFILL hf h245 audio Layer audio Layer h245 audio Layer FTUIN T32 BASEDECVALS h245 T audio Layer vals 0 NULLHFILL hf h245 audio Layer1 Mode audio Layer1 h245 audio Layer1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Layer2 Mode audio Layer2 h245 audio Layer2 element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Layer3 Mode audio Layer3 h245 audio Layer3 element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Sampling audio Sampling h245 audio Sampling FTUIN T32 BASEDECVALS h245 T audio Sampling vals 0 NULLHFILL hf h245 audio Sampling32k Mode audio Sampling32k h245 audio Sampling32k element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Sampling44k1 Mode audio Sampling44k1 h245 audio Sampling44k1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Sampling48k Mode audio Sampling48k h245 audio Sampling48k element FTNONEBASENONENULL 0 NULLHFILL hf h245 is11172multichannel Type multichannel Type h245 multichannel Type FTUIN T32 BASEDECVALS h245 I S11172 multichannel Type vals 0 I S11172 multichannel Type HFILL hf h245 single Channel Mode single Channel h245 single Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 two Channel Stereo two Channel Stereo h245 two Channel Stereo element FTNONEBASENONENULL 0 NULLHFILL hf h245 two Channel Dual two Channel Dual h245 two Channel Dual element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Layer Mode audio Layer h245 audio Layer FTUIN T32 BASEDECVALS h245 I S13818 Audio Layer vals 0 I S13818 Audio Layer HFILL hf h245 audio Sampling Mode audio Sampling h245 audio Sampling FTUIN T32 BASEDECVALS h245 I S13818 Audio Sampling vals 0 I S13818 Audio Sampling HFILL hf h245 audio Sampling16k Mode audio Sampling16k h245 audio Sampling16k element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Sampling22k05 Mode audio Sampling22k05 h245 audio Sampling22k05 element FTNONEBASENONENULL 0 NULLHFILL hf h245 audio Sampling24k Mode audio Sampling24k h245 audio Sampling24k element FTNONEBASENONENULL 0 NULLHFILL hf h245 is13818 Multichannel Type multichannel Type h245 multichannel Type FTUIN T32 BASEDECVALS h245 I S13818 Multichannel Type vals 0 I S13818 Multichannel Type HFILL hf h245 three Channels2 1 Mode three Channels2 1 h245 three Channels2 1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 three Channels3 0 Mode three Channels3 0 h245 three Channels3 0 element FTNONEBASENONENULL 0 NULLHFILL hf h245 four Channels2 0 2 0 Mode four Channels2 0 2 0 h245 four Channels2 0 2 0 element FTNONEBASENONENULL 0 NULLHFILL hf h245 four Channels2 2 Mode four Channels2 2 h245 four Channels2 2 element FTNONEBASENONENULL 0 NULLHFILL hf h245 four Channels3 1 Mode four Channels3 1 h245 four Channels3 1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 five Channels3 0 2 0 Mode five Channels3 0 2 0 h245 five Channels3 0 2 0 element FTNONEBASENONENULL 0 NULLHFILL hf h245 five Channels3 2 Mode five Channels3 2 h245 five Channels3 2 element FTNONEBASENONENULL 0 NULLHFILL hf h245 vbd type type h245 type FTUIN T32 BASEDECVALS h245 Audio Mode vals 0 Audio Mode HFILL hf h245 datamodeapplication application h245 application FTUIN T32 BASEDECVALS h245 Data Mode Application vals 0 Data Mode Application HFILL hf h245 t84 Data Protocol Capability t84 h245 t84 FTUIN T32 BASEDECVALS Data Protocol Capability vals 0 Data Protocol Capability HFILL hf h245 t38fax Data Protocol Capability t38fax h245 t38fax element FTNONEBASENONENULL 0 T38fax App HFILL hf h245 generic Data Mode generic Data Mode h245 generic Data Mode element FTNONEBASENONENULL 0 Generic Capability HFILL hf h245 bit Rate 0 4294967295 bit Rate h245 bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 h233 Encryption h233 Encryption h245 h233 Encryption element FTNONEBASENONENULL 0 NULLHFILL hf h245 mlr type type h245 type FTUIN T32 BASEDECVALS h245 Mlr type vals 0 Mlr type HFILL hf h245 system Loop system Loop h245 system Loop element FTNONEBASENONENULL 0 NULLHFILL hf h245 media Loop media Loop h245 media Loop FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 logical Channel Loop logical Channel Loop h245 logical Channel Loop FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 mla type type h245 type FTUIN T32 BASEDECVALS h245 Mla type vals 0 Mla type HFILL hf h245 mlrej type type h245 type FTUIN T32 BASEDECVALS h245 Mlrej type vals 0 Mlrej type HFILL hf h245 maintloop rej cause cause h245 cause FTUIN T32 BASEDECVALS h245 Maintenance Loop Reject Cause vals 0 Maintenance Loop Reject Cause HFILL hf h245 can Not Perform Loop can Not Perform Loop h245 can Not Perform Loop element FTNONEBASENONENULL 0 NULLHFILL hf h245 communication Mode Table communication Mode Table h245 communication Mode Table FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Communication Mode Table Entry HFILL hf h245 communication Mode Table item Communication Mode Table Entry h245 Communication Mode Table Entry element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Label terminal Label h245 terminal Label element FTNONEBASENONENULL 0 NULLHFILL hf h245 session Description session Description h245 session Description FTSTRINGBASENONENULL 0 BMP String SIZE 1 128 HFILL hf h245 entry Data Type data Type h245 data Type FTUIN T32 BASEDECVALS h245 T entry Data Type vals 0 T entry Data Type HFILL hf h245 cm media Channel media Channel h245 media Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Cm media Channel HFILL hf h245 cm media Control Channel media Control Channel h245 media Control Channel FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Transport Address HFILL hf h245 session Dependency session Dependency h245 session Dependency FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 terminal List Request terminal List Request h245 terminal List Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 make Me Chair make Me Chair h245 make Me Chair element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Make Me Chair cancel Make Me Chair h245 cancel Make Me Chair element FTNONEBASENONENULL 0 NULLHFILL hf h245 drop Terminal drop Terminal h245 drop Terminal element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 request Terminal ID request Terminal ID h245 request Terminal ID element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 enter H243 Password enter H243 Password h245 enter H243 Password element FTNONEBASENONENULL 0 NULLHFILL hf h245 enter H243 Terminal ID enter H243 Terminal ID h245 enter H243 Terminal ID element FTNONEBASENONENULL 0 NULLHFILL hf h245 enter H243 Conference ID enter H243 Conference ID h245 enter H243 Conference ID element FTNONEBASENONENULL 0 NULLHFILL hf h245 enter Extension Address enter Extension Address h245 enter Extension Address element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Chair Token Owner request Chair Token Owner h245 request Chair Token Owner element FTNONEBASENONENULL 0 NULLHFILL hf h245 request Terminal Certificate request Terminal Certificate h245 request Terminal Certificate element FTNONEBASENONENULL 0 NULLHFILL hf h245 cert Selection Criteria cert Selection Criteria h245 cert Selection Criteria FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 s Random s Random h245 s Random FTUIN T32 BASEDECNULL 0 INTEGER 1 4294967295 HFILL hf h245 broadcast My Logical Channel broadcast My Logical Channel h245 broadcast My Logical Channel FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 make Terminal Broadcaster make Terminal Broadcaster h245 make Terminal Broadcaster element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 send This Source send This Source h245 send This Source element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 request All Terminal I Ds request All Terminal I Ds h245 request All Terminal I Ds element FTNONEBASENONENULL 0 NULLHFILL hf h245 remote MC Request remote MC Request h245 remote MC Request FTUIN T32 BASEDECVALS h245 Remote MC Request vals 0 NULLHFILL hf h245 Cert Selection Criteria item Criteria h245 Criteria element FTNONEBASENONENULL 0 NULLHFILL hf h245 field field h245 field FTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 criteria Value value h245 value FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 65535 HFILL hf h245 mcu Number mcu Number h245 mcu Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 terminal Number terminal Number h245 terminal Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 m C Terminal ID Response m C Terminal ID Response h245 m C Terminal ID Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal ID terminal ID h245 terminal IDFTBYTESBASENONENULL 0 NULLHFILL hf h245 terminal ID Response terminal ID Response h245 terminal ID Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference ID Response conference ID Response h245 conference ID Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference ID conference ID h245 conference IDFTBYTESBASENONENULL 0 NULLHFILL hf h245 password Response password Response h245 password Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 password password h245 password FTBYTESBASENONENULL 0 NULLHFILL hf h245 terminal List Response terminal List Response h245 terminal List Response FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Terminal Label HFILL hf h245 terminal List Response item Terminal Label h245 Terminal Label element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Command Reject video Command Reject h245 video Command Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Drop Reject terminal Drop Reject h245 terminal Drop Reject element FTNONEBASENONENULL 0 NULLHFILL hf h245 make Me Chair Response make Me Chair Response h245 make Me Chair Response FTUIN T32 BASEDECVALS h245 T make Me Chair Response vals 0 NULLHFILL hf h245 granted Chair Token granted Chair Token h245 granted Chair Token element FTNONEBASENONENULL 0 NULLHFILL hf h245 denied Chair Token denied Chair Token h245 denied Chair Token element FTNONEBASENONENULL 0 NULLHFILL hf h245 extension Address Response extension Address Response h245 extension Address Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 extension Address extension Address h245 extension Address FTBYTESBASENONENULL 0 Terminal IDHFILL hf h245 chair Token Owner Response chair Token Owner Response h245 chair Token Owner Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal Certificate Response terminal Certificate Response h245 terminal Certificate Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 certificate Response certificate Response h245 certificate Response FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 65535 HFILL hf h245 broadcast My Logical Channel Response broadcast My Logical Channel Response h245 broadcast My Logical Channel Response FTUIN T32 BASEDECVALS h245 T broadcast My Logical Channel Response vals 0 NULLHFILL hf h245 granted Broadcast My Logical Channel granted Broadcast My Logical Channel h245 granted Broadcast My Logical Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 denied Broadcast My Logical Channel denied Broadcast My Logical Channel h245 denied Broadcast My Logical Channel element FTNONEBASENONENULL 0 NULLHFILL hf h245 make Terminal Broadcaster Response make Terminal Broadcaster Response h245 make Terminal Broadcaster Response FTUIN T32 BASEDECVALS h245 T make Terminal Broadcaster Response vals 0 NULLHFILL hf h245 granted Make Terminal Broadcaster granted Make Terminal Broadcaster h245 granted Make Terminal Broadcaster element FTNONEBASENONENULL 0 NULLHFILL hf h245 denied Make Terminal Broadcaster denied Make Terminal Broadcaster h245 denied Make Terminal Broadcaster element FTNONEBASENONENULL 0 NULLHFILL hf h245 send This Source Response send This Source Response h245 send This Source Response FTUIN T32 BASEDECVALS h245 T send This Source Response vals 0 NULLHFILL hf h245 granted Send This Source granted Send This Source h245 granted Send This Source element FTNONEBASENONENULL 0 NULLHFILL hf h245 denied Send This Source denied Send This Source h245 denied Send This Source element FTNONEBASENONENULL 0 NULLHFILL hf h245 request All Terminal I Ds Response request All Terminal I Ds Response h245 request All Terminal I Ds Response element FTNONEBASENONENULL 0 NULLHFILL hf h245 remote MC Response remote MC Response h245 remote MC Response FTUIN T32 BASEDECVALS h245 Remote MC Response vals 0 NULLHFILL hf h245 terminal Information terminal Information h245 terminal Information FTUIN T32 BASEDECNULL 0 SEQUENCEOF Terminal Information HFILL hf h245 terminal Information item Terminal Information h245 Terminal Information element FTNONEBASENONENULL 0 NULLHFILL hf h245 master Activate master Activate h245 master Activate element FTNONEBASENONENULL 0 NULLHFILL hf h245 slave Activate slave Activate h245 slave Activate element FTNONEBASENONENULL 0 NULLHFILL hf h245 de Activate de Activate h245 de Activate element FTNONEBASENONENULL 0 NULLHFILL hf h245 accept accept h245 accept element FTNONEBASENONENULL 0 NULLHFILL hf h245 reject reject h245 reject FTUIN T32 BASEDECVALS h245 T reject vals 0 NULLHFILL hf h245 function Not Supported Flag function Not Supported h245 function Not Supported element FTNONEBASENONENULL 0 NULLHFILL hf h245 call Information Req call Information h245 call Information element FTNONEBASENONENULL 0 Call Information Req HFILL hf h245 max Number Of Additional Connections max Number Of Additional Connections h245 max Number Of Additional Connections FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 add Connection Req add Connection h245 add Connection element FTNONEBASENONENULL 0 Add Connection Req HFILL hf h245 dialing Information dialing Information h245 dialing Information FTUIN T32 BASEDECVALS h245 Dialing Information vals 0 NULLHFILL hf h245 remove Connection Req remove Connection h245 remove Connection element FTNONEBASENONENULL 0 Remove Connection Req HFILL hf h245 connection Identifier connection Identifier h245 connection Identifier element FTNONEBASENONENULL 0 NULLHFILL hf h245 maximum Header Interval Req maximum Header Interval h245 maximum Header Interval element FTNONEBASENONENULL 0 Maximum Header Interval Req HFILL hf h245 request Type request Type h245 request Type FTUIN T32 BASEDECVALS h245 T request Type vals 0 NULLHFILL hf h245 current Interval Information current Interval Information h245 current Interval Information element FTNONEBASENONENULL 0 NULLHFILL hf h245 requested Interval requested Interval h245 requested Interval FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 call Information Resp call Information h245 call Information element FTNONEBASENONENULL 0 Call Information Resp HFILL hf h245 call Association Number call Association Number h245 call Association Number FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 add Connection Resp add Connection h245 add Connection element FTNONEBASENONENULL 0 Add Connection Resp HFILL hf h245 response Code response Code h245 response Code FTUIN T32 BASEDECVALS h245 T response Code vals 0 NULLHFILL hf h245 accepted accepted h245 accepted element FTNONEBASENONENULL 0 NULLHFILL hf h245 rejected rejected h245 rejected FTUIN T32 BASEDECVALS h245 T rejected vals 0 NULLHFILL hf h245 connections Not Available connections Not Available h245 connections Not Available element FTNONEBASENONENULL 0 NULLHFILL hf h245 user Rejected user Rejected h245 user Rejected element FTNONEBASENONENULL 0 NULLHFILL hf h245 remove Connection Resp remove Connection h245 remove Connection element FTNONEBASENONENULL 0 Remove Connection Resp HFILL hf h245 maximum Header Interval Resp maximum Header Interval h245 maximum Header Interval element FTNONEBASENONENULL 0 Maximum Header Interval Resp HFILL hf h245 current Interval current Interval h245 current Interval FTUIN T32 BASEDECNULL 0 INTEGER 0 65535 HFILL hf h245 crc Desired crc Desired h245 crc Desired element FTNONEBASENONENULL 0 NULLHFILL hf h245 excessive Error excessive Error h245 excessive Error element FTNONEBASENONENULL 0 NULLHFILL hf h245 differential differential h245 differential FTUIN T32 BASEDECNULL 0 SETSIZE 1 65535 OF Dialing Information Number HFILL hf h245 differential item Dialing Information Number h245 Dialing Information Number element FTNONEBASENONENULL 0 NULLHFILL hf h245 info Not Available info Not Available h245 info Not Available FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 network Address Num network Address h245 network Address FTSTRINGBASENONENULL 0 Numeric String SIZE 0 40 HFILL hf h245 sub Address sub Address h245 sub Address FTSTRINGBASENONENULL 0 I A5 String SIZE 1 40 HFILL hf h245 network Type network Type h245 network Type FTUIN T32 BASEDECNULL 0 SETSIZE 1 255 OF Dialing Information Network Type HFILL hf h245 network Type item Dialing Information Network Type h245 Dialing Information Network Type FTUIN T32 BASEDECVALS h245 Dialing Information Network Type vals 0 NULLHFILL hf h245 n isdn n isdn h245 n isdn element FTNONEBASENONENULL 0 NULLHFILL hf h245 gstn gstn h245 gstn element FTNONEBASENONENULL 0 NULLHFILL hf h245 mobile mobile h245 mobile element FTNONEBASENONENULL 0 NULLHFILL hf h245 channel Tag channel Tag h245 channel Tag FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 sequence Num sequence Number h245 sequence Number FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 maximum Bit Rate maximum Bit Rate h245 maximum Bit Rate FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 reject Reason reject Reason h245 reject Reason FTUIN T32 BASEDECVALS h245 Logical Channel Rate Reject Reason vals 0 Logical Channel Rate Reject Reason HFILL hf h245 current Maximum Bit Rate current Maximum Bit Rate h245 current Maximum Bit Rate FTUIN T32 BASEDECNULL 0 Maximum Bit Rate HFILL hf h245 undefined Reason undefined Reason h245 undefined Reason element FTNONEBASENONENULL 0 NULLHFILL hf h245 insufficient Resources insufficient Resources h245 insufficient Resources element FTNONEBASENONENULL 0 NULLHFILL hf h245 specific Request specific Request h245 specific Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 multiplex Capability Bool multiplex Capability h245 multiplex Capability FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 capability Table Entry Numbers capability Table Entry Numbers h245 capability Table Entry Numbers FTUIN T32 BASEDECNULL 0 SETSIZE 1 65535 OF Capability Table Entry Number HFILL hf h245 capability Table Entry Numbers item Capability Table Entry Number h245 Capability Table Entry Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 capability Descriptor Numbers capability Descriptor Numbers h245 capability Descriptor Numbers FTUIN T32 BASEDECNULL 0 SETSIZE 1 256 OF Capability Descriptor Number HFILL hf h245 capability Descriptor Numbers item Capability Descriptor Number h245 Capability Descriptor Number FTUIN T32 BASEDECNULL 0 NULLHFILL hf h245 generic Request Flag generic Request h245 generic Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 encryption SE encryption SE h245 encryption SEFTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 encryption IV Request encryption IV Request h245 encryption IV Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 encryption Algorithm ID encryption Algorithm ID h245 encryption Algorithm ID element FTNONEBASENONENULL 0 NULLHFILL hf h245 h233 Algorithm Identifier h233 Algorithm Identifier h245 h233 Algorithm Identifier FTUIN T32 BASEDECNULL 0 Sequence Number HFILL hf h245 associated Algorithm associated Algorithm h245 associated Algorithm element FTNONEBASENONENULL 0 Non Standard Parameter HFILL hf h245 whole Multiplex whole Multiplex h245 whole Multiplex element FTNONEBASENONENULL 0 NULLHFILL hf h245 scope scope h245 scope FTUIN T32 BASEDECVALS h245 Scope vals 0 NULLHFILL hf h245 res maximum Bit Rate maximum Bit Rate h245 maximum Bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 0 16777215 HFILL hf h245 no Restriction no Restriction h245 no Restriction element FTNONEBASENONENULL 0 NULLHFILL hf h245 restriction restriction h245 restriction FTUIN T32 BASEDECVALS h245 Restriction vals 0 NULLHFILL hf h245 disconnect disconnect h245 disconnect element FTNONEBASENONENULL 0 NULLHFILL hf h245 gstn Options gstn Options h245 gstn Options FTUIN T32 BASEDECVALS h245 T gstn Options vals 0 NULLHFILL hf h245 telephony Mode telephony Mode h245 telephony Mode element FTNONEBASENONENULL 0 NULLHFILL hf h245 v8bis v8bis h245 v8bis element FTNONEBASENONENULL 0 NULLHFILL hf h245 v34 DSVD v34 DSVD h245 v34 DSVD element FTNONEBASENONENULL 0 NULLHFILL hf h245 v34 Duplex FAX v34 Duplex FAX h245 v34 Duplex FAX element FTNONEBASENONENULL 0 NULLHFILL hf h245 v34 H324 v34 H324 h245 v34 H324 element FTNONEBASENONENULL 0 NULLHFILL hf h245 isdn Options isdn Options h245 isdn Options FTUIN T32 BASEDECVALS h245 T isdn Options vals 0 NULLHFILL hf h245 v140 v140 h245 v140 element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal On Hold terminal On Hold h245 terminal On Hold element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Broadcast My Logical Channel cancel Broadcast My Logical Channel h245 cancel Broadcast My Logical Channel FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 cancel Make Terminal Broadcaster cancel Make Terminal Broadcaster h245 cancel Make Terminal Broadcaster element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Send This Source cancel Send This Source h245 cancel Send This Source element FTNONEBASENONENULL 0 NULLHFILL hf h245 drop Conference drop Conference h245 drop Conference element FTNONEBASENONENULL 0 NULLHFILL hf h245 substitute Conference ID Command substitute Conference ID Command h245 substitute Conference ID Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 conference Identifier conference Identifier h245 conference Identifier FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 16 HFILL hf h245 master To Slave master To Slave h245 master To Slave element FTNONEBASENONENULL 0 NULLHFILL hf h245 slave To Master slave To Master h245 slave To Master element FTNONEBASENONENULL 0 NULLHFILL hf h245 mc type type h245 type FTUIN T32 BASEDECVALS h245 Mc type vals 0 Mc type HFILL hf h245 equalise Delay equalise Delay h245 equalise Delay element FTNONEBASENONENULL 0 NULLHFILL hf h245 zero Delay zero Delay h245 zero Delay element FTNONEBASENONENULL 0 NULLHFILL hf h245 multipoint Mode Command multipoint Mode Command h245 multipoint Mode Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Multipoint Mode Command cancel Multipoint Mode Command h245 cancel Multipoint Mode Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Freeze Picture video Freeze Picture h245 video Freeze Picture element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Fast Update Picture video Fast Update Picture h245 video Fast Update Picture element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Fast Update GOB video Fast Update GOB h245 video Fast Update GOB element FTNONEBASENONENULL 0 NULLHFILL hf h245 first GOB first GOB h245 first GOBFTUIN T32 BASEDECNULL 0 INTEGER 0 17 HFILL hf h245 number Of GO Bs number Of GO Bs h245 number Of GO Bs FTUIN T32 BASEDECNULL 0 INTEGER 1 18 HFILL hf h245 video Temporal Spatial Trade Off video Temporal Spatial Trade Off h245 video Temporal Spatial Trade Off FTUIN T32 BASEDECNULL 0 INTEGER 0 31 HFILL hf h245 video Send Sync Every GOB video Send Sync Every GOB h245 video Send Sync Every GOB element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Send Sync Every GOB Cancel video Send Sync Every GOB Cancel h245 video Send Sync Every GOB Cancel element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Fast Update MB video Fast Update MB h245 video Fast Update MB element FTNONEBASENONENULL 0 NULLHFILL hf h245 first GOB 0 255 first GOB h245 first GOBFTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 first MB 1 8192 first MB h245 first MBFTUIN T32 BASEDECNULL 0 INTEGER 1 8192 HFILL hf h245 number Of M Bs number Of M Bs h245 number Of M Bs FTUIN T32 BASEDECNULL 0 INTEGER 1 8192 HFILL hf h245 max H223 MUXPD Usize max H223 MUXPD Usize h245 max H223 MUXPD Usize FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 encryption Update encryption Update h245 encryption Update element FTNONEBASENONENULL 0 Encryption Sync HFILL hf h245 encryption Update Request encryption Update Request h245 encryption Update Request element FTNONEBASENONENULL 0 NULLHFILL hf h245 switch Receive Media Off switch Receive Media Off h245 switch Receive Media Off element FTNONEBASENONENULL 0 NULLHFILL hf h245 switch Receive Media On switch Receive Media On h245 switch Receive Media On element FTNONEBASENONENULL 0 NULLHFILL hf h245 progressive Refinement Start progressive Refinement Start h245 progressive Refinement Start element FTNONEBASENONENULL 0 NULLHFILL hf h245 repeat Count repeat Count h245 repeat Count FTUIN T32 BASEDECVALS h245 T repeat Count vals 0 NULLHFILL hf h245 do One Progression do One Progression h245 do One Progression element FTNONEBASENONENULL 0 NULLHFILL hf h245 do Continuous Progressions do Continuous Progressions h245 do Continuous Progressions element FTNONEBASENONENULL 0 NULLHFILL hf h245 do One Independent Progression do One Independent Progression h245 do One Independent Progression element FTNONEBASENONENULL 0 NULLHFILL hf h245 do Continuous Independent Progressions do Continuous Independent Progressions h245 do Continuous Independent Progressions element FTNONEBASENONENULL 0 NULLHFILL hf h245 progressive Refinement Abort One progressive Refinement Abort One h245 progressive Refinement Abort One element FTNONEBASENONENULL 0 NULLHFILL hf h245 progressive Refinement Abort Continuous progressive Refinement Abort Continuous h245 progressive Refinement Abort Continuous element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Bad M Bs video Bad M Bs h245 video Bad M Bs element FTNONEBASENONENULL 0 NULLHFILL hf h245 first MB first MB h245 first MBFTUIN T32 BASEDECNULL 0 INTEGER 1 9216 HFILL hf h245 number Of M Bs1 1 9216 number Of M Bs h245 number Of M Bs FTUIN T32 BASEDECNULL 0 INTEGER 1 9216 HFILL hf h245 temporal Reference temporal Reference h245 temporal Reference FTUIN T32 BASEDECNULL 0 INTEGER 0 1023 HFILL hf h245 lost Picture lost Picture h245 lost Picture FTUIN T32 BASEDECNULL 0 SEQUENCEOF Picture Reference HFILL hf h245 lost Picture item Picture Reference h245 Picture Reference FTUIN T32 BASEDECVALS h245 Picture Reference vals 0 NULLHFILL hf h245 lost Partial Picture lost Partial Picture h245 lost Partial Picture element FTNONEBASENONENULL 0 NULLHFILL hf h245 picture Reference picture Reference h245 picture Reference FTUIN T32 BASEDECVALS h245 Picture Reference vals 0 NULLHFILL hf h245 recovery Reference Picture recovery Reference Picture h245 recovery Reference Picture FTUIN T32 BASEDECNULL 0 SEQUENCEOF Picture Reference HFILL hf h245 recovery Reference Picture item Picture Reference h245 Picture Reference FTUIN T32 BASEDECVALS h245 Picture Reference vals 0 NULLHFILL hf h245 encryption Update Command encryption Update Command h245 encryption Update Command element FTNONEBASENONENULL 0 NULLHFILL hf h245 encryption Update Ack encryption Update Ack h245 encryption Update Ack element FTNONEBASENONENULL 0 NULLHFILL hf h245 direction direction h245 direction FTUIN T32 BASEDECVALS h245 Encryption Update Direction vals 0 Encryption Update Direction HFILL hf h245 secure Channel secure Channel h245 secure Channel FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 shared Secret shared Secret h245 shared Secret FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 cert Protected Key cert Protected Key h245 cert Protected Key FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 key Protection Method key Protection Method h245 key Protection Method element FTNONEBASENONENULL 0 NULLHFILL hf h245 picture Number picture Number h245 picture Number FTUIN T32 BASEDECNULL 0 INTEGER 0 1023 HFILL hf h245 long Term Picture Index long Term Picture Index h245 long Term Picture Index FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 h223 Mode Change h223 Mode Change h245 h223 Mode Change FTUIN T32 BASEDECVALS h245 T h223 Mode Change vals 0 NULLHFILL hf h245 to Level0 to Level0 h245 to Level0 element FTNONEBASENONENULL 0 NULLHFILL hf h245 to Level1 to Level1 h245 to Level1 element FTNONEBASENONENULL 0 NULLHFILL hf h245 to Level2 to Level2 h245 to Level2 element FTNONEBASENONENULL 0 NULLHFILL hf h245 to Level2with Optional Header to Level2with Optional Header h245 to Level2with Optional Header element FTNONEBASENONENULL 0 NULLHFILL hf h245 h223 Annex A Double Flag h223 Annex A Double Flag h245 h223 Annex A Double Flag FTUIN T32 BASEDECVALS h245 T h223 Annex A Double Flag vals 0 NULLHFILL hf h245 start start h245 start element FTNONEBASENONENULL 0 NULLHFILL hf h245 stop stop h245 stop element FTNONEBASENONENULL 0 NULLHFILL hf h245 bit Rate bit Rate h245 bit Rate FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 bit Rate Locked To PCR Clock bit Rate Locked To PCR Clock h245 bit Rate Locked To PCR Clock FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 bit Rate Locked To Network Clock bit Rate Locked To Network Clock h245 bit Rate Locked To Network Clock FTBOOLEANBASENONENULL 0 BOOLEANHFILL hf h245 cmd aal aal h245 aal FTUIN T32 BASEDECVALS h245 Cmd aal vals 0 Cmd aal HFILL hf h245 cmd aal1 aal1 h245 aal1 element FTNONEBASENONENULL 0 Cmd aal1 HFILL hf h245 cmd clock Recovery clock Recovery h245 clock Recovery FTUIN T32 BASEDECVALS h245 Cmd clock Recovery vals 0 Cmd clock Recovery HFILL hf h245 null Clock Recoveryflag null Clock Recovery h245 null Clock Recovery element FTNONEBASENONENULL 0 NULLHFILL hf h245 srts Clock Recovery srts Clock Recovery h245 srts Clock Recovery element FTNONEBASENONENULL 0 NULLHFILL hf h245 adaptive Clock Recovery Flag adaptive Clock Recovery h245 adaptive Clock Recovery element FTNONEBASENONENULL 0 NULLHFILL hf h245 cmd error Correction error Correction h245 error Correction FTUIN T32 BASEDECVALS h245 Cmd error Correction vals 0 Cmd error Correction HFILL hf h245 null Error Correction Flag null Error Correction h245 null Error Correction element FTNONEBASENONENULL 0 NULLHFILL hf h245 long Interleaver Flag long Interleaver h245 long Interleaver element FTNONEBASENONENULL 0 NULLHFILL hf h245 short Interleaver Flag short Interleaver h245 short Interleaver element FTNONEBASENONENULL 0 NULLHFILL hf h245 error Correction Only Flag error Correction Only h245 error Correction Only element FTNONEBASENONENULL 0 NULLHFILL hf h245 cmd aal5 aal5 h245 aal5 element FTNONEBASENONENULL 0 Cmd aal5 HFILL hf h245 cmd multiplex multiplex h245 multiplex FTUIN T32 BASEDECVALS h245 Cmd multiplex vals 0 Cmd multiplex HFILL hf h245 no Multiplex no Multiplex h245 no Multiplex element FTNONEBASENONENULL 0 NULLHFILL hf h245 transport Stream transport Stream h245 transport Stream element FTNONEBASENONENULL 0 NULLHFILL hf h245 program Stream Flag program Stream h245 program Stream element FTNONEBASENONENULL 0 NULLHFILL hf h245 cmd reverse Parameters reverse Parameters h245 reverse Parameters element FTNONEBASENONENULL 0 Cmd reverse Parameters HFILL hf h245 cmdr multiplex multiplex h245 multiplex FTUIN T32 BASEDECVALS h245 Cmd R multiplex vals 0 Cmd R multiplex HFILL hf h245 sample Size sample Size h245 sample Size FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 samples Per Frame samples Per Frame h245 samples Per Frame FTUIN T32 BASEDECNULL 0 INTEGER 1 255 HFILL hf h245 status status h245 status FTUIN T32 BASEDECVALS h245 T status vals 0 NULLHFILL hf h245 synchronized synchronized h245 synchronized element FTNONEBASENONENULL 0 NULLHFILL hf h245 reconfiguration reconfiguration h245 reconfiguration element FTNONEBASENONENULL 0 NULLHFILL hf h245 fns cause cause h245 cause FTUIN T32 BASEDECVALS h245 Function Not Supported Cause vals 0 Function Not Supported Cause HFILL hf h245 syntax Error syntax Error h245 syntax Error element FTNONEBASENONENULL 0 NULLHFILL hf h245 semantic Error semantic Error h245 semantic Error element FTNONEBASENONENULL 0 NULLHFILL hf h245 unknown Function unknown Function h245 unknown Function element FTNONEBASENONENULL 0 NULLHFILL hf h245 returned Function returned Function h245 returned Function FTBYTESBASENONENULL 0 NULLHFILL hf h245 sbe Number sbe Number h245 sbe Number FTUIN T32 BASEDECNULL 0 INTEGER 0 9 HFILL hf h245 terminal Number Assign terminal Number Assign h245 terminal Number Assign element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 terminal Joined Conference terminal Joined Conference h245 terminal Joined Conference element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 terminal Left Conference terminal Left Conference h245 terminal Left Conference element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 seen By At Least One Other seen By At Least One Other h245 seen By At Least One Other element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Seen By At Least One Other cancel Seen By At Least One Other h245 cancel Seen By At Least One Other element FTNONEBASENONENULL 0 NULLHFILL hf h245 seen By All seen By All h245 seen By All element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Seen By All cancel Seen By All h245 cancel Seen By All element FTNONEBASENONENULL 0 NULLHFILL hf h245 terminal You Are Seeing terminal You Are Seeing h245 terminal You Are Seeing element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 request For Floor request For Floor h245 request For Floor element FTNONEBASENONENULL 0 NULLHFILL hf h245 withdraw Chair Token withdraw Chair Token h245 withdraw Chair Token element FTNONEBASENONENULL 0 NULLHFILL hf h245 floor Requested floor Requested h245 floor Requested element FTNONEBASENONENULL 0 Terminal Label HFILL hf h245 terminal You Are Seeing In Sub Picture Number terminal You Are Seeing In Sub Picture Number h245 terminal You Are Seeing In Sub Picture Number element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Indicate Compose video Indicate Compose h245 video Indicate Compose element FTNONEBASENONENULL 0 NULLHFILL hf h245 master MCU master MCU h245 master MCU element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Master MCU cancel Master MCU h245 cancel Master MCU element FTNONEBASENONENULL 0 NULLHFILL hf h245 sub Picture Number sub Picture Number h245 sub Picture Number FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 composition Number composition Number h245 composition Number FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 mi type type h245 type FTUIN T32 BASEDECVALS h245 Mi type vals 0 Mi type HFILL hf h245 logical Channel Active logical Channel Active h245 logical Channel Active element FTNONEBASENONENULL 0 NULLHFILL hf h245 logical Channel Inactive logical Channel Inactive h245 logical Channel Inactive element FTNONEBASENONENULL 0 NULLHFILL hf h245 multipoint Conference multipoint Conference h245 multipoint Conference element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Multipoint Conference cancel Multipoint Conference h245 cancel Multipoint Conference element FTNONEBASENONENULL 0 NULLHFILL hf h245 multipoint Zero Comm multipoint Zero Comm h245 multipoint Zero Comm element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Multipoint Zero Comm cancel Multipoint Zero Comm h245 cancel Multipoint Zero Comm element FTNONEBASENONENULL 0 NULLHFILL hf h245 multipoint Secondary Status multipoint Secondary Status h245 multipoint Secondary Status element FTNONEBASENONENULL 0 NULLHFILL hf h245 cancel Multipoint Secondary Status cancel Multipoint Secondary Status h245 cancel Multipoint Secondary Status element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Indicate Ready To Activate video Indicate Ready To Activate h245 video Indicate Ready To Activate element FTNONEBASENONENULL 0 NULLHFILL hf h245 video Not Decoded M Bs video Not Decoded M Bs h245 video Not Decoded M Bs element FTNONEBASENONENULL 0 NULLHFILL hf h245 temporal Reference 0 255 temporal Reference h245 temporal Reference FTUIN T32 BASEDECNULL 0 INTEGER 0 255 HFILL hf h245 estimated Received Jitter Mantissa estimated Received Jitter Mantissa h245 estimated Received Jitter Mantissa FTUIN T32 BASEDECNULL 0 INTEGER 0 3 HFILL hf h245 estimated Received Jitter Exponent estimated Received Jitter Exponent h245 estimated Received Jitter Exponent FTUIN T32 BASEDECNULL 0 INTEGER 0 7 HFILL hf h245 skipped Frame Count skipped Frame Count h245 skipped Frame Count FTUIN T32 BASEDECNULL 0 INTEGER 0 15 HFILL hf h245 additional Decoder Buffer additional Decoder Buffer h245 additional Decoder Buffer FTUIN T32 BASEDECNULL 0 INTEGER 0 262143 HFILL hf h245 logical Channel Number1 logical Channel Number1 h245 logical Channel Number1 FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 logical Channel Number2 logical Channel Number2 h245 logical Channel Number2 FTUIN T32 BASEDECNULL 0 Logical Channel Number HFILL hf h245 skew skew h245 skew FTUIN T32 BASEDECNULL 0 INTEGER 0 4095 HFILL hf h245 maximum Skew maximum Skew h245 maximum Skew FTUIN T32 BASEDECNULL 0 INTEGER 0 4095 HFILL hf h245 signal Address signal Address h245 signal Address FTUIN T32 BASEDECVALS h245 Transport Address vals 0 Transport Address HFILL hf h245 vendor vendor h245 vendor FTUIN T32 BASEDECVALS h245 Non Standard Identifier vals 0 Non Standard Identifier HFILL hf h245 product Number product Number h245 product Number FTSTRINGBASENONENULL 0 OCTETSTRINGSIZE 1 256 HFILL hf h245 version Number version Number h245 version Number FTSTRINGBASENONENULL 0 OCTETSTRINGSIZE 1 256 HFILL hf h245 ind aal aal h245 aal FTUIN T32 BASEDECVALS h245 Ind aal vals 0 Ind aal HFILL hf h245 ind aal1 aal1 h245 aal1 element FTNONEBASENONENULL 0 Ind aal1 HFILL hf h245 ind clock Recovery clock Recovery h245 clock Recovery FTUIN T32 BASEDECVALS h245 Ind clock Recovery vals 0 Ind clock Recovery HFILL hf h245 ind error Correction error Correction h245 error Correction FTUIN T32 BASEDECVALS h245 Ind error Correction vals 0 Ind error Correction HFILL hf h245 ind aal5 aal5 h245 aal5 element FTNONEBASENONENULL 0 Ind aal5 HFILL hf h245 ind multiplex multiplex h245 multiplex FTUIN T32 BASEDECVALS h245 Ind multiplex vals 0 Ind multiplex HFILL hf h245 ind reverse Parameters reverse Parameters h245 reverse Parameters element FTNONEBASENONENULL 0 Ind reverse Parameters HFILL hf h245 indr multiplex multiplex h245 multiplex FTUIN T32 BASEDECVALS h245 Ind R multiplex vals 0 Ind R multiplex HFILL hf h245 iv8 iv8 h245 iv8 FTBYTESBASENONENULL 0 NULLHFILL hf h245 iv16 iv16 h245 iv16 FTBYTESBASENONENULL 0 NULLHFILL hf h245 iv iv h245 iv FTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 alphanumeric alphanumeric h245 alphanumeric FTSTRINGBASENONENULL 0 General String HFILL hf h245 user Input Support Indication user Input Support Indication h245 user Input Support Indication FTUIN T32 BASEDECVALS h245 T user Input Support Indication vals 0 NULLHFILL hf h245 signal signal h245 signal element FTNONEBASENONENULL 0 NULLHFILL hf h245 signal Type signal Type h245 signal Type FTSTRINGBASENONENULL 0 NULLHFILL hf h245 duration duration h245 duration FTUIN T32 BASEDECNULL 0 INTEGER 1 65535 HFILL hf h245 rtp rtp h245 rtp element FTNONEBASENONENULL 0 NULLHFILL hf h245 timestamp timestamp h245 timestamp FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 expiration Time expiration Time h245 expiration Time FTUIN T32 BASEDECNULL 0 INTEGER 0 4294967295 HFILL hf h245 rtp Payload Indication rtp Payload Indication h245 rtp Payload Indication element FTNONEBASENONENULL 0 NULLHFILL hf h245 param S param S h245 param S element FTNONEBASENONENULL 0 NULLHFILL hf h245 encrypted Signal Type encrypted Signal Type h245 encrypted Signal Type FTBYTESBASENONENULL 0 OCTETSTRINGSIZE 1 HFILL hf h245 algorithm OID algorithm OID h245 algorithm OIDFTOIDBASENONENULL 0 OBJECTIDENTIFIERHFILL hf h245 signal Update signal Update h245 signal Update element FTNONEBASENONENULL 0 NULLHFILL hf h245 si rtp rtp h245 rtp element FTNONEBASENONENULL 0 Si rtp HFILL hf h245 extended Alphanumeric extended Alphanumeric h245 extended Alphanumeric element FTNONEBASENONENULL 0 NULLHFILL hf h245 encrypted encrypted h245 encrypted FTBYTESBASENONENULL 0 OCTETSTRINGHFILL hf h245 encrypted Alphanumeric encrypted Alphanumeric h245 encrypted Alphanumeric element FTNONEBASENONENULL 0 NULLHFILL line 487 asn1 h245 packet h245 template c static gint ett ett h245 ett h245 returned Function line 1 asn1 h245 packet h245 ettarr c ett h245 Multimedia System Control Message ett h245 Request Message ett h245 Response Message ett h245 Command Message ett h245 Indication Message ett h245 Generic Message ett h245 T message Content ett h245 Non Standard Message ett h245 Non Standard Parameter ett h245 Non Standard Identifier ett h245 H221 Non Standard ID ett h245 Master Slave Determination ett h245 Master Slave Determination Ack ett h245 T decision ett h245 Master Slave Determination Reject ett h245 Master Slave Determination Reject Cause ett h245 Master Slave Determination Release ett h245 Terminal Capability Set ett h245 SETSIZE 1 256 OF Capability Table Entry ett h245 SETSIZE 1 256 OF Capability Descriptor ett h245 SEQUENCEOF Generic Information ett h245 Capability Table Entry ett h245 Capability Descriptor ett h245 SETSIZE 1 256 OF Alternative Capability Set ett h245 Alternative Capability Set ett h245 Terminal Capability Set Ack ett h245 Terminal Capability Set Reject ett h245 Terminal Capability Set Reject Cause ett h245 T table Entry Capacity Exceeded ett h245 Terminal Capability Set Release ett h245 Capability ett h245 T h233 Encryption Receive Capability ett h245 H235 Security Capability ett h245 Multiplex Capability ett h245 H222 Capability ett h245 SETOFVC Capability ett h245 VC Capability ett h245 T aal1 ett h245 T aal5 ett h245 T available Bit Rates ett h245 Avb type ett h245 T range Of Bit Rates ett h245 T aal1 Via Gateway ett h245 SETSIZE 1 256 OF Q2931 Address ett h245 H223 Capability ett h245 T h223 Multiplex Table Capability ett h245 T enhanced ett h245 T mobile Operation Transmit Capability ett h245 T mobile Multilink Frame Capability ett h245 H223 Annex C Capability ett h245 V76 Capability ett h245 V75 Capability ett h245 H2250 Capability ett h245 T mc Capability ett h245 SEQUENCESIZE 1 256 OF Redundancy Encoding Capability ett h245 Media Packetization Capability ett h245 SEQUENCESIZE 1 256 OFRTP Payload Type ett h245 RSVP Parameters ett h245 QOS Mode ett h245 ATM Parameters ett h245 Service Priority Value ett h245 Service Priority ett h245 Authorization Parameters ett h245 QOS Type ett h245 QOS Class ett h245 QOS Descriptor ett h245 Generic Transport Parameters ett h245 QOS Capability ett h245 Media Transport Type ett h245 T atm AA L5 compressed ett h245 Media Channel Capability ett h245 Transport Capability ett h245 SEQUENCESIZE 1 256 OFQOS Capability ett h245 SEQUENCESIZE 1 256 OF Media Channel Capability ett h245 Redundancy Encoding Capability ett h245 SEQUENCESIZE 1 256 OF Capability Table Entry Number ett h245 Redundancy Encoding Method ett h245 RTP H263 Video Redundancy Encoding ett h245 T frame To Thread Mapping ett h245 SEQUENCESIZE 1 256 OFRTP H263 Video Redundancy Frame Mapping ett h245 T contained Threads ett h245 RTP H263 Video Redundancy Frame Mapping ett h245 T frame Sequence ett h245 Multipoint Capability ett h245 SEQUENCEOF Media Distribution Capability ett h245 Media Distribution Capability ett h245 SEQUENCEOF Data Application Capability ett h245 Video Capability ett h245 Extended Video Capability ett h245 SEQUENCEOF Video Capability ett h245 SEQUENCEOF Generic Capability ett h245 H261 Video Capability ett h245 H262 Video Capability ett h245 H263 Video Capability ett h245 Enhancement Layer Info ett h245 SETSIZE 1 14 OF Enhancement Options ett h245 SETSIZE 1 14 OFB Enhancement Parameters ett h245 B Enhancement Parameters ett h245 Enhancement Options ett h245 H263 Options ett h245 SETSIZE 1 16 OF Custom Picture Clock Frequency ett h245 SETSIZE 1 16 OF Custom Picture Format ett h245 SETSIZE 1 16 OF H263 Video Mode Combos ett h245 Transparency Parameters ett h245 Ref Picture Selection ett h245 T additional Picture Memory ett h245 T video Back Channel Send ett h245 T enhanced Reference Pic Select ett h245 T sub Picture Removal Parameters ett h245 Custom Picture Clock Frequency ett h245 Custom Picture Format ett h245 T m PI ett h245 T custom PCF ett h245 T custom PCF item ett h245 T pixel Aspect Information ett h245 T pixel Aspect Code ett h245 T extended PAR ett h245 T extended PAR item ett h245 H263 Video Mode Combos ett h245 SETSIZE 1 16 OF H263 Mode Combo Flags ett h245 H263 Mode Combo Flags ett h245 H263 Version3 Options ett h245 I S11172 Video Capability ett h245 Audio Capability ett h245 T g7231 ett h245 G729 Extensions ett h245 G7231 Annex C Capability ett h245 G723 Annex C Audio Mode ett h245 I S11172 Audio Capability ett h245 I S13818 Audio Capability ett h245 GSM Audio Capability ett h245 VBD Capability ett h245 Data Application Capability ett h245 Application ett h245 T t84 ett h245 Nlpid ett h245 T t38fax ett h245 Data Protocol Capability ett h245 T v76w Compression ett h245 Compression Type ett h245 V42bis ett h245 T84 Profile ett h245 T t84 Restricted ett h245 T38 Fax Profile ett h245 T38 Fax Rate Management ett h245 T38 Fax Udp Options ett h245 T t38 Fax Udp EC ett h245 T38 Fax Tcp Options ett h245 Encryption Authentication And Integrity ett h245 Encryption Capability ett h245 Media Encryption Algorithm ett h245 Authentication Capability ett h245 Integrity Capability ett h245 User Input Capability ett h245 SEQUENCESIZE 1 16 OF Non Standard Parameter ett h245 Conference Capability ett h245 SEQUENCEOF Non Standard Parameter ett h245 Generic Capability ett h245 T collapsing ett h245 T non Collapsing ett h245 Capability Identifier ett h245 Generic Parameter ett h245 SEQUENCEOF Parameter Identifier ett h245 Parameter Identifier ett h245 Parameter Value ett h245 SEQUENCEOF Generic Parameter ett h245 Multiplexed Stream Capability ett h245 Multiplex Format ett h245 Audio Telephony Event Capability ett h245 Audio Tone Capability ett h245 No PT Audio Telephony Event Capability ett h245 No PT Audio Tone Capability ett h245 Multiple Payload Stream Capability ett h245 Dep FEC Capability ett h245 FECC rfc2733 ett h245 T separate Stream Bool ett h245 FEC Capability ett h245 Rfc2733 Format ett h245 Open Logical Channel ett h245 T forward Logical Channel Parameters ett h245 OLC forw multiplex Parameters ett h245 OLC reverse Logical Channel Parameters ett h245 OLC rev multiplex Parameters ett h245 Network Access Parameters ett h245 T distribution ett h245 T network Address ett h245 T t120 Setup Procedure ett h245 Q2931 Address ett h245 T address ett h245 V75 Parameters ett h245 Data Type ett h245 H235 Media ett h245 T media Type ett h245 Multiplexed Stream Parameter ett h245 H222 Logical Channel Parameters ett h245 H223 Logical Channel Parameters ett h245 T adaptation Layer Type ett h245 Al3 ett h245 H223 A L1 M Parameters ett h245 T transfer Mode ett h245 A L1 Header FEC ett h245 A L1 Crc Length ett h245 Arq Type ett h245 H223 A L2 M Parameters ett h245 A L2 Header FEC ett h245 H223 A L3 M Parameters ett h245 T header Format ett h245 A L3 Crc Length ett h245 H223 Annex C Arq Parameters ett h245 T number Of Retransmissions ett h245 V76 Logical Channel Parameters ett h245 T suspend Resume ett h245 V76 LCP mode ett h245 T e RM ett h245 T recovery ett h245 V76 HDLC Parameters ett h245 CRC Length ett h245 H2250 Logical Channel Parameters ett h245 T media Packetization ett h245 RTP Payload Type ett h245 T payload Descriptor ett h245 Redundancy Encoding ett h245 T rtp Redundancy Encoding ett h245 SEQUENCEOF Redundancy Encoding Element ett h245 Redundancy Encoding Element ett h245 Multiple Payload Stream ett h245 SEQUENCEOF Multiple Payload Stream Element ett h245 Multiple Payload Stream Element ett h245 Dep FEC Data ett h245 RF C2733 Data ett h245 FE Cdata mode ett h245 Dep Separate Stream ett h245 T different Port ett h245 T same Port ett h245 FEC Data ett h245 T rfc2733 ett h245 T pkt Mode ett h245 T mode rfc2733sameport ett h245 T mode rfc2733diffport ett h245 Transport Address ett h245 Unicast Address ett h245 T i P Address ett h245 T i PX Address ett h245 T i P6 Address ett h245 T i P Source Route Address ett h245 T routing ett h245 T route ett h245 Multicast Address ett h245 MIP Address ett h245 MI P6 Address ett h245 Encryption Sync ett h245 SEQUENCESIZE 1 256 OF Escrow Data ett h245 Escrow Data ett h245 Open Logical Channel Ack ett h245 OLC ack reverse Logical Channel Parameters ett h245 T olc ack multiplex Parameters ett h245 T forward Multiplex Ack Parameters ett h245 Open Logical Channel Reject ett h245 Open Logical Channel Reject Cause ett h245 Open Logical Channel Confirm ett h245 H2250 Logical Channel Ack Parameters ett h245 Close Logical Channel ett h245 T c LC source ett h245 Clc reason ett h245 Close Logical Channel Ack ett h245 Request Channel Close ett h245 T reason ett h245 Request Channel Close Ack ett h245 Request Channel Close Reject ett h245 Request Channel Close Reject Cause ett h245 Request Channel Close Release ett h245 Multiplex Entry Send ett h245 SETSIZE 1 15 OF Multiplex Entry Descriptor ett h245 Multiplex Entry Descriptor ett h245 T element List ett h245 Multiplex Element ett h245 Me type ett h245 T sub Element List ett h245 ME repeat Count ett h245 Multiplex Entry Send Ack ett h245 SETSIZE 1 15 OF Multiplex Table Entry Number ett h245 Multiplex Entry Send Reject ett h245 SETSIZE 1 15 OF Multiplex Entry Rejection Descriptions ett h245 Multiplex Entry Rejection Descriptions ett h245 Multiplex Entry Rejection Descriptions Cause ett h245 Multiplex Entry Send Release ett h245 Request Multiplex Entry ett h245 Request Multiplex Entry Ack ett h245 Request Multiplex Entry Reject ett h245 SETSIZE 1 15 OF Request Multiplex Entry Rejection Descriptions ett h245 Request Multiplex Entry Rejection Descriptions ett h245 Request Multiplex Entry Rejection Descriptions Cause ett h245 Request Multiplex Entry Release ett h245 Request Mode ett h245 SEQUENCESIZE 1 256 OF Mode Description ett h245 Request Mode Ack ett h245 Req mode ack response ett h245 Request Mode Reject ett h245 Request Mode Reject Cause ett h245 Request Mode Release ett h245 Mode Description ett h245 Mode Element Type ett h245 Mode Element ett h245 H235 Mode ett h245 T media Mode ett h245 Multiplexed Stream Mode Parameters ett h245 Redundancy Encoding DT Mode ett h245 SEQUENCEOF Redundancy Encoding DT Mode Element ett h245 Redundancy Encoding DT Mode Element ett h245 Re type ett h245 Multiple Payload Stream Mode ett h245 SEQUENCEOF Multiple Payload Stream Element Mode ett h245 Multiple Payload Stream Element Mode ett h245 Dep FEC Mode ett h245 T rfc2733 Mode ett h245 FEC mode ett h245 FEC Mode ett h245 H223 Mode Parameters ett h245 Adaptation Layer Type ett h245 V76 Mode Parameters ett h245 H2250 Mode Parameters ett h245 Redundancy Encoding Mode ett h245 T secondary Encoding Mode ett h245 Video Mode ett h245 H261 Video Mode ett h245 H261 Resolution ett h245 H262 Video Mode ett h245 T profile And Level ett h245 H263 Video Mode ett h245 H263 Resolution ett h245 I S11172 Video Mode ett h245 Audio Mode ett h245 Mode g7231 ett h245 I S11172 Audio Mode ett h245 T audio Layer ett h245 T audio Sampling ett h245 I S11172 multichannel Type ett h245 I S13818 Audio Mode ett h245 I S13818 Audio Layer ett h245 I S13818 Audio Sampling ett h245 I S13818 Multichannel Type ett h245 G7231 Annex C Mode ett h245 VBD Mode ett h245 Data Mode ett h245 Data Mode Application ett h245 T38fax App ett h245 Encryption Mode ett h245 Round Trip Delay Request ett h245 Round Trip Delay Response ett h245 Maintenance Loop Request ett h245 Mlr type ett h245 Maintenance Loop Ack ett h245 Mla type ett h245 Maintenance Loop Reject ett h245 Mlrej type ett h245 Maintenance Loop Reject Cause ett h245 Maintenance Loop Off Command ett h245 Communication Mode Command ett h245 SETSIZE 1 256 OF Communication Mode Table Entry ett h245 Communication Mode Request ett h245 Communication Mode Response ett h245 Communication Mode Table Entry ett h245 T entry Data Type ett h245 Conference Request ett h245 T request Terminal Certificate ett h245 Cert Selection Criteria ett h245 Criteria ett h245 Terminal Label ett h245 Conference Response ett h245 T m C Terminal ID Response ett h245 T terminal ID Response ett h245 T conference ID Response ett h245 T password Response ett h245 SETSIZE 1 256 OF Terminal Label ett h245 T make Me Chair Response ett h245 T extension Address Response ett h245 T chair Token Owner Response ett h245 T terminal Certificate Response ett h245 T broadcast My Logical Channel Response ett h245 T make Terminal Broadcaster Response ett h245 T send This Source Response ett h245 Request All Terminal I Ds Response ett h245 SEQUENCEOF Terminal Information ett h245 Terminal Information ett h245 Remote MC Request ett h245 Remote MC Response ett h245 T reject ett h245 Multilink Request ett h245 Call Information Req ett h245 Add Connection Req ett h245 Remove Connection Req ett h245 Maximum Header Interval Req ett h245 T request Type ett h245 Multilink Response ett h245 Call Information Resp ett h245 Add Connection Resp ett h245 T response Code ett h245 T rejected ett h245 Remove Connection Resp ett h245 Maximum Header Interval Resp ett h245 Multilink Indication ett h245 T crc Desired ett h245 T excessive Error ett h245 Dialing Information ett h245 SETSIZE 1 65535 OF Dialing Information Number ett h245 Dialing Information Number ett h245 SETSIZE 1 255 OF Dialing Information Network Type ett h245 Dialing Information Network Type ett h245 Connection Identifier ett h245 Logical Channel Rate Request ett h245 Logical Channel Rate Acknowledge ett h245 Logical Channel Rate Reject ett h245 Logical Channel Rate Reject Reason ett h245 Logical Channel Rate Release ett h245 Send Terminal Capability Set ett h245 T specific Request ett h245 SETSIZE 1 65535 OF Capability Table Entry Number ett h245 SETSIZE 1 256 OF Capability Descriptor Number ett h245 Encryption Command ett h245 T encryption Algorithm ID ett h245 Flow Control Command ett h245 Scope ett h245 Restriction ett h245 End Session Command ett h245 T gstn Options ett h245 T isdn Options ett h245 Conference Command ett h245 Substitute Conference ID Command ett h245 Encryption Update Direction ett h245 Miscellaneous Command ett h245 Mc type ett h245 T video Fast Update GOB ett h245 T video Fast Update MB ett h245 T progressive Refinement Start ett h245 T repeat Count ett h245 T video Bad M Bs ett h245 SEQUENCEOF Picture Reference ett h245 T lost Partial Picture ett h245 T encryption Update Command ett h245 T encryption Update Ack ett h245 Key Protection Method ett h245 Encryption Update Request ett h245 Picture Reference ett h245 H223 Multiplex Reconfiguration ett h245 T h223 Mode Change ett h245 T h223 Annex A Double Flag ett h245 New ATMVC Command ett h245 Cmd aal ett h245 Cmd aal1 ett h245 Cmd clock Recovery ett h245 Cmd error Correction ett h245 Cmd aal5 ett h245 Cmd multiplex ett h245 Cmd reverse Parameters ett h245 Cmd R multiplex ett h245 Mobile Multilink Reconfiguration Command ett h245 T status ett h245 Function Not Understood ett h245 Function Not Supported ett h245 Function Not Supported Cause ett h245 Conference Indication ett h245 Terminal You Are Seeing In Sub Picture Number ett h245 Video Indicate Compose ett h245 Miscellaneous Indication ett h245 Mi type ett h245 T video Not Decoded M Bs ett h245 Jitter Indication ett h245 H223 Skew Indication ett h245 H2250 Maximum Skew Indication ett h245 MC Location Indication ett h245 Vendor Identification ett h245 New ATMVC Indication ett h245 Ind aal ett h245 Ind aal1 ett h245 Ind clock Recovery ett h245 Ind error Correction ett h245 Ind aal5 ett h245 Ind multiplex ett h245 Ind reverse Parameters ett h245 Ind R multiplex ett h245 Params ett h245 User Input Indication ett h245 T user Input Support Indication ett h245 T signal ett h245 T rtp ett h245 T signal Update ett h245 Si rtp ett h245 T extended Alphanumeric ett h245 Encrypted Alphanumeric ett h245 Flow Control Indication ett h245 Mobile Multilink Reconfiguration Indication line 494 asn1 h245 packet h245 template c module t h245 module proto h245 proto register protocol PNAMEPSNAMEPFNAME register init routine h245 init proto register field array proto h245 hf array length hf proto register subtree array ett array length ett h245 module prefs register protocol proto h245 NULL prefs register bool preference h245 module reassembly Reassemble H 245 messages spanning multiple TCP segments Whether the H 245 dissector should reassemble messages spanning multiple TCP segments To use this option you must also enable Allow subdissectors to reassemble TCP streams in the TCP protocol settings h245 reassembly prefs register bool preference h245 module shorttypes Show short message types Whether the dissector should show short names or the long names from the standard h245 shorttypes register dissector h245dg dissect h245 h245 proto h245 register dissector h245 dissect h245 proto h245 nsp object dissector table register dissector table h245 nsp object H 245 Non Standard Parameter object FTSTRINGBASENONE nsp h221 dissector table register dissector table h245 nsp h221 H 245 Non Standard Parameter h221 FTUIN T32 BASEHEX gef name dissector table register dissector table h245 gef name H 245 Generic Extensible Framework names FTSTRINGBASENONE gef content dissector table register dissector table h245 gef content H 245 Generic Extensible Framework FTSTRINGBASENONE h245 tap register tap h245 h245dg tap register tap h245dg oid add from string h239 Control Capability 0 0 8 239 1 1 oid add from string h239 Extended Video Capability 0 0 8 239 1 2 oid add from string generic message 0 0 8 239 2 oid add from string h245 version 3 0 0 8 245 0 3 oid add from string h245 version 4 0 0 8 245 0 4 oid add from string h245 version 5 0 0 8 245 0 5 oid add from string h245 version 6 0 0 8 245 0 6 oid add from string h245 version 7 0 0 8 245 0 7 oid add from string h245 version 8 0 0 8 245 0 8 oid add from string h245 version 9 0 0 8 245 0 9 oid add from string h245 version 10 0 0 8 245 0 10 oid add from string h245 version 11 0 0 8 245 0 11 oid add from string h245 version 12 0 0 8 245 0 12 oid add from string h245 version 13 0 0 8 245 0 13 oid add from string ISOIEC 14496 2 MPEG 4 video 0 0 8 245 1 0 0 oid add from string ISOIEC 14496 3 MPEG 4 audio 0 0 8 245 1 1 0 oid add from string AMR 0 0 8 245 1 1 1 oid add from string acelp 0 0 8 245 1 1 2 oid add from string us1 0 0 8 245 1 1 3 oid add from string is127evrc 0 0 8 245 1 1 4 oid add from string ISOIEC 13818 7 0 0 8 245 1 1 5 oid add from string rfc3389 0 0 8 245 1 1 6 oid add from string L 16 0 0 8 245 1 1 7 oid add from string bounded audio stream 0 0 8 245 1 1 8 oid add from string AMRNB 0 0 8 245 1 1 9 oid add from string AMRWB 0 0 8 245 1 1 10 oid add from string ilbc 0 0 8 245 1 1 11 oid add from string ISOIEC 14496 1 0 0 8 245 1 2 0 oid add from string Nx64 0 0 8 245 1 2 1 oid add from string logical channel bit ratemanagement 0 0 8 245 1 3 0 oid add from string h264 generic capabilities 0 0 8 241 0 0 1 oid add from string i Ppacketization h241 Annex A single NAL unit mode 0 0 8 241 0 0 0 0 oid add from string i Ppacketization RF C3984 Non Interleaved 0 0 8 241 0 0 0 1 oid add from string i Ppacketization RF C3984 Interleaved 0 0 8 241 0 0 0 2 static void update state rt V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col int bsize V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg xd mi 0 src mi ctx mic xd mi 0 src mi xd mi 0 if cpi oxcf aq mode CYCLICREFRESHAQ seg enabled vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 vp9 init plane quantizers cpi x if is inter block mbmi vp9 update mv count cm xd if cm interp filter SWITCHABLE const int pred ctx vp9 get pred context switchable interp xd cm counts switchable interp pred ctx mbmi interp filter x skip ctx skip x skip txfm 0 mbmi segment id 0 ctx skip txfm 0 int ff MPV common frame size change Mpeg Enc Context s int i err 0 if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i else free duplicate context s if err free context frame s 0 return err if s picture for i 0 i MAXPICTURECOUNT i s picture i needs realloc 1 s last picture ptr s next picture ptr s current picture ptr NULL if s codec id AVCODECIDMPE G2 VIDEO s progressive sequence s mb height s height 31 32 2 else if s codec id AVCODECID H264 s mb height s height 15 16 if s width s height av image check size s width s height 0 s avctx return AVERRORINVALIDDATA if err init context frame s goto fail s thread context 0 s if s width s height int nb slices s slice context count if nb slices 1 for i 1 i nb slices i s thread context i av malloc sizeof Mpeg Enc Context memcpy s thread context i s sizeof Mpeg Enc Context for i 0 i nb slices i if init duplicate context s thread context i 0 goto fail s thread context i start mb y s mb height i nb slices 2 nb slices s thread context i end mb y s mb height i 1 nb slices 2 nb slices else if init duplicate context s 0 goto fail s start mb y 0 s end mb y s mb height s slice context count nb slices return 0 fail ff MPV common end s return err enum message cte message decoder parse cte struct message header line hdr struct rfc822 parser context parser enum message cte message cte string t value value t str new 64 rfc822 parser init parser hdr full value hdr full value len NULL rfc822 skip lwsp parser void rfc822 parse mime token parser value message cte MESSAGECTEUNKNOWN switch str len value case 4 if i memcasecmp str data value 7bit 4 0 i memcasecmp str data value 8bit 4 0 message cte MESSAGECTE 78 BIT break case 6 if i memcasecmp str data value base64 6 0 message cte MESSAGECTEBAS E64 else if i memcasecmp str data value binary 6 0 message cte MESSAGECTEBINARY break case 16 if i memcasecmp str data value quoted printable 16 0 message cte MESSAGECTEQP break rfc822 parser deinit parser return message cte static void evhttp connection done struct evhttp connection evcon struct evhttp request req TAILQFIRST evcon requests int con outgoing evcon flags EVHTTPCONOUTGOING if con outgoing int need close TAILQREMOVE evcon requests req next req evcon NULL evcon state EVCONIDLE need close evhttp is connection close req flags req input headers evhttp is connection close req flags req output headers if need close evhttp connection reset evcon if TAILQFIRST evcon requests NULL if evhttp connected evcon evhttp connection connect evcon else evhttp request dispatch evcon else if need close evhttp connection start detectclose evcon else evcon state EVCONWRITING req cb req req cb arg if con outgoing evhttp request free req static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Indeo3 Decode Context ctx avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data int res res decode frame headers ctx avctx buf buf size if res 0 return res if res got frame 0 return buf size if ctx frame flags BSNONREF avctx skip frame AVDISCARDNONREF return 0 if ctx frame flags BSKEYFRAME avctx skip frame AVDISCARDNONKEY return 0 ctx buf sel ctx frame flags BSBUFFER 1 if res decode plane ctx avctx ctx planes ctx y data ptr ctx y data size 40 return res if res decode plane ctx avctx ctx planes 1 ctx u data ptr ctx u data size 10 return res if res decode plane ctx avctx ctx planes 2 ctx v data ptr ctx v data size 10 return res if res ff get buffer avctx frame 0 0 av log ctx avctx AVLOGERROR get buffer failed n return res output plane ctx planes 0 ctx buf sel frame data 0 frame linesize 0 avctx height output plane ctx planes 1 ctx buf sel frame data 1 frame linesize 1 avctx height 3 2 output plane ctx planes 2 ctx buf sel frame data 2 frame linesize 2 avctx height 3 2 got frame 1 return buf size static int roq encode frame AV Codec Context avctx AV Packet pkt const AV Frame frame int got packet Roq Context enc avctx priv data int size ret enc avctx avctx enc frame to enc frame if frame quality enc lambda frame quality 1 else enc lambda 2 ROQLAMBDASCALE size enc width enc height 64 138 7 8 256 6 4 8 if ret ff alloc packet pkt size 0 av log avctx AVLOGERROR Error getting output packet with size d n size return ret enc out buf pkt data if enc frames Since Keyframe avctx gop size enc frames Since Keyframe 0 if enc first frame if ff get buffer avctx enc current frame 0 ff get buffer avctx enc last frame 0 av log avctx AVLOGERROR Ro Q get buffer failed n return 1 roq write video info chunk enc enc first frame 0 roq encode video enc pkt size enc out buf pkt data if enc frames Since Keyframe 1 pkt flags AVPKTFLAGKEY got packet 1 return 0 static int testit struct test case struct tc int retval wordexp t we sav we char dummy int bzzzt 0 int start offs 0 int i if tc env setenv var tc env 1 else unsetenv var if tc ifs setenv IFS tc ifs 1 else unsetenv IFS sav we we wordc 99 sav we we wordv dummy sav we we offs 3 we sav we printf Test d s tests tc words if tc flags WRDENOCMD registered forks 0 if tc flags WRDEAPPEND if wordexp pre1 pre2 we tc flags WRDEAPPEND 0 printf FAILED setup n return 1 retval wordexp tc words we tc flags if tc flags WRDENOCMD registered forks 0 printf FAILED fork called for WRDENOCMD n return 1 if tc flags WRDEDOOFFS start offs sav we we offs if retval tc retval retval 0 we we wordc tc wordc bzzzt 1 else if retval 0 for i 0 i start offs i if we we wordv i NULL bzzzt 1 break for i 0 i we we wordc i if we we wordv i start offs NULL strcmp tc wordv i we we wordv i start offs 0 bzzzt 1 break if bzzzt printf FAILED n printf Test words s need retval d wordc Zd n tc words tc retval tc wordc if start offs 0 printf preceded by d NUL Ls n start offs printf Got retval d wordc Zd retval we we wordc if retval 0 retval WRDENOSPACE for i 0 i we we wordc start offs i if we we wordv i NULL printf NULL else printf s we we wordv i printf n else if retval 0 retval WRDENOSPACE we we wordc sav we we wordc we we wordv sav we we wordv we we offs sav we we offs bzzzt 1 printf FAILED to restore wordexp t members n else printf OK n if retval 0 retval WRDENOSPACE wordfree we return bzzzt static int zsethalftone5 i ctx t i ctx p os ptr op osp uint count gs halftone component phtc 0 gs halftone component pc int code 0 int j bool have default gs halftone pht 0 gx device halftone pdht 0 ref sprocs GSCLIENTCOLORMAXCOMPONENTS 1 ref tprocs GSCLIENTCOLORMAXCOMPONENTS 1 gs memory t mem uint edepth ref stack count e stack int npop 2 int dict enum dict first op ref rvalue 2 int cname colorant number byte pname uint name size int halftonetype type 0 gs gstate pgs igs int space index r space index op 1 mem gs memory t idmemory spaces indexed space index check type op t dictionary check dict read op check type op 1 t dictionary check dict read op 1 code dict int param op 1 Halftone Type 1 100 0 type if code 0 return code halftonetype type 2 type 4 ht type multiple colorscreen ht type multiple have default false for count 0 if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue else if colorant number GXDEVICECOLORMAXCOMPONENTS if have default return error gs error rangecheck have default true count if count GSCLIENTCOLORMAXCOMPONENTS 1 code gs note error gs error rangecheck break if count 0 halftonetype ht type multiple have default code gs note error gs error rangecheck if code 0 check estack 5 refset null sprocs count refset null tprocs count rc alloc struct 0 pht gs halftone st halftone imemory pht 0 sethalftone5 phtc gs alloc struct array mem count gs halftone component st ht component element sethalftone5 rc alloc struct 0 pdht gx device halftone st device halftone imemory pdht 0 sethalftone5 if pht 0 phtc 0 pdht 0 j 0 code gs note error gs error V Merror if code 0 dict enum dict first op for j 0 pc phtc int type if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue pc cname cname pc comp number colorant number check dict read rvalue 1 if dict int param rvalue 1 Halftone Type 1 7 0 type 0 code gs note error gs error typecheck break switch type default code gs note error gs error rangecheck break case 1 code dict spot params rvalue 1 pc params spot sprocs j tprocs j mem pc params spot screen spot function spot1 dummy pc type ht type spot break case 3 code dict threshold params rvalue 1 pc params threshold tprocs j pc type ht type threshold break case 7 code dict threshold2 params rvalue 1 pc params threshold2 tprocs j imemory pc type ht type threshold2 break if code 0 break pc j if code 0 pht type halftonetype pht params multiple components phtc pht params multiple num comp j pht params multiple get colorname string gs get colorname string code gs sethalftone prepare igs pht pdht if code 0 dict enum dict first op for pc phtc if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue if pc type ht type spot code dict spot results i ctx p rvalue 1 pc params spot if code 0 break pc if code 0 uint odepth ref stack count o stack ref odict odict5 odict op 1 odict5 op pop 2 op osp esp 5 make mark estack esp 4 es other sethalftone cleanup esp 3 odict make istruct esp 2 0 pht make istruct esp 1 0 pdht make op estack esp sethalftone finish for j 0 j count j gx ht order porder NULL if pdht components 0 porder pdht order else int k int comp number phtc j comp number for k 0 k count k if pdht components k comp number comp number porder pdht components k corder break switch phtc j type case ht type spot code zscreen enum init i ctx p porder phtc j params spot screen sprocs j 0 0 space index if code 0 break case ht type threshold if r has type tprocs j t invalid check ostack zcolor remap one ostack check estack zcolor remap one estack code zcolor remap one i ctx p tprocs j porder transfer igs zcolor remap one finish op osp break default if code 0 ref stack pop to o stack odepth ref stack pop to e stack edepth op osp op 1 odict op odict5 break npop 0 if code 0 gs free object mem pdht sethalftone5 gs free object mem phtc sethalftone5 gs free object mem pht sethalftone5 return code pop npop return ref stack count e stack edepth o push estack 0 static void encode nonrd sb row V P9 COMP cpi const Tile Info const tile int mi row TOKENEXTRA tp SPEEDFEATURES const sf cpi sf V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd int mi col vpx memset xd left context 0 sizeof xd left context vpx memset xd left seg context 0 sizeof xd left seg context for mi col tile mi col start mi col tile mi col end mi col MIBLOCKSIZE int dummy rate 0 int64 t dummy dist 0 const int idx str cm mi stride mi row mi col MODEINFO mi cm mi idx str MODEINFO prev mi cm prev mip cm mi stride 1 idx str src mi BLOCKSIZE bsize x in static area 0 x source variance UINTMAX vp9 zero x pred mv switch sf partition search type case VARBASEDPARTITION choose partitioning cpi tile mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case SOURCEVARBASEDPARTITION set source var based partition cpi tile mi mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case VARBASEDFIXEDPARTITION case FIXEDPARTITION bsize sf partition search type FIXEDPARTITION sf always this block size get nonrd var based fixed partition cpi mi row mi col set fixed partitioning cpi tile mi mi row mi col bsize nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case REFERENCEPARTITION if sf partition check x in static area is background cpi tile mi row mi col set modeinfo offsets cm xd mi row mi col auto partition range cpi tile mi row mi col sf min partition size sf max partition size nonrd pick partition cpi tile tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 IN T64 MAX cpi pc root else copy partitioning cm mi prev mi nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break default assert 0 break static void parse content type struct message decoder context ctx struct message header line hdr struct rfc822 parser context parser const char const results string t str int ret if ctx content type NULL return rfc822 parser init parser hdr full value hdr full value len NULL rfc822 skip lwsp parser str t str new 64 ret rfc822 parse content type parser str ctx content type i strdup str c str if ret 0 rfc822 parser deinit parser return rfc2231 parse parser results for results NULL results 2 if strcasecmp results 0 charset 0 ctx content charset i strdup results 1 break rfc822 parser deinit parser static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Vmnc Context const c avctx priv data uint8 t outptr const uint8 t src buf int dx dy w h depth enc chunks res size left ret if ret ff reget buffer avctx c pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pic key frame 0 c pic pict type AVPICTURETYPEP if c screendta int i w c cur w if c width c cur x w w c width c cur x h c cur h if c height c cur y h h c height c cur y dx c cur x if dx 0 w dx dx 0 dy c cur y if dy 0 h dy dy 0 if w 0 h 0 outptr c pic data 0 dx c bpp2 dy c pic linesize 0 for i 0 i h i memcpy outptr c screendta i c cur w c bpp2 w c bpp2 outptr c pic linesize 0 src 2 chunks AVR B16 src src 2 while chunks dx AVR B16 src src 2 dy AVR B16 src src 2 w AVR B16 src src 2 h AVR B16 src src 2 enc AVR B32 src src 4 outptr c pic data 0 dx c bpp2 dy c pic linesize 0 size left buf size src buf switch enc case MAGICWM Vd if size left 2 w h c bpp2 2 av log avctx AVLOGERROR Premature end of data need i got i n 2 w h c bpp2 2 size left return 1 src 2 c cur w w c cur h h c cur hx dx c cur hy dy if c cur hx c cur w c cur hy c cur h av log avctx AVLOGERROR Cursor hot spot is not in image ix i of ix i cursor size n c cur hx c cur hy c cur w c cur h c cur hx c cur hy 0 c curbits av realloc c curbits c cur w c cur h c bpp2 c curmask av realloc c curmask c cur w c cur h c bpp2 c screendta av realloc c screendta c cur w c cur h c bpp2 load cursor c src src w h c bpp2 2 break case MAGICWM Ve src 2 break case MAGICWM Vf c cur x dx c cur hx c cur y dy c cur hy break case MAGICWM Vg src 10 break case MAGICWM Vh src 4 break case MAGICWM Vi c pic key frame 1 c pic pict type AVPICTURETYPEI depth src if depth c bpp av log avctx AVLOGINFO Depth mismatch Container i bpp Frame data i bpp n c bpp depth src c bigendian src if c bigendian 1 av log avctx AVLOGINFO Invalid header bigendian flag i n c bigendian return 1 src 13 break case MAGICWM Vj src 2 break case 0x00000000 if dx w c width dy h c height av log avctx AVLOGERROR Incorrect frame size ix i ix i of ix i n w h dx dy c width c height return 1 if size left w h c bpp2 av log avctx AVLOGERROR Premature end of data need i got i n w h c bpp2 size left return 1 paint raw outptr w h src c bpp2 c bigendian c pic linesize 0 src w h c bpp2 break case 0x00000005 if dx w c width dy h c height av log avctx AVLOGERROR Incorrect frame size ix i ix i of ix i n w h dx dy c width c height return 1 res decode hextile c outptr src size left w h c pic linesize 0 if res 0 return 1 src res break default av log avctx AVLOGERROR Unsupported block type 0x 08 X n enc chunks 0 if c screendta int i w c cur w if c width c cur x w w c width c cur x h c cur h if c height c cur y h h c height c cur y dx c cur x if dx 0 w dx dx 0 dy c cur y if dy 0 h dy dy 0 if w 0 h 0 outptr c pic data 0 dx c bpp2 dy c pic linesize 0 for i 0 i h i memcpy c screendta i c cur w c bpp2 outptr w c bpp2 outptr c pic linesize 0 outptr c pic data 0 put cursor outptr c pic linesize 0 c c cur x c cur y got frame 1 if ret av frame ref data c pic 0 return ret return buf size static void inverse transform block MACROBLOCKD xd int plane int block TXSIZE tx size uint8 t dst int stride int eob struct macroblockd plane const pd xd plane plane if eob 0 TXTYPE tx type DCTDCT tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block if xd lossless tx type DCTDCT vp9 iwht4x4 add dqcoeff dst stride eob else const PLANETYPE plane type pd plane type switch tx size case TX 4 X4 tx type get tx type 4x4 plane type xd block vp9 iht4x4 add tx type dqcoeff dst stride eob break case TX 8 X8 tx type get tx type plane type xd vp9 iht8x8 add tx type dqcoeff dst stride eob break case TX 16 X16 tx type get tx type plane type xd vp9 iht16x16 add tx type dqcoeff dst stride eob break case TX 32 X32 tx type DCTDCT vp9 idct32x32 add dqcoeff dst stride eob break default assert 0 Invalid transform size if eob 1 vpx memset dqcoeff 0 2 sizeof dqcoeff 0 else if tx type DCTDCT tx size TX 16 X16 eob 10 vpx memset dqcoeff 0 4 4 tx size sizeof dqcoeff 0 else if tx size TX 32 X32 eob 34 vpx memset dqcoeff 0 256 sizeof dqcoeff 0 else vpx memset dqcoeff 0 16 tx size 1 sizeof dqcoeff 0 int ff MPV common frame size change Mpeg Enc Context s int i err 0 if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i else free duplicate context s if err free context frame s 0 return err if s picture for i 0 i MAXPICTURECOUNT i s picture i needs realloc 1 s last picture ptr s next picture ptr s current picture ptr NULL if s codec id AVCODECIDMPE G2 VIDEO s progressive sequence s mb height s height 31 32 2 else if s codec id AVCODECID H264 s mb height s height 15 16 if s width s height av image check size s width s height 0 s avctx return AVERRORINVALIDDATA if err init context frame s goto fail s thread context 0 s if s width s height int nb slices s slice context count if nb slices 1 for i 1 i nb slices i s thread context i av malloc sizeof Mpeg Enc Context memcpy s thread context i s sizeof Mpeg Enc Context for i 0 i nb slices i if init duplicate context s thread context i 0 goto fail s thread context i start mb y s mb height i nb slices 2 nb slices s thread context i end mb y s mb height i 1 nb slices 2 nb slices else if init duplicate context s 0 goto fail s start mb y 0 s end mb y s mb height s slice context count nb slices return 0 fail ff MPV common end s return err static void fill colmap H264 Context h int map 2 16 32 int list int field int colfield int mbafi Picture const ref1 h ref list 1 0 int j old ref rfield int start mbafi 16 0 int end mbafi 16 2 h ref count 0 h ref count 0 int interl mbafi h picture structure PICTFRAME memset map list 0 sizeof map list for rfield 0 rfield 2 rfield for old ref 0 old ref ref1 ref count colfield list old ref int poc ref1 ref poc colfield list old ref if interl poc 3 else if interl poc 3 3 poc poc 3 rfield 1 for j start j end j if 4 h ref list 0 j frame num h ref list 0 j reference 3 poc int cur ref mbafi j 16 field j if ref1 mbaff map list 2 old ref rfield field 16 cur ref if rfield field interl map list old ref cur ref break static int cmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cmv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int ret if buf end buf EAPREAMBLESIZE return AVERRORINVALIDDATA if AVR L32 buf MV Ih TAGAVR B32 buf MV Ih TAG cmv process header s buf EAPREAMBLESIZE buf end return buf size if av image check size s width s height 0 s avctx return 1 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 s palette AVPALETTESIZE buf EAPREAMBLESIZE if buf 0 1 cmv decode inter s frame buf 2 buf end frame key frame 0 frame pict type AVPICTURETYPEP else frame key frame 1 frame pict type AVPICTURETYPEI cmv decode intra s frame buf 2 buf end av frame unref s last2 frame av frame move ref s last2 frame s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size void kadmin addprinc int argc char argv kadm5 principal ent rec princ kadm5 policy ent rec defpol long mask krb5 boolean randkey FALSE old style randkey FALSE int n ks tuple krb5 key salt tuple ks tuple NULL char pass canon NULL krb5 error code retval char newpw 1024 dummybuf 256 static char prompt1 1024 prompt2 1024 memset princ 0 sizeof princ princ attributes 0 if kadmin parse princ args argc argv princ mask pass randkey ks tuple n ks tuple add principal kadmin addprinc usage goto cleanup retval krb5 unparse name context princ principal canon if retval com err add principal retval while canonicalizing principal goto cleanup if mask KAD M5 POLICY mask KAD M5 POLICYCLR if kadm5 get policy handle default defpol fprintf stderr NOTICE no policy specified for s assigning default n canon princ policy default mask KAD M5 POLICY kadm5 free policy ent handle defpol else fprintf stderr WARNING no policy specified for s defaulting to no policy n canon mask KAD M5 POLICYCLR if randkey pass NULL else if pass NULL unsigned int sz sizeof newpw 1 snprintf prompt1 sizeof prompt1 Enter password for principal s canon snprintf prompt2 sizeof prompt2 Re enter password for principal s canon retval krb5 read password context prompt1 prompt2 newpw sz if retval com err add principal retval while reading password for s canon goto cleanup pass newpw mask KAD M5 PRINCIPAL retval create princ princ mask n ks tuple ks tuple pass if retval EINVAL randkey prepare dummy password dummybuf sizeof dummybuf princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES pass dummybuf retval create princ princ mask n ks tuple ks tuple pass old style randkey 1 if retval com err add principal retval while creating s canon goto cleanup if old style randkey retval randkey princ princ principal FALSE n ks tuple ks tuple if retval com err add principal retval while randomizing key for s canon goto cleanup princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES retval kadm5 modify principal handle princ mask if retval com err add principal retval while clearing DISALLOWALLTIX for s canon goto cleanup printf Principal s created n canon cleanup krb5 free principal context princ principal free ks tuple free canon kadmin free tl data princ n tl data princ tl data void ff xvmc decode mb Mpeg Enc Context s Xv MC Macro Block mv block struct xvmc pix fmt render int i cbp blocks per mb const int mb xy s mb y s mb stride s mb x if s encoding av log s avctx AVLOGERRORXVMC doesn t support encoding n return if s mb intra s last dc 0 s last dc 1 s last dc 2 128 s intra dc precision s mb skipped 0 s current picture qscale table mb xy s qscale render struct xvmc pix fmt s current picture f data 2 assert render assert render xvmc id AVXVMCID assert render mv blocks mv block render mv blocks render start mv blocks num render filled mv blocks num mv block x s mb x mv block y s mb y mv block dct type s interlaced dct if s mb intra mv block macroblock type XVMCMBTYPEINTRA else mv block macroblock type XVMCMBTYPEPATTERN if s mv dir MVDIRFORWARD mv block macroblock type XVMCMBTYPEMOTIONFORWARD mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 mv block PMV 1 0 0 s mv 0 1 0 mv block PMV 1 0 1 s mv 0 1 1 if s mv dir MVDIRBACKWARD mv block macroblock type XVMCMBTYPEMOTIONBACKWARD mv block PMV 0 1 0 s mv 1 0 0 mv block PMV 0 1 1 s mv 1 0 1 mv block PMV 1 1 0 s mv 1 1 0 mv block PMV 1 1 1 s mv 1 1 1 switch s mv type case MVTYPE 16 X16 mv block motion type XVMCPREDICTIONFRAME break case MVTYPE 16 X8 mv block motion type XVMCPREDICTION 16x8 break case MVTYPEFIELD mv block motion type XVMCPREDICTIONFIELD if s picture structure PICTFRAME mv block PMV 0 0 1 1 mv block PMV 1 0 1 1 mv block PMV 0 1 1 1 mv block PMV 1 1 1 1 break case MVTYPEDMV mv block motion type XVMCPREDICTIONDUALPRIME if s picture structure PICTFRAME mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 1 mv block PMV 0 1 0 s mv 0 0 0 mv block PMV 0 1 1 s mv 0 0 1 1 mv block PMV 1 0 0 s mv 0 2 0 mv block PMV 1 0 1 s mv 0 2 1 1 mv block PMV 1 1 0 s mv 0 3 0 mv block PMV 1 1 1 s mv 0 3 1 1 else mv block PMV 0 1 0 s mv 0 2 0 mv block PMV 0 1 1 s mv 0 2 1 break default assert 0 mv block motion vertical field select 0 if s mv type MVTYPEFIELD s mv type MVTYPE 16 X8 mv block motion vertical field select s field select 0 0 mv block motion vertical field select s field select 1 0 1 mv block motion vertical field select s field select 0 1 2 mv block motion vertical field select s field select 1 1 3 mv block index render next free data block num blocks per mb 6 if s chroma format 2 blocks per mb 4 1 s chroma format cbp 0 for i 0 i blocks per mb i cbp cbp if s block last index i 0 cbp if s flags CODECFLAGGRAY if s mb intra for i 4 i blocks per mb i memset s pblocks i 0 sizeof s pblocks i if render unsigned intra s pblocks i 0 1 10 else cbp 0xf blocks per mb 4 blocks per mb 4 mv block coded block pattern cbp if cbp 0 mv block macroblock type XVMCMBTYPEPATTERN for i 0 i blocks per mb i if s block last index i 0 if s mb intra render idct render unsigned intra s pblocks i 0 1 10 if render idct s dsp idct s pblocks i if s avctx xvmc acceleration 1 memcpy render data blocks render next free data block num 64 s pblocks i sizeof s pblocks i render next free data block num render filled mv blocks num assert render filled mv blocks num render allocated mv blocks assert render next free data block num render allocated data blocks if render filled mv blocks num render allocated mv blocks ff mpeg draw horiz band s 0 0 void xps begin opacity xps document doc const fz matrix ctm const fz rect area char base uri xps resource dict char opacity att fz xml opacity mask tag float opacity if opacity att opacity mask tag return opacity 1 if opacity att opacity fz atof opacity att if opacity mask tag strcmp fz xml tag opacity mask tag Solid Color Brush char scb opacity att fz xml att opacity mask tag Opacity char scb color att fz xml att opacity mask tag Color if scb opacity att opacity opacity fz atof scb opacity att if scb color att fz colorspace colorspace float samples FZMAXCOLORS xps parse color doc base uri scb color att colorspace samples opacity opacity samples 0 opacity mask tag NULL if doc opacity top 1 nelem doc opacity doc opacity doc opacity top 1 doc opacity doc opacity top opacity doc opacity top if opacity mask tag fz begin mask doc dev area 0 NULLNULL xps parse brush doc ctm area base uri dict opacity mask tag fz end mask doc dev static int encode thread AV Codec Context c void arg Mpeg Enc Context s void arg int mb x mb y pdif 0 int chr h 16 s chroma y shift int i j Mpeg Enc Context best s backup s uint8 t bit buf 2 MAXMBBYTES uint8 t bit buf2 2 MAXMBBYTES uint8 t bit buf tex 2 MAXMBBYTES Put Bit Context pb 2 pb2 2 tex pb 2 ff check alignment for i 0 i 2 i init put bits pb i bit buf i MAXMBBYTES init put bits pb2 i bit buf2 i MAXMBBYTES init put bits tex pb i bit buf tex i MAXMBBYTES s last bits put bits count s pb s mv bits 0 s misc bits 0 s i tex bits 0 s p tex bits 0 s i count 0 s f count 0 s b count 0 s skip count 0 for i 0 i 3 i s last dc i 128 s intra dc precision s current picture f error i 0 s mb skip run 0 memset s last mv 0 sizeof s last mv s last mv dir 0 switch s codec id case AVCODECID H263 case AVCODECID H263 P case AVCODECIDFL V1 if CONFIG H263 ENCODER s gob index ff h263 get gob height s break case AVCODECIDMPE G4 if CONFIGMPE G4 ENCODER s partitioned frame ff mpeg4 init partitions s break s resync mb x 0 s resync mb y 0 s first slice line 1 s ptr lastgob s pb buf for mb y s start mb y mb y s end mb y mb y s mb x 0 s mb y mb y ff set qscale s s qscale ff init block index s for mb x 0 mb x s mb width mb x int xy mb y s mb stride mb x int mb type s mb type xy int dmin INTMAX int dir if s pb buf end s pb buf put bits count s pb 3 MAXMBBYTES av log s avctx AVLOGERROR encoded frame too large n return 1 if s data partitioning if s pb2 buf end s pb2 buf put bits count s pb2 3 MAXMBBYTES s tex pb buf end s tex pb buf put bits count s tex pb 3 MAXMBBYTES av log s avctx AVLOGERROR encoded frame too large n return 1 s mb x mb x s mb y mb y ff update block index s if CONFIG H261 ENCODER s codec id AVCODECID H261 ff h261 reorder mb index s xy s mb y s mb stride s mb x mb type s mb type xy if s rtp mode int current packet size is gob start current packet size put bits count s pb 7 3 s ptr lastgob s pb buf is gob start s avctx rtp payload size current packet size s avctx rtp payload size mb y mb x 0 if s start mb y mb y mb y 0 mb x 0 is gob start 1 switch s codec id case AVCODECID H263 case AVCODECID H263 P if s h263 slice structured if s mb x s mb y s gob index is gob start 0 break case AVCODECIDMPE G2 VIDEO if s mb x 0 s mb y 0 is gob start 1 case AVCODECIDMPE G1 VIDEO if s mb skip run is gob start 0 break if is gob start if s start mb y mb y mb x 0 write slice end s if CONFIGMPE G4 ENCODER s codec id AVCODECIDMPE G4 s partitioned frame ff mpeg4 init partitions s assert put bits count s pb 7 0 current packet size put bits ptr s pb s ptr lastgob if s avctx error rate s resync mb x s resync mb y 0 int r put bits count s pb 8 s picture number 16 s mb x s mb y int d 100 s avctx error rate if r d 0 current packet size 0 s pb buf ptr s ptr lastgob assert put bits ptr s pb s ptr lastgob if s avctx rtp callback int number mb mb y s resync mb y s mb width mb x s resync mb x s avctx rtp callback s avctx s ptr lastgob current packet size number mb update mb info s 1 switch s codec id case AVCODECIDMPE G4 if CONFIGMPE G4 ENCODER ff mpeg4 encode video packet header s ff mpeg4 clean buffers s break case AVCODECIDMPE G1 VIDEO case AVCODECIDMPE G2 VIDEO if CONFIGMPE G1 VIDEOENCODERCONFIGMPE G2 VIDEOENCODER ff mpeg1 encode slice header s ff mpeg1 clean buffers s break case AVCODECID H263 case AVCODECID H263 P if CONFIG H263 ENCODER ff h263 encode gob header s mb y break if s flags CODECFLAGPAS S1 int bits put bits count s pb s misc bits bits s last bits s last bits bits s ptr lastgob current packet size s first slice line 1 s resync mb x mb x s resync mb y mb y if s resync mb x s mb x s resync mb y 1 s mb y s first slice line 0 s mb skipped 0 s dquant 0 update mb info s 0 if mb type mb type 1 s mpv flags FFMPVFLAGQPRD int next block 0 int pb bits count pb2 bits count tex pb bits count copy context before encode backup s s 1 backup s pb s pb best s data partitioning s data partitioning best s partitioned frame s partitioned frame if s data partitioning backup s pb2 s pb2 backup s tex pb s tex pb if mb type CANDIDATEMBTYPEINTER s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mb intra 0 s mv 0 0 0 s p mv table xy 0 s mv 0 0 1 s p mv table xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEINTER pb pb2 tex pb dmin next block s mv 0 0 0 s mv 0 0 1 if mb type CANDIDATEMBTYPEINTERI s mv dir MVDIRFORWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 0 i s p field select table i xy s mv 0 i 0 s p field mv table i j xy 0 s mv 0 i 1 s p field mv table i j xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEINTERI pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPESKIPPED s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mb intra 0 s mv 0 0 0 0 s mv 0 0 1 0 encode mb hq s backup s best s CANDIDATEMBTYPESKIPPED pb pb2 tex pb dmin next block s mv 0 0 0 s mv 0 0 1 if mb type CANDIDATEMBTYPEINTE R4 V s mv dir MVDIRFORWARD s mv type MVTYPE 8 X8 s mb intra 0 for i 0 i 4 i s mv 0 i 0 s current picture motion val 0 s block index i 0 s mv 0 i 1 s current picture motion val 0 s block index i 1 encode mb hq s backup s best s CANDIDATEMBTYPEINTE R4 V pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPEFORWARD s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mb intra 0 s mv 0 0 0 s b forw mv table xy 0 s mv 0 0 1 s b forw mv table xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEFORWARD pb pb2 tex pb dmin next block s mv 0 0 0 s mv 0 0 1 if mb type CANDIDATEMBTYPEBACKWARD s mv dir MVDIRBACKWARD s mv type MVTYPE 16 X16 s mb intra 0 s mv 1 0 0 s b back mv table xy 0 s mv 1 0 1 s b back mv table xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEBACKWARD pb pb2 tex pb dmin next block s mv 1 0 0 s mv 1 0 1 if mb type CANDIDATEMBTYPEBIDIR s mv dir MVDIRFORWARDMVDIRBACKWARD s mv type MVTYPE 16 X16 s mb intra 0 s mv 0 0 0 s b bidir forw mv table xy 0 s mv 0 0 1 s b bidir forw mv table xy 1 s mv 1 0 0 s b bidir back mv table xy 0 s mv 1 0 1 s b bidir back mv table xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEBIDIR pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPEFORWARDI s mv dir MVDIRFORWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 0 i s b field select table 0 i xy s mv 0 i 0 s b field mv table 0 i j xy 0 s mv 0 i 1 s b field mv table 0 i j xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEFORWARDI pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPEBACKWARDI s mv dir MVDIRBACKWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 1 i s b field select table 1 i xy s mv 1 i 0 s b field mv table 1 i j xy 0 s mv 1 i 1 s b field mv table 1 i j xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEBACKWARDI pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPEBIDIRI s mv dir MVDIRFORWARDMVDIRBACKWARD s mv type MVTYPEFIELD s mb intra 0 for dir 0 dir 2 dir for i 0 i 2 i j s field select dir i s b field select table dir i xy s mv dir i 0 s b field mv table dir i j xy 0 s mv dir i 1 s b field mv table dir i j xy 1 encode mb hq s backup s best s CANDIDATEMBTYPEBIDIRI pb pb2 tex pb dmin next block 0 0 if mb type CANDIDATEMBTYPEINTRA s mv dir 0 s mv type MVTYPE 16 X16 s mb intra 1 s mv 0 0 0 0 s mv 0 0 1 0 encode mb hq s backup s best s CANDIDATEMBTYPEINTRA pb pb2 tex pb dmin next block 0 0 if s h263 pred s h263 aic if best s mb intra s mbintra table mb x mb y s mb stride 1 else ff clean intra table entries s if s mpv flags FFMPVFLAGQPRD dmin INTMAX if best s mv type MVTYPE 16 X16 const int last qp backup s qscale int qpi qp dc 6 int16 t ac 6 16 const int mvdir best s mv dir MVDIRBACKWARD 1 0 static const int dquant tab 4 1 1 2 2 assert backup s dquant 0 s mv dir best s mv dir s mv type MVTYPE 16 X16 s mb intra best s mb intra s mv 0 0 0 best s mv 0 0 0 s mv 0 0 1 best s mv 0 0 1 s mv 1 0 0 best s mv 1 0 0 s mv 1 0 1 best s mv 1 0 1 qpi s pict type AVPICTURETYPEB 2 0 for qpi 4 qpi int dquant dquant tab qpi qp last qp dquant if qp s avctx qmin qp s avctx qmax continue backup s dquant dquant if s mb intra s dc val 0 for i 0 i 6 i dc i s dc val 0 s block index i memcpy ac i s ac val 0 s block index i sizeof int16 t 16 encode mb hq s backup s best s CANDIDATEMBTYPEINTER pb pb2 tex pb dmin next block s mv mvdir 0 0 s mv mvdir 0 1 if best s qscale qp if s mb intra s dc val 0 for i 0 i 6 i s dc val 0 s block index i dc i memcpy s ac val 0 s block index i ac i sizeof int16 t 16 if CONFIGMPE G4 ENCODER mb type CANDIDATEMBTYPEDIRECT int mx s b direct mv table xy 0 int my s b direct mv table xy 1 backup s dquant 0 s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT s mb intra 0 ff mpeg4 set direct mv s mx my encode mb hq s backup s best s CANDIDATEMBTYPEDIRECT pb pb2 tex pb dmin next block mx my if CONFIGMPE G4 ENCODER mb type CANDIDATEMBTYPEDIREC T0 backup s dquant 0 s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT s mb intra 0 ff mpeg4 set direct mv s 0 0 encode mb hq s backup s best s CANDIDATEMBTYPEDIRECT pb pb2 tex pb dmin next block 0 0 if best s mb intra s mpv flags FFMPVFLAGSKIPRD int coded 0 for i 0 i 6 i coded s block last index i if coded int mx my memcpy s mv best s mv sizeof s mv if CONFIGMPE G4 ENCODER best s mv dir MVDIRECT mx my 0 ff mpeg4 set direct mv s mx my else if best s mv dir MVDIRBACKWARD mx s mv 1 0 0 my s mv 1 0 1 else mx s mv 0 0 0 my s mv 0 0 1 s mv dir best s mv dir s mv type best s mv type s mb intra 0 backup s dquant 0 s skipdct 1 encode mb hq s backup s best s CANDIDATEMBTYPEINTER pb pb2 tex pb dmin next block mx my s skipdct 0 s current picture qscale table xy best s qscale copy context after encode s best s 1 pb bits count put bits count s pb flush put bits s pb avpriv copy bits backup s pb bit buf next block 1 pb bits count s pb backup s pb if s data partitioning pb2 bits count put bits count s pb2 flush put bits s pb2 avpriv copy bits backup s pb2 bit buf2 next block 1 pb2 bits count s pb2 backup s pb2 tex pb bits count put bits count s tex pb flush put bits s tex pb avpriv copy bits backup s tex pb bit buf tex next block 1 tex pb bits count s tex pb backup s tex pb s last bits put bits count s pb if CONFIG H263 ENCODER s out format FMT H263 s pict type AVPICTURETYPEB ff h263 update motion val s if next block 0 s dsp put pixels tab 0 0 s dest 0 s rd scratchpad s linesize 16 s dsp put pixels tab 1 0 s dest 1 s rd scratchpad 16 s linesize s uvlinesize 8 s dsp put pixels tab 1 0 s dest 2 s rd scratchpad 16 s linesize 8 s uvlinesize 8 if s avctx mb decision FFMBDECISIONBITS ff MPV decode mb s s block else int motion x 0 motion y 0 s mv type MVTYPE 16 X16 switch mb type case CANDIDATEMBTYPEINTRA s mv dir 0 s mb intra 1 motion x s mv 0 0 0 0 motion y s mv 0 0 1 0 break case CANDIDATEMBTYPEINTER s mv dir MVDIRFORWARD s mb intra 0 motion x s mv 0 0 0 s p mv table xy 0 motion y s mv 0 0 1 s p mv table xy 1 break case CANDIDATEMBTYPEINTERI s mv dir MVDIRFORWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 0 i s p field select table i xy s mv 0 i 0 s p field mv table i j xy 0 s mv 0 i 1 s p field mv table i j xy 1 break case CANDIDATEMBTYPEINTE R4 V s mv dir MVDIRFORWARD s mv type MVTYPE 8 X8 s mb intra 0 for i 0 i 4 i s mv 0 i 0 s current picture motion val 0 s block index i 0 s mv 0 i 1 s current picture motion val 0 s block index i 1 break case CANDIDATEMBTYPEDIRECT if CONFIGMPE G4 ENCODER s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT s mb intra 0 motion x s b direct mv table xy 0 motion y s b direct mv table xy 1 ff mpeg4 set direct mv s motion x motion y break case CANDIDATEMBTYPEDIREC T0 if CONFIGMPE G4 ENCODER s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT s mb intra 0 ff mpeg4 set direct mv s 0 0 break case CANDIDATEMBTYPEBIDIR s mv dir MVDIRFORWARDMVDIRBACKWARD s mb intra 0 s mv 0 0 0 s b bidir forw mv table xy 0 s mv 0 0 1 s b bidir forw mv table xy 1 s mv 1 0 0 s b bidir back mv table xy 0 s mv 1 0 1 s b bidir back mv table xy 1 break case CANDIDATEMBTYPEBACKWARD s mv dir MVDIRBACKWARD s mb intra 0 motion x s mv 1 0 0 s b back mv table xy 0 motion y s mv 1 0 1 s b back mv table xy 1 break case CANDIDATEMBTYPEFORWARD s mv dir MVDIRFORWARD s mb intra 0 motion x s mv 0 0 0 s b forw mv table xy 0 motion y s mv 0 0 1 s b forw mv table xy 1 break case CANDIDATEMBTYPEFORWARDI s mv dir MVDIRFORWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 0 i s b field select table 0 i xy s mv 0 i 0 s b field mv table 0 i j xy 0 s mv 0 i 1 s b field mv table 0 i j xy 1 break case CANDIDATEMBTYPEBACKWARDI s mv dir MVDIRBACKWARD s mv type MVTYPEFIELD s mb intra 0 for i 0 i 2 i j s field select 1 i s b field select table 1 i xy s mv 1 i 0 s b field mv table 1 i j xy 0 s mv 1 i 1 s b field mv table 1 i j xy 1 break case CANDIDATEMBTYPEBIDIRI s mv dir MVDIRFORWARDMVDIRBACKWARD s mv type MVTYPEFIELD s mb intra 0 for dir 0 dir 2 dir for i 0 i 2 i j s field select dir i s b field select table dir i xy s mv dir i 0 s b field mv table dir i j xy 0 s mv dir i 1 s b field mv table dir i j xy 1 break default av log s avctx AVLOGERROR illegal MB type n encode mb s motion x motion y s last mv dir s mv dir if CONFIG H263 ENCODER s out format FMT H263 s pict type AVPICTURETYPEB ff h263 update motion val s ff MPV decode mb s s block if s mb intra s p mv table xy 0 0 s p mv table xy 1 0 if s flags CODECFLAGPSNR int w 16 int h 16 if s mb x 16 16 s width w s width s mb x 16 if s mb y 16 16 s height h s height s mb y 16 s current picture f error 0 sse s s new picture f data 0 s mb x 16 s mb y s linesize 16 s dest 0 w h s linesize s current picture f error 1 sse s s new picture f data 1 s mb x 8 s mb y s uvlinesize chr h s dest 1 w 1 h s chroma y shift s uvlinesize s current picture f error 2 sse s s new picture f data 2 s mb x 8 s mb y s uvlinesize chr h s dest 2 w 1 h s chroma y shift s uvlinesize if s loop filter if CONFIG H263 ENCODER s out format FMT H263 ff h263 loop filter s av dlog s avctx MB d d bits n s mb x s mb y s mb stride put bits count s pb ot beautiful here but we must write it before flushing so it has to be here if CONFIGMSMPE G4 ENCODER s msmpeg4 version s msmpeg4 version 4 s pict type AVPICTURETYPEI ff msmpeg4 encode ext header s write slice end s if s avctx rtp callback int number mb mb y s resync mb y s mb width s resync mb x pdif put bits ptr s pb s ptr lastgob emms c s avctx rtp callback s avctx s ptr lastgob pdif number mb return 0 void ff MPV frame end Mpeg Enc Context s int i if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s else if s er error count s encoding s avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU s unrestricted mv s current picture f reference s intra only s flags CODECFLAGEMUEDGE const AV Pix Fmt Descriptor desc av pix fmt desc get s avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h s dsp draw edges s current picture f data 0 s linesize s h edge pos s v edge pos EDGEWIDTHEDGEWIDTHEDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 1 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM s dsp draw edges s current picture f data 2 s uvlinesize s h edge pos hshift s v edge pos vshift EDGEWIDTH hshift EDGEWIDTH vshift EDGETOPEDGEBOTTOM emms c s last pict type s pict type s last lambda for s pict type s current picture ptr f quality if s pict type AVPICTURETYPEB s last non b pict type s pict type i MAXPICTURECOUNT i if s picture i f data 0 s current picture f data 0 s picture i s current picture break assert i MAXPICTURECOUNT for i 0 i s picture count i if s picture i f data 0 s picture i f reference free frame buffer s s picture i static int bmv aud decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int blocks 0 total blocks i int ret int16 t output samples int scale 2 total blocks buf if buf size total blocks 65 1 av log avctx AVLOGERROR expected d bytes got d n total blocks 65 1 buf size return AVERRORINVALIDDATA frame nb samples total blocks 32 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret output samples int16 t frame data 0 for blocks 0 blocks total blocks blocks uint8 t code buf code code 1 code 7 scale 0 bmv aud mults code 0x F scale 1 bmv aud mults code 4 for i 0 i 32 i output samples av clip int16 scale 0 int8 t buf 5 output samples av clip int16 scale 1 int8 t buf 5 got frame ptr 1 return buf size void vp9 tokenize initialize TOKENVALUE const t dct value tokens DCTMAXVALUE const vp9 extra bit const e vp9 extra bits int i DCTMAXVALUE int sign 1 do if i sign 0 const int a sign i i int eb sign if a 4 int j 4 while j 11 e j base val a t i token j eb a e j base val 1 else t i token a t i extra eb int cost 0 const vp9 extra bit p vp9 extra bits t i token if p base val const int extra t i extra const int length p len if length cost treed cost p tree p prob extra 1 length cost vp9 cost bit vp9 prob half extra 1 dct value cost i DCTMAXVALUE cost while i DCTMAXVALUE vp9 dct value tokens ptr dct value tokens DCTMAXVALUE vp9 dct value cost ptr dct value cost static int zrsdparams i ctx t i ctx p os ptr op osp ref p Filter ref p Decode Parms int Intent 0 bool Async Read false ref empty array filter1 array parms1 array uint i int code 0 if ref stack count o stack 1 return error gs error stackunderflow if r has type op t dictionary r has type op t null return error gs error typecheck make empty array empty array a readonly if r has type op t dictionary dict find string op Filter p Filter 0 if r is array p Filter if r has type p Filter t name return error gs error typecheck make array filter1 array a readonly 1 p Filter p Filter filter1 array else p Filter empty array if p Filter empty array dict find string op Decode Parms p Decode Parms 0 if p Filter filter1 array make array parms1 array a readonly 1 p Decode Parms p Decode Parms parms1 array else if r is array p Decode Parms return error gs error typecheck else if r size p Filter r size p Decode Parms return error gs error rangecheck else p Decode Parms 0 for i 0 i r size p Filter i ref f fname dp array get imemory p Filter long i f if r has type f t name return error gs error typecheck name string ref imemory f fname if r size fname 6 memcmp fname value bytes r size fname 6 Decode 6 return error gs error rangecheck if p Decode Parms array get imemory p Decode Parms long i dp if r has type dp t dictionary r has type dp t null return error gs error typecheck if r has type op t dictionary code dict int param op Intent 0 3 0 Intent if code 0 code gs error rangecheck return code if r has type op t dictionary if code dict bool param op Async Read false Async Read 0 return code push 1 op 1 p Filter if p Decode Parms op p Decode Parms else make null op return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic avctx coded frame const uint32 t src const uint32 t avpkt data int aligned width FFALIGN avctx width 64 uint8 t dst line if pic data 0 avctx release buffer avctx pic if avpkt size 4 aligned width avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 dst line pic data 0 for h 0 h avctx height h uint16 t dst uint16 t dst line for w 0 w avctx width w uint32 t pixel av be2ne32 src uint16 t r g b if avctx codec id AVCODECID R210 b pixel 6 g pixel 4 0xffc0 r pixel 14 0xffc0 else b pixel 4 g pixel 6 0xffc0 r pixel 16 0xffc0 dst r r 10 dst g g 10 dst b b 10 src aligned width avctx width dst line pic linesize 0 got frame 1 AV Frame data avctx coded frame return avpkt size static Selectivity calc arraycontsel Variable Stat Data vardata Datum constval Oid elemtype Oid operator Selectivity selec Type Cache Entry typentry Fmgr Info cmpfunc Array Type array typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid return DEFAULTSEL operator cmpfunc typentry cmp proc finfo array Datum Get Array Type P constval if Heap Tuple Is Valid vardata stats Tuple Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if operator OIDARRAYCONTAINEDOP get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 selec mcelem array selec array typentry values nvalues numbers nnumbers hist nhist operator cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc selec 1 0 stats stanullfrac else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc if Pointer Get Datum array constval pfree array return selec static int libopus decode AV Codec Context avc void data int got frame ptr AV Packet pkt struct libopus context opus avc priv data AV Frame frame data int ret nb samples frame nb samples MAXFRAMESIZE ret ff get buffer avc frame if ret 0 av log avc AVLOGERROR get buffer failed n return ret if avc sample fmt AVSAMPLEFMT S16 nb samples opus multistream decode opus dec pkt data pkt size opus int16 frame data 0 frame nb samples 0 else nb samples opus multistream decode float opus dec pkt data pkt size float frame data 0 frame nb samples 0 if nb samples 0 av log avc AVLOGERROR Decoding error s n opus strerror nb samples return ff opus error to averror nb samples frame nb samples nb samples got frame ptr 1 return pkt size static inline int direct search Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me int P 10 2 const int mot stride s mb stride const int mot xy mb y mot stride mb x const int shift 1 s quarter sample int dmin i const int time pp s pp time const int time pb s pb time int mx my xmin xmax ymin ymax int16 t mv table 2 s b direct mv table c current mv penalty c mv penalty 1 MAXMV ymin xmin 32 shift ymax xmax 31 shift if IS 8 X8 s next picture mb type mot xy s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 for i 0 i 4 i int index s block index i int min max c co located mv i 0 s next picture motion val 0 index 0 c co located mv i 1 s next picture motion val 0 index 1 c direct basis mv i 0 c co located mv i 0 time pb time pp i 1 shift 3 c direct basis mv i 1 c co located mv i 1 time pb time pp i 1 shift 3 max FFMAX c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift min FFMIN c direct basis mv i 0 c direct basis mv i 0 c co located mv i 0 shift max 16 mb x 1 min 16 mb x 1 xmax FFMIN xmax s width max xmin FFMAX xmin 16 min max FFMAX c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift min FFMIN c direct basis mv i 1 c direct basis mv i 1 c co located mv i 1 shift max 16 mb y 1 min 16 mb y 1 ymax FFMIN ymax s height max ymin FFMAX ymin 16 min if s mv type MVTYPE 16 X16 break assert xmax 15 ymax 15 xmin 16 ymin 16 if xmax 0 xmin 0 ymax 0 ymin 0 s b direct mv table mot xy 0 0 s b direct mv table mot xy 1 0 return 256 256 256 64 c xmin xmin c ymin ymin c xmax xmax c ymax ymax c flags FLAGDIRECT c sub flags FLAGDIRECT c pred x 0 c pred y 0 PLEFT 0 av clip mv table mot xy 1 0 xmin shift xmax shift PLEFT 1 av clip mv table mot xy 1 1 ymin shift ymax shift if s first slice line PTOP 0 av clip mv table mot xy mot stride 0 xmin shift xmax shift PTOP 1 av clip mv table mot xy mot stride 1 ymin shift ymax shift PTOPRIGHT 0 av clip mv table mot xy mot stride 1 0 xmin shift xmax shift PTOPRIGHT 1 av clip mv table mot xy mot stride 1 1 ymin shift ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 dmin ff epzs motion search s mx my P 0 0 mv table 1 16 shift 0 16 if c sub flags FLAGQPEL dmin qpel motion search s mx my dmin 0 0 0 16 else dmin hpel motion search s mx my dmin 0 0 0 16 if c avctx me sub cmp c avctx mb cmp c skip dmin get mb score s mx my 0 0 0 16 1 get limits s 16 mb x 16 mb y mv table mot xy 0 mx mv table mot xy 1 my c flags FLAGDIRECT c sub flags FLAGDIRECT return dmin static int ws snd decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int in size out size ret int sample 128 uint8 t samples uint8 t samples end if buf size return 0 if buf size 4 av log avctx AVLOGERROR packet is too small n return AVERROREINVAL out size AVR L16 buf 0 in size AVR L16 buf 2 buf 4 if in size buf size av log avctx AVLOGERROR Frame data is larger than input buffer n return 1 frame nb samples out size if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples frame data 0 samples end samples out size if in size out size memcpy samples buf out size got frame ptr 1 return buf size while samples samples end buf avpkt data buf size int code smp size uint8 t count code buf 6 count buf 0x3 F buf switch code case 0 smp 4 count 1 break case 1 smp 2 count 1 break case 2 smp count 0x20 1 count 1 break default smp count 1 break if samples end samples smp break size code 2 count 0x20 code 3 0 count 1 if buf avpkt data size buf size break switch code case 0 for count count 0 count code buf sample code 0x3 2 sample av clip uint8 sample samples sample sample code 2 0x3 2 sample av clip uint8 sample samples sample sample code 4 0x3 2 sample av clip uint8 sample samples sample sample code 6 2 sample av clip uint8 sample samples sample break case 1 for count count 0 count code buf sample ws adpcm 4bit code 0x F sample av clip uint8 sample samples sample sample ws adpcm 4bit code 4 sample av clip uint8 sample samples sample break case 2 if count 0x20 int8 t t t count t 3 sample t 3 sample av clip uint8 sample samples sample else memcpy samples buf smp samples smp buf smp sample buf 1 break default memset samples sample smp samples smp frame nb samples samples frame data 0 got frame ptr 1 return buf size void vmmouse get data uint32 t data X86 CPU cpu X86 CPU current cpu CPU X86 State env cpu env data 0 env regs REAX data 1 env regs REBX data 2 env regs RECX data 3 env regs REDX data 4 env regs RESI data 5 env regs WORKSTATE ossl statem server pre work SSL s WORKSTATE wst OSSLSTATEM st s statem switch st hand state case TLSSTSWHELLOREQ s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s break case DTLSSTSWHELLOVERIFYREQUEST s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s st use timer 0 break case TLSSTSWSRVRHELLO if SSLISDTLS s st use timer 1 break case TLSSTSWSRVRDONE ifndef OPENSSLNOSCTP if SSLISDTLS s BIO dgram is sctp SSL get wbio s return dtls wait for dry s case TLSSTSWSESSIONTICKET if SSLISDTLS s st use timer 0 break case TLSSTSWCHANGE s session cipher s s3 tmp new cipher if s method ssl3 enc setup key block s ossl statem set error s return WORKERROR if SSLISDTLS s st use timer 0 return WORKFINISHEDCONTINUE case TLSSTOK return tls finish handshake s wst default break return static int vcr1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size VC R1 Context const a avctx priv data AV Frame picture data AV Frame const p a picture const uint8 t bytestream buf int i x y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 for i 0 i 16 i a delta i bytestream bytestream for y 0 y avctx height y int offset uint8 t luma a picture data 0 y a picture linesize 0 if y 3 0 uint8 t cb a picture data 1 y 2 a picture linesize 1 uint8 t cr a picture data 2 y 2 a picture linesize 2 for i 0 i 4 i a offset i bytestream offset a offset 0 a delta bytestream 2 0x F for x 0 x avctx width x 4 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 0 0x F luma 3 offset a delta bytestream 0 4 luma 4 cb bytestream 3 cr bytestream 1 bytestream 4 else offset a offset y 3 a delta bytestream 2 0x F for x 0 x avctx width x 8 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 3 0x F luma 3 offset a delta bytestream 3 4 luma 4 offset a delta bytestream 0 0x F luma 5 offset a delta bytestream 0 4 luma 6 offset a delta bytestream 1 0x F luma 7 offset a delta bytestream 1 4 luma 8 bytestream 4 picture a picture got frame 1 return buf size static int slice end AV Codec Context avctx AV Frame pict Mpeg1 Context s1 avctx priv data Mpeg Enc Context s s1 mpeg enc ctx if s1 mpeg enc ctx allocated s current picture ptr return 0 if s avctx hwaccel if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode picture n if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s if s first field ff er frame end s er ff MPV frame end s if s pict type AVPICTURETYPEB s low delay int ret av frame ref pict s current picture ptr f if ret 0 return ret ff print debug info s s current picture ptr else if avctx active thread type FFTHREADFRAME s picture number if s last picture ptr NULL int ret av frame ref pict s last picture ptr f if ret 0 return ret ff print debug info s s last picture ptr return 1 else return 0 size t compile tree struct filter op fop int i 1 struct filter op array NULL struct unfold elm ue if tree root NULL return 0 fprintf stdout Unfolding the meta tree fflush stdout unfold blk tree root fprintf stdout done n n labels to offsets TAILQFOREACH ue unfolded tree next if ue label 0 SAFEREALLOC array i sizeof struct filter op memcpy array i 1 ue fop sizeof struct filter op i SAFEREALLOC array i sizeof struct filter op array i 1 opcode FOPEXIT fop array return i int EVP Encrypt Update EVPCIPHERCTX ctx unsigned char out int outl const unsigned char in int inl int i j bl if ctx cipher flags EVPCIPHFLAGCUSTOMCIPHER i ctx cipher do cipher ctx out in inl if i 0 return 0 else outl i return 1 if inl 0 outl 0 return inl 0 if ctx buf len 0 inl ctx block mask 0 if ctx cipher do cipher ctx out in inl outl inl return 1 else outl 0 return 0 i ctx buf len bl ctx cipher block size OPENSSL assert bl int sizeof ctx buf if i 0 if bl i inl memcpy ctx buf i in inl ctx buf len inl outl 0 return 1 else j bl i memcpy ctx buf i in j if ctx cipher do cipher ctx out ctx buf bl return 0 inl j in j out bl outl bl else outl 0 i inl bl 1 inl i if inl 0 if ctx cipher do cipher ctx out in inl return 0 outl inl if i 0 memcpy ctx buf in inl i ctx buf len i return 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Four X Context const f avctx priv data AV Frame picture data AV Frame p int i frame 4cc frame size ret frame 4cc AVR L32 buf if buf size AVR L32 buf 4 8 buf size 20 av log f avctx AVLOGERROR size mismatch d d n buf size AVR L32 buf 4 if frame 4cc AVR L32 cfrm int free index 1 const int data size buf size 20 const int id AVR L32 buf 12 const int whole size AVR L32 buf 16 C Frame Buffer cfrm for i 0 i CFRAMEBUFFERCOUNT i if f cfrm i id f cfrm i id avctx frame number av log f avctx AVLOGERROR lost c frame d n f cfrm i id for i 0 i CFRAMEBUFFERCOUNT i if f cfrm i id id break if f cfrm i size 0 free index i if i CFRAMEBUFFERCOUNT i free index f cfrm i id id cfrm f cfrm i cfrm data av fast realloc cfrm data cfrm allocated size cfrm size data size FFINPUTBUFFERPADDINGSIZE if cfrm data av log f avctx AVLOGERROR realloc failure return AVERRORENOMEM memcpy cfrm data cfrm size buf 20 data size cfrm size data size if cfrm size whole size buf cfrm data frame size cfrm size if id avctx frame number av log f avctx AVLOGERROR cframe id mismatch d d n id avctx frame number cfrm size cfrm id 0 frame 4cc AVR L32 pfrm else return buf size else buf buf 12 frame size buf size 12 FFSWAPAV Frame f current picture f last picture p f current picture avctx coded frame p avctx flags CODECFLAGEMUEDGE if p data 0 avctx release buffer avctx p p reference 1 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret if frame 4cc AVR L32 ifr2 p pict type AVPICTURETYPEI if ret decode i2 frame f buf 4 frame size 4 0 return ret else if frame 4cc AVR L32 ifrm p pict type AVPICTURETYPEI if ret decode i frame f buf frame size 0 return ret else if frame 4cc AVR L32 pfrm frame 4cc AVR L32 pfr2 if f last picture data 0 f last picture reference 1 if ret ff get buffer avctx f last picture 0 av log avctx AVLOGERROR get buffer failed n return ret memset f last picture data 0 0 avctx height FFABS f last picture linesize 0 p pict type AVPICTURETYPEP if ret decode p frame f buf frame size 0 return ret else if frame 4cc AVR L32 snd av log avctx AVLOGERROR ignoring snd chunk length d n buf size else av log avctx AVLOGERROR ignoring unknown chunk length d n buf size p key frame p pict type AVPICTURETYPEI picture p got frame 1 emms c return buf size static int aura decode frame AV Codec Context avctx void data int got frame AV Packet pkt Aura Decode Context s avctx priv data uint8 t YUV uint8 t val int x y ret const uint8 t buf pkt data const int8 t delta table const int8 t buf 16 if pkt size 48 avctx height avctx width av log avctx AVLOGERROR got a buffer with d bytes when d were expected n pkt size 48 avctx height avctx width return AVERRORINVALIDDATA buf 48 if s frame data 0 avctx release buffer avctx s frame s frame buffer hints FFBUFFERHINTSVALID s frame reference 0 if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret Y s frame data 0 U s frame data 1 V s frame data 2 for y 0 y avctx height y val buf U 0 val 0x F0 Y 0 val 4 val buf V 0 val 0x F0 Y 1 Y 0 delta table val 0x FY 2 UV for x 1 x avctx width 1 x val buf U 0 U 1 delta table val 4 Y 0 Y 1 delta table val 0x F val buf V 0 V 1 delta table val 4 Y 1 Y 0 delta table val 0x FY 2 UVY s frame linesize 0 avctx width U s frame linesize 1 avctx width 1 V s frame linesize 2 avctx width 1 got frame 1 AV Frame data s frame return pkt size static int ra288 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float out int i ret R A288 Context ractx avctx priv data Get Bit Context gb if buf size avctx block align av log avctx AVLOGERROR Error Input buffer is too small d d n buf size avctx block align return AVERRORINVALIDDATA frame nb samples R A288 BLOCKSIZER A288 BLOCKSPERFRAME if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out float frame data 0 init get bits gb buf avctx block align 8 for i 0 i R A288 BLOCKSPERFRAME i float gain amptable get bits gb 3 int cb coef get bits gb 6 i 1 decode ractx gain cb coef memcpy out ractx sp hist 70 36 R A288 BLOCKSIZE sizeof out out R A288 BLOCKSIZE if i 7 3 backward filter ractx ractx sp hist ractx sp rec syn window ractx sp lpc syn bw tab 36 40 35 70 backward filter ractx ractx gain hist ractx gain rec gain window ractx gain lpc gain bw tab 10 8 20 28 got frame ptr 1 return avctx block align static int ivr read header AV Format Context s unsigned tag type len tlen value int i j n count nb streams 0 ret uint8 t key 256 val 256 AVIO Context pb s pb AV Stream st int64 t pos offset temp pos avio tell pb tag avio rl32 pb if tag MKTAGR 1 M if avio rb16 pb 1 return AVERRORINVALIDDATA if avio r8 pb 1 return AVERRORINVALIDDATA len avio rb32 pb avio skip pb len avio skip pb 5 temp avio rb64 pb while avio feof pb temp offset temp temp avio rb64 pb avio skip pb offset avio tell pb if avio r8 pb 1 return AVERRORINVALIDDATA len avio rb32 pb avio skip pb len if avio r8 pb 2 return AVERRORINVALIDDATA avio skip pb 16 pos avio tell pb tag avio rl32 pb if tag MKTAGREC return AVERRORINVALIDDATA if avio r8 pb 0 return AVERRORINVALIDDATA count avio rb32 pb for i 0 i count i if avio feof pb return AVERRORINVALIDDATA type avio r8 pb tlen avio rb32 pb avio get str pb tlen key sizeof key len avio rb32 pb if type 5 avio get str pb len val sizeof val av log s AVLOGDEBUG s s n key val else if type 4 av log s AVLOGDEBUG s 0x key for j 0 j len j if avio feof pb return AVERRORINVALIDDATA av log s AVLOGDEBUGX avio r8 pb av log s AVLOGDEBUG n else if len 4 type 3 strncmp key Stream Count tlen nb streams value avio rb32 pb else if len 4 type 3 value avio rb32 pb av log s AVLOGDEBUG s d n key value else av log s AVLOGDEBUG Skipping unsupported key s n key avio skip pb len for n 0 n nb streams n st avformat new stream s NULL if st return AVERRORENOMEM st priv data ff rm alloc rmstream if st priv data return AVERRORENOMEM if avio r8 pb 1 return AVERRORINVALIDDATA count avio rb32 pb for i 0 i count i if avio feof pb return AVERRORINVALIDDATA type avio r8 pb tlen avio rb32 pb avio get str pb tlen key sizeof key len avio rb32 pb if type 5 avio get str pb len val sizeof val av log s AVLOGDEBUG s s n key val else if type 4 strncmp key Opaque Data tlen ret ffio ensure seekback pb 4 if ret 0 return ret if avio rb32 pb MKBETAGMLTI ret rm read multi s pb st NULL else avio seek pb 4 SEEKCUR ret ff rm read mdpr codecdata s pb st st priv data len NULL if ret 0 return ret else if type 4 int j av log s AVLOGDEBUG s 0x key for j 0 j len j av log s AVLOGDEBUGX avio r8 pb av log s AVLOGDEBUG n else if len 4 type 3 strncmp key Duration tlen st duration avio rb32 pb else if len 4 type 3 value avio rb32 pb av log s AVLOGDEBUG s d n key value else av log s AVLOGDEBUG Skipping unsupported key s n key avio skip pb len if avio r8 pb 6 return AVERRORINVALIDDATA avio skip pb 12 avio skip pb avio rb64 pb pos avio tell s pb if avio r8 pb 8 return AVERRORINVALIDDATA avio skip pb 8 return 0 static void vc1 mc 1mv V C1 Context v int dir Mpeg Enc Context s v s DSP Context dsp v s dsp H264 Chroma Context h264chroma v h264chroma uint8 t src Y src U src V int dxy mx my uvmx uvmy src x src y uvsrc x uvsrc y int off off uv int v edge pos s v edge pos v field mode if v field mode v ref field type dir 1 v cur field type 1 v s last picture f data 0 return mx s mv dir 0 0 my s mv dir 0 1 if s pict type AVPICTURETYPEP s current picture f motion val 1 s block index 0 v blocks off 0 mx s current picture f motion val 1 s block index 0 v blocks off 1 my uvmx mx mx 3 3 1 uvmy my my 3 3 1 v luma mv s mb x 0 uvmx v luma mv s mb x 1 uvmy if v field mode v cur field type v ref field type dir my my 2 4 v cur field type uvmy uvmy 2 4 v cur field type if v fastuvmc v fcm ILACEFRAME uvmx uvmx uvmx 0 uvmx 1 uvmx 1 uvmy uvmy uvmy 0 uvmy 1 uvmy 1 if v field mode if dir if v cur field type v ref field type dir v cur field type src Y s current picture f data 0 src U s current picture f data 1 src V s current picture f data 2 else src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 else if dir src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 src x s mb x 16 mx 2 src y s mb y 16 my 2 uvsrc x s mb x 8 uvmx 2 uvsrc y s mb y 8 uvmy 2 if v profile PROFILEADVANCED src x av clip src x 16 s mb width 16 src y av clip src y 16 s mb height 16 uvsrc x av clip uvsrc x 8 s mb width 8 uvsrc y av clip uvsrc y 8 s mb height 8 else src x av clip src x 17 s avctx coded width src y av clip src y 18 s avctx coded height 1 uvsrc x av clip uvsrc x 8 s avctx coded width 1 uvsrc y av clip uvsrc y 8 s avctx coded height 1 src Y src y s linesize src x src U uvsrc y s uvlinesize uvsrc x src V uvsrc y s uvlinesize uvsrc x if v field mode v ref field type dir src Y s current picture ptr f linesize 0 src U s current picture ptr f linesize 1 src V s current picture ptr f linesize 2 if s flags CODECFLAGGRAY src U s edge emu buffer 18 s linesize src V s edge emu buffer 18 s linesize if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 22 v edge pos 22 unsigned src x s mspel s h edge pos mx 3 16 s mspel 3 unsigned src y 1 v edge pos my 3 16 3 uint8 t uvbuf s edge emu buffer 19 s linesize src Y s mspel 1 s linesize s vdsp emulated edge mc s edge emu buffer src Y s linesize 17 s mspel 2 17 s mspel 2 src x s mspel src y s mspel s h edge pos v edge pos src Y s edge emu buffer s vdsp emulated edge mc uvbuf src U s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 s vdsp emulated edge mc uvbuf 16 src V s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 src U uvbuf src V uvbuf 16 if v rangeredfrm int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i src i 128 1 128 src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i src i 128 1 128 src2 i src2 i 128 1 128 src s uvlinesize src2 s uvlinesize if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i v luty src i src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i v lutuv src i src2 i v lutuv src2 i src s uvlinesize src2 s uvlinesize src Y s mspel 1 s linesize if v field mode v cur field type off s current picture ptr f linesize 0 off uv s current picture ptr f linesize 1 else off 0 off uv 0 if s mspel dxy my 3 2 mx 3 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 src Y 8 s linesize v rnd src Y s linesize 8 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize 8 src Y 8 s linesize v rnd else dxy my 2 mx 2 1 if v rnd dsp put pixels tab 0 dxy s dest 0 off src Y s linesize 16 else dsp put no rnd pixels tab 0 dxy s dest 0 off src Y s linesize 16 if s flags CODECFLAGGRAY return uvmx uvmx 3 1 uvmy uvmy 3 1 if v rnd h264chroma put h264 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy h264chroma put h264 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy else v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy static void slurm rpc submit batch job slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESSDEFTIMERS uint32 t job id 0 priority 0 struct job record job ptr NULL slurm msg t response msg submit response msg t submit msg job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info gid t gid g slurm auth get gid msg auth cred slurmctld config auth info char err msg NULL job submit user msg NULL bool reject job false STARTTIMER debug2 Processing RPCREQUESTSUBMITBATCHJOB from uid d uid if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if error code valid id REQUESTSUBMITBATCHJOB job desc msg uid gid reject job true goto send msg if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTSUBMITBATCHJOB lacks alloc node from uid d uid dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if error code reject job true goto send msg throttle start active rpc cnt lock slurmctld job write lock STARTTIMER if fed mgr fed rec if fed mgr job allocate msg job desc msg false uid msg protocol version job id error code err msg reject job true else job desc msg pack job offset NOVAL error code job allocate job desc msg job desc msg immediate false NULL 0 uid job ptr err msg msg protocol version if job ptr error code job ptr job state JOBFAILED reject job true else job id job ptr job id priority job ptr priority if job desc msg immediate error code SLURMSUCCESS error code ESLURMCANNOTSTARTIMMEDIATELY reject job true unlock slurmctld job write lock throttle fini active rpc cnt send msg ENDTIME R2 slurm rpc submit batch job if reject job info s s func slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else info s Job Id u Init Prio u s func job id priority TIMESTR submit msg job id job id submit msg step id SLURMBATCHSCRIPT submit msg error code error code submit msg job submit user msg job submit user msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg conn msg conn response msg msg type RESPONSESUBMITBATCHJOB response msg data submit msg slurm send node msg msg conn fd response msg schedule job save schedule node save queue job scheduler xfree err msg xfree job submit user msg static vpx codec err t validate config vpx codec alg priv t ctx const vpx codec enc cfg t cfg const struct vp9 extracfg extra cfg RANGECHECK cfg g w 1 65535 RANGECHECK cfg g h 1 65535 RANGECHECK cfg g timebase den 1 1000000000 RANGECHECK cfg g timebase num 1 cfg g timebase den RANGECHECKHI cfg g profile 3 RANGECHECKHI cfg rc max quantizer 63 RANGECHECKHI cfg rc min quantizer cfg rc max quantizer RANGECHECKBOOL extra cfg lossless RANGECHECK extra cfg aq mode 0 AQMODECOUNT 1 RANGECHECK extra cfg frame periodic boost 0 1 RANGECHECKHI cfg g threads 64 RANGECHECKHI cfg g lag in frames MAXLAGBUFFERSRANGECHECK cfg rc end usage VPXVBRVPXQRANGECHECKHI cfg rc undershoot pct 1000 RANGECHECKHI cfg rc overshoot pct 1000 RANGECHECKHI cfg rc 2pass vbr bias pct 100 RANGECHECK cfg kf mode VPXKFDISABLEDVPXKFAUTORANGECHECKBOOL cfg rc resize allowed RANGECHECKHI cfg rc dropframe thresh 100 RANGECHECKHI cfg rc resize up thresh 100 RANGECHECKHI cfg rc resize down thresh 100 RANGECHECK cfg g pass VPXRCONEPASSVPXRCLASTPASS if cfg rc resize allowed 1 RANGECHECK cfg rc scaled width 1 cfg g w RANGECHECK cfg rc scaled height 1 cfg g h RANGECHECK cfg ss number layers 1 VPXSSMAXLAYERSRANGECHECK cfg ts number layers 1 VPXTSMAXLAYERS if cfg ts number layers 1 unsigned int i for i 1 i cfg ts number layers i if cfg ts target bitrate i cfg ts target bitrate i 1 ERROR ts target bitrate entries are not increasing RANGECHECK cfg ts rate decimator cfg ts number layers 1 1 1 for i cfg ts number layers 2 i 0 i if cfg ts rate decimator i 1 2 cfg ts rate decimator i ERROR ts rate decimator factors are not powers of 2 unsigned int i alt ref sum 0 for i 0 i cfg ss number layers i if cfg ss enable auto alt ref i alt ref sum if alt ref sum REFFRAMES cfg ss number layers ERROR Not enough ref buffers for svc alt ref frames if cfg ss number layers 3 cfg ss number layers cfg ts number layers 4 cfg g error resilient 0 ERROR Multiple frame context are not supported for more than 3 spatial layers or more than 4 spatial x temporal layers int dtls1 get record SSL s int ssl major ssl minor int i n SS L3 RECORD rr unsigned char p NULL unsigned short version DTL S1 BITMAP bitmap unsigned int is next epoch rr RECORDLAYER get rrec s rlayer again if dtls1 process buffered records s 0 return 1 if dtls1 get processed record s return 1 if RECORDLAYER get rstate s rlayer SSLSTREADBODYRECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH n ssl3 read n s DTL S1 RTHEADERLENGTHSS L3 BUFFER get len s rlayer rbuf 0 1 if n 0 return n if RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTHRECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADBODY p RECORDLAYER get packet s rlayer if s msg callback s msg callback 0 0 SS L3 RTHEADER p DTL S1 RTHEADERLENGTH s s msg callback arg rr type p ssl major p ssl minor p version ssl major 8 ssl minor n2s p rr epoch memcpy RECORDLAYER get read sequence s rlayer 2 p 6 p 6 n2s p rr length if s first packet if version s version rr length 0 RECORDLAYER reset packet length s rlayer goto again if version 0xff00 s version 0xff00 rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length SS L3 RTMAXENCRYPTEDLENGTH rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH i rr length n ssl3 read n s i i 1 1 if n i rr length 0 RECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADHEADER bitmap dtls1 get bitmap s rr is next epoch if bitmap NULL rr length 0 RECORDLAYER reset packet length s rlayer goto again rr length 0 RECORDLAYER reset packet length s rlayer goto again static void h245 setup channels packet info pinfo channel info t upcoming channel lcl rtp dyn payload t rtp dyn payload NULL struct srtp info dummy srtp info NULL if upcoming channel lcl return if strcmp upcoming channel lcl data type str t38fax if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 t38 add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num return if upcoming channel lcl rfc2198 0 rtp dyn payload rtp dyn payload new rtp dyn payload insert rtp dyn payload upcoming channel lcl rfc2198 red 8000 if upcoming channel lcl srtp flag dummy srtp info wmem new0 wmem file scope struct srtp info if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 srtp add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num upcoming channel lcl is video rtp dyn payload dummy srtp info if upcoming channel lcl media control addr addr type ATNONE upcoming channel lcl media control addr port 0 rtcp handle srtcp add address pinfo upcoming channel lcl media control addr addr upcoming channel lcl media control addr port 0 H245 pinfo fd num dummy srtp info static int ec G F2m montgomery point multiply const ECGROUP group ECPOINT r const BIGNUM scalar const ECPOINT point BNCTX ctx BIGNUM x1 x2 z1 z2 int ret 0 i BNULONG mask word if r point E Cerr ECFECG F2 MMONTGOMERYPOINTMULTIPLYECRINVALIDARGUMENT return 0 if scalar NULLBN is zero scalar point NULLECPOINT is at infinity group point return ECPOINT set to infinity group r if point Z is one return 0 BNCTX start ctx x1 BNCTX get ctx z1 BNCTX get ctx if z1 NULL goto err x2 r X z2 r Y bn wexpand x1 group field top bn wexpand z1 group field top bn wexpand x2 group field top bn wexpand z2 group field top if BNG F2m mod arr x1 point X group poly goto err if BN one z1 goto err if group meth field sqr group z2 x1 ctx goto err if group meth field sqr group x2 z2 ctx goto err if BNG F2m add x2 x2 group b goto err i scalar top 1 mask BNTBIT word scalar d i while word mask mask 1 mask 1 if mask i mask BNTBIT for i 0 i word scalar d i while mask BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top if gf2m Madd group point X x2 z2 x1 z1 ctx goto err if gf2m Mdouble group x1 z1 ctx goto err BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top mask 1 mask BNTBIT i gf2m Mxy group point X point Y x1 z1 x2 z2 ctx if i 0 goto err else if i 1 if ECPOINT set to infinity group r goto err else if BN one r Z goto err r Z is one 1 BN set negative r X 0 BN set negative r Y 0 ret 1 err BNCTX end ctx return ret static int decode frame Wmall Decode Ctx s Get Bit Context gb s gb int more frames 0 len 0 i ret s frame nb samples s samples per frame if ret ff get buffer s avctx s frame 0 0 av log s avctx AVLOGERROR not enough space for the output samples n s packet loss 1 return ret for i 0 i s num channels i s samples 16 i int16 t s frame extended data i s samples 32 i int32 t s frame extended data i if s len prefix len get bits gb s log2 frame size if decode tilehdr s s packet loss 1 return 0 if s dynamic range compression s drc gain get bits gb 8 if get bits1 gb int av unused skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx start skip i n skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx end skip i n skip s parsed all subframes 0 for i 0 i s num channels i s channel i decoded samples 0 s channel i cur subframe 0 while s parsed all subframes if decode subframe s 0 s packet loss 1 return 0 av dlog s avctx Frame done n if s skip frame s skip frame 0 if s len prefix if len get bits count gb s frame offset 2 av log s avctx AVLOGERROR frame i would have to skip i bits n s frame num len get bits count gb s frame offset 1 s packet loss 1 return 0 skip bits long gb len get bits count gb s frame offset 1 more frames get bits1 gb s frame num return more frames static int mpeg decode mb Mpeg Enc Context s int16 t block 12 64 int i j k cbp val mb type motion type const int mb block count 4 1 s chroma format av dlog s avctx decode mb x d y d n s mb x s mb y assert s mb skipped 0 if s mb skip run 0 if s pict type AVPICTURETYPEP s mb skipped 1 s current picture mb type s mb x s mb y s mb stride MBTYPESKIPMBTYPE L0 MBTYPE 16x16 else int mb type if s mb x mb type s current picture mb type s mb x s mb y s mb stride 1 else mb type s current picture mb type s mb width s mb y 1 s mb stride 1 if ISINTRA mb type return 1 s current picture mb type s mb x s mb y s mb stride mb type MBTYPESKIP if s mv 0 0 0 s mv 0 0 1 s mv 1 0 0 s mv 1 0 1 0 s mb skipped 1 return 0 switch s pict type default case AVPICTURETYPEI if get bits1 s gb 0 if get bits1 s gb 0 av log s avctx AVLOGERROR invalid mb type in I Frame at d d n s mb x s mb y return 1 mb type MBTYPEQUANTMBTYPEINTRA else mb type MBTYPEINTRA break case AVPICTURETYPEP mb type get vlc2 s gb mb ptype vlc table MBPTYPEVLCBITS 1 if mb type 0 av log s avctx AVLOGERROR invalid mb type in P Frame at d d n s mb x s mb y return 1 mb type ptype2mb type mb type break case AVPICTURETYPEB mb type get vlc2 s gb mb btype vlc table MBBTYPEVLCBITS 1 if mb type 0 av log s avctx AVLOGERROR invalid mb type in B Frame at d d n s mb x s mb y return 1 mb type btype2mb type mb type break av dlog s avctx mb type x n mb type if ISINTRA mb type s dsp clear blocks s block 0 if s chroma y shift s dsp clear blocks s block 6 if s picture structure PICTFRAME s frame pred frame dct s interlaced dct get bits1 s gb if ISQUANT mb type s qscale get qscale s if s concealment motion vectors if s picture structure PICTFRAME skip bits1 s gb s mv 0 0 0 s last mv 0 0 0 s last mv 0 1 0 mpeg decode motion s s mpeg f code 0 0 s last mv 0 0 0 s mv 0 0 1 s last mv 0 0 1 s last mv 0 1 1 mpeg decode motion s s mpeg f code 0 1 s last mv 0 0 1 skip bits1 s gb else memset s last mv 0 sizeof s last mv s mb intra 1 if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration 1 ff xvmc pack pblocks s 1 if s swap uv exchange uv s if s codec id AVCODECIDMPE G2 VIDEO if s flags2 CODECFLA G2 FAST for i 0 i 6 i mpeg2 fast decode block intra s s pblocks i i else for i 0 i mb block count i if mpeg2 decode block intra s s pblocks i i 0 return 1 else for i 0 i 6 i if mpeg1 decode block intra s s pblocks i i 0 return 1 else if mb type MBTYPEZEROMV assert mb type MBTYPECBP s mv dir MVDIRFORWARD if s picture structure PICTFRAME if s frame pred frame dct s interlaced dct get bits1 s gb s mv type MVTYPE 16 X16 else s mv type MVTYPEFIELD mb type MBTYPEINTERLACED s field select 0 0 s picture structure 1 if ISQUANT mb type s qscale get qscale s s last mv 0 0 0 0 s last mv 0 0 1 0 s last mv 0 1 0 0 s last mv 0 1 1 0 s mv 0 0 0 0 s mv 0 0 1 0 else assert mb type MBTYPE L0 L1 if s frame pred frame dct motion type MTFRAME else motion type get bits s gb 2 if s picture structure PICTFRAMEHASCBP mb type s interlaced dct get bits1 s gb if ISQUANT mb type s qscale get qscale s s mv dir mb type 13 3 av dlog s avctx motion type d n motion type switch motion type case MTFRAME if s picture structure PICTFRAME mb type MBTYPE 16x16 s mv type MVTYPE 16 X16 for i 0 i 2 i if USESLIST mb type i s mv i 0 0 s last mv i 0 0 s last mv i 1 0 mpeg decode motion s s mpeg f code i 0 s last mv i 0 0 s mv i 0 1 s last mv i 0 1 s last mv i 1 1 mpeg decode motion s s mpeg f code i 1 s last mv i 0 1 if s full pel i s mv i 0 0 1 s mv i 0 1 1 else mb type MBTYPE 16x8 MBTYPEINTERLACED s mv type MVTYPE 16 X8 for i 0 i 2 i if USESLIST mb type i for j 0 j 2 j s field select i j get bits1 s gb for k 0 k 2 k val mpeg decode motion s s mpeg f code i k s last mv i j k s last mv i j k val s mv i j k val break case MTFIELD s mv type MVTYPEFIELD if s picture structure PICTFRAME mb type MBTYPE 16x8 MBTYPEINTERLACED for i 0 i 2 i if USESLIST mb type i for j 0 j 2 j s field select i j get bits1 s gb val mpeg decode motion s s mpeg f code i 0 s last mv i j 0 s last mv i j 0 val s mv i j 0 val av dlog s avctx fmx d n val val mpeg decode motion s s mpeg f code i 1 s last mv i j 1 1 s last mv i j 1 val 1 s mv i j 1 val av dlog s avctx fmy d n val else mb type MBTYPE 16x16 MBTYPEINTERLACED for i 0 i 2 i if USESLIST mb type i s field select i 0 get bits1 s gb for k 0 k 2 k val mpeg decode motion s s mpeg f code i k s last mv i 0 k s last mv i 0 k val s last mv i 1 k val s mv i 0 k val break case MTDMV s mv type MVTYPEDMV for i 0 i 2 i if USESLIST mb type i int dmx dmy mx my m const int my shift s picture structure PICTFRAME mx mpeg decode motion s s mpeg f code i 0 s last mv i 0 0 s last mv i 0 0 mx s last mv i 1 0 mx dmx get dmv s my mpeg decode motion s s mpeg f code i 1 s last mv i 0 1 my shift dmy get dmv s s last mv i 0 1 my my shift s last mv i 1 1 my my shift s mv i 0 0 mx s mv i 0 1 my s mv i 1 0 mx s mv i 1 1 my if s picture structure PICTFRAME mb type MBTYPE 16x16 MBTYPEINTERLACED m s top field first 1 3 s mv i 2 0 mx m mx 0 1 dmx s mv i 2 1 my m my 0 1 dmy 1 m 4 m s mv i 3 0 mx m mx 0 1 dmx s mv i 3 1 my m my 0 1 dmy 1 else mb type MBTYPE 16x16 s mv i 2 0 mx mx 0 1 dmx s mv i 2 1 my my 0 1 dmy if s picture structure PICTTOPFIELD s mv i 2 1 else s mv i 2 1 break default av log s avctx AVLOGERROR 00 motion type at d d n s mb x s mb y return 1 s mb intra 0 if HASCBP mb type s dsp clear blocks s block 0 cbp get vlc2 s gb mb pat vlc table MBPATVLCBITS 1 if mb block count 6 cbp mb block count 6 cbp get bits s gb mb block count 6 s dsp clear blocks s block 6 if cbp 0 av log s avctx AVLOGERROR invalid cbp at d d n s mb x s mb y return 1 if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration 1 ff xvmc pack pblocks s cbp if s swap uv exchange uv s if s codec id AVCODECIDMPE G2 VIDEO if s flags2 CODECFLA G2 FAST for i 0 i 6 i if cbp 32 mpeg2 fast decode block non intra s s pblocks i i else s block last index i 1 cbp cbp else cbp 12 mb block count for i 0 i mb block count i if cbp 1 11 if mpeg2 decode block non intra s s pblocks i i 0 return 1 else s block last index i 1 cbp cbp else if s flags2 CODECFLA G2 FAST for i 0 i 6 i if cbp 32 mpeg1 fast decode block inter s s pblocks i i else s block last index i 1 cbp cbp else for i 0 i 6 i if cbp 32 if mpeg1 decode block inter s s pblocks i i 0 return 1 else s block last index i 1 cbp cbp else for i 0 i 12 i s block last index i 1 s current picture mb type s mb x s mb y s mb stride mb type return 0 int ff h264 decode ref pic list reordering H264 Context h int list index pic structure i print short term h print long term h for list 0 list h list count list for i 0 i h ref count list i COPYPICTURE h ref list list i h default ref list list i if get bits1 h gb int pred h curr pic num for index 0 index unsigned int reordering of pic nums idc get ue golomb 31 h gb unsigned int pic id int i Picture ref NULL if reordering of pic nums idc 3 break if index h ref count list av log h avctx AVLOGERROR reference count overflow n return 1 if reordering of pic nums idc 3 if reordering of pic nums idc 2 const unsigned int abs diff pic num get ue golomb h gb 1 int frame num if abs diff pic num h max pic num av log h avctx AVLOGERROR abs diff pic num overflow n return 1 if reordering of pic nums idc 0 pred abs diff pic num else pred abs diff pic num pred h max pic num 1 frame num pic num extract h pred pic structure for i h short ref count 1 i 0 i ref h short ref i assert ref reference assert ref long ref if ref frame num frame num ref reference pic structure break if i 0 ref pic id pred else int long idx pic id get ue golomb h gb long idx pic num extract h pic id pic structure if long idx 31 av log h avctx AVLOGERROR long term pic idx overflow n return 1 ref h long ref long idx assert ref ref reference if ref ref reference pic structure ref pic id pic id assert ref long ref i 0 else i 1 if i 0 av log h avctx AVLOGERROR reference picture missing during reorder n memset h ref list list index 0 sizeof Picture else for i index i 1 h ref count list i if ref long ref h ref list list i long ref ref pic id h ref list list i pic id break for i index i COPYPICTURE h ref list list i h ref list list i 1 COPYPICTURE h ref list list index ref if FIELDPICTURE pic as field h ref list list index pic structure else av log h avctx AVLOGERROR illegal reordering of pic nums idc n return 1 for list 0 list h list count list for index 0 index h ref count list index if h ref list list index f data 0 av log h avctx AVLOGERROR Missing reference picture n if h default ref list list 0 f data 0 COPYPICTURE h ref list list index h default ref list list 0 else return 1 return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint32 t src const uint32 t avpkt data AV Frame pic avctx coded frame int width avctx width int y 0 uint16 t ydst udst vdst yend int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 8 3 av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA if avpkt size avctx width avctx height 8 3 av log ask for sample avctx Probably padded data n pic reference 0 if ret ff get buffer avctx pic 0 return ret ydst uint16 t pic data 0 udst uint16 t pic data 1 vdst uint16 t pic data 2 yend ydst width pic pict type AVPICTURETYPEI pic key frame 1 for uint32 t v av be2ne32 src udst v 16 0x FF C0 ydst v 6 0x FF C0 vdst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 6 0x FF C0 ydst v 4 0x FF C0 v av be2ne32 src vdst v 16 0x FF C0 ydst v 6 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 vdst v 6 0x FF C0 ydst v 4 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break got frame 1 AV Frame data avctx coded frame return avpkt size int encode function char string struct filter op fop char str strdup string int ret ENOTFOUND char name args int nargs 0 i char dec args NULL char tok memset fop 0 sizeof struct filter op name ec strtok string tok args name strlen name 1 dec args decode args args nargs fop opcode FOPFUNC if strcmp name search if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCSEARCH fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name regex if nargs 2 int err regex t regex char errbuf 100 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCREGEX fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 err regcomp regex const char fop op func string REGEXTENDEDREGNOSUBREGICASE if err regerror err regex errbuf sizeof errbuf SCRIPTERROR s errbuf regfree regex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name pcre regex const char errbuf NULL int erroff if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func string strdup dec args 1 fop op func slen strlen fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else if nargs 3 fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func level 5 fop op func string strdup dec args 1 fop op func slen strlen fop op func string fop op func replace strdup dec args 2 fop op func rlen strlen fop op func replace ret ESUCCESS pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name replace if nargs 2 fop op func op FFUNCREPLACE fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string fop op func replace u char strdup dec args 1 fop op func rlen strescape char fop op func replace char fop op func replace ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name inject if nargs 1 fop op func op FFUNCINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name execinject if nargs 1 fop op func op FFUNCEXECINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name log if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCLOG fop op func string u char strdup dec args 1 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name drop if nargs 0 fop op func op FFUNCDROP ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name kill if nargs 0 fop op func op FFUNCKILL ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name msg if nargs 1 fop op func op FFUNCMSG fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exec if nargs 1 fop op func op FFUNCEXEC fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exit if nargs 0 fop opcode FOPEXIT ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name for i 0 i nargs i SAFEFREE dec args i SAFEFREE dec args SAFEFREE str return ret static int decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt RALF Context ctx avctx priv data AV Frame frame data int16 t samples0 int16 t samples1 int ret Get Bit Context gb int table size table bytes i const uint8 t src block pointer int src size int bytes left if ctx has pkt ctx has pkt 0 table bytes AVR B16 avpkt data 7 3 if table bytes 3 avpkt size avpkt size RALFMAXPKTSIZE av log avctx AVLOGERROR Wrong packet s breath smells of wrong data n return AVERRORINVALIDDATA if memcmp ctx pkt avpkt data 2 table bytes av log avctx AVLOGERROR Wrong packet tails are wrong n return AVERRORINVALIDDATA src ctx pkt src size RALFMAXPKTSIZE avpkt size memcpy ctx pkt RALFMAXPKTSIZE avpkt data 2 table bytes avpkt size 2 table bytes else if avpkt size RALFMAXPKTSIZE memcpy ctx pkt avpkt data avpkt size ctx has pkt 1 got frame ptr 0 return avpkt size src avpkt data src size avpkt size frame nb samples ctx max frame size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR Me fail get buffer That s unpossible n return ret samples0 int16 t frame data 0 samples1 int16 t frame data 1 if src size 5 av log avctx AVLOGERROR too short packets are too short n return AVERRORINVALIDDATA table size AVR B16 src table bytes table size 7 3 if src size table bytes 3 av log avctx AVLOGERROR short packets are short n return AVERRORINVALIDDATA init get bits gb src 2 table size ctx num blocks 0 while get bits left gb 0 ctx block size ctx num blocks get bits gb 15 if get bits1 gb ctx block pts ctx num blocks get bits gb 9 else ctx block pts ctx num blocks 0 ctx num blocks block pointer src table bytes 2 bytes left src size table bytes 2 ctx sample offset 0 for i 0 i ctx num blocks i if bytes left ctx block size i av log avctx AVLOGERRORI m pedaling backwards n break init get bits gb block pointer ctx block size i 8 if decode block avctx gb samples0 ctx sample offset samples1 ctx sample offset 0 av log avctx AVLOGERROR Sir I got carsick in your office Not decoding the rest of packet n break block pointer ctx block size i bytes left ctx block size i frame nb samples ctx sample offset got frame ptr ctx sample offset 0 return avpkt size static byte i alloc byte array immovable gs memory t mem uint num elements uint elt size client name t cname gs ref memory t const imem gs ref memory t mem obj header t obj ulong lsize obj alloc obj imem lsize st bytes ALLOCIMMOVABLEALLOCDIRECT cname if debug6m A mem a d b s bytes lu u u 0x lx n alloc trace space imem client name string cname ulong num elements elt size num elements elt size ulong obj return byte obj int ff h263 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg Enc Context s avctx priv data int ret AV Frame pict data s flags2 avctx flags2 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got frame 1 return 0 if s flags CODECFLAGTRUNCATED int next if CONFIGMPE G4 DECODER s codec id AVCODECIDMPE G4 next ff mpeg4 find frame end s parse context buf buf size else if CONFIG H263 DECODER s codec id AVCODECID H263 next ff h263 find frame end s parse context buf buf size else av log s avctx AVLOGERROR this codec does not support truncated bitstreams n return 1 if ff combine frame s parse context next const uint8 t buf buf size 0 return buf size retry if s bitstream buffer size s divx packed buf size 20 init get bits s gb s bitstream buffer s bitstream buffer size 8 else init get bits s gb buf buf size 8 s bitstream buffer size 0 if s context initialized if ff MPV common init s 0 return 1 if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 return i s current picture ptr s picture i if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode picture header s else if CONFIGMSMPE G4 DECODER s msmpeg4 version ret ff msmpeg4 decode picture header s else if CONFIGMPE G4 DECODER s h263 pred if s avctx extradata size s picture number 0 Get Bit Context gb init get bits gb s avctx extradata s avctx extradata size 8 ret ff mpeg4 decode picture header s gb ret ff mpeg4 decode picture header s s gb else if CONFIG H263 IDECODER s codec id AVCODECID H263 I ret ff intel h263 decode picture header s else if CONFIGFLVDECODER s h263 flv ret ff flv decode picture header s else ret ff h263 decode picture header s if ret FRAMESKIPPED return get consumed bytes s buf size if ret 0 av log s avctx AVLOGERROR header damaged n return 1 avctx has b frames s low delay if s xvid build 1 s divx version 1 s lavc build 1 if s stream codec tag AVR L32 XVID s codec tag AVR L32 XVID s codec tag AVR L32 XVIX s codec tag AVR L32 RM P4 s codec tag AVR L32 ZM P4 s codec tag AVR L32 SIPP s xvid build 0 if s xvid build 1 s divx version 1 s lavc build 1 if s codec tag AVR L32 DIVX s vo type 0 s vol control parameters 0 s divx version 400 if s xvid build 0 s divx version 0 s divx version s divx build 1 if s workaround bugs FFBUGAUTODETECT if s codec tag AVR L32 XVIX s workaround bugs FFBUGXVIDILACE if s codec tag AVR L32 UM P4 s workaround bugs FFBUGUM P4 if s divx version 500 s divx build 1814 s workaround bugs FFBUGQPELCHROMA if s divx version 502 s divx build 1814 s workaround bugs FFBUGQPELCHROM A2 if s xvid build 3 U s padding bug score 256 256 256 64 if s xvid build 1 U s workaround bugs FFBUGQPELCHROMA if s xvid build 12 U s workaround bugs FFBUGEDGE if s xvid build 32 U s workaround bugs FFBUGDCCLIP s dsp put no rnd postfix1 ff put no rnd postfix2 s dsp avg postfix1 ff avg postfix2 if s lavc build 4653 U s workaround bugs FFBUGSTDQPEL if s lavc build 4655 U s workaround bugs FFBUGDIRECTBLOCKSIZE if s lavc build 4670 U s workaround bugs FFBUGEDGE if s lavc build 4712 U s workaround bugs FFBUGDCCLIP if s divx version 0 s workaround bugs FFBUGDIRECTBLOCKSIZE if s divx version 501 s divx build 20020416 s padding bug score 256 256 256 64 if s divx version 500 U s workaround bugs FFBUGEDGE if s divx version 0 s workaround bugs FFBUGHPELCHROMA if s resync marker 0 s data partitioning 0 s divx version 1 s codec id AVCODECIDMPE G4 s vo type 0 s workaround bugs FFBUGNOPADDING if s lavc build 4609 U s workaround bugs FFBUGNOPADDING if s workaround bugs FFBUGSTDQPELSETQPELFUNC qpel pixels tab 0 5 qpel16 mc11 old c SETQPELFUNC qpel pixels tab 0 7 qpel16 mc31 old c SETQPELFUNC qpel pixels tab 0 9 qpel16 mc12 old c SETQPELFUNC qpel pixels tab 0 11 qpel16 mc32 old c SETQPELFUNC qpel pixels tab 0 13 qpel16 mc13 old c SETQPELFUNC qpel pixels tab 0 15 qpel16 mc33 old c SETQPELFUNC qpel pixels tab 1 5 qpel8 mc11 old c SETQPELFUNC qpel pixels tab 1 7 qpel8 mc31 old c SETQPELFUNC qpel pixels tab 1 9 qpel8 mc12 old c SETQPELFUNC qpel pixels tab 1 11 qpel8 mc32 old c SETQPELFUNC qpel pixels tab 1 13 qpel8 mc13 old c SETQPELFUNC qpel pixels tab 1 15 qpel8 mc33 old c if avctx debug FFDEBUGBUGS av log s avctx AVLOGDEBUG bugs X lavc build d xvid build d divx version d divx build d s n s workaround bugs s lavc build s xvid build s divx version s divx build s divx packed p avctx idct algo FFIDCTXVIDMMX ff dct common init s s picture number 0 Parse Context pc s parse context s parse context buffer 0 ff MPV common end s s parse context pc avcodec set dimensions avctx s width s height goto retry if s width avctx coded width s height avctx coded height s context reinit s context reinit 0 avcodec set dimensions avctx s width s height if ret ff MPV common frame size change s return ret if s codec id AVCODECID H263 s codec id AVCODECID H263 P s codec id AVCODECID H263 I s gob index ff h263 get gob height s s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable return get consumed bytes s buf size if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return get consumed bytes s buf size if s next p frame damaged if s pict type AVPICTURETYPEB return get consumed bytes s buf size else s next p frame damaged 0 if s no rounding s pict type AVPICTURETYPEB s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab else s me qpel put s dsp put no rnd qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if ff MPV frame start s avctx 0 return 1 if s divx packed ff thread finish setup avctx if CONFIGMPE G4 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau mpeg4 decode picture s s gb buffer s gb buffer end s gb buffer goto frame end if avctx hwaccel if avctx hwaccel start frame avctx s gb buffer s gb buffer end s gb buffer 0 return 1 ff mpeg er frame start s if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode secondary picture header s if ret 0 return ret if ret 1 goto intrax8 decoded s mb x 0 s mb y 0 ret decode slice s while s mb y s mb height if s msmpeg4 version if s slice height 0 s mb x 0 s mb y s slice height 0 get bits left s gb 0 break else int prev x s mb x prev y s mb y if ff h263 resync s 0 break if prev y s mb width prev x s mb y s mb width s mb x s er error occurred 1 if s msmpeg4 version 4 s h263 pred ff mpeg4 clean buffers s if decode slice s 0 ret AVERRORINVALIDDATA if s msmpeg4 version s msmpeg4 version 4 s pict type AVPICTURETYPEI if CONFIGMSMPE G4 DECODER ff msmpeg4 decode ext header s buf size 0 s er error status table s mb num 1 ERMBERROR assert s bitstream buffer size 0 frame end if s codec id AVCODECIDMPE G4 s divx packed int current pos get bits count s gb 3 int startcode found 0 if buf size current pos 5 int i for i current pos i buf size 3 i if buf i 0 buf i 1 0 buf i 2 1 buf i 3 0x B6 startcode found 1 break if s gb buffer s bitstream buffer buf size 7 s xvid build 0 startcode found 1 current pos 0 if startcode found av fast malloc s bitstream buffer s allocated bitstream buffer size buf size current pos FFINPUTBUFFERPADDINGSIZE if s bitstream buffer return AVERRORENOMEM memcpy s bitstream buffer buf current pos buf size current pos s bitstream buffer size buf size current pos intrax8 decoded ff er frame end s er if avctx hwaccel if avctx hwaccel end frame avctx 0 return 1 ff MPV frame end s assert s current picture f pict type s current picture ptr f pict type assert s current picture f pict type s pict type if s pict type AVPICTURETYPEB s low delay pict s current picture ptr f else if s last picture ptr NULL pict s last picture ptr f if s last picture ptr s low delay got frame 1 ff print debug info s pict void xps begin opacity xps document doc const fz matrix ctm const fz rect area char base uri xps resource dict char opacity att fz xml opacity mask tag float opacity if opacity att opacity mask tag return opacity 1 if opacity att opacity fz atof opacity att if opacity mask tag strcmp fz xml tag opacity mask tag Solid Color Brush char scb opacity att fz xml att opacity mask tag Opacity char scb color att fz xml att opacity mask tag Color if scb opacity att opacity opacity fz atof scb opacity att if scb color att fz colorspace colorspace float samples FZMAXCOLORS xps parse color doc base uri scb color att colorspace samples opacity opacity samples 0 opacity mask tag NULL if doc opacity top 1 nelem doc opacity doc opacity doc opacity top 1 doc opacity doc opacity top opacity doc opacity top if opacity mask tag fz begin mask doc dev area 0 NULLNULL xps parse brush doc ctm area base uri dict opacity mask tag fz end mask doc dev static int s302m decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int block size ret int frame size s302m parse frame header avctx buf buf size if frame size 0 return frame size buf size AE S3 HEADERLEN buf AE S3 HEADERLEN block size avctx bits per coded sample 4 4 frame nb samples 2 buf size block size avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf size frame nb samples avctx channels 2 block size if avctx bits per coded sample 24 uint32 t o uint32 t frame data 0 for buf size 6 buf size 7 o ff reverse buf 2 24 ff reverse buf 1 16 ff reverse buf 0 8 o ff reverse buf 6 0xf0 28 ff reverse buf 5 20 ff reverse buf 4 12 ff reverse buf 3 0x0f 4 buf 7 else if avctx bits per coded sample 20 uint32 t o uint32 t frame data 0 for buf size 5 buf size 6 o ff reverse buf 2 0xf0 28 ff reverse buf 1 20 ff reverse buf 0 12 o ff reverse buf 5 0xf0 28 ff reverse buf 4 20 ff reverse buf 3 12 buf 6 else uint16 t o uint16 t frame data 0 for buf size 4 buf size 5 o ff reverse buf 1 8 ff reverse buf 0 o ff reverse buf 4 0xf0 12 ff reverse buf 3 4 ff reverse buf 2 4 buf 5 got frame ptr 1 return avpkt size static int ir2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ir2 Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p s picture int start ret if ret ff reget buffer avctx p 0 av log s avctx AVLOGERROR reget buffer failed n return ret start 48 if start buf size av log s avctx AVLOGERROR input buffer size too small d n buf size return AVERRORINVALIDDATA s decode delta buf 18 i buf size i buf i ff reverse buf i if s decode delta if ret ir2 decode plane s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret else if ret ir2 decode plane inter s avctx width avctx height s picture data 0 s picture linesize 0 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 2 s picture linesize 2 ir2 luma table 0 return ret if ret ir2 decode plane inter s avctx width 2 avctx height 2 s picture data 1 s picture linesize 1 ir2 luma table 0 return ret if ret av frame ref picture s picture 0 return ret got frame 1 return buf size static inline void evhttp send struct evhttp request req struct evbuffer databuf struct evhttp connection evcon req evcon if evcon NULL evhttp request free req return assert TAILQFIRST evcon requests req req userdone 1 if databuf NULL evbuffer add buffer req output buffer databuf evhttp make header evcon req evhttp write buffer evcon evhttp send done static int asf write packet AV Format Context s AV Packet pkt ASF Context asf s priv data AVIO Context pb s pb ASF Stream stream AV Codec Context codec uint32 t packet number int64 t pts int start sec int flags pkt flags int ret uint64 t offset avio tell pb codec s streams pkt stream index codec stream asf streams pkt stream index if codec codec type AVMEDIATYPEAUDIO flags AVPKTFLAGKEY pts pkt pts AVNOPTSVALUE pkt pts pkt dts av assert0 pts AVNOPTSVALUE if pts PREROLLTIME pts INTMAX 3 10000 LLASFINDEXEDINTERVALPREROLLTIME av log s AVLOGERROR input pts PR Id64 is invalid n pts return AVERROREINVAL pts 10000 asf duration FFMAX asf duration pts pkt duration 10000 packet number asf nb packets put frame s stream s streams pkt stream index pkt dts pkt data pkt size flags start sec int PREROLLTIME 10000 pts ASFINDEXEDINTERVAL 1 ASFINDEXEDINTERVAL if asf is streamed flags AVPKTFLAGKEY uint16 t packet count asf nb packets packet number ret update index s start sec packet number packet count offset if ret 0 return ret asf end sec start sec return 0 static int ipvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Ipvideo Context s avctx priv data int ret s decoding map size avctx width avctx height 8 8 2 if buf size s decoding map size return buf size s decoding map buf bytestream2 init s stream ptr buf s decoding map size buf size s decoding map size s current frame reference 3 if ret ff get buffer avctx s current frame 0 av log avctx AVLOGERROR Interplay Video get buffer failed n return ret if s is 16bpp const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s current frame palette has changed 1 memcpy s pal pal AVPALETTESIZE ipvideo decode opcodes s got frame 1 AV Frame data s current frame if s second last frame data 0 avctx release buffer avctx s second last frame s second last frame s last frame s last frame s current frame s current frame data 0 NULL return buf size static void inverse transform block MACROBLOCKD xd int plane int block TXSIZE tx size uint8 t dst int stride int eob struct macroblockd plane const pd xd plane plane if eob 0 TXTYPE tx type DCTDCT tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block if xd lossless tx type DCTDCT vp9 iwht4x4 add dqcoeff dst stride eob else const PLANETYPE plane type pd plane type switch tx size case TX 4 X4 tx type get tx type 4x4 plane type xd block vp9 iht4x4 add tx type dqcoeff dst stride eob break case TX 8 X8 tx type get tx type plane type xd vp9 iht8x8 add tx type dqcoeff dst stride eob break case TX 16 X16 tx type get tx type plane type xd vp9 iht16x16 add tx type dqcoeff dst stride eob break case TX 32 X32 tx type DCTDCT vp9 idct32x32 add dqcoeff dst stride eob break default assert 0 Invalid transform size if eob 1 vpx memset dqcoeff 0 2 sizeof dqcoeff 0 else if tx type DCTDCT tx size TX 16 X16 eob 10 vpx memset dqcoeff 0 4 4 tx size sizeof dqcoeff 0 else if tx size TX 32 X32 eob 34 vpx memset dqcoeff 0 256 sizeof dqcoeff 0 else vpx memset dqcoeff 0 16 tx size 1 sizeof dqcoeff 0 int jbig2 decode halftone mmr Jbig2 Ctx ctx const Jbig2 Generic Region Params params const byte data size t size Jbig2 Image image size t consumed bytes Jbig2 Mmr Ctx mmr const uint32 t rowstride image stride byte dst image data byte ref NULL uint32 t y int code 0 const uint32 t EOFB 0x001001 jbig2 decode mmr init mmr image width image height data size for y 0 y image height y memset dst 0 rowstride code jbig2 decode mmr line mmr ref dst if code 0 return code ref dst dst rowstride if mmr word 8 EOFB mmr data index 3 consumed bytes mmr data index mmr bit index 3 mmr bit index 0 1 0 return code static int synth superframe AV Codec Context ctx AV Frame frame int got frame ptr WMA Voice Context s ctx priv data Get Bit Context gb s gb s gb int n res n samples 480 double lsps MAXFRAMESMAXLSPS const double mean lsf s lsps 16 wmavoice mean lsf16 s lsp def mode wmavoice mean lsf10 s lsp def mode float excitation MAXSIGNALHISTORYMAXSFRAMESIZE 12 float synth MAXLSPSMAXSFRAMESIZE float samples memcpy synth s synth history s lsps sizeof synth memcpy excitation s excitation history s history nsamples sizeof excitation if s sframe cache size 0 gb s gb init get bits gb s sframe cache s sframe cache size s sframe cache size 0 if res check bits for superframe gb s 1 got frame ptr 0 return 1 if get bits1 gb av log missing feature ctx WMA Pro in WMA Voice 1 return AVERRORPATCHWELCOME if get bits1 gb if n samples get bits gb 12 480 av log ctx AVLOGERROR Superframe encodes 480 samples d not allowed n n samples return 1 if s has residual lsps double prev lsps MAXLSPS a1 MAXLSPS 2 a2 MAXLSPS 2 for n 0 n s lsps n prev lsps n s prev lsps n mean lsf n if s lsps 10 dequant lsp10r gb lsps 2 prev lsps a1 a2 s lsp q mode else dequant lsp16r gb lsps 2 prev lsps a1 a2 s lsp q mode for n 0 n s lsps n lsps 0 n mean lsf n a1 n a2 n 2 lsps 1 n mean lsf n a1 s lsps n a2 n 2 1 lsps 2 n mean lsf n for n 0 n 3 n stabilize lsps lsps n s lsps frame nb samples 480 if res ff get buffer ctx frame 0 av log ctx AVLOGERROR get buffer failed n return res frame nb samples n samples samples float frame data 0 for n 0 n 3 n if s has residual lsps int m if s lsps 10 dequant lsp10i gb lsps n else dequant lsp16i gb lsps n for m 0 m s lsps m lsps n m mean lsf m stabilize lsps lsps n s lsps if res synth frame ctx gb n samples n MAXFRAMESIZE lsps n n 0 s prev lsps lsps n 1 excitation s history nsamples n MAXFRAMESIZE synth s lsps n MAXFRAMESIZE got frame ptr 0 return res if get bits1 gb res get bits gb 4 skip bits gb 10 res 1 got frame ptr 1 memcpy s prev lsps lsps 2 s lsps sizeof s prev lsps memcpy s synth history synth MAXSFRAMESIZE s lsps sizeof synth memcpy s excitation history excitation MAXSFRAMESIZE s history nsamples sizeof excitation if s do apf memmove s zero exc pf s zero exc pf MAXSFRAMESIZE s history nsamples sizeof s zero exc pf return 0 static gint dissect rtp tvbuff t tvb packet info pinfo proto tree tree void data U proto item ti NULL proto tree volatile rtp tree NULL proto tree rtp csrc tree NULL proto tree rtp hext tree NULL guint8 octet1 octet2 unsigned int version gboolean padding set gboolean extension set unsigned int csrc count gboolean marker set unsigned int payload type gchar payload type str NULL gboolean is srtp FALSE unsigned int i 0 unsigned int hdr extension len 0 unsigned int hdr extension id 0 volatile unsigned int padding count gint length reported length int data len volatile unsigned int offset 0 guint16 seq num guint32 timestamp guint32 sync src guint32 csrc item struct rtp conversation info p conv data NULL unsigned int hdrext offset 0 tvbuff t newtvb NULL const char pt NULL static struct rtp info rtp info arr 4 static int rtp info current 0 struct rtp info rtp info rtp info current if rtp info current 4 rtp info current 0 rtp info rtp info arr rtp info current octet1 tvb get guint8 tvb offset version RTPVERSION octet1 if version 0 switch global rtp version0 type case RT P0 STUN call dissector stun handle tvb pinfo tree return tvb length tvb case RT P0 CLASSICSTUN call dissector classicstun handle tvb pinfo tree return tvb length tvb case RT P0 T38 call dissector t38 handle tvb pinfo tree return tvb length tvb case RT P0 SPRT call dissector sprt handle tvb pinfo tree return tvb length tvb case RT P0 INVALID if tvb memeql tvb 4 ZRTP 4 call dissector zrtp handle tvb pinfo tree return tvb length tvb default rtp info info version version if version 2 col set str pinfo cinfo COLPROTOCOLRTP col add fstr pinfo cinfo COLINFO Unknown RTP version u version if tree ti proto tree add item tree proto rtp tvb offset 1 ENCNA rtp tree proto item add subtree ti ett rtp proto tree add uint rtp tree hf rtp version tvb offset 1 octet1 return offset padding set RTPPADDING octet1 extension set RTPEXTENSION octet1 csrc count RTPCSRCCOUNT octet1 octet2 tvb get guint8 tvb offset 1 marker set RTPMARKER octet2 payload type RTPPAYLOADTYPE octet2 if marker set payload type FIRSTRTCPCONFLICTPAYLOADTYPE payload type LASTRTCPCONFLICTPAYLOADTYPE call dissector rtcp handle tvb pinfo tree return tvb length tvb seq num tvb get ntohs tvb offset 2 timestamp tvb get ntohl tvb offset 4 sync src tvb get ntohl tvb offset 8 rtp info info padding set padding set rtp info info padding count 0 rtp info info marker set marker set rtp info info is video FALSE rtp info info payload type payload type rtp info info seq num seq num rtp info info timestamp timestamp rtp info info sync src sync src rtp info info is srtp FALSE rtp info info setup frame num 0 rtp info info payload type str NULL rtp info info payload rate 0 length tvb length remaining tvb offset reported length tvb reported length remaining tvb offset if reported length 0 length reported length rtp info info all data present TRUE rtp info info data len reported length rtp info info data tvb get ptr tvb 0 1 else rtp info info all data present FALSE rtp info info data len 0 rtp info info data NULL get conv info pinfo rtp info p conv data struct rtp conversation info p get proto data wmem file scope pinfo proto rtp 0 if p conv data rtp info info is video p conv data is video if p conv data p conv data srtp info is srtp TRUE rtp info info is srtp is srtp col set str pinfo cinfo COLPROTOCOL is srtp SRTPRTP p conv data struct rtp conversation info p get proto data wmem file scope pinfo proto rtp 0 srtp info p conv data srtp info if rtp info info all data present srtp offset rtp info info data len srtp info mki len srtp info auth tag len static void rv34 pred mv R V34 Dec Context r int block type int subblock no int dmv no Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j int mx my int avail r avail cache avail indexes subblock no int c off part sizes w block type mv pos subblock no 1 subblock no 1 s b8 stride if subblock no 3 c off 1 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail c off 4 if avail 4 avail 1 r rv30 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride c off 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride c off 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv dmv no 0 my r dmv dmv no 1 for j 0 j part sizes h block type j for i 0 i part sizes w block type i s current picture ptr f motion val 0 mv pos i j s b8 stride 0 mx s current picture ptr f motion val 0 mv pos i j s b8 stride 1 my static int ipvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Ipvideo Context s avctx priv data int ret s decoding map size avctx width avctx height 8 8 2 if buf size s decoding map size return buf size s decoding map buf bytestream2 init s stream ptr buf s decoding map size buf size s decoding map size s current frame reference 3 if ret ff get buffer avctx s current frame 0 av log avctx AVLOGERROR Interplay Video get buffer failed n return ret if s is 16bpp const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s current frame palette has changed 1 memcpy s pal pal AVPALETTESIZE ipvideo decode opcodes s got frame 1 AV Frame data s current frame if s second last frame data 0 avctx release buffer avctx s second last frame s second last frame s last frame s last frame s current frame s current frame data 0 NULL return buf size static void examine simple variable Planner Info root Var var Variable Stat Data vardata Range Tbl Entry rte root simple rte array var varno Assert Is A rte Range Tbl Entry if get relation stats hook get relation stats hook root rte var varattno vardata if Heap Tuple Is Valid vardata stats Tuple vardata freefunc elog ERROR no function provided to release variable stats with else if rte rtekind RTERELATION vardata stats Tuple Search Sys Cache3 STATRELATTINH Object Id Get Datum rte relid Int16 Get Datum var varattno Bool Get Datum rte inh vardata freefunc Release Sys Cache if Heap Tuple Is Valid vardata stats Tuple vardata acl ok pg class aclcheck rte relid Get User Id ACLSELECTACLCHECKOK pg attribute aclcheck rte relid var varattno Get User Id ACLSELECTACLCHECKOK else vardata acl ok true else if rte rtekind RTESUBQUERY rte inh Query subquery rte subquery Rel Opt Info rel Target Entry ste if var varattno Invalid Attr Number return if subquery set Operations subquery group Clause return rel find base rel root var varno if rel subroot NULL return Assert Is A rel subroot Planner Info subquery rel subroot parse Assert Is A subquery Query ste get tle by resno subquery target List var varattno if ste NULL ste resjunk elog ERROR subquery s does not have attribute d rte eref aliasname var varattno var Var ste expr if subquery distinct Clause if list length subquery distinct Clause 1 target Is In Sort List ste Invalid Oid subquery distinct Clause vardata isunique true return if rte security barrier return if var Is A var Var var varlevelsup 0 examine simple variable rel subroot var vardata else static int output data MLP Decode Context m unsigned int substr AV Frame frame int got frame ptr AV Codec Context avctx m avctx Sub Stream s m substream substr unsigned int i out ch 0 int32 t data 32 int16 t data 16 int ret int is32 m avctx sample fmt AVSAMPLEFMT S32 if m avctx channels s max matrix channel 1 av log m avctx AVLOGERROR channel count mismatch n return AVERRORINVALIDDATA if s blockpos av log avctx AVLOGERROR No samples to output n return AVERRORINVALIDDATA frame nb samples s blockpos if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret data 32 int32 t frame data 0 data 16 int16 t frame data 0 for i 0 i s blockpos i for out ch 0 out ch s max matrix channel out ch int mat ch s ch assign out ch int32 t sample m sample buffer i mat ch s output shift mat ch s lossless check data sample 0xffffff mat ch if is32 data 32 sample 8 else data 16 sample 8 got frame ptr 1 return 0 static void vc1 mc 4mv chroma V C1 Context v int dir Mpeg Enc Context s v s H264 Chroma Context h264chroma v h264chroma uint8 t src U src V int uvmx uvmy uvsrc x uvsrc y int k tx 0 ty 0 int mvx 4 mvy 4 intra 4 mv f 4 int valid count int chroma ref type v cur field type off 0 int v edge pos s v edge pos v field mode if v field mode v s last picture f data 0 return if s flags CODECFLAGGRAY return for k 0 k 4 k mvx k s mv dir k 0 mvy k s mv dir k 1 intra k v mb type 0 s block index k if v field mode mv f k v mv f dir s block index k v blocks off if v field mode v field mode v numref valid count get chroma mv mvx mvy intra 0 tx ty chroma ref type v reffield if valid count s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 return o need to do MC for intra blocks else int dominant 0 if mv f 0 mv f 1 mv f 2 mv f 3 2 dominant 1 valid count get chroma mv mvx mvy mv f dominant tx ty if dominant chroma ref type v cur field type if v field mode chroma ref type 1 v cur field type 1 v s last picture f data 0 return s current picture motion val 1 s block index 0 v blocks off 0 tx s current picture motion val 1 s block index 0 v blocks off 1 ty uvmx tx tx 3 3 1 uvmy ty ty 3 3 1 v luma mv s mb x 0 uvmx v luma mv s mb x 1 uvmy if v fastuvmc uvmx uvmx uvmx 0 uvmx 1 uvmx 1 uvmy uvmy uvmy 0 uvmy 1 uvmy 1 if v cur field type chroma ref type uvmy 2 4 chroma ref type uvsrc x s mb x 8 uvmx 2 uvsrc y s mb y 8 uvmy 2 if v profile PROFILEADVANCED uvsrc x av clip uvsrc x 8 s mb width 8 uvsrc y av clip uvsrc y 8 s mb height 8 else uvsrc x av clip uvsrc x 8 s avctx coded width 1 uvsrc y av clip uvsrc y 8 s avctx coded height 1 if dir if v field mode if v cur field type chroma ref type v cur field type src U s current picture f data 1 uvsrc y s uvlinesize uvsrc x src V s current picture f data 2 uvsrc y s uvlinesize uvsrc x else src U s last picture f data 1 uvsrc y s uvlinesize uvsrc x src V s last picture f data 2 uvsrc y s uvlinesize uvsrc x else src U s last picture f data 1 uvsrc y s uvlinesize uvsrc x src V s last picture f data 2 uvsrc y s uvlinesize uvsrc x else src U s next picture f data 1 uvsrc y s uvlinesize uvsrc x src V s next picture f data 2 uvsrc y s uvlinesize uvsrc x if v field mode if chroma ref type src U s current picture ptr f linesize 1 src V s current picture ptr f linesize 2 off v cur field type s current picture ptr f linesize 1 0 if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 18 v edge pos 18 unsigned uvsrc x s h edge pos 1 9 unsigned uvsrc y v edge pos 1 9 s vdsp emulated edge mc s edge emu buffer src U s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 s vdsp emulated edge mc s edge emu buffer 16 src V s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 src U s edge emu buffer src V s edge emu buffer 16 if v rangeredfrm int i j uint8 t src src2 src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i src i 128 1 128 src2 i src2 i 128 1 128 src s uvlinesize src2 s uvlinesize if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src2 src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i v lutuv src i src2 i v lutuv src2 i src s uvlinesize src2 s uvlinesize uvmx uvmx 3 1 uvmy uvmy 3 1 if v rnd h264chroma put h264 chroma pixels tab 0 s dest 1 off src U s uvlinesize 8 uvmx uvmy h264chroma put h264 chroma pixels tab 0 s dest 2 off src V s uvlinesize 8 uvmx uvmy else v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 1 off src U s uvlinesize 8 uvmx uvmy v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 2 off src V s uvlinesize 8 uvmx uvmy static uint32 t nvic readl nvic state s uint32 t offset uint32 t val int irq switch offset case 4 return s num irq 32 1 case 0x10 val s systick control s systick control SYSTICKCOUNTFLAG return val case 0x14 return s systick reload case 0x18 int64 t t if s systick control SYSTICKENABLE 0 return 0 t qemu get clock ns vm clock if t s systick tick return 0 val s systick tick t 1 systick scale s 1 if val s systick reload val 0 return val case 0x1c return 10000 case 0xd00 return cpu single env cp15 c0 cpuid case 0xd04 val s gic running irq 0 if val 1023 val 0 else if val 32 val 16 if s gic running irq 0 1023 s gic last active s gic running irq 0 0 1023 val 1 11 if s gic current pending 0 1023 val s gic current pending 0 12 for irq 32 irq s num irq irq if s gic irq state irq pending val 1 22 break if s gic irq state ARM V7 MEXCPSYSTICK pending val 1 26 if s gic irq state ARM V7 MEXCPPENDSV pending val 1 28 if s gic irq state ARM V7 MEXCPNMI pending val 1 31 return val case 0xd08 return cpu single env v7m vecbase case 0xd0c return 0xfa05000 case 0xd10 return 0 case 0xd14 return 0 case 0xd24 val 0 if s gic irq state ARM V7 MEXCPMEM active val 1 0 if s gic irq state ARM V7 MEXCPBUS active val 1 1 if s gic irq state ARM V7 MEXCPUSAGE active val 1 3 if s gic irq state ARM V7 MEXCPSVC active val 1 7 if s gic irq state ARM V7 MEXCPDEBUG active val 1 8 if s gic irq state ARM V7 MEXCPPENDSV active val 1 10 if s gic irq state ARM V7 MEXCPSYSTICK active val 1 11 if s gic irq state ARM V7 MEXCPUSAGE pending val 1 12 if s gic irq state ARM V7 MEXCPMEM pending val 1 13 if s gic irq state ARM V7 MEXCPBUS pending val 1 14 if s gic irq state ARM V7 MEXCPSVC pending val 1 15 if s gic irq state ARM V7 MEXCPMEM enabled val 1 16 if s gic irq state ARM V7 MEXCPBUS enabled val 1 17 if s gic irq state ARM V7 MEXCPUSAGE enabled val 1 18 return val case 0xd28 qemu log mask LOGUNIMP Configurable Fault Status unimplemented n return 0 case 0xd2c case 0xd30 case 0xd34 case 0xd38 case 0xd3c qemu log mask LOGUNIMP Fault status registers unimplemented n return 0 case 0xd40 return 0x00000030 case 0xd44 return 0x00000200 case 0xd48 return 0x00100000 case 0xd4c return 0x00000000 case 0xd50 return 0x00000030 case 0xd54 return 0x00000000 case 0xd58 return 0x00000000 case 0xd5c return 0x00000000 case 0xd60 return 0x01141110 case 0xd64 return 0x02111000 case 0xd68 return 0x21112231 case 0xd6c return 0x01111110 case 0xd70 return 0x01310102 default qemu log mask LOGGUESTERRORNVIC Bad read offset 0x x n offset return 0 static int aura decode frame AV Codec Context avctx void data int got frame AV Packet pkt Aura Decode Context s avctx priv data uint8 t YUV uint8 t val int x y ret const uint8 t buf pkt data const int8 t delta table const int8 t buf 16 if pkt size 48 avctx height avctx width av log avctx AVLOGERROR got a buffer with d bytes when d were expected n pkt size 48 avctx height avctx width return AVERRORINVALIDDATA buf 48 if s frame data 0 avctx release buffer avctx s frame s frame buffer hints FFBUFFERHINTSVALID s frame reference 0 if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret Y s frame data 0 U s frame data 1 V s frame data 2 for y 0 y avctx height y val buf U 0 val 0x F0 Y 0 val 4 val buf V 0 val 0x F0 Y 1 Y 0 delta table val 0x FY 2 UV for x 1 x avctx width 1 x val buf U 0 U 1 delta table val 4 Y 0 Y 1 delta table val 0x F val buf V 0 V 1 delta table val 4 Y 1 Y 0 delta table val 0x FY 2 UVY s frame linesize 0 avctx width U s frame linesize 1 avctx width 1 V s frame linesize 2 avctx width 1 got frame 1 AV Frame data s frame return pkt size int ff h263 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg Enc Context s avctx priv data int ret AV Frame pict data s flags2 avctx flags2 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got frame 1 return 0 if s flags CODECFLAGTRUNCATED int next if CONFIGMPE G4 DECODER s codec id AVCODECIDMPE G4 next ff mpeg4 find frame end s parse context buf buf size else if CONFIG H263 DECODER s codec id AVCODECID H263 next ff h263 find frame end s parse context buf buf size else av log s avctx AVLOGERROR this codec does not support truncated bitstreams n return 1 if ff combine frame s parse context next const uint8 t buf buf size 0 return buf size retry if s bitstream buffer size s divx packed buf size 20 init get bits s gb s bitstream buffer s bitstream buffer size 8 else init get bits s gb buf buf size 8 s bitstream buffer size 0 if s context initialized if ff MPV common init s 0 return 1 if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 return i s current picture ptr s picture i if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode picture header s else if CONFIGMSMPE G4 DECODER s msmpeg4 version ret ff msmpeg4 decode picture header s else if CONFIGMPE G4 DECODER s h263 pred if s avctx extradata size s picture number 0 Get Bit Context gb init get bits gb s avctx extradata s avctx extradata size 8 ret ff mpeg4 decode picture header s gb ret ff mpeg4 decode picture header s s gb else if CONFIG H263 IDECODER s codec id AVCODECID H263 I ret ff intel h263 decode picture header s else if CONFIGFLVDECODER s h263 flv ret ff flv decode picture header s else ret ff h263 decode picture header s if ret FRAMESKIPPED return get consumed bytes s buf size if ret 0 av log s avctx AVLOGERROR header damaged n return 1 avctx has b frames s low delay if s xvid build 1 s divx version 1 s lavc build 1 if s stream codec tag AVR L32 XVID s codec tag AVR L32 XVID s codec tag AVR L32 XVIX s codec tag AVR L32 RM P4 s codec tag AVR L32 ZM P4 s codec tag AVR L32 SIPP s xvid build 0 if s xvid build 1 s divx version 1 s lavc build 1 if s codec tag AVR L32 DIVX s vo type 0 s vol control parameters 0 s divx version 400 if s xvid build 0 s divx version 0 s divx version s divx build 1 if s workaround bugs FFBUGAUTODETECT if s codec tag AVR L32 XVIX s workaround bugs FFBUGXVIDILACE if s codec tag AVR L32 UM P4 s workaround bugs FFBUGUM P4 if s divx version 500 s divx build 1814 s workaround bugs FFBUGQPELCHROMA if s divx version 502 s divx build 1814 s workaround bugs FFBUGQPELCHROM A2 if s xvid build 3 U s padding bug score 256 256 256 64 if s xvid build 1 U s workaround bugs FFBUGQPELCHROMA if s xvid build 12 U s workaround bugs FFBUGEDGE if s xvid build 32 U s workaround bugs FFBUGDCCLIP s dsp put no rnd postfix1 ff put no rnd postfix2 s dsp avg postfix1 ff avg postfix2 if s lavc build 4653 U s workaround bugs FFBUGSTDQPEL if s lavc build 4655 U s workaround bugs FFBUGDIRECTBLOCKSIZE if s lavc build 4670 U s workaround bugs FFBUGEDGE if s lavc build 4712 U s workaround bugs FFBUGDCCLIP if s divx version 0 s workaround bugs FFBUGDIRECTBLOCKSIZE if s divx version 501 s divx build 20020416 s padding bug score 256 256 256 64 if s divx version 500 U s workaround bugs FFBUGEDGE if s divx version 0 s workaround bugs FFBUGHPELCHROMA if s resync marker 0 s data partitioning 0 s divx version 1 s codec id AVCODECIDMPE G4 s vo type 0 s workaround bugs FFBUGNOPADDING if s lavc build 4609 U s workaround bugs FFBUGNOPADDING if s workaround bugs FFBUGSTDQPELSETQPELFUNC qpel pixels tab 0 5 qpel16 mc11 old c SETQPELFUNC qpel pixels tab 0 7 qpel16 mc31 old c SETQPELFUNC qpel pixels tab 0 9 qpel16 mc12 old c SETQPELFUNC qpel pixels tab 0 11 qpel16 mc32 old c SETQPELFUNC qpel pixels tab 0 13 qpel16 mc13 old c SETQPELFUNC qpel pixels tab 0 15 qpel16 mc33 old c SETQPELFUNC qpel pixels tab 1 5 qpel8 mc11 old c SETQPELFUNC qpel pixels tab 1 7 qpel8 mc31 old c SETQPELFUNC qpel pixels tab 1 9 qpel8 mc12 old c SETQPELFUNC qpel pixels tab 1 11 qpel8 mc32 old c SETQPELFUNC qpel pixels tab 1 13 qpel8 mc13 old c SETQPELFUNC qpel pixels tab 1 15 qpel8 mc33 old c if avctx debug FFDEBUGBUGS av log s avctx AVLOGDEBUG bugs X lavc build d xvid build d divx version d divx build d s n s workaround bugs s lavc build s xvid build s divx version s divx build s divx packed p avctx idct algo FFIDCTXVIDMMX ff dct common init s s picture number 0 Parse Context pc s parse context s parse context buffer 0 ff MPV common end s s parse context pc avcodec set dimensions avctx s width s height goto retry if s width avctx coded width s height avctx coded height s context reinit s context reinit 0 avcodec set dimensions avctx s width s height if ret ff MPV common frame size change s return ret if s codec id AVCODECID H263 s codec id AVCODECID H263 P s codec id AVCODECID H263 I s gob index ff h263 get gob height s s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable return get consumed bytes s buf size if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return get consumed bytes s buf size if s next p frame damaged if s pict type AVPICTURETYPEB return get consumed bytes s buf size else s next p frame damaged 0 if s no rounding s pict type AVPICTURETYPEB s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab else s me qpel put s dsp put no rnd qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if ff MPV frame start s avctx 0 return 1 if s divx packed ff thread finish setup avctx if CONFIGMPE G4 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau mpeg4 decode picture s s gb buffer s gb buffer end s gb buffer goto frame end if avctx hwaccel if avctx hwaccel start frame avctx s gb buffer s gb buffer end s gb buffer 0 return 1 ff mpeg er frame start s if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode secondary picture header s if ret 0 return ret if ret 1 goto intrax8 decoded s mb x 0 s mb y 0 ret decode slice s while s mb y s mb height if s msmpeg4 version if s slice height 0 s mb x 0 s mb y s slice height 0 get bits left s gb 0 break else int prev x s mb x prev y s mb y if ff h263 resync s 0 break if prev y s mb width prev x s mb y s mb width s mb x s er error occurred 1 if s msmpeg4 version 4 s h263 pred ff mpeg4 clean buffers s if decode slice s 0 ret AVERRORINVALIDDATA if s msmpeg4 version s msmpeg4 version 4 s pict type AVPICTURETYPEI if CONFIGMSMPE G4 DECODER ff msmpeg4 decode ext header s buf size 0 s er error status table s mb num 1 ERMBERROR assert s bitstream buffer size 0 frame end if s codec id AVCODECIDMPE G4 s divx packed int current pos get bits count s gb 3 int startcode found 0 if buf size current pos 5 int i for i current pos i buf size 3 i if buf i 0 buf i 1 0 buf i 2 1 buf i 3 0x B6 startcode found 1 break if s gb buffer s bitstream buffer buf size 7 s xvid build 0 startcode found 1 current pos 0 if startcode found av fast malloc s bitstream buffer s allocated bitstream buffer size buf size current pos FFINPUTBUFFERPADDINGSIZE if s bitstream buffer return AVERRORENOMEM memcpy s bitstream buffer buf current pos buf size current pos s bitstream buffer size buf size current pos intrax8 decoded ff er frame end s er if avctx hwaccel if avctx hwaccel end frame avctx 0 return 1 ff MPV frame end s assert s current picture f pict type s current picture ptr f pict type assert s current picture f pict type s pict type if s pict type AVPICTURETYPEB s low delay pict s current picture ptr f else if s last picture ptr NULL pict s last picture ptr f if s last picture ptr s low delay got frame 1 ff print debug info s pict static int64 t rd pick intra sub 8x8 y mode V P9 COMP cpi MACROBLOCK mb int rate int rate y int64 t distortion int64 t best rd int i j const MACROBLOCKD const xd mb e mbd MODEINFO const mic xd mi 0 const MODEINFO above mi xd mi xd mi stride const MODEINFO left mi xd left available xd mi 1 NULL const BLOCKSIZE bsize xd mi 0 mbmi sb type const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize int idx idy int cost 0 int64 t total distortion 0 int tot rate y 0 int64 t total rd 0 ENTROPYCONTEXT t above 4 t left 4 const int bmode costs cpi mbmode cost vpx memcpy t above xd plane 0 above context sizeof t above vpx memcpy t left xd plane 0 left context sizeof t left for idy 0 idy 2 idy num 4x4 blocks high for idx 0 idx 2 idx num 4x4 blocks wide PREDICTIONMODE best mode DCPRED int r INTMAX ry INTMAX int64 t d IN T64 MAX this rd IN T64 MAX i idy 2 idx if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi i const PREDICTIONMODEL vp9 left block mode mic left mi i bmode costs cpi y mode costs AL this rd rd pick intra4x4block cpi mb i best mode bmode costs t above idx t left idy r ry d bsize best rd total rd if this rd best rd total rd return IN T64 MAX total rd this rd cost r total distortion d tot rate y ry mic bmi i as mode best mode for j 1 j num 4x4 blocks high j mic bmi i j 2 as mode best mode for j 1 j num 4x4 blocks wide j mic bmi i j as mode best mode if total rd best rd return IN T64 MAX rate cost rate y tot rate y distortion total distortion mic mbmi mode mic bmi 3 as mode return RDCOST mb rdmult mb rddiv cost total distortion static void dump table char table char db char ignore flag char buf 200 table buff NAMELEN 3 DYNAMICSTRING query string char table type NAMELEN char result table table buff2 NAMELEN 2 3 opt quoted table int error 0 ulong rownr row break total length init length uint num fields MYSQLRES res MYSQLFIELD field MYSQLROW row DBUGENTER dump table num fields get table structure table db table type ignore flag if strcmp table type VIEW 0 DBUGVOIDRETURN if opt no data verbose msg Skipping dump data for table s no data was used n table DBUGVOIDRETURNDBUGPRINT info ignore flag x num fields d int ignore flag num fields if ignore flag IGNOREDATA verbose msg Warning Skipping data for table s because it s of type s n table table type DBUGVOIDRETURN if num fields 0 verbose msg Skipping dump data for table s it has no fields n table DBUGVOIDRETURN if opt events my strcasecmp my charset latin1 db mysql my strcasecmp my charset latin1 table event verbose msg Skipping data table mysql event skip events was used n DBUGVOIDRETURN result table quote name table table buff 1 opt quoted table quote name table table buff2 0 verbose msg Sending SELECT query n init dynamic string checked query string 1024 1024 if path char filename FNREFLEN tmp path FNREFLEN convert dirname tmp path path Null S my load path tmp path tmp path NULL fn format filename table tmp path txt MYFMYUNPACKFILENAME my delete filename MYF 0 to unix path filename dynstr append checked query string SELECTINTOOUTFILE dynstr append checked query string filename dynstr append checked query string dynstr append checked query string if fields terminated enclosed opt enclosed escaped dynstr append checked query string FIELDS add load option query string TERMINATEDBY fields terminated add load option query string ENCLOSEDBY enclosed add load option query string OPTIONALLYENCLOSEDBY opt enclosed add load option query string ESCAPEDBY escaped add load option query string LINESTERMINATEDBY lines terminated dynstr append checked query string FROM dynstr append checked query string result table if where dynstr append checked query string WHERE dynstr append checked query string where if order by dynstr append checked query string ORDERBY dynstr append checked query string order by if mysql real query mysql query string str query string length DB error mysql when executing SELECTINTOOUTFILE dynstr free query string DBUGVOIDRETURN else print comment md result file 0 n n Dumping data for table s n n fix for comment result table dynstr append checked query string SELECTFROM dynstr append checked query string result table if where print comment md result file 0 WHERE s n fix for comment where dynstr append checked query string WHERE dynstr append checked query string where if order by print comment md result file 0 ORDERBY s n fix for comment order by dynstr append checked query string ORDERBY dynstr append checked query string order by if opt xml opt compact fputs n md result file check io md result file if mysql query with error report mysql 0 query string str DB error mysql when retrieving data from server goto err if quick res mysql use result mysql else res mysql store result mysql if res DB error mysql when retrieving data from server goto err verbose msg Retrieving rows n if mysql num fields res num fields fprintf stderr s Error in field count for table s Aborting n my progname short result table error EXCONSCHECK goto err if opt lock fprintf md result file LOCKTABLES s WRITE n opt quoted table check io md result file if opt disable keys fprintf md result file n opt quoted table check io md result file total length opt net buffer length row break 0 rownr 0 init length uint insert pat length 4 if opt xml print xml tag md result file t n table data name table Null S if opt autocommit fprintf md result file set autocommit 0 n check io md result file while row mysql fetch row res uint i ulong lengths mysql fetch lengths res rownr if extended insert opt xml fputs insert pat str md result file check io md result file mysql field seek res 0 if opt xml fputs t row n md result file check io md result file for i 0 i mysql num fields res i int is blob ulong length lengths i if field mysql fetch field res die EXCONSCHECK Not enough fields from table s Aborting n result table is blob opt hex blob field charsetnr 63 field type MYSQLTYPEBIT field type MYSQLTYPESTRING field type MYSQLTYPEVARSTRING field type MYSQLTYPEVARCHAR field type MYSQLTYPEBLOB field type MYSQLTYPELONGBLOB field type MYSQLTYPEMEDIUMBLOB field type MYSQLTYPETINYBLOB field type MYSQLTYPEGEOMETRY 1 0 if extended insert opt xml if i 0 dynstr set checked extended row else dynstr append checked extended row if row i if length if field flags NUMFLAG dynstr realloc checked extended row length 2 2 1 if opt hex blob is blob dynstr append checked extended row 0x extended row length mysql hex string extended row str extended row length row i length DBUGASSERT extended row length 1 extended row max length DBUGASSERT extended row str extended row length 0 else dynstr append checked extended row extended row length mysql real escape string mysql connection extended row str extended row length row i length extended row str extended row length 0 dynstr append checked extended row else char ptr row i if my isalpha charset info ptr ptr my isalpha charset info ptr 1 dynstr append checked extended row NULL else if field type MYSQLTYPEDECIMAL dynstr append checked extended row dynstr append checked extended row ptr dynstr append checked extended row else dynstr append checked extended row ptr else dynstr append checked extended row else dynstr append checked extended row NULL else if i opt xml fputc md result file check io md result file if row i if field flags NUMFLAG if opt xml if opt hex blob is blob length print xml tag md result file t t field name field name xsi type xs hex Binary Null S print blob as hex md result file row i length else print xml tag md result file t t field name field name Null S print quoted xml md result file row i length 0 fputs field n md result file else if opt hex blob is blob length fputs 0x md result file print blob as hex md result file row i length else unescape md result file row i length else char ptr row i if opt xml print xml tag md result file t t field name field name Null S fputs my isalpha charset info ptr ptr NULL md result file fputs field n md result file else if my isalpha charset info ptr ptr my isalpha charset info ptr 1 fputs NULL md result file else if field type MYSQLTYPEDECIMAL fputc md result file fputs ptr md result file fputc md result file else fputs ptr md result file else if opt xml fputs NULL md result file else print xml null tag md result file t t field name field name n check io md result file if opt xml fputs t row n md result file check io md result file if extended insert ulong row length dynstr append checked extended row row length 2 extended row length if total length row length opt net buffer length total length row length fputc md result file fputs extended row str md result file else if row break fputs n md result file row break 1 fputs insert pat str md result file fputs extended row str md result file total length row length init length check io md result file else if opt xml fputs n md result file check io md result file if opt xml fputs t table data n md result file else if extended insert row break fputs n md result file fflush md result file check io md result file if mysql errno mysql my snprintf buf sizeof buf s Error d s when dumping table s at row ld n my progname short mysql errno mysql mysql error mysql result table rownr fputs buf stderr error EXCONSCHECK goto err if opt disable keys fprintf md result file n opt quoted table check io md result file if opt lock fputs UNLOCKTABLES n md result file check io md result file if opt autocommit fprintf md result file commit n check io md result file mysql free result res dynstr free query string DBUGVOIDRETURN err dynstr free query string maybe exit error static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt WN V1 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data unsigned char YUV int i j ret int prev y 0 prev u 0 prev v 0 uint8 t rbuf rbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if rbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n av free rbuf return ret p key frame 1 for i 8 i buf size i rbuf i ff reverse buf i init get bits l gb rbuf 8 buf size 8 8 if buf 2 4 6 l shift 2 else l shift 8 buf 2 4 if l shift 4 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 4 if l shift 1 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 1 Y p data 0 U p data 1 V p data 2 for j 0 j avctx height j for i 0 i avctx width 2 i Y i 2 wnv1 get code l prev y prev u U i wnv1 get code l prev u prev y Y i 2 1 wnv1 get code l Y i 2 prev v V i wnv1 get code l prev v Y p linesize 0 U p linesize 1 V p linesize 2 got frame 1 av free rbuf return buf size static int test candidate kf TWOPASS twopass const FIRSTPASSSTATS last frame const FIRSTPASSSTATS this frame const FIRSTPASSSTATS next frame int is viable kf 0 if this frame pcnt second ref 0 10 next frame pcnt second ref 0 10 this frame pcnt inter 0 05 this frame pcnt inter this frame pcnt neutral 0 35 this frame intra error DOUBLEDIVIDECHECK this frame coded error 2 5 fabs last frame coded error this frame coded error DOUBLEDIVIDECHECK this frame coded error 0 40 fabs last frame intra error this frame intra error DOUBLEDIVIDECHECK this frame intra error 0 40 next frame intra error DOUBLEDIVIDECHECK next frame coded error 3 5 int i const FIRSTPASSSTATS start pos twopass stats in FIRSTPASSSTATS local next frame next frame double boost score 0 0 double old boost score 0 0 double decay accumulator 1 0 for i 0 i 16 i double next iiratio IIKFACTO R1 local next frame intra error DOUBLEDIVIDECHECK local next frame coded error if next iiratio RMAX next iiratio RMAX if local next frame pcnt inter 0 85 decay accumulator local next frame pcnt inter else decay accumulator 0 85 local next frame pcnt inter 2 0 boost score decay accumulator next iiratio if local next frame pcnt inter 0 05 next iiratio 1 5 local next frame pcnt inter local next frame pcnt neutral 0 20 next iiratio 3 0 boost score old boost score 3 0 local next frame intra error 200 break old boost score boost score if EOF input stats twopass local next frame break if boost score 30 0 i 3 is viable kf 1 else reset fpf position twopass start pos is viable kf 0 return is viable kf static uint dump events for db char db char query buff QUERYLENGTH char db name buff NAMELEN 2 3 name buff NAMELEN 2 3 char event name char delimiter QUERYLENGTHFILE sql file md result file MYSQLRES event res event list res MYSQLROW row event list row char db cl name MYCSNAMESIZE int db cl altered FALSEDBUGENTER dump events for db DBUGPRINT enter db s db mysql real escape string mysql db name buff db ulong strlen db print comment sql file 0 n n Dumping events for database s n n db if lock tables mysql query mysql LOCKTABLES mysql event READ if mysql query with error report mysql event list res show events DBUGRETURN 0 strcpy delimiter if mysql num rows event list res 0 if opt xml fputs t events n sql file else fprintf sql file n if fetch db collation db name buff db cl name sizeof db cl name DBUGRETURN 1 if switch character set results mysql binary DBUGRETURN 1 while event list row mysql fetch row event list res NULL event name quote name event list row 1 name buff 0 DBUGPRINT info retrieving CREATEEVENT for s name buff my snprintf query buff sizeof query buff SHOWCREATEEVENT s event name if mysql query with error report mysql event res query buff DBUGRETURN 1 while row mysql fetch row event res NULL if opt xml print xml row sql file event event res row Create Event continue if strlen row 3 0 char query str if opt drop fprintf sql file s n event name delimiter if create delimiter row 3 delimiter sizeof delimiter NULL fprintf stderr s Warning Can t create delimiter for event s n my progname short event name DBUGRETURN 1 fprintf sql file DELIMITER s n delimiter if mysql num fields event res 7 if switch db collation sql file db name buff delimiter db cl name row 6 db cl altered DBUGRETURN 1 switch cs variables sql file delimiter row 4 row 4 row 5 else fprintf sql file n WARNING old server version The following dump may be incomplete n n switch sql mode sql file delimiter row 1 switch time zone sql file delimiter row 2 query str cover definer clause row 3 strlen row 3 CSTRINGWITHLEN 50117 CSTRINGWITHLEN 50106 CSTRINGWITHLENEVENT fprintf sql file s n const char query str NULL query str row 3 const char delimiter my free query str restore time zone sql file delimiter restore sql mode sql file delimiter if mysql num fields event res 7 restore cs variables sql file delimiter if db cl altered if restore db collation sql file db name buff delimiter db cl name DBUGRETURN 1 mysql free result event res if opt xml fputs t events n sql file check io sql file else fprintf sql file DELIMITER n fprintf sql file n if switch character set results mysql default charset DBUGRETURN 1 mysql free result event list res if lock tables void mysql query with error report mysql 0 UNLOCKTABLESDBUGRETURN 0 void vp9 set speed features V P9 COMP cpi SPEEDFEATURES const sf cpi sf V P9 COMMON const cm cpi common const V P9 Encoder Config const oxcf cpi oxcf int i sf frame parameter update 1 sf mv search method NSTEP sf recode loop ALLOWRECODE sf mv subpel search method SUBPELTREE sf mv subpel iters per step 2 sf mv subpel force stop 0 sf optimize coefficients is lossless requested cpi oxcf sf mv reduce first step size 0 sf mv auto mv step size 0 sf mv fullpel search step param 6 sf comp inter joint search thresh BLOCK 4 X4 sf adaptive rd thresh 0 sf use lastframe partitioning LASTFRAMEPARTITIONOFF sf tx size search method USEFULLRD sf use lp32x32fdct 0 sf adaptive motion search 0 sf adaptive pred interp filter 0 sf adaptive mode search 0 sf cb pred filter search 0 sf cb partition search 0 sf motion field mode search 0 sf alt ref search fp 0 sf use quant fp 0 sf reference masking 0 sf partition search type SEARCHPARTITION sf less rectangular check 0 sf use square partition only 0 sf auto min max partition size NOTINUSE sf max partition size BLOCK 64 X64 sf min partition size BLOCK 4 X4 sf adjust partitioning from last frame 0 sf last partitioning redo frequency 4 sf constrain copy partition 0 sf disable split mask 0 sf mode search skip flags 0 sf force frame boost 0 sf max delta qindex 0 sf disable filter search var thresh 0 sf adaptive interp filter search 0 for i 0 i TXSIZES i sf intra y mode mask i INTRAALL sf intra uv mode mask i INTRAALL sf use rd breakout 0 sf skip encode sb 0 sf use uv intra rd estimate 0 sf allow skip recode 0 sf lpf pick LPFPICKFROMFULLIMAGE sf use fast coef updates TWOLOOP sf use fast coef costing 0 sf mode skip start MAXMODES sf schedule mode search 0 sf use nonrd pick mode 0 for i 0 i BLOCKSIZES i sf inter mode mask i INTERALL sf max intra bsize BLOCK 64 X64 sf reuse inter pred sby 0 sf always this block size BLOCK 16 X16 sf search type check frequency 50 sf encode breakout thresh 0 sf elevate newmv thresh 0 sf recode tolerance 25 sf default interp filter SWITCHABLE sf tx size search breakout 0 sf partition search breakout dist thr 0 sf partition search breakout rate thr 0 if oxcf mode REALTIME set rt speed feature cpi sf oxcf speed oxcf content else if oxcf mode GOOD set good speed feature cpi cm sf oxcf speed cpi full search sad vp9 full search sad cpi diamond search sad oxcf mode BEST vp9 full range search vp9 diamond search sad cpi refining search sad vp9 refining search sad if oxcf pass 1 sf optimize coefficients 0 if oxcf pass 0 sf recode loop DISALLOWRECODE sf optimize coefficients 0 if sf mv subpel search method SUBPELTREE cpi find fractional mv step vp9 find best sub pixel tree else if sf mv subpel search method SUBPELTREEPRUNED cpi find fractional mv step vp9 find best sub pixel tree pruned cpi mb optimize sf optimize coefficients 1 oxcf pass 1 if sf disable split mask DISABLEALLSPLIT sf adaptive pred interp filter 0 if cpi oxcf frame periodic boost sf max delta qindex 0 if cpi encode breakout oxcf mode REALTIME sf encode breakout thresh cpi encode breakout cpi encode breakout sf encode breakout thresh uint8 t jbig2 decode gray scale image Jbig2 Ctx ctx Jbig2 Segment segment const byte data const size t size bool GSMMR uint32 t GSW uint32 t GSH uint32 t GSBPP bool GSUSESKIP Jbig2 Image GSKIP int GSTEMPLATE Jbig2 Arith Cx GB stats uint8 t GSVALSNULL size t consumed bytes 0 int i j code stride int x y Jbig2 Image GSPLANES Jbig2 Generic Region Params rparams Jbig2 Word Stream ws NULL Jbig2 Arith State as NULLGSPLANES jbig2 new ctx Jbig2 Image GSBPP if GSPLANESNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate d bytes for GSPLANESGSBPP return NULL for i 0 i GSBPP i GSPLANES i jbig2 image new ctx GSWGSH if GSPLANES i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate dx d image for GSPLANESGSWGSH for j i 1 j 0 j jbig2 image release ctx GSPLANES j jbig2 free ctx allocator GSPLANES return NULL rparams MMRGSMMR rparams GBTEMPLATEGSTEMPLATE rparams TPGDON 0 rparams USESKIPGSUSESKIP rparams gbat 0 GSTEMPLATE 1 3 2 rparams gbat 1 1 rparams gbat 2 3 rparams gbat 3 1 rparams gbat 4 2 rparams gbat 5 2 rparams gbat 6 2 rparams gbat 7 2 if GSMMR code jbig2 decode halftone mmr ctx rparams data size GSPLANESGSBPP 1 consumed bytes else ws jbig2 word stream buf new ctx data size if ws NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate ws in jbig2 decode gray scale image goto cleanup as jbig2 arith new ctx ws if as NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate as in jbig2 decode gray scale image goto cleanup code jbig2 decode generic region ctx segment rparams as GSPLANESGSBPP 1 GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup j GSBPP 2 while j 0 if GSMMR code jbig2 decode halftone mmr ctx rparams data consumed bytes size consumed bytes GSPLANES j consumed bytes else code jbig2 decode generic region ctx segment rparams as GSPLANES j GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup stride GSPLANES 0 stride for i 0 i stride GSH i GSPLANES j data i GSPLANES j 1 data i j GSVALS jbig2 new ctx uint8 t GSW if GSVALSNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSW goto cleanup for i 0 i GSW i GSVALS i jbig2 new ctx uint8 t GSH if GSVALS i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSHGSW for j i 1 j 0 j jbig2 free ctx allocator GSVALS j jbig2 free ctx allocator GSVALSGSVALSNULL goto cleanup for x 0 x GSW x for y 0 y GSH y GSVALS x y 0 for j 0 j GSBPP j GSVALS x y jbig2 image get pixel GSPLANES j x y j cleanup if GSMMR jbig2 free ctx allocator as jbig2 word stream buf free ctx ws for i 0 i GSBPP i jbig2 image release ctx GSPLANES i jbig2 free ctx allocator GSPLANES return static int slice end AV Codec Context avctx AV Frame pict Mpeg1 Context s1 avctx priv data Mpeg Enc Context s s1 mpeg enc ctx if s1 mpeg enc ctx allocated s current picture ptr return 0 if s avctx hwaccel if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode picture n if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s if s first field ff er frame end s er ff MPV frame end s if s pict type AVPICTURETYPEB s low delay int ret av frame ref pict s current picture ptr f if ret 0 return ret ff print debug info s s current picture ptr else if avctx active thread type FFTHREADFRAME s picture number if s last picture ptr NULL int ret av frame ref pict s last picture ptr f if ret 0 return ret ff print debug info s s last picture ptr return 1 else return 0 static int cinvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cin Video Context cin avctx priv data int i y palette type palette colors count bitmap frame type bitmap frame size res 0 palette type buf 0 palette colors count AVR L16 buf 1 bitmap frame type buf 3 buf 4 bitmap frame size buf size 4 if bitmap frame size palette colors count 3 palette type 0 return AVERRORINVALIDDATA if palette type 0 if palette colors count 256 return AVERRORINVALIDDATA for i 0 i palette colors count i cin palette i bytestream get le24 buf bitmap frame size 3 else for i 0 i palette colors count i cin palette buf 0 AVR L24 buf 1 buf 4 bitmap frame size 4 switch bitmap frame type case 9 cin decode rle buf bitmap frame size cin bitmap table CINCURBMP cin bitmap size break case 34 cin decode rle buf bitmap frame size cin bitmap table CINCURBMP cin bitmap size cin apply delta data cin bitmap table CINPREBMP cin bitmap table CINCURBMP cin bitmap size break case 35 cin decode huffman buf bitmap frame size cin bitmap table CININTBMP cin bitmap size cin decode rle cin bitmap table CININTBMP bitmap frame size cin bitmap table CINCURBMP cin bitmap size break case 36 bitmap frame size cin decode huffman buf bitmap frame size cin bitmap table CININTBMP cin bitmap size cin decode rle cin bitmap table CININTBMP bitmap frame size cin bitmap table CINCURBMP cin bitmap size cin apply delta data cin bitmap table CINPREBMP cin bitmap table CINCURBMP cin bitmap size break case 37 cin decode huffman buf bitmap frame size cin bitmap table CINCURBMP cin bitmap size break case 38 res cin decode lzss buf bitmap frame size cin bitmap table CINCURBMP cin bitmap size if res 0 return res break case 39 res cin decode lzss buf bitmap frame size cin bitmap table CINCURBMP cin bitmap size if res 0 return res cin apply delta data cin bitmap table CINPREBMP cin bitmap table CINCURBMP cin bitmap size break cin frame buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if avctx reget buffer avctx cin frame av log cin avctx AVLOGERROR delphinecinvideo reget buffer failed to allocate a frame n return 1 memcpy cin frame data 1 cin palette sizeof cin palette cin frame palette has changed 1 for y 0 y cin avctx height y memcpy cin frame data 0 cin avctx height 1 y cin frame linesize 0 cin bitmap table CINCURBMP y cin avctx width cin avctx width FFSWAP uint8 t cin bitmap table CINCURBMP cin bitmap table CINPREBMP got frame 1 AV Frame data cin frame return buf size static void super block uvrd const V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skippable int64 t sse BLOCKSIZE bsize int64 t ref best rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const TXSIZE uv tx size get uv tx size mbmi xd plane 1 int plane int pnrate 0 pnskip 1 int64 t pndist 0 pnsse 0 if ref best rd 0 goto term if is inter block mbmi int plane for plane 1 plane MAXMBPLANE plane vp9 subtract plane x bsize plane rate 0 distortion 0 sse 0 skippable 1 for plane 1 plane MAXMBPLANE plane txfm rd in plane x pnrate pndist pnskip pnsse ref best rd plane bsize uv tx size cpi sf use fast coef costing if pnrate INTMAX goto term rate pnrate distortion pndist sse pnsse skippable pnskip return term rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 return static void update stats V P9 COMMON cm const MACROBLOCK x const MACROBLOCKD const xd x e mbd const MODEINFO const mi xd mi 0 const MBMODEINFO const mbmi mi mbmi if frame is intra only cm const int seg ref active vp9 segfeature active cm seg mbmi segment id SEGLVLREFFRAME if seg ref active FRAMECOUNTS const counts cm counts const int inter block is inter block mbmi counts intra inter vp9 get intra inter context xd inter block if inter block const MVREFERENCEFRAME ref0 mbmi ref frame 0 if cm reference mode REFERENCEMODESELECT counts comp inter vp9 get reference mode context cm xd has second ref mbmi if has second ref mbmi counts comp ref vp9 get pred context comp ref p cm xd ref0 GOLDENFRAME else counts single ref vp9 get pred context single ref p1 xd 0 ref0 LASTFRAME if ref0 LASTFRAME counts single ref vp9 get pred context single ref p2 xd 1 ref0 static int vp9 pattern search const MACROBLOCK x MV ref mv int search param int sad per bit int do init search int sad list const vp9 variance fn ptr t vfp int use mvcost const MV center mv MV best mv const int num candidates MAXPATTERNSCALES const MV candidates MAXPATTERNSCALESMAXPATTERNCANDIDATES const MACROBLOCKD const xd x e mbd static const int search param to steps MAXMVSEARCHSTEPS 10 9 8 7 6 5 4 3 2 1 0 int i s t const struct buf 2d const what x plane 0 src const struct buf 2d const in what xd plane 0 pre 0 int br bc int bestsad INTMAX int thissad int k 1 const MV fcenter mv center mv row 3 center mv col 3 int best init s search param to steps search param clamp mv ref mv x mv col min x mv col max x mv row min x mv row max br ref mv row bc ref mv col bestsad vfp sdf what buf what stride get buf from mv in what ref mv in what stride mvsad err cost x ref mv fcenter mv sad per bit if do init search s best init s best init s 1 for t 0 t s t int best site 1 if check bounds x br bc 1 t for i 0 i num candidates t i const MV this mv br candidates t i row bc candidates t i col thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER else for i 0 i num candidates t i const MV this mv br candidates t i row bc candidates t i col if is mv in x this mv continue thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER if best site 1 continue else best init s t k best site if best init s 1 br candidates best init s k row bc candidates best init s k col if best init s 1 int best site 1 s best init s do if do init search s best init s if check bounds x br bc 1 s for i 0 i num candidates s i const MV this mv br candidates s i row bc candidates s i col thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER else for i 0 i num candidates s i const MV this mv br candidates s i row bc candidates s i col if is mv in x this mv continue thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER if best site 1 continue else br candidates s best site row bc candidates s best site col k best site do int next chkpts indices PATTERNCANDIDATESREF best site 1 next chkpts indices 0 k 0 num candidates s 1 k 1 next chkpts indices 1 k next chkpts indices 2 k num candidates s 1 0 k 1 if check bounds x br bc 1 s for i 0 i PATTERNCANDIDATESREF i const MV this mv br candidates s next chkpts indices i row bc candidates s next chkpts indices i col thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER else for i 0 i PATTERNCANDIDATESREF i const MV this mv br candidates s next chkpts indices i row bc candidates s next chkpts indices i col if is mv in x this mv continue thissad vfp sdf what buf what stride get buf from mv in what this mv in what stride CHECKBETTER if best site 1 k next chkpts indices best site br candidates s k row bc candidates s k col while best site 1 while s if sad list static const MV neighbors 4 0 1 1 0 0 1 1 0 sad list 0 bestsad if check bounds x br bc 1 for i 0 i 4 i const MV this mv br neighbors i row bc neighbors i col sad list i 1 vfp sdf what buf what stride get buf from mv in what this mv in what stride use mvcost mvsad err cost x this mv fcenter mv sad per bit 0 else for i 0 i 4 i const MV this mv br neighbors i row bc neighbors i col if is mv in x this mv sad list i 1 INTMAX else sad list i 1 vfp sdf what buf what stride get buf from mv in what this mv in what stride use mvcost mvsad err cost x this mv fcenter mv sad per bit 0 best mv row br best mv col bc return bestsad void vp9 xform quant MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size tran low t const coeff BLOCKOFFSET p coeff block tran low t const qcoeff BLOCKOFFSET p qcoeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break void ff draw horiz band AV Codec Context avctx DSP Context dsp Picture cur Picture last int y int h int picture structure int first field int draw edges int low delay int v edge pos int h edge pos const AV Pix Fmt Descriptor desc av pix fmt desc get avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h const int field pic picture structure PICTFRAME if field pic h 1 y 1 if avctx hwaccel avctx codec capabilities CODECCAPHWACCELVDPAU draw edges cur f reference avctx flags CODECFLAGEMUEDGE int linesize cur f linesize int sides 0 edge h if y 0 sides EDGETOP if y h v edge pos sides EDGEBOTTOM edge h FFMIN h v edge pos y dsp draw edges cur f data 0 y linesize 0 linesize 0 h edge pos edge h EDGEWIDTHEDGEWIDTH sides dsp draw edges cur f data 1 y vshift linesize 1 linesize 1 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides dsp draw edges cur f data 2 y vshift linesize 2 linesize 2 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides h FFMIN h avctx height y if field pic first field avctx slice flags SLICEFLAGALLOWFIELD return if avctx draw horiz band AV Frame src int offset AVNUMDATAPOINTERS int i if cur f pict type AVPICTURETYPEB low delay avctx slice flags SLICEFLAGCODEDORDER src cur f else if last src last f else return if cur f pict type AVPICTURETYPEB picture structure PICTFRAME avctx codec id AVCODECID H264 avctx codec id AVCODECIDSV Q3 for i 0 i AVNUMDATAPOINTERS i offset i 0 else offset 0 y src linesize 0 offset 1 offset 2 y vshift src linesize 1 for i 3 i AVNUMDATAPOINTERS i offset i 0 emms c avctx draw horiz band avctx src offset y picture structure h static gint detect version wtap wth int err gchar err info gint bytes read guint16 payload length guint16 try header size guint8 buffer gint64 file offset guint32 log length guint32 tag length guint16 tmp file offset file tell wth fh bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 payload length pletoh16 tmp bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 try header size pletoh16 tmp buffer guint8 g malloc 5 4 payload length bytes read file read buffer 5 4 payload length wth fh if bytes read 5 4 payload length if bytes read 4 4 payload length err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD g free buffer return 1 if try header size 24 tag length guint32 strlen buffer 5 4 1 1 log length guint32 strlen buffer 5 4 1 tag length 1 if payload length 1 tag length log length g free buffer return 2 tag length guint32 strlen buffer 4 4 1 1 log length guint32 strlen buffer 4 4 1 tag length 1 if payload length 1 tag length log length if file seek wth fh file offset 4 4 1 tag length log length SEEKSET err 1 g free buffer return 1 g free buffer return 1 g free buffer return 0 static void block rd txfm int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct rdcost block args args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi int64 t rd1 rd2 rd if args skip return if is inter block mbmi vp9 encode block intra x plane block plane bsize tx size mbmi skip dist block plane block tx size args else if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args else if x skip txfm plane 2 block tx size 1 2 tran low t const coeff BLOCKOFFSET x plane plane coeff block tran low t const dqcoeff BLOCKOFFSET xd plane plane dqcoeff block vp9 xform quant dc x plane block plane bsize tx size args sse x bsse plane 2 block tx size 1 4 args dist args sse if x plane plane eobs block args dist args sse coeff 0 coeff 0 coeff 0 dqcoeff 0 coeff 0 dqcoeff 0 2 else x plane plane eobs block 0 args sse x bsse plane 2 block tx size 1 4 args dist args sse else vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args rate block plane block plane bsize tx size args rd1 RDCOST x rdmult x rddiv args rate args dist rd2 RDCOST x rdmult x rddiv 0 args sse rd MIN rd1 rd2 if plane 0 x zcoeff blk tx size block x plane plane eobs block rd1 rd2 xd lossless args this rate args rate args this dist args dist args this sse args sse args this rd rd if args this rd args best rd args skip 1 return int Parse Caff Header Config FILE infile char infilename char fourcc Wavpack Context wpc Wavpack Config config uint32 t chan chunk 0 channel layout 0 bcount unsigned char channel identities NULL unsigned char channel reorder NULL int64 t total samples 0 infilesize CAF File Header caf file header CAF Chunk Header caf chunk header CAF Audio Format caf audio format int i infilesize Do Get File Size infile memcpy caf file header fourcc 4 if Do Read File infile char caf file header 4 sizeof CAF File Header 4 bcount bcount sizeof CAF File Header 4 error line s is not a valid CAF file infilename return WAVPACKSOFTERROR else if config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc caf file header sizeof CAF File Header error line s Wavpack Get Error Message wpc return WAVPACKSOFTERROR Wavpack Big Endian To Native caf file header CAF File Header Format if caf file header m File Version 1 error line s can t handle version d CAF files infilename caf file header m File Version return WAVPACKSOFTERROR while 1 if Do Read File infile caf chunk header sizeof CAF Chunk Header bcount bcount sizeof CAF Chunk Header error line s is not a valid CAF file infilename return WAVPACKSOFTERROR else if config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc caf chunk header sizeof CAF Chunk Header error line s Wavpack Get Error Message wpc return WAVPACKSOFTERROR Wavpack Big Endian To Native caf chunk header CAF Chunk Header Format if strncmp caf chunk header m Chunk Type desc 4 int supported TRUE if caf chunk header m Chunk Size sizeof CAF Audio Format Do Read File infile caf audio format uint32 t caf chunk header m Chunk Size bcount bcount caf chunk header m Chunk Size error line s is not a valid CAF file infilename return WAVPACKSOFTERROR else if config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc caf audio format uint32 t caf chunk header m Chunk Size error line s Wavpack Get Error Message wpc return WAVPACKSOFTERROR Wavpack Big Endian To Native caf audio format CAF Audio Format Format if debug logging mode char formatstr 5 memcpy formatstr caf audio format m Format ID 4 formatstr 4 0 error line format s flags x sampling rate g formatstr caf audio format m Format Flags caf audio format m Sample Rate error line packet d bytes and d frames caf audio format m Bytes Per Packet caf audio format m Frames Per Packet error line channels per frame d bits per channel d caf audio format m Channels Per Frame caf audio format m Bits Per Channel if strncmp caf audio format m Format ID lpcm 4 caf audio format m Format Flags 3 supported FALSE else if caf audio format m Sample Rate 1 0 caf audio format m Sample Rate 16777215 0 caf audio format m Sample Rate floor caf audio format m Sample Rate supported FALSE else if caf audio format m Channels Per Frame caf audio format m Channels Per Frame 256 supported FALSE else if caf audio format m Bits Per Channel 1 caf audio format m Bits Per Channel 32 caf audio format m Format Flags CAFFORMATFLOAT caf audio format m Bits Per Channel 32 supported FALSE else if caf audio format m Frames Per Packet 1 caf audio format m Bytes Per Packet caf audio format m Channels Per Frame caf audio format m Bits Per Channel 7 8 caf audio format m Bytes Per Packet caf audio format m Channels Per Frame 4 caf audio format m Bytes Per Packet caf audio format m Channels Per Frame supported FALSE if supported error line s is an unsupported CAF format infilename return WAVPACKSOFTERROR config bytes per sample caf audio format m Bytes Per Packet caf audio format m Channels Per Frame config float norm exp caf audio format m Format Flags CAFFORMATFLOAT 127 0 config bits per sample caf audio format m Bits Per Channel config num channels caf audio format m Channels Per Frame config sample rate int caf audio format m Sample Rate if caf audio format m Format Flags CAFFORMATLITTLEENDIAN config bytes per sample 1 config qmode QMODEBIGENDIAN if config bytes per sample 1 config qmode QMODESIGNEDBYTES if debug logging mode if config float norm exp 127 error line data format 32 bit s endian floating point config qmode QMODEBIGENDIAN big little else error line data format d bit s endian integers stored in d byte s config bits per sample config qmode QMODEBIGENDIAN big little config bytes per sample else if strncmp caf chunk header m Chunk Type chan 4 CAF Channel Layout caf channel layout malloc size t caf chunk header m Chunk Size if caf chunk header m Chunk Size sizeof CAF Channel Layout Do Read File infile caf channel layout uint32 t caf chunk header m Chunk Size bcount bcount caf chunk header m Chunk Size error line s is not a valid CAF file infilename free caf channel layout return WAVPACKSOFTERROR else if config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc caf channel layout uint32 t caf chunk header m Chunk Size error line s Wavpack Get Error Message wpc free caf channel layout return WAVPACKSOFTERROR Wavpack Big Endian To Native caf channel layout CAF Channel Layout Format chan chunk 1 if config channel mask config qmode QMODECHANSUNASSIGNED error line this CAF file already has channel order information free caf channel layout return WAVPACKSOFTERROR switch caf channel layout m Channel Layout Tag case k CAF Channel Layout Tag Use Channel Descriptions CAF Channel Description descriptions CAF Channel Description caf channel layout 1 int num descriptions caf channel layout m Number Channel Descriptions int label cindex 0 idents 0 if caf chunk header m Chunk Size sizeof CAF Channel Layout sizeof CAF Channel Description num descriptions num descriptions config num channels error line channel descriptions in chan chunk are the wrong size free caf channel layout return WAVPACKSOFTERROR if num descriptions 256 error line d channel descriptions is more than we can handle ignoring break channel reorder malloc num descriptions memset channel reorder 1 num descriptions channel identities malloc num descriptions 1 for i 0 i num descriptions i Wavpack Big Endian To Native descriptions i CAF Channel Description Format if debug logging mode error line chan d d i 1 descriptions i m Channel Label for label 1 label 18 label for i 0 i num descriptions i if descriptions i m Channel Label label config channel mask 1 label 1 channel reorder i cindex break for i 0 i num descriptions i if channel reorder i unsigned char 1 uint32 t clabel descriptions i m Channel Label if clabel 0 clabel 0xffffffff clabel 100 channel identities idents 0xff else if clabel 33 clabel 44 clabel 200 clabel 207 clabel 301 clabel 305 channel identities idents clabel 301 clabel 80 clabel else error line warning unknown channel descriptions label d clabel channel identities idents 0xff channel reorder i cindex for i 0 i num descriptions i if channel reorder i i break if i num descriptions free channel reorder channel reorder NULL else config qmode QMODEREORDEREDCHANS channel layout num descriptions if idents free channel identities channel identities NULL else channel identities idents 0 if debug logging mode error line layout tag 0x 08x so generated bitmap of 0x 08x from d descriptions d non MS caf channel layout m Channel Layout Tag config channel mask caf channel layout m Number Channel Descriptions idents if channel reorder num descriptions 8 char reorder string 12345678 for i 0 i num descriptions i reorder string i channel reorder i 1 reorder string i 0 error line reordering string s n reorder string break case k CAF Channel Layout Tag Use Channel Bitmap config channel mask caf channel layout m Channel Bitmap if debug logging mode error line layout tag 0x 08x so using supplied bitmap of 0x 08x caf channel layout m Channel Layout Tag caf channel layout m Channel Bitmap break default for i 0 i NUMLAYOUTS i if caf channel layout m Channel Layout Tag layouts i m Channel Layout Tag config channel mask layouts i m Channel Bitmap channel layout layouts i m Channel Layout Tag if layouts i m Channel Reorder channel reorder unsigned char strdup layouts i m Channel Reorder config qmode QMODEREORDEREDCHANS if layouts i m Channel Identities channel identities unsigned char strdup layouts i m Channel Identities if debug logging mode error line layout tag 0x 08x found in table bitmap 0x 08x reorder s identities s channel layout config channel mask channel reorder yes no channel identities yes no break if i NUMLAYOUTS debug logging mode error line layout tag 0x 08x not found in table all channels unassigned caf channel layout m Channel Layout Tag break free caf channel layout else if strncmp caf chunk header m Chunk Type data 4 uint32 t m Edit Count if Do Read File infile m Edit Count sizeof m Edit Count bcount bcount sizeof m Edit Count error line s is not a valid CAF file infilename return WAVPACKSOFTERROR else if config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc m Edit Count sizeof m Edit Count error line s Wavpack Get Error Message wpc return WAVPACKSOFTERROR if config qmode QMODEIGNORELENGTH caf chunk header m Chunk Size 1 config qmode QMODEIGNORELENGTH if infilesize Do Get File Position infile 1 total samples infilesize Do Get File Position infile caf audio format m Bytes Per Packet else total samples 1 else if infilesize infilesize caf chunk header m Chunk Size 16777216 error line CAF file s has over 16 MB of extra CAFF data probably is corrupt infilename return WAVPACKSOFTERROR if caf chunk header m Chunk Size 4 caf audio format m Bytes Per Packet error line CAF file s has an invalid data chunk size probably is corrupt infilename return WAVPACKSOFTERROR total samples caf chunk header m Chunk Size 4 caf audio format m Bytes Per Packet if total samples error line this CAF file has no audio samples probably is corrupt return WAVPACKSOFTERROR if total samples MAXWAVPACKSAMPLES error line s has too many samples for Wav Pack infilename return WAVPACKSOFTERROR break else int bytes to copy uint32 t caf chunk header m Chunk Size char buff malloc bytes to copy if debug logging mode error line extra unknown chunk c c c c of d bytes caf chunk header m Chunk Type 0 caf chunk header m Chunk Type 1 caf chunk header m Chunk Type 2 caf chunk header m Chunk Type 3 caf chunk header m Chunk Size if Do Read File infile buff bytes to copy bcount bcount bytes to copy config qmode QMODENOSTOREWRAPPER Wavpack Add Wrapper wpc buff bytes to copy error line s Wavpack Get Error Message wpc free buff return WAVPACKSOFTERROR free buff if chan chunk config channel mask config num channels 2 config qmode QMODECHANSUNASSIGNED config channel mask 0x5 config num channels if Wavpack Set Configuration64 wpc config total samples channel identities error line s Wavpack Get Error Message wpc return WAVPACKSOFTERROR if channel identities free channel identities if channel layout channel reorder if Wavpack Set Channel Layout wpc channel layout channel reorder error line problem with setting channel layout should not happen return WAVPACKSOFTERROR if channel reorder free channel reorder return static int execstack continue i ctx t i ctx p os ptr op osp return do execstack i ctx p false false op void vp9 loop filter frame mt Y V12 BUFFERCONFIG frame V P9 Decoder pbi V P9 COMMON cm int frame filter level int y only V P9 Lf Sync const lf sync pbi lf row sync const V P9 Worker Interface const winterface vp9 get worker interface const int sb rows mi cols aligned to sb cm mi rows MIBLOCKSIZELO G2 const int tile cols 1 cm log2 tile cols const int num workers MIN pbi max threads 1 tile cols int i if frame filter level return if lf sync sync range cm last height cm height vp9 loop filter dealloc lf sync vp9 loop filter alloc lf sync cm sb rows cm width vp9 loop filter frame init cm frame filter level vpx memset lf sync cur sb col 1 sizeof lf sync cur sb col sb rows for i 0 i num workers i V P9 Worker const worker pbi tile workers i Tile Worker Data const tile data Tile Worker Data worker data1 LF Worker Data const lf data tile data lfdata worker hook V P9 Worker Hook loop filter row worker lf data frame buffer frame lf data cm cm vp9 copy lf data planes pbi mb plane lf data start i lf data stop sb rows lf data y only y only lf data lf sync lf sync lf data num lf workers num workers if i num workers 1 winterface execute worker else winterface launch worker for i 0 i num workers i winterface sync pbi tile workers i static void dump Databases P Gconn conn P Gresult res int i if server version 70100 res execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 else res execute Query conn SELECT datname FROM pg database ORDERBY 1 for i 0 i P Qntuples res i int ret char dbname P Qgetvalue res i 0 PQ Exp Buffer Data connectbuf if verbose fprintf stderr s dumping database s n progname dbname init PQ Exp Buffer connectbuf append Psql Meta Connect connectbuf dbname fprintf OPF s n connectbuf data term PQ Exp Buffer connectbuf fprintf OPFSET default transaction read only off n n if filename fclose OPF ret run Pg Dump dbname if ret 0 fprintf stderr s pg dump failed on database s exiting n progname dbname exit nicely 1 if filename OPF fopen filename PGBINARYA if OPF fprintf stderr s could not re open the output file s s n progname filename strerror errno exit nicely 1 P Qclear res void vp9 init layer context V P9 COMP const cpi SVC const svc cpi svc const V P9 Encoder Config const oxcf cpi oxcf int layer int layer end int alt ref idx svc number spatial layers svc number temporal layers svc spatial layer id 0 svc temporal layer id 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR layer end svc number temporal layers else layer end svc number spatial layers for layer 0 layer layer end layer LAYERCONTEXT const lc svc layer context layer RATECONTROL const lrc lc rc int i lc current video frame in layer 0 lc layer size 0 lc frames from key frame 0 lc last frame type FRAMETYPES lrc ni av qi oxcf worst allowed q lrc total actual bits 0 lrc total target vs actual 0 lrc ni tot qi 0 lrc tot q 0 0 lrc avg q 0 0 lrc ni frames 0 lrc decimation count 0 lrc decimation factor 0 for i 0 i RATEFACTORLEVELS i lrc rate correction factors i 1 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR lc target bandwidth oxcf ts target bitrate layer lrc last q INTERFRAME oxcf worst allowed q lrc avg frame qindex INTERFRAME oxcf worst allowed q else lc target bandwidth oxcf ss target bitrate layer lrc last q KEYFRAME oxcf best allowed q lrc last q INTERFRAME oxcf best allowed q lrc avg frame qindex KEYFRAME oxcf worst allowed q oxcf best allowed q 2 lrc avg frame qindex INTERFRAME oxcf worst allowed q oxcf best allowed q 2 if oxcf ss play alternate layer lc alt ref idx alt ref idx else lc alt ref idx 1 lc gold ref idx 1 lrc buffer level oxcf starting buffer level ms lc target bandwidth 1000 lrc bits off target lrc buffer level if svc number temporal layers 1 cpi oxcf rc mode VPXCBR alt ref idx REFFRAMES svc layer context 0 gold ref idx alt ref idx int ff rv34 decode frame AV Codec Context avctx void data int got picture ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size R V34 Dec Context r avctx priv data Mpeg Enc Context s r s AV Frame pict data Slice Info si int i int slice count const uint8 t slices hdr NULL int last 0 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got picture ptr 1 return 0 if avctx slice count slice count buf 1 slices hdr buf 4 buf 8 slice count buf size 1 8 slice count else slice count avctx slice count if get slice offset avctx slices hdr 0 0 get slice offset avctx slices hdr 0 buf size av log avctx AVLOGERROR Slice offset is invalid n return AVERRORINVALIDDATA init get bits s gb buf get slice offset avctx slices hdr 0 buf size get slice offset avctx slices hdr 0 8 if r parse slice header r r s gb si 0 si start av log avctx AVLOGERROR First slice header is incorrect n return AVERRORINVALIDDATA if s last picture ptr s last picture ptr f data 0 si type AVPICTURETYPEB av log avctx AVLOGERROR Invalid decoder state B frame without reference data n return AVERRORINVALIDDATA if avctx skip frame AVDISCARDNONREF si type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY si type AVPICTURETYPEI avctx skip frame AVDISCARDALL return avpkt size if si start 0 if s mb num left 0 av log avctx AVLOGERROR New frame but still d MB left s mb num left ff er frame end s er ff MPV frame end s if s width si width s height si height int err av log s avctx AVLOGWARNING Changing dimensions to dx d n si width si height s width si width s height si height avcodec set dimensions s avctx s width s height if err ff MPV common frame size change s 0 return err if err rv34 decoder realloc r 0 return err s pict type si type si type AVPICTURETYPEI if ff MPV frame start s s avctx 0 return 1 ff mpeg er frame start s if r tmp b block base int i r tmp b block base av malloc s linesize 48 for i 0 i 2 i r tmp b block y i r tmp b block base i 16 s linesize for i 0 i 4 i r tmp b block uv i r tmp b block base 32 s linesize i 1 8 s uvlinesize i 1 16 r cur pts si pts if s pict type AVPICTURETYPEB r last pts r next pts r next pts r cur pts else int refdist GETPTSDIFF r next pts r last pts int dist0 GETPTSDIFF r cur pts r last pts int dist1 GETPTSDIFF r next pts r cur pts if refdist r mv weight1 r mv weight2 r weight1 r weight2 8192 r scaled weight 0 else r mv weight1 dist0 14 refdist r mv weight2 dist1 14 refdist if r mv weight1 r mv weight2 511 r weight1 r mv weight1 r weight2 r mv weight2 r scaled weight 0 else r weight1 r mv weight1 9 r weight2 r mv weight2 9 r scaled weight 1 s mb x s mb y 0 ff thread finish setup s avctx else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log s avctx AVLOGERROR Decoder needs full frames in frame multithreading mode start MB is d n si start return AVERRORINVALIDDATA for i 0 i slice count i int offset get slice offset avctx slices hdr i int size if i 1 slice count size buf size offset else size get slice offset avctx slices hdr i 1 offset if offset 0 offset buf size av log avctx AVLOGERROR Slice offset is invalid n break r si end s mb width s mb height s mb num left r s mb x r s mb y r s mb width r si start if i 1 slice count if get slice offset avctx slices hdr i 1 0 get slice offset avctx slices hdr i 1 buf size av log avctx AVLOGERROR Slice offset is invalid n break init get bits s gb buf get slice offset avctx slices hdr i 1 buf size get slice offset avctx slices hdr i 1 8 if r parse slice header r r s gb si 0 if i 2 slice count size get slice offset avctx slices hdr i 2 offset else size buf size offset else r si end si start if size 0 size buf size offset av log avctx AVLOGERROR Slice size is invalid n break last rv34 decode slice r r si end buf offset size if last break if s current picture ptr if last if r loop filter r loop filter r s mb height 1 got picture ptr finish frame avctx pict else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log avctx AVLOGINFO marking unfished frame as finished n ff er frame end s er ff MPV frame end s s mb num left 0 ff thread report progress s current picture ptr f INTMAX 0 return AVERRORINVALIDDATA return avpkt size static int svq3 decode mb SV Q3 Context s unsigned int mb type H264 Context h s h int i j k m dir mode int cbp 0 uint32 t vlc int8 t top left const int mb xy h mb xy const int b xy 4 h mb x 4 h mb y h b stride h top samples available h mb y 0 0x33 FF 0x FFFF h left samples available h mb x 0 0x5 F5 F 0x FFFF h topright samples available 0x FFFF if mb type 0 if h pict type AVPICTURETYPEP s next pic f mb type mb xy 1 svq3 mc dir part s 16 h mb x 16 h mb y 16 16 0 0 0 0 0 0 if h pict type AVPICTURETYPEB svq3 mc dir part s 16 h mb x 16 h mb y 16 16 0 0 0 0 1 1 mb type MBTYPESKIP else mb type FFMIN s next pic f mb type mb xy 6 if svq3 mc dir s mb type PREDICTMODE 0 0 0 return 1 if svq3 mc dir s mb type PREDICTMODE 1 1 0 return 1 mb type MBTYPE 16x16 else if mb type 8 if s thirdpel flag s halfpel flag get bits1 h gb mode THIRDPELMODE else if s halfpel flag s thirdpel flag get bits1 h gb mode HALFPELMODE else mode FULLPELMODE for m 0 m 2 m if h mb x 0 h intra4x4 pred mode h mb2br xy mb xy 1 6 1 for i 0 i 4 i AVCOP Y32 h mv cache m scan8 0 1 i 8 h cur pic f motion val m b xy 1 i h b stride else for i 0 i 4 i AVZER O32 h mv cache m scan8 0 1 i 8 if h mb y 0 memcpy h mv cache m scan8 0 1 8 h cur pic f motion val m b xy h b stride 4 2 sizeof int16 t memset h ref cache m scan8 0 1 8 h intra4x4 pred mode h mb2br xy mb xy h mb stride 1 PARTNOTAVAILABLE 1 4 if h mb x h mb width 1 AVCOP Y32 h mv cache m scan8 0 4 1 8 h cur pic f motion val m b xy h b stride 4 h ref cache m scan8 0 4 1 8 h intra4x4 pred mode h mb2br xy mb xy h mb stride 1 6 1 h intra4x4 pred mode h mb2br xy mb xy h mb stride 1 PARTNOTAVAILABLE 1 else h ref cache m scan8 0 4 1 8 PARTNOTAVAILABLE if h mb x 0 AVCOP Y32 h mv cache m scan8 0 1 1 8 h cur pic f motion val m b xy h b stride 1 h ref cache m scan8 0 1 1 8 h intra4x4 pred mode h mb2br xy mb xy h mb stride 1 3 1 PARTNOTAVAILABLE 1 else h ref cache m scan8 0 1 1 8 PARTNOTAVAILABLE else memset h ref cache m scan8 0 1 8 1 PARTNOTAVAILABLE 8 if h pict type AVPICTURETYPEB break if h pict type AVPICTURETYPEP if svq3 mc dir s mb type 1 mode 0 0 0 return 1 else if mb type 2 if svq3 mc dir s 0 mode 0 0 0 return 1 else for i 0 i 4 i memset h cur pic f motion val 0 b xy i h b stride 0 4 2 sizeof int16 t if mb type 1 if svq3 mc dir s 0 mode 1 mb type 3 0 return 1 else for i 0 i 4 i memset h cur pic f motion val 1 b xy i h b stride 0 4 2 sizeof int16 t mb type MBTYPE 16x16 else if mb type 8 mb type 33 memset h intra4x4 pred mode cache 1 8 5 sizeof int8 t if mb type 8 if h mb x 0 for i 0 i 4 i h intra4x4 pred mode cache scan8 0 1 i 8 h intra4x4 pred mode h mb2br xy mb xy 1 6 i if h intra4x4 pred mode cache scan8 0 1 1 h left samples available 0x5 F5 F if h mb y 0 h intra4x4 pred mode cache 4 8 0 h intra4x4 pred mode h mb2br xy mb xy h mb stride 0 h intra4x4 pred mode cache 5 8 0 h intra4x4 pred mode h mb2br xy mb xy h mb stride 1 h intra4x4 pred mode cache 6 8 0 h intra4x4 pred mode h mb2br xy mb xy h mb stride 2 h intra4x4 pred mode cache 7 8 0 h intra4x4 pred mode h mb2br xy mb xy h mb stride 3 if h intra4x4 pred mode cache 4 8 0 1 h top samples available 0x33 FF for i 0 i 16 i 2 vlc svq3 get ue golomb h gb if vlc 25 av log h avctx AVLOGERROR luma prediction d n vlc return 1 left h intra4x4 pred mode cache scan8 i 1 top h intra4x4 pred mode cache scan8 i 8 left 1 svq3 pred 1 top 0 1 left 0 1 svq3 pred 0 vlc 0 left 2 svq3 pred 1 top 1 1 left 1 1 svq3 pred 0 vlc 1 if left 1 1 left 2 1 av log h avctx AVLOGERROR weird prediction n return 1 else for i 0 i 4 i memset h intra4x4 pred mode cache scan8 0 8 i DCPRED 4 write back intra pred mode h if mb type 8 ff h264 check intra4x4 pred mode h h top samples available h mb y 0 0x33 FF 0x FFFF h left samples available h mb x 0 0x5 F5 F 0x FFFF else for i 0 i 4 i memset h intra4x4 pred mode cache scan8 0 8 i DC 128 PRED 4 h top samples available 0x33 FF h left samples available 0x5 F5 F mb type MBTYPEINTR A4x4 else dir i mb type info mb type 8 pred mode dir dir 1 3 dir 1 1 if h intra16x16 pred mode ff h264 check intra pred mode h dir 0 1 av log h avctx AVLOGERROR check intra pred mode 1 n return 1 cbp i mb type info mb type 8 cbp mb type MBTYPEINTR A16x16 if ISINTER mb type h pict type AVPICTURETYPEI for i 0 i 4 i memset h cur pic f motion val 0 b xy i h b stride 0 4 2 sizeof int16 t if h pict type AVPICTURETYPEB for i 0 i 4 i memset h cur pic f motion val 1 b xy i h b stride 0 4 2 sizeof int16 t if ISINTR A4x4 mb type memset h intra4x4 pred mode h mb2br xy mb xy DCPRED 8 if ISSKIP mb type h pict type AVPICTURETYPEB memset h non zero count cache 8 0 14 8 sizeof uint8 t h dsp clear blocks h mb 0 h dsp clear blocks h mb 384 if ISINTR A16x16 mb type ISSKIP mb type h pict type AVPICTURETYPEB if vlc svq3 get ue golomb h gb 48 av log h avctx AVLOGERROR cbp vlc d n vlc return 1 cbp ISINTRA mb type golomb to intra4x4 cbp vlc golomb to inter cbp vlc if ISINTR A16x16 mb type h pict type AVPICTURETYPEI s adaptive quant cbp h qscale svq3 get se golomb h gb if h qscale 31u av log h avctx AVLOGERROR qscale d n h qscale return 1 if ISINTR A16x16 mb type AVZER O128 h mb luma dc 0 0 AVZER O128 h mb luma dc 0 8 if svq3 decode block h gb h mb luma dc 0 0 1 av log h avctx AVLOGERROR error while decoding intra luma dc n return 1 if cbp const int index ISINTR A16x16 mb type 1 0 const int type h qscale 24 ISINTR A4x4 mb type 2 1 for i 0 i 4 i if cbp 1 i for j 0 j 4 j k index 1 j 1 2 i 1 2 j 2 4 i 2 4 i j h non zero count cache scan8 k 1 if svq3 decode block h gb h mb 16 k index type av log h avctx AVLOGERROR error while decoding block n return 1 if cbp 0x30 for i 1 i 3 i if svq3 decode block h gb h mb 16 16 i 0 3 av log h avctx AVLOGERROR error while decoding chroma dc block n return 1 if cbp 0x20 for i 1 i 3 i for j 0 j 4 j k 16 i j h non zero count cache scan8 k 1 if svq3 decode block h gb h mb 16 k 1 1 av log h avctx AVLOGERROR error while decoding chroma ac block n return 1 h cbp cbp h cur pic f mb type mb xy mb type if ISINTRA mb type h chroma pred mode ff h264 check intra pred mode h DCPRE D8x8 1 return 0 static int mss2 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S2 Context ctx avctx priv data MS S12 Context c ctx c Get Bit Context gb Get Byte Context g B Arith Coder acoder int keyframe has wmv9 has mv is rle is 555 ret Rectangle wmv9rects MAXWM V9 RECTANGLES r int used rects 0 i implicit rect 0 av uninit wmv9 mask av assert0 FFINPUTBUFFERPADDINGSIZEARIT H2 PADDINGMINCACHEBITS 7 8 init get bits gb buf buf size 8 if keyframe get bits1 gb skip bits gb 7 has wmv9 get bits1 gb has mv keyframe 0 get bits1 gb is rle get bits1 gb is 555 is rle get bits1 gb if c slice split 0 ctx split position c slice split else if c slice split 0 if get bits1 gb if get bits1 gb if get bits1 gb ctx split position get bits gb 16 else ctx split position get bits gb 12 else ctx split position get bits gb 8 4 else if keyframe ctx split position avctx height 2 else ctx split position avctx height if c slice split ctx split position 1 is 555 ctx split position avctx height 1 return AVERRORINVALIDDATA align get bits gb buf get bits count gb 3 buf size get bits count gb 3 if buf size 1 return AVERRORINVALIDDATA if is 555 has wmv9 has mv c slice split ctx split position return AVERRORINVALIDDATA avctx pix fmt is 555 AVPIXFMTRG B555 AVPIXFMTRG B24 if ctx pic data 0 ctx pic format avctx pix fmt avctx release buffer avctx ctx pic if has wmv9 bytestream2 init g B buf buf size ARIT H2 PADDING arith2 init acoder g B implicit rect arith2 get bit acoder while arith2 get bit acoder if used rects MAXWM V9 RECTANGLES return AVERRORINVALIDDATA r wmv9rects used rects if used rects r x arith2 get number acoder avctx width else r x arith2 get number acoder avctx width wmv9rects used rects 1 x wmv9rects used rects 1 x r y arith2 get number acoder avctx height r w arith2 get number acoder avctx width r x 1 r h arith2 get number acoder avctx height r y 1 used rects if implicit rect used rects av log avctx AVLOGERROR implicit rect used rects 0 n return AVERRORINVALIDDATA if implicit rect wmv9rects 0 x 0 wmv9rects 0 y 0 wmv9rects 0 w avctx width wmv9rects 0 h avctx height used rects 1 for i 0 i used rects i if implicit rect arith2 get bit acoder av log avctx AVLOGERROR Unexpected grandchildren n return AVERRORINVALIDDATA if i wmv9 mask arith2 get bit acoder 1 if wmv9 mask wmv9 mask arith2 get number acoder 256 wmv9rects i coded arith2 get number acoder 2 buf arith2 get consumed bytes acoder buf size arith2 get consumed bytes acoder if buf size 1 return AVERRORINVALIDDATA c mv X c mv Y 0 if keyframe is 555 if i decode pal v2 c buf buf size 0 return AVERRORINVALIDDATA buf i buf size i else if has mv buf 4 buf size 4 if buf size 1 return AVERRORINVALIDDATA c mv XAVR B16 buf 4 avctx width c mv YAVR B16 buf 2 avctx height if c mv X 0 c mv Y 0 FFSWAPAV Frame ctx pic ctx last pic FFSWAP uint8 t c pal pic c last pal pic if ctx pic data 0 avctx release buffer avctx ctx pic ctx pic reference 3 ctx pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSREADABLEFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret ff get buffer avctx ctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret if ctx last pic data 0 av assert0 ctx pic linesize 0 ctx last pic linesize 0 c last rgb pic ctx last pic data 0 ctx last pic linesize 0 avctx height 1 else av log avctx AVLOGERROR Missing keyframe n return AVERRORINVALIDDATA else if ctx last pic data 0 avctx release buffer avctx ctx last pic ctx pic reference 3 ctx pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSREADABLEFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx ctx pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c last rgb pic NULL c rgb pic ctx pic data 0 ctx pic linesize 0 avctx height 1 c rgb stride ctx pic linesize 0 ctx pic key frame keyframe ctx pic pict type keyframe AVPICTURETYPEIAVPICTURETYPEP if is 555 bytestream2 init g B buf buf size if decode 555 g B uint16 t c rgb pic c rgb stride 1 keyframe avctx width avctx height return AVERRORINVALIDDATA buf size bytestream2 tell g B else if keyframe c corrupted 0 ff mss12 slicecontext reset ctx sc 0 if c slice split ff mss12 slicecontext reset ctx sc 1 if is rle init get bits gb buf buf size 8 if ret decode rle gb c pal pic c pal stride c rgb pic c rgb stride c pal keyframe ctx split position 0 avctx width avctx height return ret align get bits gb if c slice split if ret decode rle gb c pal pic c pal stride c rgb pic c rgb stride c pal keyframe ctx split position 1 avctx width avctx height return ret align get bits gb buf get bits count gb 3 buf size get bits count gb 3 else if implicit rect wmv9 mask 1 if c corrupted return AVERRORINVALIDDATA bytestream2 init g B buf buf size ARIT H2 PADDING arith2 init acoder g B c keyframe keyframe if c corrupted ff mss12 decode rect ctx sc 0 acoder 0 0 avctx width ctx split position return AVERRORINVALIDDATA buf arith2 get consumed bytes acoder buf size arith2 get consumed bytes acoder if c slice split if buf size 1 return AVERRORINVALIDDATA bytestream2 init g B buf buf size ARIT H2 PADDING arith2 init acoder g B if c corrupted ff mss12 decode rect ctx sc 1 acoder 0 ctx split position avctx width avctx height ctx split position return AVERRORINVALIDDATA buf arith2 get consumed bytes acoder buf size arith2 get consumed bytes acoder else memset c pal pic 0 c pal stride avctx height if has wmv9 for i 0 i used rects i int x wmv9rects i x int y wmv9rects i y int w wmv9rects i w int h wmv9rects i h if wmv9rects i coded int WM V9coded Frame Size if buf size 4 WM V9coded Frame Size AVR L24 buf return AVERRORINVALIDDATA if ret decode wmv9 avctx buf 3 buf size 3 x y w h wmv9 mask return ret buf WM V9coded Frame Size 3 buf size WM V9coded Frame Size 3 else uint8 t dst c rgb pic y c rgb stride x 3 if wmv9 mask 1 ctx dsp mss2 gray fill masked dst c rgb stride wmv9 mask c pal pic y c pal stride x c pal stride w h else do memset dst 0x80 w 3 dst c rgb stride while h if buf size av log avctx AVLOGWARNING buffer not fully consumed n got frame 1 AV Frame data ctx pic return avpkt size static double var eq const Variable Stat Data vardata Oid operator Datum constval bool constisnull bool varonleft double selec bool isdefault Oid opfuncoid if constisnull return 0 0 if vardata isunique vardata rel vardata rel tuples 1 0 return 1 0 vardata rel tuples if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opfuncoid get opcode operator Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers bool match false int i stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDMCV Invalid Oid NULL values nvalues numbers nnumbers Fmgr Info eqproc fmgr info opfuncoid eqproc for i 0 i nvalues i if varonleft match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values i constval else match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID constval values i if match break else values NULL numbers NULL i nvalues nnumbers 0 if match selec numbers i else double sumcommon 0 0 double otherdistinct for i 0 i nnumbers i sumcommon numbers i selec 1 0 sumcommon stats stanullfrac CLAMPPROBABILITY selec otherdistinct get variable numdistinct vardata isdefault nnumbers if otherdistinct 1 selec otherdistinct if nnumbers 0 selec numbers nnumbers 1 selec numbers nnumbers 1 free attstatsslot vardata atttype values nvalues numbers nnumbers else selec 1 0 get variable numdistinct vardata isdefault CLAMPPROBABILITY selec return selec int ff alloc picture Mpeg Enc Context s Picture pic int shared const int big mb num s mb stride s mb height 1 1 const int mb array size s mb stride s mb height const int b8 array size s b8 stride s mb height 2 const int b4 array size s b4 stride s mb height 4 int i int r 1 if shared assert pic f data 0 assert pic f type 0 pic f type FFBUFFERTYPESHARED pic f type FFBUFFERTYPESHARED else assert pic f data 0 if alloc frame buffer s pic 0 return 1 s linesize pic f linesize 0 s uvlinesize pic f linesize 1 if pic f qscale table NULL if s encoding FFALLOCZORGOTO s avctx pic mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mc mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mb mean mb array size sizeof int8 t fail FFALLOCZORGOTO s avctx pic f mbskip table mb array size sizeof uint8 t 2 fail FFALLOCZORGOTO s avctx pic qscale table base big mb num s mb stride sizeof uint8 t fail FFALLOCZORGOTO s avctx pic mb type base big mb num s mb stride sizeof uint32 t fail pic f mb type pic mb type base 2 s mb stride 1 pic f qscale table pic qscale table base 2 s mb stride 1 if s out format FMT H264 for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b4 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 2 else if s out format FMT H263 s encoding s avctx debug FFDEBUGMV s avctx debug mv for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b8 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 3 if s avctx debug FFDEBUGDCTCOEFFFFALLOCZORGOTO s avctx pic f dct coeff 64 mb array size sizeof int16 t 6 fail pic f qstride s mb stride FFALLOCZORGOTO s avctx pic f pan scan 1 sizeof AV Pan Scan fail pic owner2 s return 0 fail if r 0 free frame buffer s pic return 1 void vp9 choose segmap coding method V P9 COMMON cm MACROBLOCKD xd struct segmentation seg cm seg int no pred cost int t pred cost INTMAX int i tile col mi row mi col int temporal predictor count PREDICTIONPROBS 2 0 int no pred segcounts MAXSEGMENTS 0 int t unpred seg counts MAXSEGMENTS 0 vp9 prob no pred tree SEGTREEPROBS vp9 prob t pred tree SEGTREEPROBS vp9 prob t nopred prob PREDICTIONPROBS vpx memset seg tree probs 255 sizeof seg tree probs vpx memset seg pred probs 255 sizeof seg pred probs for tile col 0 tile col 1 cm log2 tile cols tile col Tile Info tile MODEINFO mi ptr vp9 tile init tile cm 0 tile col mi ptr cm mi grid visible tile mi col start for mi row 0 mi row cm mi rows mi row 8 mi ptr 8 cm mi stride MODEINFO mi mi ptr for mi col tile mi col start mi col tile mi col end mi col 8 mi 8 count segs sb cm xd tile mi no pred segcounts temporal predictor count t unpred seg counts mi row mi col BLOCK 64 X64 calc segtree probs no pred segcounts no pred tree no pred cost cost segmap no pred segcounts no pred tree if frame is intra only cm calc segtree probs t unpred seg counts t pred tree t pred cost cost segmap t unpred seg counts t pred tree for i 0 i PREDICTIONPROBS i const int count0 temporal predictor count i 0 const int count1 temporal predictor count i 1 t nopred prob i get binary prob count0 count1 t pred cost count0 vp9 cost zero t nopred prob i count1 vp9 cost one t nopred prob i if t pred cost no pred cost seg temporal update 1 vpx memcpy seg tree probs t pred tree sizeof t pred tree vpx memcpy seg pred probs t nopred prob sizeof t nopred prob else seg temporal update 0 vpx memcpy seg tree probs no pred tree sizeof no pred tree static int skip check Mpeg Enc Context s Picture p Picture ref int x y plane int score 0 int64 t score64 0 for plane 0 plane 3 plane const int stride p f linesize plane const int bw plane 1 2 for y 0 y s mb height bw y for x 0 x s mb width bw x int off p f type FFBUFFERTYPESHARED 0 16 uint8 t dptr p f data plane 8 x y stride off uint8 t rptr ref f data plane 8 x y stride int v s dsp frame skip cmp 1 s dptr rptr stride 8 switch s avctx frame skip exp case 0 score FFMAX score v break case 1 score FFABS v break case 2 score v v break case 3 score64 FFABS v v int64 t v break case 4 score64 v v int64 t v v break if score score64 score if score64 s avctx frame skip threshold return 1 if score64 s avctx frame skip factor int64 t s lambda 8 return 1 return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Jv Context s avctx priv data int buf size avpkt size const uint8 t buf avpkt data const uint8 t buf end buf buf size int video size video type i j video size AVR L32 buf video type buf 4 buf 5 if video size if avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return 1 if video type 0 video type 1 Get Bit Context gb init get bits gb buf 8 FFMIN video size buf end buf for j 0 j avctx height j 8 for i 0 i avctx width i 8 decode8x8 gb s frame data 0 j s frame linesize 0 i s frame linesize 0 s dsp buf video size else if video type 2 if buf 1 buf end int v buf for j 0 j avctx height j memset s frame data 0 j s frame linesize 0 v avctx width else av log avctx AVLOGWARNING unsupported frame type i n video type return AVERRORINVALIDDATA if buf buf end for i 0 i AVPALETTECOUNT buf 3 buf end i s palette i AVR B24 buf 2 buf 3 s palette has changed 1 if video size s frame key frame 1 s frame pict type AVPICTURETYPEI s frame palette has changed s palette has changed s palette has changed 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size static enum fetch step vbf stp error struct worker wrk struct busyobj bo ssize t l ll o double now uint8 t ptr struct vsb synth body CHECKOBJNOTNULL wrk WORKERMAGICCHECKOBJNOTNULL bo BUSYOBJMAGICCHECKOBJNOTNULL bo fetch objcore OBJCOREMAGICAN bo fetch objcore flags OCFBUSY assert bo director state DIRSNULL wrk stats fetch failed now WTIM real wrk VS Lb ts busyobj bo Error now if bo fetch objcore stobj stevedore NULL Obj Free Obj bo wrk bo fetch objcore HTTP Setup bo beresp bo ws bo vsl SLT Beresp Method http Put Response bo beresp HTTP 1 1 503 Backend fetch failed http Time Header bo beresp Date now http Set Header bo beresp Server Varnish bo fetch objcore t origin now if VTAILQEMPTY bo fetch objcore objhead waitinglist bo fetch objcore ttl 1 bo fetch objcore grace 5 bo fetch objcore keep 5 else bo fetch objcore ttl 0 bo fetch objcore grace 0 bo fetch objcore keep 0 synth body VSB new auto AN synth body VCL backend error method bo vcl wrk NULL bo synth body AZVSB finish synth body if wrk handling VCLRETABANDON wrk handling VCLRETFAILVSB destroy synth body return FSTPFAIL if wrk handling VCLRETRETRYVSB destroy synth body if bo retries cache param max retries return FSTPRETRYVS Lb bo vsl SLTVCL Error Too many retries failing return FSTPFAIL assert wrk handling VCLRETDELIVER bo vfc bo bo bo vfc wrk bo wrk bo vfc oc bo fetch objcore bo vfc http bo beresp bo vfc esi req bo bereq if vbf beresp2obj bo void VFP Error bo vfc Could not get storage VSB destroy synth body return FSTPFAIL ll VSB len synth body o 0 while ll 0 l ll if VFP Get Storage bo vfc l ptr VFPOK break if l ll l ll memcpy ptr VSB data synth body o l VFP Extend bo vfc l ll l o l AZ Obj Set U64 wrk bo fetch objcore OALEN o VSB destroy synth body HSH Unbusy wrk bo fetch objcore Obj Set State wrk bo fetch objcore BOSFINISHED return static void find mv refs idx const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int block int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const MODEINFO prev mi cm error resilient mode cm prev mi cm prev mi grid visible mi row xd mi stride mi col NULL const MBMODEINFO const prev mbmi prev mi prev mi mbmi NULL const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col block else if candidate ref frame 1 ref frame ADDMVREFLIST get sub block mv candidate mi 1 mv ref col block for i MVREFNEIGHBOURS i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 else if candidate ref frame 1 ref frame ADDMVREFLIST candidate mv 1 if prev mbmi if prev mbmi ref frame 0 ref frame ADDMVREFLIST prev mbmi mv 0 else if prev mbmi ref frame 1 ref frame ADDMVREFLIST prev mbmi mv 1 if different ref found for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate if prev mbmi IFDIFFREFFRAMEADDMV prev mbmi Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd void vp9 encode sb MACROBLOCK x BLOCKSIZE bsize MACROBLOCKD const xd x e mbd struct optimize ctx ctx MBMODEINFO mbmi xd mi 0 src mi mbmi struct encode b args arg x ctx mbmi skip int plane mbmi skip 1 if x skip return for plane 0 plane MAXMBPLANE plane if x skip recode vp9 subtract plane x bsize plane if x optimize x skip recode x skip optimize const struct macroblockd plane const pd xd plane plane const TXSIZE tx size plane get uv tx size mbmi pd mbmi tx size vp9 get entropy contexts bsize tx size pd ctx ta plane ctx tl plane vp9 foreach transformed block in plane xd bsize plane encode block arg int ff generate sliding window mmcos H264 Context h int first slice MMCO mmco temp MAXMMCOCOUNT mmco first slice h mmco mmco temp int mmco index 0 i assert h long ref count h short ref count h sps ref frame count if h short ref count h long ref count h short ref count h sps ref frame count FIELDPICTURE h first field h cur pic ptr f reference mmco 0 opcode MMCOSHOR T2 UNUSED mmco 0 short pic num h short ref h short ref count 1 frame num mmco index 1 if FIELDPICTURE mmco 0 short pic num 2 mmco 1 opcode MMCOSHOR T2 UNUSED mmco 1 short pic num mmco 0 short pic num 1 mmco index 2 if first slice h mmco index mmco index else if first slice mmco index 0 mmco index h mmco index i check opcodes h mmco mmco temp mmco index av log h avctx AVLOGERROR Inconsistent MMCO state between slices d d d n mmco index h mmco index i return AVERRORINVALIDDATA return 0 static void pk transaction authorize actions finished cb G Object source object G Async Result res struct Authorize Actions Data data const gchar action id NULL Pk Transaction Private priv data transaction priv g autoptr G Error error NULL g autoptr Polkit Authorization Result result NULL g assert data actions data actions len 0 action id g ptr array index data actions 0 result polkit authority check authorization finish priv authority res error if g cancellable is cancelled priv cancellable priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED The authentication was cancelled due to a timeout pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if result NULL g autofree gchar message NULL priv waiting for auth FALSE g warning failed to check for auth s error message pk transaction status changed emit data transaction PKSTATUSENUMFINISHED message g strdup printf Failed to check for authentication s error message pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED message pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if polkit authorization result get is authorized result if g strcmp0 action id org freedesktop packagekit package install 0 pk bitfield contain priv cached transaction flags PKTRANSACTIONFLAGENUMALLOWREINSTALL g debug allowing just reinstallation pk bitfield add priv cached transaction flags PKTRANSACTIONFLAGENUMJUSTREINSTALL else priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED Failed to obtain authentication pk transaction finished emit data transaction PKEXITENUMFAILED 0 syslog LOGAUTHLOGNOTICE uid i failed to obtain auth priv uid goto out if data actions len 1 priv waiting for auth FALSE pk transaction set state data transaction PKTRANSACTIONSTATEREADY syslog LOGAUTHLOGINFO uid i obtained auth for s priv uid action id else g ptr array remove index data actions 0 pk transaction authorize actions data transaction data role data actions out g ptr array unref data actions g free data static int vcr1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size VC R1 Context const a avctx priv data AV Frame picture data AV Frame const p a picture const uint8 t bytestream buf int i x y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 for i 0 i 16 i a delta i bytestream bytestream for y 0 y avctx height y int offset uint8 t luma a picture data 0 y a picture linesize 0 if y 3 0 uint8 t cb a picture data 1 y 2 a picture linesize 1 uint8 t cr a picture data 2 y 2 a picture linesize 2 for i 0 i 4 i a offset i bytestream offset a offset 0 a delta bytestream 2 0x F for x 0 x avctx width x 4 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 0 0x F luma 3 offset a delta bytestream 0 4 luma 4 cb bytestream 3 cr bytestream 1 bytestream 4 else offset a offset y 3 a delta bytestream 2 0x F for x 0 x avctx width x 8 luma 0 offset a delta bytestream 2 0x F luma 1 offset a delta bytestream 2 4 luma 2 offset a delta bytestream 3 0x F luma 3 offset a delta bytestream 3 4 luma 4 offset a delta bytestream 0 0x F luma 5 offset a delta bytestream 0 4 luma 6 offset a delta bytestream 1 0x F luma 7 offset a delta bytestream 1 4 luma 8 bytestream 4 picture a picture got frame 1 return buf size static inline void vc1 pred mv V C1 Context v int n int dmv x int dmv y int mv1 int r x int r y uint8 t is intra int pred flag int dir Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int mixedmv pic num samefield 0 num oppfield 0 int opposite a f b f c f int16 t field pred A 2 int16 t field pred B 2 int16 t field pred C 2 int a valid b valid c valid int hybridmv thresh y bias 0 if v mv mode MVPMODEMIXEDMV v mv mode MVPMODEINTENSITYCOMP v mv mode2 MVPMODEMIXEDMV mixedmv pic 1 else mixedmv pic 0 dmv x 1 s quarter sample dmv y 1 s quarter sample wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture f motion val 0 xy v blocks off 0 0 s mv 0 n 1 s current picture f motion val 0 xy v blocks off 1 0 s current picture f motion val 1 xy v blocks off 0 0 s current picture f motion val 1 xy v blocks off 1 0 if mv1 s current picture f motion val 0 xy 1 v blocks off 0 0 s current picture f motion val 0 xy 1 v blocks off 1 0 s current picture f motion val 0 xy wrap v blocks off 0 0 s current picture f motion val 0 xy wrap v blocks off 1 0 s current picture f motion val 0 xy wrap 1 v blocks off 0 0 s current picture f motion val 0 xy wrap 1 v blocks off 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture f motion val 1 xy 1 v blocks off 0 0 s current picture f motion val 1 xy 1 v blocks off 1 0 s current picture f motion val 1 xy wrap 0 0 s current picture f motion val 1 xy wrap v blocks off 1 0 s current picture f motion val 1 xy wrap 1 v blocks off 0 0 s current picture f motion val 1 xy wrap 1 v blocks off 1 0 return C s current picture f motion val dir xy 1 v blocks off A s current picture f motion val dir xy wrap v blocks off if mv1 if v field mode mixedmv pic off s mb x s mb width 1 2 2 else off s mb x s mb width 1 1 2 else switch n case 0 off s mb x 0 1 1 break case 1 off s mb x s mb width 1 1 1 break case 2 off 1 break case 3 off 1 B s current picture f motion val dir xy wrap off v blocks off a valid s first slice line n 2 n 3 b valid a valid s mb width 1 c valid s mb x n 1 n 3 if v field mode a valid a valid is intra xy wrap b valid b valid is intra xy wrap off c valid c valid is intra xy 1 if a valid a f v mv f dir xy wrap v blocks off num oppfield a f num samefield 1 a f field pred A 0 A 0 field pred A 1 A 1 else field pred A 0 field pred A 1 0 a f 0 if b valid b f v mv f dir xy wrap off v blocks off num oppfield b f num samefield 1 b f field pred B 0 B 0 field pred B 1 B 1 else field pred B 0 field pred B 1 0 b f 0 if c valid c f v mv f dir xy 1 v blocks off num oppfield c f num samefield 1 c f field pred C 0 C 0 field pred C 1 C 1 else field pred C 0 field pred C 1 0 c f 0 if v field mode if v numref opposite 1 v reffield else if num samefield num oppfield opposite 1 pred flag else opposite pred flag else opposite 0 if opposite if a valid a f field pred A 0 scaleforopp v field pred A 0 0 dir field pred A 1 scaleforopp v field pred A 1 1 dir if b valid b f field pred B 0 scaleforopp v field pred B 0 0 dir field pred B 1 scaleforopp v field pred B 1 1 dir if c valid c f field pred C 0 scaleforopp v field pred C 0 0 dir field pred C 1 scaleforopp v field pred C 1 1 dir v mv f dir xy v blocks off 1 v ref field type dir v cur field type else if a valid a f field pred A 0 scaleforsame v n field pred A 0 0 dir field pred A 1 scaleforsame v n field pred A 1 1 dir if b valid b f field pred B 0 scaleforsame v n field pred B 0 0 dir field pred B 1 scaleforsame v n field pred B 1 1 dir if c valid c f field pred C 0 scaleforsame v n field pred C 0 0 dir field pred C 1 scaleforsame v n field pred C 1 1 dir v mv f dir xy v blocks off 0 v ref field type dir v cur field type if a valid px field pred A 0 py field pred A 1 else if c valid px field pred C 0 py field pred C 1 else if b valid px field pred B 0 py field pred B 1 else px 0 py 0 if num samefield num oppfield 1 px mid pred field pred A 0 field pred B 0 field pred C 0 py mid pred field pred A 1 field pred B 1 field pred C 1 if v field mode int qx qy XY qx s mb x 6 n 1 n 3 32 0 qy s mb y 6 n 2 n 3 32 0 X s mb width 6 4 Y s mb height 6 4 if mv1 if qx px 60 px 60 qx if qy py 60 py 60 qy else if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy if v field mode s pict type AVPICTURETYPEB hybridmv thresh 32 if a valid c valid if is intra xy wrap sum FFABS px FFABS py else sum FFABS px field pred A 0 FFABS py field pred A 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 else if is intra xy 1 sum FFABS px FFABS py else sum FFABS px field pred C 0 FFABS py field pred C 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 if v field mode v numref r y 1 if v field mode v cur field type v ref field type dir 0 y bias 1 s mv dir n 0 s current picture f motion val dir xy v blocks off 0 px dmv x r x r x 1 1 r x s mv dir n 1 s current picture f motion val dir xy v blocks off 1 py dmv y r y y bias r y 1 1 r y y bias if mv1 s current picture f motion val dir xy 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 v mv f dir xy 1 v blocks off v mv f dir xy v blocks off v mv f dir xy wrap v blocks off v mv f dir xy wrap 1 v blocks off v mv f dir xy v blocks off static void dist block int plane int block TXSIZE tx size struct rdcost block args args const int ss txfrm size tx size 1 MACROBLOCK const x args x MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane int64 t this sse int shift tx size TX 32 X32 0 2 tran low t const coeff BLOCKOFFSET p coeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block args dist vp9 block error coeff dqcoeff 16 ss txfrm size this sse shift args sse this sse shift if x skip encode is inter block xd mi 0 src mi mbmi int64 t p pd dequant 1 pd dequant 1 1 ss txfrm size shift 2 args dist p 4 args sse p const char vpx svc dump statistics Svc Context svc ctx int number of frames encode frame count int i j uint32 t bytes total 0 double scale COMPONENTS double psnr COMPONENTS double mse COMPONENTS double y scale Svc Internal const si get svc internal svc ctx if svc ctx NULL si NULL return NULL svc log reset svc ctx encode frame count si encode frame count if si encode frame count 0 return vpx svc get message svc ctx svc log svc ctx SVCLOGINFO n for i 0 i si layers i number of frames encode frame count svc log svc ctx SVCLOGINFO Layer d Average PSNR 2 3f 2 3f 2 3f 2 3f Bytes u n i double si psnr sum i 0 number of frames double si psnr sum i 1 number of frames double si psnr sum i 2 number of frames double si psnr sum i 3 number of frames si bytes sum i y scale si width si height 255 0 255 0 number of frames scale 1 y scale scale 2 scale 3 y scale 4 scale 0 y scale 1 5 for j 0 j COMPONENTS j psnr j calc psnr si sse sum i j scale j mse j si sse sum i j 255 0 255 0 scale j svc log svc ctx SVCLOGINFO Layer d Overall PSNR 2 3f 2 3f 2 3f 2 3f n i psnr 0 psnr 1 psnr 2 psnr 3 svc log svc ctx SVCLOGINFO Layer d Overall MSE 2 3f 2 3f 2 3f 2 3f n i mse 0 mse 1 mse 2 mse 3 bytes total si bytes sum i si bytes sum i 0 for j 0 j COMPONENTS j si psnr sum i j 0 si sse sum i j 0 si encode frame count 0 svc log svc ctx SVCLOGINFO Total Bytes u n bytes total return vpx svc get message svc ctx void vp9 loop filter frame mt Y V12 BUFFERCONFIG frame V P9 Decoder pbi V P9 COMMON cm int frame filter level int y only V P9 Lf Sync const lf sync pbi lf row sync const V P9 Worker Interface const winterface vp9 get worker interface const int sb rows mi cols aligned to sb cm mi rows MIBLOCKSIZELO G2 const int tile cols 1 cm log2 tile cols const int num workers MIN pbi max threads 1 tile cols int i if frame filter level return if lf sync sync range cm last height cm height vp9 loop filter dealloc lf sync vp9 loop filter alloc lf sync cm sb rows cm width vp9 loop filter frame init cm frame filter level vpx memset lf sync cur sb col 1 sizeof lf sync cur sb col sb rows for i 0 i num workers i V P9 Worker const worker pbi tile workers i Tile Worker Data const tile data Tile Worker Data worker data1 LF Worker Data const lf data tile data lfdata worker hook V P9 Worker Hook loop filter row worker lf data frame buffer frame lf data cm cm vp9 copy lf data planes pbi mb plane lf data start i lf data stop sb rows lf data y only y only lf data lf sync lf sync lf data num lf workers num workers if i num workers 1 winterface execute worker else winterface launch worker for i 0 i num workers i winterface sync pbi tile workers i static void set good speed feature V P9 COMP cpi V P9 COMMON cm SPEEDFEATURES sf int speed const int boosted frame is boosted cpi sf adaptive rd thresh 1 sf allow skip recode 1 if speed 1 sf use square partition only frame is intra only cm sf less rectangular check 1 if MIN cm width cm height 720 sf disable split mask cm show frame DISABLEALLSPLITDISABLEALLINTERSPLIT else sf disable split mask DISABLECOMPOUNDSPLIT sf use rd breakout 1 sf adaptive motion search 1 sf mv auto mv step size 1 sf adaptive rd thresh 2 sf mv subpel iters per step 1 sf mode skip start 10 sf adaptive pred interp filter 1 sf recode loop ALLOWRECODEKFARFGF sf intra y mode mask TX 32 X32 INTRADCHV sf intra uv mode mask TX 32 X32 INTRADCHV sf intra y mode mask TX 16 X16 INTRADCHV sf intra uv mode mask TX 16 X16 INTRADCHV sf tx size search breakout 1 if MIN cm width cm height 720 sf partition search breakout dist thr 1 23 else sf partition search breakout dist thr 1 21 sf partition search breakout rate thr 500 if speed 2 sf tx size search method frame is boosted cpi USEFULLRDUSELARGESTALL if MIN cm width cm height 720 sf lf motion threshold LOWMOTIONTHRESHOLD sf last partitioning redo frequency 3 sf disable split mask cm show frame DISABLEALLSPLITDISABLEALLINTERSPLIT sf adaptive pred interp filter 0 else sf disable split mask LASTANDINTRASPLITONLY sf last partitioning redo frequency 2 sf lf motion threshold NOMOTIONTHRESHOLD sf reference masking 1 sf mode search skip flags FLAGSKIPINTRADIRMISMATCHFLAGSKIPINTRABESTINTERFLAGSKIPCOMPBESTINTRAFLAGSKIPINTRALOWVAR sf disable filter search var thresh 100 sf comp inter joint search thresh BLOCKSIZES sf auto min max partition size CONSTRAINNEIGHBORINGMINMAX sf use lastframe partitioning LASTFRAMEPARTITIONLOWMOTION sf adjust partitioning from last frame 1 if MIN cm width cm height 720 sf partition search breakout dist thr 1 24 else sf partition search breakout dist thr 1 22 sf partition search breakout rate thr 700 if speed 3 sf tx size search method frame is intra only cm USEFULLRDUSELARGESTALL if MIN cm width cm height 720 sf disable split mask DISABLEALLSPLIT else sf max intra bsize BLOCK 32 X32 sf disable split mask DISABLEALLINTERSPLIT sf adaptive pred interp filter 0 sf adaptive mode search 1 sf cb partition search boosted sf cb pred filter search 1 sf alt ref search fp 1 sf motion field mode search boosted sf lf motion threshold LOWMOTIONTHRESHOLD sf last partitioning redo frequency 2 sf recode loop ALLOWRECODEKFMAXBW sf adaptive rd thresh 3 sf mode skip start 6 sf intra y mode mask TX 32 X32 INTRADC sf intra uv mode mask TX 32 X32 INTRADC sf adaptive interp filter search 1 if MIN cm width cm height 720 sf partition search breakout dist thr 1 25 else sf partition search breakout dist thr 1 23 sf partition search breakout rate thr 1000 if speed 4 sf use square partition only 1 sf tx size search method USELARGESTALL sf disable split mask DISABLEALLSPLIT sf adaptive rd thresh 4 sf mode search skip flags FLAGSKIPCOMPREFMISMATCHFLAGEARLYTERMINATE sf disable filter search var thresh 200 sf use lastframe partitioning LASTFRAMEPARTITIONALL sf use lp32x32fdct 1 sf use fast coef updates ONELOOPREDUCED sf use fast coef costing 1 if MIN cm width cm height 720 sf partition search breakout dist thr 1 26 else sf partition search breakout dist thr 1 24 sf partition search breakout rate thr 1500 if speed 5 int i sf partition search type FIXEDPARTITION sf optimize coefficients 0 sf mv search method HEX sf disable filter search var thresh 500 for i 0 i TXSIZES i sf intra y mode mask i INTRADC sf intra uv mode mask i INTRADC cpi allow encode breakout ENCODEBREAKOUTENABLED if speed 6 sf mv reduce first step size 1 static vpx codec err t encoder init vpx codec ctx t ctx vpx codec priv enc mr cfg t data vpx codec err t res VPXCODECOK void data if ctx priv NULL vpx codec alg priv t const priv vpx calloc 1 sizeof priv if priv NULL return VPXCODECMEMERROR ctx priv vpx codec priv t priv ctx priv init flags ctx init flags ctx priv enc total encoders 1 if ctx config enc priv cfg ctx config enc ctx config enc priv cfg priv extra cfg default extra cfg vp9 initialize enc res validate config priv priv cfg priv extra cfg if res VPXCODECOK set encoder config priv oxcf priv cfg priv extra cfg priv cpi vp9 create compressor priv oxcf if priv cpi NULL res VPXCODECMEMERROR else priv cpi output pkt list priv pkt list head return res static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt PNG Dec Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame p data uint8 t crow buf base NULL uint32 t tag length int ret if buf size 8 memcmp buf ff pngsig 8 0 memcmp buf ff mngsig 8 0 return 1 bytestream2 init s gb buf 8 buf size 8 s y s state 0 s zstream zalloc ff png zalloc s zstream zfree ff png zfree s zstream opaque NULL ret inflate Init s zstream if ret ZOK return 1 for if bytestream2 get bytes left s gb 0 goto fail length bytestream2 get be32 s gb if length 0x7fffffff goto fail tag bytestream2 get le32 s gb av dlog avctx png tag c c c c length u n tag 0xff tag 8 0xff tag 16 0xff tag 24 0xff length switch tag case MKTAGIHDR if length 13 goto fail s width bytestream2 get be32 s gb s height bytestream2 get be32 s gb if av image check size s width s height 0 avctx s width s height 0 goto fail s bit depth bytestream2 get byte s gb s color type bytestream2 get byte s gb s compression type bytestream2 get byte s gb s filter type bytestream2 get byte s gb s interlace type bytestream2 get byte s gb bytestream2 skip s gb 4 s state PNGIHDR av dlog avctx width d height d depth d color type d compression type d filter type d interlace type d n s width s height s bit depth s color type s compression type s filter type s interlace type break case MKTAGIDAT if s state PNGIHDR goto fail if s state PNGIDAT avctx width s width avctx height s height s channels ff png get nb channels s color type s bits per pixel s bit depth s channels s bpp s bits per pixel 7 3 s row size avctx width s bits per pixel 7 3 if s bit depth 8 s color type PNGCOLORTYPERGB avctx pix fmt AVPIXFMTRG B24 else if s bit depth 8 s color type PNGCOLORTYPERGBALPHA avctx pix fmt AVPIXFMTRG B32 else if s bit depth 8 s color type PNGCOLORTYPEGRAY avctx pix fmt AVPIXFMTGRA Y8 else if s bit depth 16 s color type PNGCOLORTYPEGRAY avctx pix fmt AVPIXFMTGRA Y16 BE else if s bit depth 16 s color type PNGCOLORTYPERGB avctx pix fmt AVPIXFMTRG B48 BE else if s bit depth 1 s color type PNGCOLORTYPEGRAY avctx pix fmt AVPIXFMTMONOBLACK else if s bit depth 8 s color type PNGCOLORTYPEPALETTE avctx pix fmt AVPIXFMTPA L8 else if s bit depth 8 s color type PNGCOLORTYPEGRAYALPHA avctx pix fmt AVPIXFMT Y400 A else goto fail if ff get buffer avctx p AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n goto fail p pict type AVPICTURETYPEI p key frame 1 p interlaced frame s interlace type if s interlace type s crow size s row size 1 else s pass 0 s pass row size ff png pass row size s pass s bits per pixel s width s crow size s pass row size 1 av dlog avctx row size d crow size d n s row size s crow size s image buf p data 0 s image linesize p linesize 0 if s color type PNGCOLORTYPEPALETTE memcpy p data 1 s palette 256 sizeof uint32 t s last row av mallocz s row size if s last row goto fail if s interlace type s color type PNGCOLORTYPERGBALPHA s tmp row av malloc s row size if s tmp row goto fail crow buf base av malloc s row size 16 if crow buf base goto fail s crow buf crow buf base 15 s zstream avail out s crow size s zstream next out s crow buf s state PNGIDAT if png decode idat s length 0 goto fail bytestream2 skip s gb 4 break case MKTAGPLTE int n i r g b if length 3 0 length 256 3 goto skip tag n length 3 for i 0 i n i r bytestream2 get byte s gb g bytestream2 get byte s gb b bytestream2 get byte s gb s palette i 0xff 24 r 16 g 8 b for i 256 i s palette i 0xff 24 s state PNGPLTE bytestream2 skip s gb 4 break case MKTAG t RNS int v i if s color type PNGCOLORTYPEPALETTE length 256 s state PNGPLTE goto skip tag for i 0 i length i v bytestream2 get byte s gb s palette i s palette i 0x00ffffff v 24 bytestream2 skip s gb 4 break case MKTAGIEND if s state PNGALLIMAGE goto fail bytestream2 skip s gb 4 goto exit loop default skip tag bytestream2 skip s gb length 4 break exit loop if s prev data 0 if avpkt flags AVPKTFLAGKEY int i j uint8 t pd p data 0 uint8 t pd last s prev data 0 for j 0 j s height j for i 0 i s width s bpp i pd i pd last i pd s image linesize pd last s image linesize av frame unref s prev if ret av frame ref s prev p 0 goto fail got frame 1 ret bytestream2 tell s gb the end inflate End s zstream av free crow buf base s crow buf NULL av freep s last row av freep s tmp row return ret fail ret 1 goto the end static int g722 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt G722 Context c avctx priv data AV Frame frame data int16 t out buf int j ret const int skip 8 c bits per codeword const int16 t quantizer table low inv quants skip Get Bit Context gb frame nb samples avpkt size 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out buf int16 t frame data 0 init get bits gb avpkt data avpkt size 8 for j 0 j avpkt size j int ilow ihigh rlow rhigh dhigh int xout1 xout2 ihigh get bits gb 2 ilow get bits gb 6 skip skip bits gb skip rlow av clip c band 0 scale factor quantizer table ilow 10 c band 0 s predictor 16384 16383 ff g722 update low predictor c band 0 ilow 2 skip dhigh c band 1 scale factor ff g722 high inv quant ihigh 10 rhigh av clip dhigh c band 1 s predictor 16384 16383 ff g722 update high predictor c band 1 dhigh ihigh c prev samples c prev samples pos rlow rhigh c prev samples c prev samples pos rlow rhigh ff g722 apply qmf c prev samples c prev samples pos 24 xout1 xout2 out buf av clip int16 xout1 11 out buf av clip int16 xout2 11 if c prev samples pos PREVSAMPLESBUFSIZE memmove c prev samples c prev samples c prev samples pos 22 22 sizeof c prev samples 0 c prev samples pos 22 got frame ptr 1 return avpkt size static int proc connectinfo struct usb dev state ps void user arg struct usbdevfs connectinfo ci devnum ps dev devnum slow ps dev speed USBSPEEDLOW if copy to user arg ci sizeof ci return EFAULT return 0 int main int argc char argv using std string if argc 2 fprintf stderr One argument the input filename must be provided n return 1 string filename argv 1 string outfilename filename substr 0 filename find last of woff2 fprintf stdout Processing s s n filename c str outfilename c str string input woff2 Get File Content filename const uint8 t input data reinterpret cast const uint8 t input data size t output size woff2 Max WOF F2 Compressed Size input data input size string output output size 0 uint8 t output data reinterpret cast uint8 t output 0 woff2 WOF F2 Params params if woff2 Convert TTF To WOF F2 input data input size output data output size params fprintf stderr Compression failed n return 1 output resize output size woff2 Set File Contents outfilename output begin output end return 0 static double eqjoinsel semi Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 Rel Opt Info inner rel double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid Oid Is Valid operator get opcode operator Invalid Oid if vardata2 rel nd2 Min nd2 vardata2 rel rows nd2 Min nd2 inner rel rows if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Oid Is Valid operator Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double matchfreq1 uncertainfrac uncertain int i nmatches clamped nvalues2 clamped nvalues2 Min nvalues2 nd2 fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 clamped nvalues2 sizeof bool nmatches 0 for i 0 i nvalues1 i int j for j 0 j clamped nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true nmatches break matchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 pfree hasmatch1 pfree hasmatch2 if isdefault1 isdefault2 nd1 nmatches nd2 nmatches if nd1 nd2 nd2 0 uncertainfrac 1 0 else uncertainfrac nd2 nd1 else uncertainfrac 0 5 uncertain 1 0 matchfreq1 nullfrac1 CLAMPPROBABILITY uncertain selec matchfreq1 uncertainfrac uncertain else double nullfrac1 stats1 stats1 stanullfrac 0 0 if isdefault1 isdefault2 if nd1 nd2 nd2 0 selec 1 0 nullfrac1 else selec nd2 nd1 1 0 nullfrac1 else selec 0 5 1 0 nullfrac1 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static int decode tag AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Nelly Moser Decode Context s avctx priv data int blocks i ret float samples flt blocks buf size NELLYBLOCKLEN if blocks 0 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if buf size NELLYBLOCKLEN av log avctx AVLOGWARNING Leftover bytes d n buf size NELLYBLOCKLEN frame nb samples NELLYSAMPLES blocks if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples flt float frame data 0 for i 0 i blocks i nelly decode block s buf samples flt samples flt NELLYSAMPLES buf NELLYBLOCKLEN got frame ptr 1 return buf size int vp9 receive raw frame V P9 COMP cpi unsigned int frame flags Y V12 BUFFERCONFIG sd int64 t time stamp int64 t end time V P9 COMMON cm cpi common struct vpx usec timer timer int res 0 const int subsampling x sd uv width sd y width const int subsampling y sd uv height sd y height check initial width cpi subsampling x subsampling y vpx usec timer start timer else endif res vp9 lookahead push cpi lookahead sd time stamp end time frame flags if res res 1 vpx usec timer mark timer cpi time receive data vpx usec timer elapsed timer if cm profile PROFILE 0 cm profile PROFILE 2 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM Non 4 2 0 color space requires profile 1 or 3 res 1 if cm profile PROFILE 1 cm profile PROFILE 3 subsampling x 1 subsampling y 1 vpx internal error cm error VPXCODECINVALIDPARAM 4 2 0 color space requires profile 0 or 2 res 1 return res static void examine simple variable Planner Info root Var var Variable Stat Data vardata Range Tbl Entry rte root simple rte array var varno Assert Is A rte Range Tbl Entry if get relation stats hook get relation stats hook root rte var varattno vardata if Heap Tuple Is Valid vardata stats Tuple vardata freefunc elog ERROR no function provided to release variable stats with else if rte rtekind RTERELATION vardata stats Tuple Search Sys Cache3 STATRELATTINH Object Id Get Datum rte relid Int16 Get Datum var varattno Bool Get Datum rte inh vardata freefunc Release Sys Cache if Heap Tuple Is Valid vardata stats Tuple vardata acl ok pg class aclcheck rte relid Get User Id ACLSELECTACLCHECKOK pg attribute aclcheck rte relid var varattno Get User Id ACLSELECTACLCHECKOK else vardata acl ok true else if rte rtekind RTESUBQUERY rte inh Query subquery rte subquery Rel Opt Info rel Target Entry ste if var varattno Invalid Attr Number return if subquery set Operations subquery group Clause return rel find base rel root var varno if rel subroot NULL return Assert Is A rel subroot Planner Info subquery rel subroot parse Assert Is A subquery Query ste get tle by resno subquery target List var varattno if ste NULL ste resjunk elog ERROR subquery s does not have attribute d rte eref aliasname var varattno var Var ste expr if subquery distinct Clause if list length subquery distinct Clause 1 target Is In Sort List ste Invalid Oid subquery distinct Clause vardata isunique true return if rte security barrier return if var Is A var Var var varlevelsup 0 examine simple variable rel subroot var vardata else static vpx codec err t ctrl set noise sensitivity vpx codec alg priv t ctx va list args struct vp9 extracfg extra cfg ctx extra cfg extra cfg noise sensitivity CASTV P8 ESETNOISESENSITIVITY args return update extra cfg ctx extra cfg static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size C93 Decoder Context const c93 avctx priv data AV Frame const newpic c93 pictures c93 currentpic AV Frame const oldpic c93 pictures c93 currentpic 1 AV Frame picture data Get Byte Context gb uint8 t out int stride ret i x y b bt 0 c93 currentpic 1 newpic reference 1 newpic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLEFFBUFFERHINTSREADABLE if ret avctx reget buffer avctx newpic 0 av log avctx AVLOGERROR reget buffer failed n return ret stride newpic linesize 0 bytestream2 init gb buf buf size b bytestream2 get byte gb if b C93 FIRSTFRAME newpic pict type AVPICTURETYPEI newpic key frame 1 else newpic pict type AVPICTURETYPEP newpic key frame 0 for y 0 y HEIGHT y 8 out newpic data 0 y stride for x 0 x WIDTH x 8 uint8 t copy from oldpic data 0 unsigned int offset j uint8 t cols 4 grps 4 C93 Block Type block type if bt bt bytestream2 get byte gb block type bt 0x0 F switch block type case C93 8 X8 FROMPREV offset bytestream2 get le16 gb if ret copy block avctx out copy from offset 8 stride 0 return ret break case C93 4 X4 FROMCURR copy from newpic data 0 case C93 4 X4 FROMPREV for j 0 j 8 j 4 for i 0 i 8 i 4 offset bytestream2 get le16 gb if ret copy block avctx out j stride i copy from offset 4 stride 0 return ret break case C93 8 X8 2 COLOR bytestream2 get buffer gb cols 2 for i 0 i 8 i draw n color out i stride stride 8 1 1 cols NULL bytestream2 get byte gb break case C93 4 X4 2 COLOR case C93 4 X4 4 COLOR case C93 4 X4 4 COLORGRP for j 0 j 8 j 4 for i 0 i 8 i 4 if block type C93 4 X4 2 COLOR bytestream2 get buffer gb cols 2 draw n color out i j stride stride 4 4 1 cols NULL bytestream2 get le16 gb else if block type C93 4 X4 4 COLOR bytestream2 get buffer gb cols 4 draw n color out i j stride stride 4 4 2 cols NULL bytestream2 get le32 gb else bytestream2 get buffer gb grps 4 draw n color out i j stride stride 4 4 1 cols grps bytestream2 get le16 gb break case C93 NOOP break case C93 8 X8 INTRA for j 0 j 8 j bytestream2 get buffer gb out j stride 8 break default av log avctx AVLOGERROR unexpected type x at dx d n block type x y return AVERRORINVALIDDATA bt 4 out 8 if b C93 HASPALETTE uint32 t palette uint32 t newpic data 1 for i 0 i 256 i palette i bytestream2 get be24 gb newpic palette has changed 1 else if oldpic data 1 memcpy newpic data 1 oldpic data 1 256 4 picture newpic got frame 1 return buf size int Imaging Fli Decode Imaging im Imaging Codec State state UIN T8 buf int bytes UIN T8 ptr int framesize int c chunks int l lines int i j x 0 y ymax if bytes 4 return 0 ptr buf framesize I32 ptr if framesize I32 ptr return 0 if I16 ptr 4 0x F1 FA state errcode IMAGINGCODECUNKNOWN return 1 chunks I16 ptr 6 ptr 16 for c 0 c chunks c UIN T8 data ptr 6 switch I16 ptr 4 case 4 case 11 break case 7 lines I16 data data 2 for l y 0 l lines y state ysize l y UIN T8 buf UIN T8 im image y int p packets packets I16 data data 2 while packets 0x8000 if packets 0x4000 y 65536 packets if y state ysize state errcode IMAGINGCODECOVERRUN return 1 buf UIN T8 im image y else buf state xsize 1 UIN T8 packets packets I16 data data 2 for p x 0 p packets p x data 0 if data 1 128 i 256 data 1 if x i i state xsize break for j 0 j i j buf x data 2 buf x data 3 data 2 2 else i 2 int data 1 if x i state xsize break memcpy buf x data 2 i data 2 i x i if p packets break if l lines state errcode IMAGINGCODECOVERRUN return 1 break case 12 y I16 data ymax y I16 data 2 data 4 for y ymax y state ysize y UIN T8 out UIN T8 im image y int p packets data for p x 0 p packets p x i x data 0 if data 1 0x80 i 256 data 1 if x i state xsize break memset out x data 2 i data 3 else i data 1 if x i state xsize break memcpy out x data 2 i data i 2 if p packets break if y ymax state errcode IMAGINGCODECOVERRUN return 1 break case 13 for y 0 y state ysize y memset im image y 0 state xsize break case 15 for y 0 y state ysize y UIN T8 out UIN T8 im image y data 1 for x 0 x state xsize x i if data 0 0x80 i 256 data 0 if x i state xsize break memcpy out x data 1 i data i 1 else i data 0 if x i state xsize break memset out x data 1 i data 2 if x state xsize state errcode IMAGINGCODECOVERRUN return 1 break case 16 for y 0 y state ysize y UIN T8 buf UIN T8 im image y memcpy buf x data state xsize data state xsize break case 18 break default state errcode IMAGINGCODECUNKNOWN return 1 ptr I32 ptr return 1 void vp9 rc update rate correction factors V P9 COMP cpi int damp var const V P9 COMMON const cm cpi common int correction factor 100 double rate correction factor get rate correction factor cpi double adjustment limit int projected size based on q 0 if cpi rc is src frame alt ref return vp9 clear system state projected size based on q estimate bits at q cm frame type cm base qindex cm M Bs rate correction factor cm bit depth if projected size based on q 0 correction factor 100 cpi rc projected frame size projected size based on q switch damp var case 0 adjustment limit 0 75 break case 1 adjustment limit 0 375 break case 2 default adjustment limit 0 25 break if correction factor 102 correction factor int 100 correction factor 100 adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MAXBPBFACTOR rate correction factor MAXBPBFACTOR else if correction factor 99 correction factor int 100 100 correction factor adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MINBPBFACTOR rate correction factor MINBPBFACTOR set rate correction factor cpi rate correction factor void vp9 update mv count V P9 COMMON cm const MACROBLOCKD xd const MODEINFO mi xd mi 0 src mi const MBMODEINFO const mbmi mi mbmi if mbmi sb type BLOCK 8 X8 const int num 4x4 w num 4x4 blocks wide lookup mbmi sb type const int num 4x4 h num 4x4 blocks high lookup mbmi sb type int idx idy for idy 0 idy 2 idy num 4x4 h for idx 0 idx 2 idx num 4x4 w const int i idy 2 idx if mi bmi i as mode NEWMV inc mvs mbmi mi bmi i as mv cm counts mv else if mbmi mode NEWMV inc mvs mbmi mbmi mv cm counts mv static int tmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt TMV Context tmv avctx priv data const uint8 t src avpkt data uint8 t dst unsigned char cols avctx width 3 unsigned char rows avctx height 3 unsigned x y fg bg c int ret if tmv pic data 0 avctx release buffer avctx tmv pic if ret ff get buffer avctx tmv pic 0 av log avctx AVLOGERROR get buffer failed n return ret if avpkt size 2 char rows char cols av log avctx AVLOGERROR Input buffer too small truncated sample n got frame 0 return AVERRORINVALIDDATA tmv pic pict type AVPICTURETYPEI tmv pic key frame 1 dst tmv pic data 0 tmv pic palette has changed 1 memcpy tmv pic data 1 ff cga palette 16 4 for y 0 y char rows y for x 0 x char cols x c src bg src 4 fg src 0x F ff draw pc font dst x 8 tmv pic linesize 0 ff cga font 8 c fg bg dst tmv pic linesize 0 8 got frame 1 AV Frame data tmv pic return avpkt size static int rv34 decode slice R V34 Dec Context r int end const uint8 t buf int buf size Mpeg Enc Context s r s Get Bit Context gb s gb int mb pos slice type int res init get bits r s gb buf buf size 8 res r parse slice header r gb r si if res 0 av log s avctx AVLOGERROR Incorrect or unknown slice header n return 1 slice type r si type r si type AVPICTURETYPEI if slice type s pict type av log s avctx AVLOGERROR Slice type mismatch n return AVERRORINVALIDDATA r si end end s qscale r si quant s mb num left r si end r si start r s mb skip run 0 mb pos s mb x s mb y s mb width if r si start mb pos av log s avctx AVLOGERROR Slice indicates MB offset d got d n r si start mb pos s mb x r si start s mb width s mb y r si start s mb width memset r intra types hist 1 r intra types stride 4 2 sizeof r intra types hist s first slice line 1 s resync mb x s mb x s resync mb y s mb y ff init block index s while check slice end r s ff update block index s if r si type res rv34 decode inter macroblock r r intra types s mb x 4 4 else res rv34 decode intra macroblock r r intra types s mb x 4 4 if res 0 ff er add slice s er s resync mb x s resync mb y s mb x 1 s mb y ERMBERROR return 1 if s mb x s mb width s mb x 0 s mb y ff init block index s memmove r intra types hist r intra types r intra types stride 4 sizeof r intra types hist memset r intra types 1 r intra types stride 4 sizeof r intra types hist if r loop filter s mb y 2 r loop filter r s mb y 2 if HAVETHREADS s avctx active thread type FFTHREADFRAME ff thread report progress s current picture ptr tf s mb y 2 0 if s mb x s resync mb x s first slice line 0 s mb num left ff er add slice s er s resync mb x s resync mb y s mb x 1 s mb y ERMBEND return s mb y s mb height int64 t vp9 rd pick inter mode sb V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg struct macroblockd plane const pd xd plane PREDICTIONMODE this mode MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i k int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE int mv single newmv MAXREFFRAMES 0 INTERPFILTER single inter filter MBMODECOUNTMAXREFFRAMES int single skippable MBMODECOUNTMAXREFFRAMES static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best tx rd TXMODES int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int best mode skippable 0 int midx best mode index 1 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p int64 t best intra rd IN T64 MAX unsigned int best pred sse UINTMAXPREDICTIONMODE best intra mode DCPRED int rate uv intra TXSIZES rate uv tokenonly TXSIZES int64 t dist uv TXSIZES int skip uv TXSIZESPREDICTIONMODE mode uv TXSIZES const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int best skip2 0 uint8 t ref frame skip mask 2 0 uint16 t mode skip mask MAXREFFRAMES 0 int mode skip start cpi sf mode skip start 1 const int const rd threshes rd opt threshes segment id bsize const int const rd thresh freq fact rd opt thresh freq fact bsize int mode threshold MAXMODES int mode map rd opt mode map bsize const int mode search skip flags cpi sf mode search skip flags vp9 zero best mbmode x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i TXMODES i best tx rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX for i 0 i TXSIZES i rate uv intra i INTMAX for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i 0 i MBMODECOUNT i for k 0 k MAXREFFRAMES k single inter filter i k SWITCHABLE single skippable i k 0 returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame x pred mv sad ref frame INTMAX if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK else if cpi sf reference masking for i LASTFRAME i ALTREFFRAME i if x pred mv sad ref frame 2 x pred mv sad i mode skip mask ref frame INTERNEARESTNEARZERO break if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 ref frame skip mask 0 1 LASTFRAME 1 GOLDENFRAME ref frame skip mask 1 SECONDREFFRAMEMASK mode skip mask ALTREFFRAMEINTERNEARESTNEARZERO if frame mv NEARMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARMV if frame mv NEARESTMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARESTMV if cpi rc is src frame alt ref if cpi sf alt ref search fp mode skip mask ALTREFFRAME 0 ref frame skip mask 0 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK if bsize cpi sf max intra bsize ref frame skip mask 0 1 INTRAFRAME ref frame skip mask 1 1 INTRAFRAME mode skip mask INTRAFRAME cpi sf intra y mode mask max txsize lookup bsize for i 0 i MAXMODES i mode threshold i int64 t rd threshes i rd thresh freq fact i 5 midx cpi sf schedule mode search mode skip start 0 while midx 4 uint8 t end pos 0 for i 5 i midx i if mode threshold mode map i 1 mode threshold mode map i uint8 t tmp mode map i mode map i mode map i 1 mode map i 1 tmp end pos i midx end pos for midx 0 midx MAXMODES midx int mode index mode map midx int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int64 t tx cache TXMODES int this skip2 0 int64 t total sse IN T64 MAX int early term 0 this mode vp9 mode order mode index mode ref frame vp9 mode order mode index ref frame 0 second ref frame vp9 mode order mode index ref frame 1 if midx mode skip start best mode index 0 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 LASTFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 GOLDENFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 ALTREFMODEMASK break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if mode skip mask ref frame 1 this mode continue if best mode skippable cpi sf schedule mode search mode threshold mode index 1 if best rd mode threshold mode index continue if cpi sf motion field mode search const int mi width MIN num 8x8 blocks wide lookup bsize tile mi col end mi col const int mi height MIN num 8x8 blocks high lookup bsize tile mi row end mi row const int bsl mi width log2 bsize int cb partition search ctrl mi row mi col bsl get chessboard index cm current video frame 0x1 MBMODEINFO ref mbmi int const motion 1 int skip ref frame cb partition search ctrl MVREFERENCEFRAME rf NONE int mv ref mv ref mv as int INVALIDMV if mi row 1 tile mi row start ref mv xd mi xd mi stride src mi mbmi mv 0 rf xd mi xd mi stride src mi mbmi ref frame 0 for i 0 i mi width i ref mbmi xd mi xd mi stride i src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if mi col 1 tile mi col start if ref mv as int INVALIDMV ref mv xd mi 1 src mi mbmi mv 0 if rf NONE rf xd mi 1 src mi mbmi ref frame 0 for i 0 i mi height i ref mbmi xd mi i xd mi stride 1 src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if skip ref frame this mode NEARESTMV this mode NEWMV if rf INTRAFRAME if ref frame rf continue if const motion if this mode NEARMV this mode ZEROMV continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if mode search skip flags FLAGSKIPCOMPBESTINTRA best mode index 0 best mbmode ref frame 0 INTRAFRAME continue mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if ref frame INTRAFRAME if cpi sf adaptive mode search if x source variance num pels log2 lookup bsize best pred sse continue if this mode DCPRED const unsigned int skip intra var thresh 64 if mode search skip flags FLAGSKIPINTRALOWVAR x source variance skip intra var thresh continue if mode search skip flags FLAGSKIPINTRABESTINTER this mode D45 PRED this mode TMPRED if best mode index 0 best mbmode ref frame 0 INTRAFRAME continue if mode search skip flags FLAGSKIPINTRADIRMISMATCH if conditional skipintra this mode best intra mode continue else const MVREFERENCEFRAME ref frames 2 ref frame second ref frame if check best zero mv cpi mbmi mode context frame mv this mode ref frames continue mbmi mode this mode mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter mbmi mv 0 as int mbmi mv 1 as int 0 x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i for i 0 i TXMODES i tx cache i IN T64 MAX if ref frame INTRAFRAMETXSIZE uv tx super block yrd cpi x rate y distortion y skippable NULL bsize tx cache best rd if rate y INTMAX continue uv tx get uv tx size impl mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y if rate uv intra uv tx INTMAX choose intra uv mode cpi ctx bsize uv tx rate uv intra uv tx rate uv tokenonly uv tx dist uv uv tx skip uv uv tx mode uv uv tx rate uv rate uv tokenonly uv tx distortion uv dist uv uv tx skippable skippable skip uv uv tx mbmi uv mode mode uv uv tx rate2 rate y cpi mbmode cost mbmi mode rate uv intra uv tx if this mode DCPRED this mode TMPRED rate2 intra cost penalty distortion2 distortion y distortion uv else this rd handle inter mode cpi x bsize tx cache rate2 distortion2 skippable rate y distortion y rate uv distortion uv disable skip frame mv mi row mi col single newmv single inter filter single skippable total sse best rd if this rd IN T64 MAX continue compmode cost vp9 cost bit comp mode p comp pred if cm reference mode REFERENCEMODESELECT rate2 compmode cost if comp pred rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if skippable rate2 rate y rate uv rate2 vp9 cost bit vp9 get skip prob cm xd 1 else if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if ref frame INTRAFRAME if this rd best intra rd best intra rd this rd best intra mode mbmi mode if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip int max plane MAXMBPLANE if mode excluded best mode index mode index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 else best pred sse x pred sse ref frame returnrate rate2 returndistortion distortion2 best rd this rd best mbmode mbmi best skip2 this skip2 best mode skippable skippable if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk mbmi tx size sizeof uint8 t ctx num 4x4 blk if mode search skip flags FLAGEARLYTERMINATE mode index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred if single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter for i 0 i SWITCHABLEFILTERCONTEXTS i int64 t adj rd if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 tx cache ALLOW 16 X16 tx cache ALLOW 8 X8 tx cache ALLOW 32 X32 tx cache ALLOW 16 X16 if mode excluded this rd IN T64 MAX for i 0 i TXMODES tx cache i IN T64 MAX i int64 t adj rd IN T64 MAX adj rd this rd tx cache i tx cache cm tx mode if adj rd best tx rd i best tx rd i adj rd if early term break if x skip comp pred break if best mbmode mode NEWMV const MVREFERENCEFRAME refs 2 best mbmode ref frame 0 best mbmode ref frame 1 int comp pred mode refs 1 INTRAFRAME if frame mv NEARESTMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARESTMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARESTMV else if frame mv NEARMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARMV else if best mbmode mv 0 as int 0 comp pred mode best mbmode mv 1 as int 0 comp pred mode best mbmode mode ZEROMV if best mode index 0 best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAMETXSIZE uv tx size mbmi best mbmode uv tx size get uv tx size mbmi xd plane 1 rd pick intra sbuv mode cpi x ctx rate uv intra uv tx size rate uv tokenonly uv tx size dist uv uv tx size skip uv uv tx size bsize BLOCK 8 X8 BLOCK 8 X8 bsize uv tx size assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode if cpi rc is src frame alt ref update rd thresh fact cpi bsize best mode index mbmi best mbmode x skip best skip2 for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 for i 0 i TXMODES i if best tx rd i IN T64 MAX best tx diff i 0 else best tx diff i best rd best tx rd i else vp9 zero best filter diff vp9 zero best tx diff x skip best mode skippable store coding context x ctx best mode index best pred diff best tx diff best filter diff best mode skippable return best rd static int fill vaapi Reference Frames VA Picture Parameter Buffer H264 pic param H264 Context h DPB dpb int i dpb size 0 dpb max size FFARRAYELEMS pic param Reference Frames dpb va pics pic param Reference Frames for i 0 i dpb max size i init vaapi pic dpb va pics i for i 0 i h short ref count i Picture const pic h short ref i if pic pic reference dpb add dpb pic 0 return 1 for i 0 i 16 i Picture const pic h long ref i if pic pic reference dpb add dpb pic 0 return 1 return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Indeo3 Decode Context ctx avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data int res res decode frame headers ctx avctx buf buf size if res 0 return res if res got frame 0 return buf size if ctx frame flags BSNONREF avctx skip frame AVDISCARDNONREF return 0 if ctx frame flags BSKEYFRAME avctx skip frame AVDISCARDNONKEY return 0 ctx buf sel ctx frame flags BSBUFFER 1 if res decode plane ctx avctx ctx planes ctx y data ptr ctx y data size 40 return res if res decode plane ctx avctx ctx planes 1 ctx u data ptr ctx u data size 10 return res if res decode plane ctx avctx ctx planes 2 ctx v data ptr ctx v data size 10 return res if res ff get buffer avctx frame 0 0 av log ctx avctx AVLOGERROR get buffer failed n return res output plane ctx planes 0 ctx buf sel frame data 0 frame linesize 0 avctx height output plane ctx planes 1 ctx buf sel frame data 1 frame linesize 1 avctx height 3 2 output plane ctx planes 2 ctx buf sel frame data 2 frame linesize 2 avctx height 3 2 got frame 1 return buf size static double ineq histogram selectivity Planner Info root Variable Stat Data vardata Fmgr Info opproc bool isgt Datum constval Oid consttype double hist selec Oid hist op Datum values int nvalues hist selec 1 0 if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opproc fn oid get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid hist op values nvalues NULLNULL if nvalues 1 double histfrac int lobound 0 int hibound nvalues bool have end false if nvalues 2 have end get actual variable range root vardata hist op values 0 values 1 while lobound hibound int probe lobound hibound 2 bool ltcmp if probe 0 nvalues 2 have end get actual variable range root vardata hist op values 0 NULL else if probe nvalues 1 nvalues 2 have end get actual variable range root vardata hist op NULL values probe ltcmp Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values probe constval if isgt ltcmp ltcmp if ltcmp lobound probe 1 else hibound probe if lobound 0 histfrac 0 0 else if lobound nvalues histfrac 1 0 else int i lobound double val high low double binfrac if convert to scalar constval consttype val values i 1 values i vardata vartype low high if high low binfrac 0 5 else if val low binfrac 0 0 else if val high binfrac 1 0 else binfrac val low high low if isnan binfrac binfrac 0 0 binfrac 1 0 binfrac 0 5 else binfrac 0 5 histfrac double i 1 binfrac histfrac double nvalues 1 hist selec isgt 1 0 histfrac histfrac if have end CLAMPPROBABILITY hist selec else if hist selec 0 0001 hist selec 0 0001 else if hist selec 0 9999 hist selec 0 9999 free attstatsslot vardata atttype values nvalues NULL 0 return hist selec static void model rd for sb y V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum unsigned int var y unsigned int sse y unsigned int sse int rate int64 t dist struct macroblock plane const p x plane 0 struct macroblockd plane const pd xd plane 0 const uint32 t dc quant pd dequant 0 const uint32 t ac quant pd dequant 1 unsigned int var cpi fn ptr bsize vf p src buf p src stride pd dst buf pd dst stride sse var y var sse y sse if sse dc quant dc quant 6 x skip txfm 0 1 else if var ac quant ac quant 6 x skip txfm 0 2 else x skip txfm 0 0 if cpi common tx mode TXMODESELECT if sse var 2 xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode else xd mi 0 src mi mbmi tx size TX 8 X8 else xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode vp9 model rd from var lapndz sse var 1 num pels log2 lookup bsize dc quant 3 rate dist out rate sum rate 1 out dist sum dist 3 vp9 model rd from var lapndz var 1 num pels log2 lookup bsize ac quant 3 rate dist out rate sum rate out dist sum dist 4 void evhttp send reply chunk struct evhttp request req struct evbuffer databuf if req chunked evbuffer add printf req evcon output buffer x r n unsigned EVBUFFERLENGTH databuf evbuffer add buffer req evcon output buffer databuf if req chunked evbuffer add req evcon output buffer r n 2 evhttp write buffer req evcon static int v410 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame pic data uint8 t src avpkt data uint16 t y u v uint32 t val int i j if avpkt size 4 avctx height avctx width av log avctx AVLOGERROR Insufficient input data n return AVERROREINVAL if ff get buffer avctx pic 0 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 for i 0 i avctx height i for j 0 j avctx width j val AVR L32 src u j val 2 0x3 FF y j val 12 0x3 FF v j val 22 src 4 y pic linesize 0 1 u pic linesize 1 1 v pic linesize 2 1 got frame 1 return avpkt size kadm5 ret t kadm5 modify principal void server handle kadm5 principal ent t entry long mask int ret ret2 i kadm5 policy ent rec pol krb5 boolean have pol FALSE krb5 db entry kdb krb5 tl data tl data orig osa princ ent rec adb kadm5 server handle t handle server handle CHECKHANDLE server handle krb5 clear error message handle context if mask KAD M5 PRINCIPAL mask KAD M5 LASTPWDCHANGE mask KAD M5 MODTIME mask KAD M5 MODNAME mask KAD M5 MKVNO mask KAD M5 AUXATTRIBUTES mask KAD M5 KEYDATA mask KAD M5 LASTSUCCESS mask KAD M5 LASTFAILED return KAD M5 BADMASK if mask ALLPRINCMASK return KAD M5 BADMASK if mask KAD M5 POLICY mask KAD M5 POLICYCLR return KAD M5 BADMASK if entry kadm5 principal ent t NULL return EINVAL if mask KAD M5 TLDATA tl data orig entry tl data while tl data orig if tl data orig tl data type 256 return KAD M5 BADTLTYPE tl data orig tl data orig tl data next ret kdb get entry handle entry principal kdb adb if ret return ret if mask KAD M5 POLICY ret get policy handle entry policy pol have pol if ret goto done adb aux attributes KAD M5 POLICY if adb policy free adb policy adb policy strdup entry policy if have pol if pol pw max life ret krb5 dbe lookup last pwd change handle context kdb kdb pw expiration if ret goto done kdb pw expiration pol pw max life else kdb pw expiration 0 if mask KAD M5 POLICYCLR adb aux attributes KAD M5 POLICY free adb policy adb policy NULL adb aux attributes KAD M5 POLICY kdb pw expiration 0 if mask KAD M5 ATTRIBUTES kdb attributes entry attributes if mask KAD M5 MAXLIFE kdb max life entry max life if mask KAD M5 PRINCEXPIRETIME kdb expiration entry princ expire time if mask KAD M5 PWEXPIRATION kdb pw expiration entry pw expiration if mask KAD M5 MAXRLIFE kdb max renewable life entry max renewable life if mask KAD M5 KVNO for i 0 i kdb n key data i kdb key data i key data kvno entry kvno if mask KAD M5 TLDATA krb5 tl data tl for tl entry tl data tl tl tl tl data next ret krb5 dbe update tl data handle context kdb tl if ret goto done if mask KAD M5 FAILAUTHCOUNT if entry fail auth count 0 ret KAD M5 BADSERVERPARAMS goto done kdb fail auth count 0 kdb mask mask ret k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPRECOMMIT entry mask if ret goto done ret kdb put entry handle kdb adb if ret goto done void k5 kadm5 hook modify handle context handle hook handles KAD M5 HOOKSTAGEPOSTCOMMIT entry mask ret KAD M5 OK done if have pol ret2 kadm5 free policy ent handle lhandle pol ret ret ret ret2 kdb free entry handle kdb adb return ret void vp9 init plane quantizers V P9 COMP cpi MACROBLOCK x const V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd QUANTS const quants cpi quants const int segment id xd mi 0 mbmi segment id const int qindex vp9 get qindex cm seg segment id cm base qindex const int rdmult vp9 compute rd mult cpi qindex cm y dc delta q const int zbin cpi zbin mode boost int i x plane 0 quant quants y quant qindex x plane 0 quant fp quants y quant fp qindex x plane 0 round fp quants y round fp qindex x plane 0 quant shift quants y quant shift qindex x plane 0 zbin quants y zbin qindex x plane 0 round quants y round qindex x plane 0 quant thred 0 cm y dequant qindex 0 cm y dequant qindex 0 x plane 0 quant thred 1 cm y dequant qindex 1 cm y dequant qindex 1 x plane 0 zbin extra int16 t cm y dequant qindex 1 zbin 7 xd plane 0 dequant cm y dequant qindex for i 1 i 3 i x plane i quant quants uv quant qindex x plane i quant fp quants uv quant fp qindex x plane i round fp quants uv round fp qindex x plane i quant shift quants uv quant shift qindex x plane i zbin quants uv zbin qindex x plane i round quants uv round qindex x plane i quant thred 0 cm y dequant qindex 0 cm y dequant qindex 0 x plane i quant thred 1 cm y dequant qindex 1 cm y dequant qindex 1 x plane i zbin extra int16 t cm uv dequant qindex 1 zbin 7 xd plane i dequant cm uv dequant qindex x skip block vp9 segfeature active cm seg segment id SEGLVLSKIP x q index qindex x errorperbit rdmult 6 x errorperbit x errorperbit 0 vp9 initialize me consts cpi x q index static int do uncompress compress filter context t zfx z stream zs IOBUF a size t ret len int zrc int rc 0 int leave 0 size t n int nread count int refill zs avail in if DBGFILTER log debug begin inflate avail in u avail out u inbuf u n unsigned zs avail in unsigned zs avail out unsigned zfx inbufsize do if zs avail in zfx inbufsize refill n zs avail in if n ifndef riscos zs next in zfx inbuf nread iobuf read a zfx inbuf n count if nread 1 nread 0 n nread if nread count zfx algo 1 zfx algo1hack 4 zfx inbuf n 0x FF zfx algo1hack n leave 1 zs avail in n refill 1 if DBGFILTER log debug enter inflate avail in u avail out u n unsigned zs avail in unsigned zs avail out if zrc ZSTREAMEND rc 1 else if zrc ZOK zrc ZBUFERROR if zs msg log fatal zlib inflate problem s n zs msg else log fatal zlib inflate problem rc d n zrc while zs avail out zrc ZSTREAMEND zrc ZBUFERROR leave ret len zfx outbufsize zs avail out if DBGFILTER log debug do uncompress returning u bytes n unsigned ret len return rc static Asn1 Generic Decode Asn1 Der Octet String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 OCTETSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL memcpy a str const char d ptr length a str length 0 d ptr length a length d ptr buffer return a int rtp packetize xiph config sout stream id sys t id const char fmtp int64 t i pts if fmtp NULL return VLCEGENERIC char start strstr fmtp configuration assert start NULL start sizeof configuration 1 char end strchr start assert end NULL size t len end start char b64 malloc len 1 if b64 return VLCEGENERIC memcpy b64 start len b64 len 0 int i max rtp mtu id 6 uint8 t p orig p data int i data i data vlc b64 decode binary p orig b64 free b64 if i data 9 free p orig return VLCEGENERIC p data p orig 9 i data 9 int i count i data i max 1 i max for int i 0 i i count i int i payload MIN i max i data block t out block Alloc 18 i payload unsigned fragtype numpkts if i count 1 fragtype 0 numpkts 1 else numpkts 0 if i 0 fragtype 1 else if i i count 1 fragtype 3 else fragtype 2 uint32 t header XIPHIDENT 0xffffff 8 fragtype 6 1 4 numpkts rtp packetize common id out 0 i pts Set DWBE out p buffer 12 header Set WBE out p buffer 16 i payload memcpy out p buffer 18 p data i payload out i dts i pts rtp packetize send id out p data i payload i data i payload free p orig return static void dtls1 clear queues SSL s pitem item NULL hm fragment frag NULL while item pqueue pop s d1 buffered messages NULL frag hm fragment item data dtls1 hm fragment free frag pitem free item while item pqueue pop s d1 sent messages NULL frag hm fragment item data dtls1 hm fragment free frag pitem free item static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic avctx coded frame const uint32 t src const uint32 t avpkt data int aligned width FFALIGN avctx width 64 uint8 t dst line if pic data 0 avctx release buffer avctx pic if avpkt size 4 aligned width avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 dst line pic data 0 for h 0 h avctx height h uint16 t dst uint16 t dst line for w 0 w avctx width w uint32 t pixel av be2ne32 src uint16 t r g b if avctx codec id AVCODECID R210 b pixel 6 g pixel 4 0xffc0 r pixel 14 0xffc0 else b pixel 4 g pixel 6 0xffc0 r pixel 16 0xffc0 dst r r 10 dst g g 10 dst b b 10 src aligned width avctx width dst line pic linesize 0 got frame 1 AV Frame data avctx coded frame return avpkt size static void fill slice long AV Codec Context avctx DXVA Slice H264 Long slice unsigned position unsigned size const H264 Context h avctx priv data struct dxva context ctx avctx hwaccel context unsigned list memset slice 0 sizeof slice slice BSNA Lunit Data Location position slice Slice Bytes In Buffer size slice w Bad Slice Chopping 0 slice first mb in slice h mb y FIELDORMBAFFPICTURE h mb width h mb x slice Num Mbs For Slice 0 slice Bit Offset To Slice Data get bits count h gb slice slice type ff h264 get slice type h if h slice type fixed slice slice type 5 slice luma log2 weight denom h luma log2 weight denom slice chroma log2 weight denom h chroma log2 weight denom if h list count 0 slice num ref idx l0 active minus1 h ref count 0 1 if h list count 1 slice num ref idx l1 active minus1 h ref count 1 1 slice slice alpha c0 offset div2 h slice alpha c0 offset 2 26 slice slice beta offset div2 h slice beta offset 2 26 slice Reserved8 Bits 0 for list 0 list 2 list unsigned i for i 0 i FFARRAYELEMS slice Ref Pic List list i if list h list count i h ref count list const Picture r h ref list list i unsigned plane fill picture entry slice Ref Pic List list i ff dxva2 get surface index ctx r r reference PICTBOTTOMFIELD for plane 0 plane 3 plane int w o if plane 0 h luma weight flag list w h luma weight i list 0 o h luma weight i list 1 else if plane 1 h chroma weight flag list w h chroma weight i list plane 1 0 o h chroma weight i list plane 1 1 else w 1 plane 0 h luma log2 weight denom h chroma log2 weight denom o 0 slice Weights list i plane 0 w slice Weights list i plane 1 o else unsigned plane slice Ref Pic List list i b Pic Entry 0xff for plane 0 plane 3 plane slice Weights list i plane 0 0 slice Weights list i plane 1 0 slice slice qs delta 0 slice slice qp delta h qscale h pps init qp slice redundant pic cnt h redundant pic count if h slice type AVPICTURETYPEB slice direct spatial mv pred flag h direct spatial mv pred slice cabac init idc h pps cabac h cabac init idc 0 if h deblocking filter 2 slice disable deblocking filter idc 1 h deblocking filter else slice disable deblocking filter idc h deblocking filter slice slice id h current slice 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt LOCO Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data int decoded ret if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p key frame 1 switch l mode case LOCOCYU Y2 case LOCOYU Y2 case LOCOUYVY decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height p linesize 1 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height p linesize 2 buf buf size 1 break case LOCOCY V12 case LOCOY V12 decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf buf size 1 break case LOCOCRGB case LOCORGB decoded loco decode plane l p data 0 p linesize 0 avctx height 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 2 avctx width avctx height p linesize 0 buf buf size 3 break case LOCORGBA decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 1 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 2 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 3 avctx width avctx height p linesize 0 buf buf size 4 break got frame 1 return buf size buf too small av log avctx AVLOGERROR Input data too small n return int64 t vp9 rd pick inter mode sb V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mi row int mi col int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg struct macroblockd plane const pd xd plane PREDICTIONMODE this mode MVREFERENCEFRAME ref frame second ref frame unsigned char segment id mbmi segment id int comp pred i k int mv frame mv MBMODECOUNTMAXREFFRAMES struct buf 2d yv12 mb 4 MAXMBPLANE int mv single newmv MAXREFFRAMES 0 INTERPFILTER single inter filter MBMODECOUNTMAXREFFRAMES int single skippable MBMODECOUNTMAXREFFRAMES static const int flag list 4 0 V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG int64 t best rd best rd so far int64 t best tx rd TXMODES int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best pred rd REFERENCEMODES int64 t best filter rd SWITCHABLEFILTERCONTEXTS int64 t best filter diff SWITCHABLEFILTERCONTEXTSMBMODEINFO best mbmode int best mode skippable 0 int midx best mode index 1 unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p int64 t best intra rd IN T64 MAX unsigned int best pred sse UINTMAXPREDICTIONMODE best intra mode DCPRED int rate uv intra TXSIZES rate uv tokenonly TXSIZES int64 t dist uv TXSIZES int skip uv TXSIZESPREDICTIONMODE mode uv TXSIZES const int intra cost penalty vp9 dc quant cm base qindex cm y dc delta q cm bit depth int best skip2 0 uint8 t ref frame skip mask 2 0 uint16 t mode skip mask MAXREFFRAMES 0 int mode skip start cpi sf mode skip start 1 const int const rd threshes rd opt threshes segment id bsize const int const rd thresh freq fact rd opt thresh freq fact bsize int mode threshold MAXMODES int mode map rd opt mode map bsize const int mode search skip flags cpi sf mode search skip flags vp9 zero best mbmode x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i REFERENCEMODES i best pred rd i IN T64 MAX for i 0 i TXMODES i best tx rd i IN T64 MAX for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i IN T64 MAX for i 0 i TXSIZES i rate uv intra i INTMAX for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i 0 i MBMODECOUNT i for k 0 k MAXREFFRAMES k single inter filter i k SWITCHABLE single skippable i k 0 returnrate INTMAX for ref frame LASTFRAME ref frame ALTREFFRAME ref frame x pred mv sad ref frame INTMAX if cpi ref frame flags flag list ref frame setup buffer inter cpi x tile ref frame bsize mi row mi col frame mv NEARESTMV frame mv NEARMV yv12 mb frame mv NEWMV ref frame as int INVALIDMV frame mv ZEROMV ref frame as int 0 for ref frame LASTFRAME ref frame ALTREFFRAME ref frame if cpi ref frame flags flag list ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK else if cpi sf reference masking for i LASTFRAME i ALTREFFRAME i if x pred mv sad ref frame 2 x pred mv sad i mode skip mask ref frame INTERNEARESTNEARZERO break if vp9 segfeature active seg segment id SEGLVLREFFRAME vp9 get segdata seg segment id SEGLVLREFFRAME int ref frame ref frame skip mask 0 1 ref frame ref frame skip mask 1 SECONDREFFRAMEMASK if vp9 segfeature active seg segment id SEGLVLREFFRAME if cpi rc is src frame alt ref cpi oxcf arnr max frames 0 ref frame skip mask 0 1 LASTFRAME 1 GOLDENFRAME ref frame skip mask 1 SECONDREFFRAMEMASK mode skip mask ALTREFFRAMEINTERNEARESTNEARZERO if frame mv NEARMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARMV if frame mv NEARESTMVALTREFFRAME as int 0 mode skip mask ALTREFFRAME 1 NEARESTMV if cpi rc is src frame alt ref if cpi sf alt ref search fp mode skip mask ALTREFFRAME 0 ref frame skip mask 0 1 ALTREFFRAME ref frame skip mask 1 SECONDREFFRAMEMASK if bsize cpi sf max intra bsize ref frame skip mask 0 1 INTRAFRAME ref frame skip mask 1 1 INTRAFRAME mode skip mask INTRAFRAME cpi sf intra y mode mask max txsize lookup bsize for i 0 i MAXMODES i mode threshold i int64 t rd threshes i rd thresh freq fact i 5 midx cpi sf schedule mode search mode skip start 0 while midx 4 uint8 t end pos 0 for i 5 i midx i if mode threshold mode map i 1 mode threshold mode map i uint8 t tmp mode map i mode map i mode map i 1 mode map i 1 tmp end pos i midx end pos for midx 0 midx MAXMODES midx int mode index mode map midx int mode excluded 0 int64 t this rd IN T64 MAX int disable skip 0 int compmode cost 0 int rate2 0 rate y 0 rate uv 0 int64 t distortion2 0 distortion y 0 distortion uv 0 int skippable 0 int64 t tx cache TXMODES int this skip2 0 int64 t total sse IN T64 MAX int early term 0 this mode vp9 mode order mode index mode ref frame vp9 mode order mode index ref frame 0 second ref frame vp9 mode order mode index ref frame 1 if midx mode skip start best mode index 0 switch best mbmode ref frame 0 case INTRAFRAME break case LASTFRAME ref frame skip mask 0 LASTFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case GOLDENFRAME ref frame skip mask 0 GOLDENFRAMEMODEMASK ref frame skip mask 1 SECONDREFFRAMEMASK break case ALTREFFRAME ref frame skip mask 0 ALTREFMODEMASK break case NONE case MAXREFFRAMES assert 0 Invalid Reference frame break if ref frame skip mask 0 1 ref frame ref frame skip mask 1 1 MAX 0 second ref frame continue if mode skip mask ref frame 1 this mode continue if best mode skippable cpi sf schedule mode search mode threshold mode index 1 if best rd mode threshold mode index continue if cpi sf motion field mode search const int mi width MIN num 8x8 blocks wide lookup bsize tile mi col end mi col const int mi height MIN num 8x8 blocks high lookup bsize tile mi row end mi row const int bsl mi width log2 bsize int cb partition search ctrl mi row mi col bsl get chessboard index cm current video frame 0x1 MBMODEINFO ref mbmi int const motion 1 int skip ref frame cb partition search ctrl MVREFERENCEFRAME rf NONE int mv ref mv ref mv as int INVALIDMV if mi row 1 tile mi row start ref mv xd mi xd mi stride src mi mbmi mv 0 rf xd mi xd mi stride src mi mbmi ref frame 0 for i 0 i mi width i ref mbmi xd mi xd mi stride i src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if mi col 1 tile mi col start if ref mv as int INVALIDMV ref mv xd mi 1 src mi mbmi mv 0 if rf NONE rf xd mi 1 src mi mbmi ref frame 0 for i 0 i mi height i ref mbmi xd mi i xd mi stride 1 src mi mbmi const motion ref mv as int ref mbmi mv 0 as int ref frame ref mbmi ref frame 0 skip ref frame rf ref mbmi ref frame 0 if skip ref frame this mode NEARESTMV this mode NEWMV if rf INTRAFRAME if ref frame rf continue if const motion if this mode NEARMV this mode ZEROMV continue comp pred second ref frame INTRAFRAME if comp pred if cm allow comp inter inter continue if cpi ref frame flags flag list second ref frame continue if vp9 segfeature active seg segment id SEGLVLREFFRAME continue if mode search skip flags FLAGSKIPCOMPBESTINTRA best mode index 0 best mbmode ref frame 0 INTRAFRAME continue mode excluded cm reference mode SINGLEREFERENCE else if ref frame INTRAFRAME mode excluded cm reference mode COMPOUNDREFERENCE if ref frame INTRAFRAME if cpi sf adaptive mode search if x source variance num pels log2 lookup bsize best pred sse continue if this mode DCPRED const unsigned int skip intra var thresh 64 if mode search skip flags FLAGSKIPINTRALOWVAR x source variance skip intra var thresh continue if mode search skip flags FLAGSKIPINTRABESTINTER this mode D45 PRED this mode TMPRED if best mode index 0 best mbmode ref frame 0 INTRAFRAME continue if mode search skip flags FLAGSKIPINTRADIRMISMATCH if conditional skipintra this mode best intra mode continue else const MVREFERENCEFRAME ref frames 2 ref frame second ref frame if check best zero mv cpi mbmi mode context frame mv this mode ref frames continue mbmi mode this mode mbmi uv mode DCPRED mbmi ref frame 0 ref frame mbmi ref frame 1 second ref frame mbmi interp filter cm interp filter SWITCHABLEEIGHTTAP cm interp filter mbmi mv 0 as int mbmi mv 1 as int 0 x skip 0 set ref ptrs cm xd ref frame second ref frame for i 0 i MAXMBPLANE i xd plane i pre 0 yv12 mb ref frame i if comp pred xd plane i pre 1 yv12 mb second ref frame i for i 0 i TXMODES i tx cache i IN T64 MAX if ref frame INTRAFRAMETXSIZE uv tx super block yrd cpi x rate y distortion y skippable NULL bsize tx cache best rd if rate y INTMAX continue uv tx get uv tx size impl mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y if rate uv intra uv tx INTMAX choose intra uv mode cpi ctx bsize uv tx rate uv intra uv tx rate uv tokenonly uv tx dist uv uv tx skip uv uv tx mode uv uv tx rate uv rate uv tokenonly uv tx distortion uv dist uv uv tx skippable skippable skip uv uv tx mbmi uv mode mode uv uv tx rate2 rate y cpi mbmode cost mbmi mode rate uv intra uv tx if this mode DCPRED this mode TMPRED rate2 intra cost penalty distortion2 distortion y distortion uv else this rd handle inter mode cpi x bsize tx cache rate2 distortion2 skippable rate y distortion y rate uv distortion uv disable skip frame mv mi row mi col single newmv single inter filter single skippable total sse best rd if this rd IN T64 MAX continue compmode cost vp9 cost bit comp mode p comp pred if cm reference mode REFERENCEMODESELECT rate2 compmode cost if comp pred rate2 ref costs comp ref frame else rate2 ref costs single ref frame if disable skip if skippable rate2 rate y rate uv rate2 vp9 cost bit vp9 get skip prob cm xd 1 else if ref frame INTRAFRAME xd lossless if RDCOST x rdmult x rddiv rate y rate uv distortion2 RDCOST x rdmult x rddiv 0 total sse rate2 vp9 cost bit vp9 get skip prob cm xd 0 else rate2 vp9 cost bit vp9 get skip prob cm xd 1 distortion2 total sse assert total sse 0 rate2 rate y rate uv this skip2 1 else rate2 vp9 cost bit vp9 get skip prob cm xd 0 this rd RDCOST x rdmult x rddiv rate2 distortion2 if ref frame INTRAFRAME if this rd best intra rd best intra rd this rd best intra mode mbmi mode if disable skip ref frame INTRAFRAME for i 0 i REFERENCEMODES i best pred rd i MIN best pred rd i this rd for i 0 i SWITCHABLEFILTERCONTEXTS i best filter rd i MIN best filter rd i this rd if this rd best rd x skip int max plane MAXMBPLANE if mode excluded best mode index mode index if ref frame INTRAFRAME mbmi mv 0 as int 0 max plane 1 else best pred sse x pred sse ref frame returnrate rate2 returndistortion distortion2 best rd this rd best mbmode mbmi best skip2 this skip2 best mode skippable skippable if x select tx size swap block ptr x ctx 1 0 0 max plane vpx memcpy ctx zcoeff blk x zcoeff blk mbmi tx size sizeof uint8 t ctx num 4x4 blk if mode search skip flags FLAGEARLYTERMINATE mode index MINEARLYTERMINDEX const int qstep xd plane 0 dequant 1 int scale 4 if x source variance UINTMAX const int var adjust x source variance 16 scale var adjust if ref frame INTRAFRAME distortion2 scale qstep qstep early term 1 if disable skip ref frame INTRAFRAME int64 t single rd hybrid rd single rate hybrid rate if cm reference mode REFERENCEMODESELECT single rate rate2 compmode cost hybrid rate rate2 else single rate rate2 hybrid rate rate2 compmode cost single rd RDCOST x rdmult x rddiv single rate distortion2 hybrid rd RDCOST x rdmult x rddiv hybrid rate distortion2 if comp pred if single rd best pred rd SINGLEREFERENCE best pred rd SINGLEREFERENCE single rd else if single rd best pred rd COMPOUNDREFERENCE best pred rd COMPOUNDREFERENCE single rd if hybrid rd best pred rd REFERENCEMODESELECT best pred rd REFERENCEMODESELECT hybrid rd if mode excluded cm interp filter BILINEAR int64 t ref rd opt filter cache cm interp filter SWITCHABLESWITCHABLEFILTERS cm interp filter for i 0 i SWITCHABLEFILTERCONTEXTS i int64 t adj rd if ref IN T64 MAX adj rd 0 else if rd opt filter cache i IN T64 MAX adj rd rd opt mask filter ref 10 else adj rd rd opt filter cache i ref adj rd this rd best filter rd i MIN best filter rd i adj rd if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 tx cache ALLOW 16 X16 tx cache ALLOW 8 X8 tx cache ALLOW 32 X32 tx cache ALLOW 16 X16 if mode excluded this rd IN T64 MAX for i 0 i TXMODES tx cache i IN T64 MAX i int64 t adj rd IN T64 MAX adj rd this rd tx cache i tx cache cm tx mode if adj rd best tx rd i best tx rd i adj rd if early term break if x skip comp pred break if best mbmode mode NEWMV const MVREFERENCEFRAME refs 2 best mbmode ref frame 0 best mbmode ref frame 1 int comp pred mode refs 1 INTRAFRAME if frame mv NEARESTMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARESTMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARESTMV else if frame mv NEARMV refs 0 as int best mbmode mv 0 as int comp pred mode frame mv NEARMV refs 1 as int best mbmode mv 1 as int comp pred mode best mbmode mode NEARMV else if best mbmode mv 0 as int 0 comp pred mode best mbmode mv 1 as int 0 comp pred mode best mbmode mode ZEROMV if best mode index 0 best rd best rd so far return IN T64 MAX if cpi sf use uv intra rd estimate if best mbmode ref frame 0 INTRAFRAMETXSIZE uv tx size mbmi best mbmode uv tx size get uv tx size mbmi xd plane 1 rd pick intra sbuv mode cpi x ctx rate uv intra uv tx size rate uv tokenonly uv tx size dist uv uv tx size skip uv uv tx size bsize BLOCK 8 X8 BLOCK 8 X8 bsize uv tx size assert cm interp filter SWITCHABLE cm interp filter best mbmode interp filter is inter block best mbmode if cpi rc is src frame alt ref update rd thresh fact cpi bsize best mode index mbmi best mbmode x skip best skip2 for i 0 i REFERENCEMODES i if best pred rd i IN T64 MAX best pred diff i INTMIN else best pred diff i best rd best pred rd i if x skip for i 0 i SWITCHABLEFILTERCONTEXTS i if best filter rd i IN T64 MAX best filter diff i 0 else best filter diff i best rd best filter rd i if cm interp filter SWITCHABLE assert best filter diff SWITCHABLEFILTERS 0 for i 0 i TXMODES i if best tx rd i IN T64 MAX best tx diff i 0 else best tx diff i best rd best tx rd i else vp9 zero best filter diff vp9 zero best tx diff x skip best mode skippable store coding context x ctx best mode index best pred diff best tx diff best filter diff best mode skippable return best rd static int tqi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size Tqi Context t avctx priv data Mpeg Enc Context s t s AV Frame frame data int ret s width AVR L16 buf 0 s height AVR L16 buf 2 tqi calculate qtable s buf 4 buf 8 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret av fast padded malloc t bitstream buf t bitstream buf size buf end buf if t bitstream buf return AVERRORENOMEM s dsp bswap buf t bitstream buf const uint32 t buf buf end buf 4 init get bits s gb t bitstream buf 8 buf end buf s last dc 0 s last dc 1 s last dc 2 0 for s mb y 0 s mb y avctx height 15 16 s mb y for s mb x 0 s mb x avctx width 15 16 s mb x if tqi decode mb s t block 0 break tqi idct put t frame t block got frame 1 return buf size VALUE rb dlhandle initialize int argc VALUE argv VALUE self void ptr struct dl handle dlhandle VALUE lib flag char clib int cflag const char err switch rb scan args argc argv 02 lib flag case 0 clib NULL cflag RTLDLAZYRTLDGLOBAL break case 1 clib NILP lib NULL String Value Ptr lib cflag RTLDLAZYRTLDGLOBAL break case 2 clib NILP lib NULL String Value Ptr lib cflag NU M2 INT flag break default rb bug rb dlhandle new ptr dlopen clib cflag rb raise rb e DL Error s err static int ulti decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Ultimotion Decode Context s avctx priv data int modifier 0 int uniq 0 int mode 0 int blocks 0 int done 0 int x 0 y 0 int i ret int skip int tmp if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret bytestream2 init s gb buf buf size while done int idx if blocks s blocks y s height break if bytestream2 get bytes left s gb 1 goto err idx bytestream2 get byteu s gb if idx 0x F8 0x70 switch idx case 0x70 modifier bytestream2 get byte s gb if modifier 1 av log avctx AVLOGINFO warning modifier must be 0 or 1 got i n modifier break case 0x71 uniq 1 break case 0x72 mode mode break case 0x73 done 1 break case 0x74 skip bytestream2 get byte s gb if blocks skip s blocks break blocks skip x skip 8 while x s width x s width y 8 break default av log avctx AVLOGINFO warning unknown escape 0x 02 X n idx else int code int cf int angle 0 uint8 t Y 4 int tx 0 ty 0 int chroma 0 if mode uniq uniq 0 cf 1 chroma 0 else cf 0 if idx chroma bytestream2 get byte s gb for i 0 i 4 i code idx 6 i 2 3 if code continue if cf chroma bytestream2 get byte s gb tx x block coords i 2 ty y block coords i 2 1 switch code case 1 tmp bytestream2 get byte s gb angle angle by index tmp 6 0x3 Y 0 tmp 0x3 FY 1 Y 0 if angle Y 2 Y 0 1 if Y 2 0x3 FY 2 0x3 FY 3 Y 2 else Y 2 Y 0 Y 3 Y 0 break case 2 if modifier tmp bytestream2 get be24 s gb Y 0 tmp 18 0x3 FY 1 tmp 12 0x3 FY 2 tmp 6 0x3 FY 3 tmp 0x3 F angle 16 else tmp bytestream2 get be16 s gb angle tmp 12 0x F tmp 0x FFF tmp 2 Y 0 s ulti codebook tmp Y 1 s ulti codebook tmp 1 Y 2 s ulti codebook tmp 2 Y 3 s ulti codebook tmp 3 break case 3 if modifier uint8 t Luma 16 if bytestream2 get bytes left s gb 12 goto err tmp bytestream2 get be24u s gb Luma 0 tmp 18 0x3 F Luma 1 tmp 12 0x3 F Luma 2 tmp 6 0x3 F Luma 3 tmp 0x3 F tmp bytestream2 get be24u s gb Luma 4 tmp 18 0x3 F Luma 5 tmp 12 0x3 F Luma 6 tmp 6 0x3 F Luma 7 tmp 0x3 F tmp bytestream2 get be24u s gb Luma 8 tmp 18 0x3 F Luma 9 tmp 12 0x3 F Luma 10 tmp 6 0x3 F Luma 11 tmp 0x3 F tmp bytestream2 get be24u s gb Luma 12 tmp 18 0x3 F Luma 13 tmp 12 0x3 F Luma 14 tmp 6 0x3 F Luma 15 tmp 0x3 F ulti convert yuv s frame tx ty Luma chroma else if bytestream2 get bytes left s gb 4 goto err tmp bytestream2 get byteu s gb if tmp 0x80 angle tmp 4 0x7 tmp tmp 8 bytestream2 get byteu s gb Y 0 tmp 6 0x3 FY 1 tmp 0x3 FY 2 bytestream2 get byteu s gb 0x3 FY 3 bytestream2 get byteu s gb 0x3 F ulti grad s frame tx ty Y chroma angle else int f0 f1 f0 bytestream2 get byteu s gb f1 tmp Y 0 bytestream2 get byteu s gb 0x3 FY 1 bytestream2 get byteu s gb 0x3 F ulti pattern s frame tx ty f1 f0 Y 0 Y 1 chroma break if code 3 ulti grad s frame tx ty Y chroma angle blocks x 8 if x s width x 0 y 8 got frame 1 if ret av frame ref data s frame 0 return ret return buf size err av log avctx AVLOGERROR Insufficient data n return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Camtasia Context const c avctx priv data const unsigned char encoded buf int zret int ret len buf size if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN c zstream next in encoded c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZFINISH if zret ZOK zret ZSTREAMEND zret ZDATAERROR av log avctx AVLOGERROR Inflate error d n zret return AVERRORUNKNOWN if zret ZDATAERROR bytestream2 init c gb c decomp buf c decomp size c zstream avail out ff msrle decode avctx AV Picture c pic c bpp c gb if c avctx pix fmt AVPIXFMTPA L8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static const char cmd hash engine cmd parms cmd void dcfg const char p1 directory config dcfg directory config dcfg if dcfg NULL return NULL if strcasecmp p1 on 0 dcfg hash is enabled HASHENABLED dcfg hash enforcement HASHENABLED else if strcasecmp p1 off 0 dcfg hash is enabled HASHDISABLED dcfg hash enforcement HASHDISABLED else return apr psprintf cmd pool Mod Security Invalid value for Sex Hash Engine s p1 return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ansi Context s avctx priv data uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size int ret i count ret avctx reget buffer avctx s frame if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset s frame data 0 0 avctx height FFABS s frame linesize 0 memset s frame data 1 0 AVPALETTESIZE s frame pict type AVPICTURETYPEI s frame palette has changed 1 memcpy s frame data 1 ff cga palette 16 4 while buf buf end switch s state case STATENORMAL switch buf 0 case 0x00 case 0x07 case 0x1 A break case 0x08 s x FFMAX s x 1 0 break case 0x09 i s x FONTWIDTH count i 8 7 i for i 0 i count i draw char avctx break case 0x0 A hscroll avctx case 0x0 D s x 0 break case 0x0 C erase screen avctx break case 0x1 B s state STATEESCAPE break default draw char avctx buf 0 break case STATEESCAPE if buf 0 s state STATECODE s nb args 0 s args 0 0 else s state STATENORMAL draw char avctx 0x1 B continue break case STATECODE switch buf 0 case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 case 8 case 9 if s nb args MAXNBARGS s args s nb args s args s nb args 10 buf 0 0 break case s nb args if s nb args MAXNBARGS s args s nb args 0 break case M s state STATEMUSICPREAMBLE break case case break default if s nb args MAXNBARGS av log avctx AVLOGWARNING args overflow i n s nb args if s nb args MAXNBARGS s args s nb args s nb args if ret execute code avctx buf 0 0 return ret s state STATENORMAL break case STATEMUSICPREAMBLE if buf 0 0x0 E buf 0 0x1 B s state STATENORMAL break buf got frame 1 AV Frame data s frame return buf size enum Imap Auth Res imap auth cram md5 struct Imap Data idata const char method char ibuf LONGSTRING 2 obuf LONGSTRING unsigned char hmac response M D5 DIGESTLEN int len int rc if mutt bit isset idata capabilities ACRAMM D5 return IMAPAUTHUNAVAIL mutt message Authenticating CRAMM D5 if mutt account getlogin idata conn account 0 return IMAPAUTHFAILURE if mutt account getpass idata conn account 0 return IMAPAUTHFAILURE imap cmd start idata AUTHENTICATECRAMM D5 do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 Invalid response from server s n ibuf goto bail len mutt b64 decode obuf idata buf 2 sizeof obuf if len 1 mutt debug 1 Error decoding base64 response n goto bail obuf len 0 mutt debug 2 CRAM challenge s n obuf hmac md5 idata conn account pass obuf hmac response int off snprintf obuf sizeof obuf s idata conn account user mutt md5 toascii hmac response obuf off mutt debug 2 CRAM response s n obuf mutt b64 encode ibuf obuf strlen obuf sizeof ibuf 2 mutt str strcat ibuf sizeof ibuf r n mutt socket send idata conn ibuf do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDOK mutt debug 1 Error receiving server response n goto bail if imap code idata buf return IMAPAUTHSUCCESS bail mutt error CRAMM D5 authentication failed return static void rv40 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int alpha beta beta Y beta C int q int mbtype 4 int mb strong 4 int clip 4 int cbp 4 int uvcbp 4 2 unsigned mvmasks 4 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r cbp luma mb pos r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int y h deblock y v deblock int c v deblock 2 c h deblock 2 int clip left int avail 4 unsigned y to deblock int c to deblock 2 q s current picture ptr f qscale table mb pos alpha rv40 alpha tab q beta rv40 beta tab q beta Y beta C beta 3 if s width s height 176 144 beta Y beta avail 0 1 avail 1 row avail 2 mb x avail 3 row s mb height 1 for i 0 i 4 i if avail i int pos mb pos neighbour offs x i neighbour offs y i s mb stride mvmasks i r deblock coefs pos mbtype i s current picture ptr f mb type pos cbp i r cbp luma pos uvcbp i 0 r cbp chroma pos 0x F uvcbp i 1 r cbp chroma pos 4 else mvmasks i 0 mbtype i mbtype 0 cbp i 0 uvcbp i 0 uvcbp i 1 0 mb strong i ISINTRA mbtype i ISSEPARATEDC mbtype i clip i rv40 filter clip tbl mb strong i 1 q y to deblock mvmasks POSCUR mvmasks POSBOTTOM 16 y h deblock y to deblock cbp POSCUR 4 MASKYTOPROW cbp POSTOPMASKYLASTROW 12 y v deblock y to deblock cbp POSCUR 1 MASKYLEFTCOL cbp POSLEFTMASKYRIGHTCOL 3 if mb x y v deblock MASKYLEFTCOL if row y h deblock MASKYTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM y h deblock MASKYTOPROW 16 for i 0 i 2 i c to deblock i uvcbp POSBOTTOM i 4 uvcbp POSCUR i c v deblock i c to deblock i uvcbp POSCUR i 1 MASKCLEFTCOL uvcbp POSLEFT i MASKCRIGHTCOL 1 c h deblock i c to deblock i uvcbp POSTOP i MASKCLASTROW 2 uvcbp POSCUR i 2 if mb x c v deblock i MASKCLEFTCOL if row c h deblock i MASKCTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM c h deblock i MASKCTOPROW 4 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j int clip cur y to deblock MASKCUR ij clip POSCUR 0 int dither j ij i 4 if y h deblock MASKBOTTOM ij rv40 adaptive loop filter r rdsp Y 4 s linesize s linesize dither y to deblock MASKBOTTOM ij clip POSCUR 0 clip cur alpha beta beta Y 0 0 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 else clip left y to deblock MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 0 1 if j y h deblock MASKCUR i mb strong POSCUR mb strong POSTOP rv40 adaptive loop filter r rdsp Y s linesize dither clip cur mvmasks POSTOPMASKTOP i clip POSTOP 0 alpha beta beta Y 0 1 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 1 1 for k 0 k 2 k for j 0 j 2 j C s current picture ptr f data k 1 mb x 8 row 8 j 4 s uvlinesize for i 0 i 2 i C 4 int ij i j 2 int clip cur c to deblock k MASKCUR ij clip POSCUR 0 if c h deblock k MASKCUR ij 2 int clip bot c to deblock k MASKCUR ij 2 clip POSCUR 0 rv40 adaptive loop filter r rdsp C 4 s uvlinesize s uvlinesize i 8 clip bot clip cur alpha beta beta C 1 0 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 else clip left c to deblock k MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 0 1 if j c h deblock k MASKCUR ij mb strong POSCUR mb strong POSTOP int clip top uvcbp POSTOP k MASKCUR ij 2 clip POSTOP 0 rv40 adaptive loop filter r rdsp C s uvlinesize i 8 clip cur clip top alpha beta beta C 1 1 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 1 1 static int zerocodec decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Zero Codec Context zc avctx priv data AV Frame pic data AV Frame prev pic zc previous frame z stream zstream zc zstream uint8 t prev prev pic data 0 uint8 t dst int i j zret ret if avpkt flags AVPKTFLAGKEY pic key frame 1 pic pict type AVPICTURETYPEI else if prev av log avctx AVLOGERROR Missing reference frame n return AVERRORINVALIDDATA prev avctx height 1 prev pic linesize 0 pic key frame 0 pic pict type AVPICTURETYPEP zret inflate Reset zstream if zret ZOK av log avctx AVLOGERROR Could not reset inflate d n zret return AVERRORINVALIDDATA if ff get buffer avctx pic AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM zstream next in avpkt data zstream avail in avpkt size dst pic data 0 avctx height 1 pic linesize 0 for i 0 i avctx height i zstream next out dst zstream avail out avctx width 1 zret inflate zstream ZSYNCFLUSH if zret ZOK zret ZSTREAMEND av log avctx AVLOGERROR Inflate failed with return code d n zret return AVERRORINVALIDDATA if avpkt flags AVPKTFLAGKEY for j 0 j avctx width 1 j dst j prev j dst j prev prev pic linesize 0 dst pic linesize 0 av frame unref zc previous frame if ret av frame ref zc previous frame pic 0 return ret got frame 1 return avpkt size P Gconn Get Connection void P Gconn tmpconn int argcount 7 int i const char keywords const char values const char tmpparam bool need password P Qconninfo Option conn opts NULLP Qconninfo Option conn opt char err msg NULL i 0 if connection string conn opts P Qconninfo Parse connection string err msg if conn opts NULL fprintf stderr s s progname err msg exit 1 for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 argcount keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 keywords i conn opt keyword values i conn opt val i else keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values keywords i dbname values i dbname NULL replication dbname i keywords i replication values i dbname NULL true database i keywords i fallback application name values i progname i if dbhost keywords i host values i dbhost i if dbuser keywords i user values i dbuser i if dbport keywords i port values i dbport i need password dbgetpassword 1 dbpassword NULL do if need password if dbpassword free dbpassword dbpassword simple prompt Password 100 false need password false if dbpassword keywords i password values i dbpassword else keywords i NULL values i NULL tmpconn P Qconnectdb Params keywords values true if tmpconn fprintf stderr s could not connect to server n progname exit 1 if P Qstatus tmpconn CONNECTIONBADP Qconnection Needs Password tmpconn dbgetpassword 1 P Qfinish tmpconn need password true while need password if P Qstatus tmpconn CONNECTIONOK fprintf stderr s could not connect to server s progname P Qerror Message tmpconn P Qfinish tmpconn free values free keywords if conn opts P Qconninfo Free conn opts return NULL free values free keywords if conn opts P Qconninfo Free conn opts tmpparam P Qparameter Status tmpconn integer datetimes if tmpparam fprintf stderr s could not determine server setting for integer datetimes n progname P Qfinish tmpconn exit 1 fprintf stderr s integer datetimes compile flag does not match server n progname P Qfinish tmpconn exit 1 static vpx codec err t ctrl set svc parameters vpx codec alg priv t ctx va list args V P9 COMP const cpi ctx cpi vpx svc parameters t const params va arg args vpx svc parameters t if params NULL params spatial layer 0 params spatial layer cpi svc number spatial layers return VPXCODECINVALIDPARAM if params spatial layer 0 int i for i 0 i cpi svc number spatial layers i cpi svc layer context i svc params received spatial layer 1 cpi svc layer context params spatial layer svc params received params return void vp9 xform quant MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size tran low t const coeff BLOCKOFFSET p coeff block tran low t const qcoeff BLOCKOFFSET p qcoeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break int ff h264 decode mb cabac H264 Context h int mb xy int mb type partition count cbp 0 int dct8x8 allowed h pps transform 8x8 mode int decode chroma h sps chroma format idc 1 h sps chroma format idc 2 const int pixel shift h pixel shift mb xy h mb xy h mb x h mb y h mb stride tprintf h avctx pic d mb d d n h frame num h mb x h mb y if h slice type nos AVPICTURETYPEI int skip if FRAMEMBAFF h mb y 1 1 h prev mb skipped skip h next mb skipped else skip decode cabac mb skip h h mb x h mb y if skip if FRAMEMBAFF h mb y 1 0 h cur pic mb type mb xy MBTYPESKIP h next mb skipped decode cabac mb skip h h mb x h mb y 1 if h next mb skipped h mb mbaff h mb field decoding flag decode cabac field decoding flag h decode mb skip h h cbp table mb xy 0 h chroma pred mode table mb xy 0 h last qscale diff 0 return 0 if FRAMEMBAFF if h mb y 1 0 h mb mbaff h mb field decoding flag decode cabac field decoding flag h h prev mb skipped 0 fill decode neighbors h MBFIELD if h slice type nos AVPICTURETYPEB int ctx 0 assert h slice type nos AVPICTURETYPEB if ISDIRECT h left type LTOP 1 ctx if ISDIRECT h top type 1 ctx if get cabac noinline h cabac h cabac state 27 ctx mb type 0 else if get cabac noinline h cabac h cabac state 27 3 mb type 1 get cabac noinline h cabac h cabac state 27 5 else int bits bits get cabac noinline h cabac h cabac state 27 4 3 bits get cabac noinline h cabac h cabac state 27 5 2 bits get cabac noinline h cabac h cabac state 27 5 1 bits get cabac noinline h cabac h cabac state 27 5 if bits 8 mb type bits 3 else if bits 13 mb type decode cabac intra mb type h 32 0 goto decode intra mb else if bits 14 mb type 11 else if bits 15 mb type 22 else bits bits 1 get cabac noinline h cabac h cabac state 27 5 mb type bits 4 partition count b mb type info mb type partition count mb type b mb type info mb type type else if h slice type nos AVPICTURETYPEP if get cabac noinline h cabac h cabac state 14 0 if get cabac noinline h cabac h cabac state 15 0 mb type 3 get cabac noinline h cabac h cabac state 16 else mb type 2 get cabac noinline h cabac h cabac state 17 partition count p mb type info mb type partition count mb type p mb type info mb type type else mb type decode cabac intra mb type h 17 0 goto decode intra mb else mb type decode cabac intra mb type h 3 1 if h slice type AVPICTURETYPESI mb type mb type assert h slice type nos AVPICTURETYPEI decode intra mb partition count 0 cbp i mb type info mb type cbp h intra16x16 pred mode i mb type info mb type pred mode mb type i mb type info mb type type if MBFIELD mb type MBTYPEINTERLACED h slice table mb xy h slice num if ISINTRAPCM mb type const int mb size ff h264 mb sizes h sps chroma format idc h sps bit depth luma 3 const uint8 t ptr ptr h cabac bytestream if h cabac low 0x1 ptr if CABACBITS 16 if h cabac low 0x1 FF ptr if int h cabac bytestream end ptr mb size return 1 h intra pcm ptr ptr ptr mb size ff init cabac decoder h cabac ptr h cabac bytestream end ptr h cbp table mb xy 0xf7ef h chroma pred mode table mb xy 0 h cur pic qscale table mb xy 0 memset h non zero count mb xy 16 48 h cur pic mb type mb xy mb type h last qscale diff 0 return 0 fill decode caches h mb type if ISINTRA mb type int i pred mode if ISINTR A4x4 mb type if dct8x8 allowed get cabac noinline h cabac h cabac state 399 h neighbor transform size mb type MBTYPE 8x8 DCT for i 0 i 16 i 4 int pred pred intra mode h i int mode decode cabac mb intra4x4 pred mode h pred fill rectangle h intra4x4 pred mode cache scan8 i 2 2 8 mode 1 else for i 0 i 16 i int pred pred intra mode h i h intra4x4 pred mode cache scan8 i decode cabac mb intra4x4 pred mode h pred av dlog h avctx i4x4 pred d mode d n pred h intra4x4 pred mode cache scan8 i write back intra pred mode h if ff h264 check intra4x4 pred mode h 0 return 1 else h intra16x16 pred mode ff h264 check intra pred mode h h intra16x16 pred mode 0 if h intra16x16 pred mode 0 return 1 if decode chroma h chroma pred mode table mb xy pred mode decode cabac mb chroma pre mode h pred mode ff h264 check intra pred mode h pred mode 1 if pred mode 0 return 1 h chroma pred mode pred mode else h chroma pred mode DC 128 PRE D8x8 else if partition count 4 int i j sub partition count 4 list ref 2 4 if h slice type nos AVPICTURETYPEB for i 0 i 4 i h sub mb type i decode cabac b mb sub type h sub partition count i b sub mb type info h sub mb type i partition count h sub mb type i b sub mb type info h sub mb type i type if ISDIRECT h sub mb type 0 h sub mb type 1 h sub mb type 2 h sub mb type 3 ff h264 pred direct motion h mb type h ref cache 0 scan8 4 h ref cache 1 scan8 4 h ref cache 0 scan8 12 h ref cache 1 scan8 12 PARTNOTAVAILABLE for i 0 i 4 i fill rectangle h direct cache scan8 4 i 2 2 8 h sub mb type i 1 0x FF 1 else for i 0 i 4 i h sub mb type i decode cabac p mb sub type h sub partition count i p sub mb type info h sub mb type i partition count h sub mb type i p sub mb type info h sub mb type i type for list 0 list h list count list for i 0 i 4 i if ISDIRECT h sub mb type i continue if ISDIR h sub mb type i 0 list int rc h ref count list MBMBAFF if rc 1 ref list i decode cabac mb ref h list 4 i if ref list i unsigned rc av log h avctx AVLOGERROR Reference d d n ref list i rc return 1 else ref list i 0 else ref list i 1 h ref cache list scan8 4 i 1 h ref cache list scan8 4 i 8 h ref cache list scan8 4 i 9 ref list i if dct8x8 allowed dct8x8 allowed get dct8x8 allowed h for list 0 list h list count list for i 0 i 4 i h ref cache list scan8 4 i h ref cache list scan8 4 i 1 if ISDIRECT h sub mb type i fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 continue if ISDIR h sub mb type i 0 list ISDIRECT h sub mb type i const int sub mb type h sub mb type i const int block width sub mb type MBTYPE 16x16 MBTYPE 16x8 2 1 for j 0 j sub partition count i j int mpx mpy int mx my const int index 4 i block width j int16 t mv cache 2 h mv cache list scan8 index uint8 t mvd cache 2 h mvd cache list scan8 index pred motion h index block width list h ref cache list scan8 index mx my DECODECABACMBMVD h list index tprintf h avctx final mv d d n mx my if ISSUB 8 X8 sub mb type mv cache 1 0 mv cache 8 0 mv cache 9 0 mx mv cache 1 1 mv cache 8 1 mv cache 9 1 my mvd cache 1 0 mvd cache 8 0 mvd cache 9 0 mpx mvd cache 1 1 mvd cache 8 1 mvd cache 9 1 mpy else if ISSUB 8 X4 sub mb type mv cache 1 0 mx mv cache 1 1 my mvd cache 1 0 mpx mvd cache 1 1 mpy else if ISSUB 4 X8 sub mb type mv cache 8 0 mx mv cache 8 1 my mvd cache 8 0 mpx mvd cache 8 1 mpy mv cache 0 0 mx mv cache 0 1 my mvd cache 0 0 mpx mvd cache 0 1 mpy else fill rectangle h mv cache list scan8 4 i 2 2 8 0 4 fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 else if ISDIRECT mb type ff h264 pred direct motion h mb type fill rectangle h mvd cache 0 scan8 0 4 4 8 0 2 fill rectangle h mvd cache 1 scan8 0 4 4 8 0 2 dct8x8 allowed h sps direct 8x8 inference flag else int list i if IS 16 X16 mb type for list 0 list h list count list if ISDIR mb type 0 list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 0 if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 4 4 8 ref 1 for list 0 list h list count list if ISDIR mb type 0 list int mx my mpx mpy pred motion h 0 4 list h ref cache list scan8 0 mx my DECODECABACMBMVD h list 0 tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 4 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 4 4 8 pack16to32 mx my 4 else if IS 16 X8 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 8 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 16 i 4 2 8 ref 1 else fill rectangle h ref cache list scan8 0 16 i 4 2 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 16x8 motion h 8 i list h ref cache list scan8 0 16 i mx my DECODECABACMBMVD h list 8 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 16 i 4 2 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 16 i 4 2 8 0 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 0 4 else assert IS 8 X16 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 4 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 2 i 2 4 8 ref 1 else fill rectangle h ref cache list scan8 0 2 i 2 4 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 8x16 motion h i 4 list h ref cache list scan8 0 2 i mx my DECODECABACMBMVD h list 4 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 2 i 2 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 2 i 2 4 8 0 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 0 4 if ISINTER mb type h chroma pred mode table mb xy 0 write back motion h mb type if ISINTR A16x16 mb type cbp decode cabac mb cbp luma h if decode chroma cbp decode cabac mb cbp chroma h 4 h cbp table mb xy h cbp cbp if dct8x8 allowed cbp 15 ISINTRA mb type mb type MBTYPE 8x8 DCT get cabac noinline h cabac h cabac state 399 h neighbor transform size if CHROM A444 IS 8x8 DCT mb type int i uint8 t nnz cache h non zero count cache for i 0 i 2 i if h left type LEFT i IS 8x8 DCT h left type LEFT i nnz cache 3 8 1 2 8 i nnz cache 3 8 2 2 8 i nnz cache 3 8 6 2 8 i nnz cache 3 8 7 2 8 i nnz cache 3 8 11 2 8 i nnz cache 3 8 12 2 8 i ISINTRA mb type 64 0 if h top type IS 8x8 DCT h top type uint32 t top empty CABACISINTRA mb type 0 0x40404040 AVW N32 A nnz cache 4 8 0 top empty AVW N32 A nnz cache 4 8 5 top empty AVW N32 A nnz cache 4 8 10 top empty h cur pic mb type mb xy mb type if cbp ISINTR A16x16 mb type const uint8 t scan scan8x8 const uint32 t qmul if ISINTERLACED mb type scan8x8 h qscale h field scan8x8 h field scan8x8 q0 scan h qscale h field scan h field scan q0 else scan8x8 h qscale h zigzag scan8x8 h zigzag scan8x8 q0 scan h qscale h zigzag scan h zigzag scan q0 if get cabac noinline h cabac h cabac state 60 h last qscale diff 0 int val 1 int ctx 2 const int max qp 51 6 h sps bit depth luma 8 while get cabac noinline h cabac h cabac state 60 ctx ctx 3 val if val 2 max qp av log h avctx AVLOGERROR cabac decode of qscale diff failed at d d n h mb x h mb y return 1 if val 0x01 val val 1 1 else val val 1 1 h last qscale diff val h qscale val if unsigned h qscale max qp if h qscale 0 h qscale max qp 1 else h qscale max qp 1 h chroma qp 0 get chroma qp h 0 h qscale h chroma qp 1 get chroma qp h 1 h qscale else h last qscale diff 0 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 0 if CHROM A444 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 1 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 2 else if CHROM A422 if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc 422 h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma422 dc scan 8 if cbp 0x20 int c i i8x8 for c 0 c 2 c int16 t mb h mb 16 16 16 c pixel shift qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i8x8 0 i8x8 2 i8x8 for i 0 i 4 i const int index 16 16 c 8 i8x8 i decode cabac residual nondc h mb 4 index scan 1 qmul 15 mb 16 pixel shift else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma dc scan 4 if cbp 0x20 int c i for c 0 c 2 c qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i 0 i 4 i const int index 16 16 c i decode cabac residual nondc h h mb 16 index pixel shift 4 index scan 1 qmul 15 else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else fill rectangle h non zero count cache scan8 0 4 4 8 0 1 fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 h last qscale diff 0 h cur pic qscale table mb xy h qscale write back non zero count h return 0 static inline int h263 mv4 search Mpeg Enc Context s int mx int my int shift Motion Est Context const c s me const int size 1 const int h 8 int block int P 10 2 int dmin sum 0 mx4 sum 0 my4 sum 0 int same 1 const int stride c stride uint8 t mv penalty c current mv penalty init mv4 ref c for block 0 block 4 block int mx4 my4 int pred x4 pred y4 int dmin4 static const int off 4 2 1 1 1 const int mot stride s b8 stride const int mot xy s block index block PLEFT 0 s current picture f motion val 0 mot xy 1 0 PLEFT 1 s current picture f motion val 0 mot xy 1 1 if PLEFT 0 c xmax shift PLEFT 0 c xmax shift if s first slice line block 2 c pred x pred x4 PLEFT 0 c pred y pred y4 PLEFT 1 else PTOP 0 s current picture f motion val 0 mot xy mot stride 0 PTOP 1 s current picture f motion val 0 mot xy mot stride 1 PTOPRIGHT 0 s current picture f motion val 0 mot xy mot stride off block 0 PTOPRIGHT 1 s current picture f motion val 0 mot xy mot stride off block 1 if PTOP 1 c ymax shift PTOP 1 c ymax shift if PTOPRIGHT 0 c xmin shift PTOPRIGHT 0 c xmin shift if PTOPRIGHT 0 c xmax shift PTOPRIGHT 0 c xmax shift if PTOPRIGHT 1 c ymax shift PTOPRIGHT 1 c ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 c pred x pred x4 PMEDIAN 0 c pred y pred y4 PMEDIAN 1 PM V1 0 mx PM V1 1 my dmin4 epzs motion search4 s mx4 my4 P block block s p mv table 1 16 shift dmin4 c sub motion search s mx4 my4 dmin4 block block size h if s dsp me sub cmp 0 s dsp mb cmp 0 int dxy const int offset block 1 block 1 stride 8 uint8 t dest y c scratchpad offset if s quarter sample uint8 t ref c ref block 0 mx4 2 my4 2 stride dxy my4 3 2 mx4 3 if s no rounding s dsp put no rnd qpel pixels tab 1 dxy dest y ref stride else s dsp put qpel pixels tab 1 dxy dest y ref stride else uint8 t ref c ref block 0 mx4 1 my4 1 stride dxy my4 1 1 mx4 1 if s no rounding s dsp put no rnd pixels tab 1 dxy dest y ref stride h else s dsp put pixels tab 1 dxy dest y ref stride h dmin sum mv penalty mx4 pred x4 mv penalty my4 pred y4 c mb penalty factor else dmin sum dmin4 if s quarter sample mx4 sum mx4 2 my4 sum my4 2 else mx4 sum mx4 my4 sum my4 s current picture f motion val 0 s block index block 0 mx4 s current picture f motion val 0 s block index block 1 my4 if mx4 mx my4 my same 0 if same return INTMAX if s dsp me sub cmp 0 s dsp mb cmp 0 dmin sum s dsp mb cmp 0 s s new picture f data 0 s mb x 16 s mb y 16 stride c scratchpad stride 16 if c avctx mb cmp FFCMPCHROMA int dxy int mx my int offset mx ff h263 round chroma mx4 sum my ff h263 round chroma my4 sum dxy my 1 1 mx 1 offset s mb x 8 mx 1 s mb y 8 my 1 s uvlinesize if s no rounding s dsp put no rnd pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put no rnd pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 else s dsp put pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 1 s mb x 8 s mb y 8 s uvlinesize c scratchpad s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 2 s mb x 8 s mb y 8 s uvlinesize c scratchpad 8 s uvlinesize 8 c pred x mx c pred y my switch c avctx mb cmp 0x FF case FFCMPRD return dmin sum default return dmin sum 11 c mb penalty factor static int ar read header struct archive read a struct archive entry entry struct ar ar const char h size t unconsumed char filename AR name size 1 uint64 t number size t bsd name length entry size char p st const void b int r if strncmp h AR fmag offset n 2 0 archive set error a archive EINVAL Incorrect file header signature return ARCHIVEWARN strncpy filename h AR name offset AR name size filename AR name size 0 if a archive archive format ARCHIVEFORMATAR if strncmp filename 1 3 0 a archive archive format ARCHIVEFORMATARBSD else if strchr filename NULL a archive archive format ARCHIVEFORMATARGNU else if strncmp filename SYMDEF 9 0 a archive archive format ARCHIVEFORMATARBSD if a archive archive format ARCHIVEFORMATARGNU a archive archive format name ar GNUSV R4 else if a archive archive format ARCHIVEFORMATARBSD a archive archive format name ar BSD else a archive archive format name ar p filename AR name size 1 while p filename p p 0 p if filename 0 p p 0 if strcmp filename ar parse common header ar entry h archive entry copy pathname entry filename archive entry set filetype entry AEIFREG number ar atol10 h AR size offset AR size size if number SIZEMAX archive set error a archive ARCHIVEERRNOMISC Filename table too large return ARCHIVEFATAL entry size size t number if entry size 0 archive set error a archive EINVAL Invalid string table return ARCHIVEWARN if ar strtab NULL archive set error a archive EINVAL More than one string tables exist return ARCHIVEWARN st malloc entry size if st NULL archive set error a archive ENOMEM Can t allocate filename table buffer return ARCHIVEFATAL ar strtab st ar strtab size entry size if unconsumed archive read consume a unconsumed unconsumed 0 if b archive read ahead a entry size NULLNULL return ARCHIVEFATAL memcpy st b entry size archive read consume a entry size ar entry bytes remaining 0 archive entry set size entry ar entry bytes remaining return ar parse gnu filename table a if filename 0 filename 1 0 filename 1 9 number ar atol10 h AR name offset 1 AR name size 1 if ar strtab NULL number ar strtab size archive set error a archive EINVAL Can t find long filename for entry archive entry copy pathname entry filename ar parse common header ar entry h return ARCHIVEWARN archive entry copy pathname entry ar strtab size t number return ar parse common header ar entry h if strncmp filename 1 3 0 ar parse common header ar entry h number ar atol10 h AR name offset 3 AR name size 3 bsd name length size t number if number uint64 t bsd name length 1 int64 t bsd name length ar entry bytes remaining archive set error a archive ARCHIVEERRNOMISC Bad input file size return ARCHIVEFATAL ar entry bytes remaining bsd name length archive entry set size entry ar entry bytes remaining if unconsumed archive read consume a unconsumed unconsumed 0 if b archive read ahead a bsd name length NULLNULL archive set error a archive ARCHIVEERRNOMISC Truncated input file return ARCHIVEFATAL p char malloc bsd name length 1 if p NULL archive set error a archive ENOMEM Can t allocate fname buffer return ARCHIVEFATAL strncpy p b bsd name length p bsd name length 0 archive read consume a bsd name length archive entry copy pathname entry p free p return ARCHIVEOK if strcmp filename 0 archive entry copy pathname entry r ar parse common header ar entry h archive entry set filetype entry AEIFREG return r if strcmp filename SYMDEF 0 archive entry copy pathname entry filename return ar parse common header ar entry h archive entry copy pathname entry filename return ar parse common header ar entry h static void preview obmc Mpeg Enc Context s Get Bit Context gb s gb int cbpc i pred x pred y mx my int16 t mot val const int xy s mb x 1 s mb y s mb stride const int stride s b8 stride 2 for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x assert s pict type AVPICTURETYPEP do if get bits1 s gb mot val s current picture motion val 0 s block index 0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride 0 mot val 1 mot val 3 mot val 1 stride mot val 3 stride 0 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 while cbpc 20 if cbpc 4 s current picture mb type xy MBTYPEINTRA else get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpc 8 if s modified quant if get bits1 s gb skip bits s gb 1 else skip bits s gb 5 else skip bits s gb 2 if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 mot val ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my end for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x s gb gb static int decode cabac mb skip H264 Context h int mb x int mb y int mba xy mbb xy int ctx 0 if FRAMEMBAFF int mb xy mb x mb y 1 h mb stride mba xy mb xy 1 if mb y 1 h slice table mba xy h slice num MBFIELDISINTERLACED h cur pic mb type mba xy mba xy h mb stride if MBFIELD mbb xy mb xy h mb stride if mb y 1 h slice table mbb xy h slice num ISINTERLACED h cur pic mb type mbb xy mbb xy h mb stride else mbb xy mb x mb y 1 h mb stride else int mb xy h mb xy mba xy mb xy 1 mbb xy mb xy h mb stride FIELDPICTURE if h slice table mba xy h slice num ISSKIP h cur pic mb type mba xy ctx if h slice table mbb xy h slice num ISSKIP h cur pic mb type mbb xy ctx if h slice type nos AVPICTURETYPEB ctx 13 return get cabac noinline h cabac h cabac state 11 ctx static int register interfaces extcap parameters extcap conf const char adb server ip unsigned short adb server tcp port static char packet PACKETLENGTH static char helpful packet PACKETLENGTH char response char device list gssize data length gssize device length socket handle t sock const char adb transport serial templace 04x host transport s const char adb check port templace 04x shell cat proc set tcp const char adb devices 000 E host devices l const char adb api level 0022 shell getprop ro build version sdk const char adb hcidump version 0017 shell hcidump version const char adb ps droid bluetooth 0018 shell ps droid bluetooth const char adb ps bluetooth app 001 E shell ps com android bluetooth const char adb tcpdump help 0010 shell tcpdump h char serial number SERIALNUMBERLENGTHMAX size t serial number length char model name MODELNAMELENGTHMAX int result char pos char i pos char model pos char device pos char prev pos int api level int disable interface sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET return EXITCODEINVALIDSOCKETINTERFACESLIST device list adb send and receive sock adb devices packet sizeof packet device length closesocket sock if device list errmsg print ERROR Cannot get list of interfaces from devices return EXITCODECANNOTGETINTERFACESLIST device list device length 0 pos char device list while pos char device list device length prev pos pos pos strchr pos i pos pos result int pos prev pos pos strchr pos n 1 if result int sizeof serial number verbose print WARNING Serial number too long ignore device n continue memcpy serial number prev pos result serial number result 0 serial number length strlen serial number model name 0 0 model pos g strstr len i pos pos i pos model if model pos device pos g strstr len i pos pos i pos device if device pos device pos model pos 6 1 MODELNAMELENGTHMAX memcpy model name model pos 6 device pos model pos 6 1 model name device pos model pos 6 1 0 if model name 0 0 strcpy model name unknown verbose print VERBOSE Processing device s s n serial number model name sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET continue result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet for transport closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 1 result adb send sock helpful packet if result verbose print WARNING Error while setting adb transport for s n helpful packet closesocket sock else response adb send and read sock adb tcpdump help helpful packet sizeof helpful packet data length closesocket sock if response response data length 0 if strstr response tcpdump version new interface extcap conf INTERFACEANDROIDWIFITCPDUMP model name serial number Android Wi Fi else verbose print WARNING Error on socket s n helpful packet sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET continue result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 2 result adb send sock helpful packet if result verbose print WARNING Error while setting adb transport for s n helpful packet closesocket sock continue response adb send and read sock adb api level helpful packet sizeof helpful packet data length closesocket sock if response verbose print WARNING Error on socket s n helpful packet continue response data length 0 api level int g ascii strtoll response NULL 10 verbose print VERBOSE Android API Level for s is i n serial number api level if api level 21 new interface extcap conf INTERFACEANDROIDLOGCATMAIN model name serial number Android Logcat Main new interface extcap conf INTERFACEANDROIDLOGCATSYSTEM model name serial number Android Logcat System new interface extcap conf INTERFACEANDROIDLOGCATRADIO model name serial number Android Logcat Radio new interface extcap conf INTERFACEANDROIDLOGCATEVENTS model name serial number Android Logcat Events else new interface extcap conf INTERFACEANDROIDLOGCATTEXTMAIN model name serial number Android Logcat Main new interface extcap conf INTERFACEANDROIDLOGCATTEXTSYSTEM model name serial number Android Logcat System new interface extcap conf INTERFACEANDROIDLOGCATTEXTRADIO model name serial number Android Logcat Radio new interface extcap conf INTERFACEANDROIDLOGCATTEXTEVENTS model name serial number Android Logcat Events new interface extcap conf INTERFACEANDROIDLOGCATTEXTCRASH model name serial number Android Logcat Crash if api level 5 api level 17 disable interface 0 sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET continue result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 3 result adb send sock helpful packet if result errmsg print ERROR Error while setting adb transport for s helpful packet closesocket sock return EXITCODEGENERIC response adb send and read sock adb hcidump version helpful packet sizeof helpful packet data length closesocket sock if response data length 1 verbose print WARNING Error while getting hcidump version by s p len GGSSIZEFORMAT n adb hcidump version void response data length verbose print VERBOSE Android hcidump version for s is unknown n serial number disable interface 1 else response data length 0 if g ascii strtoull response NULL 10 0 verbose print VERBOSE Android hcidump version for s is unknown n serial number disable interface 1 else verbose print VERBOSE Android hcidump version for s is s n serial number response if disable interface new interface extcap conf INTERFACEANDROIDBLUETOOTHHCIDUMP model name serial number Android Bluetooth Hcidump if api level 17 api level 21 disable interface 0 sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET continue result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 4 result adb send sock helpful packet if result errmsg print ERROR Error while setting adb transport for s helpful packet closesocket sock return EXITCODEGENERIC response adb send and read sock adb ps droid bluetooth helpful packet sizeof helpful packet data length closesocket sock if response data length 1 verbose print WARNING Error while getting Bluetooth application process id by s p len GGSSIZEFORMAT n adb hcidump version void response data length verbose print VERBOSE Android Bluetooth application PID for s is unknown n serial number disable interface 1 else char data str char pid 16 memset pid 0 sizeof pid response data length 0 data str strchr response n if data str sscanf data str s s pid 1 verbose print VERBOSE Android Bluetooth application PID for s is s n serial number pid sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET return EXITCODEINVALIDSOCKET 1 result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 5 result adb send sock helpful packet if result errmsg print ERROR Error while setting adb transport for s helpful packet closesocket sock return EXITCODEGENERIC result g snprintf char helpful packet PACKETLENGTH adb check port templace strlen adb check port templace 6 strlen pid pid if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 6 response adb send and read sock helpful packet helpful packet sizeof helpful packet data length closesocket sock if response disable interface 1 else response data length 0 data str strchr response n if data str sscanf data str s s pid 1 strcmp pid 9 10 EA 0 verbose print VERBOSE Bluedroid External Parser Port for s is s n serial number pid 9 else disable interface 1 verbose print VERBOSE Bluedroid External Parser Port for s is unknown n serial number else disable interface 1 verbose print VERBOSE Android Bluetooth application PID for s is unknown n serial number if disable interface new interface extcap conf INTERFACEANDROIDBLUETOOTHEXTERNALPARSER model name serial number Android Bluetooth External Parser if api level 21 disable interface 0 sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET continue result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 7 result adb send sock helpful packet if result errmsg print ERROR Error while setting adb transport for s helpful packet closesocket sock return EXITCODEGENERIC if api level 23 response adb send and read sock adb ps bluetooth app helpful packet sizeof helpful packet data length else response adb send and read sock adb ps droid bluetooth helpful packet sizeof helpful packet data length closesocket sock if response data length 1 verbose print WARNING Error while getting Bluetooth application process id by s p len GGSSIZEFORMAT n adb hcidump version void response data length verbose print VERBOSE Android Bluetooth application PID for s is unknown n serial number disable interface 1 else char data str char pid 16 memset pid 0 sizeof pid response data length 0 data str strchr response n if data str sscanf data str s s pid 1 verbose print VERBOSE Android Bluetooth application PID for s is s n serial number pid sock adb connect adb server ip adb server tcp port if sock INVALIDSOCKET return EXITCODEINVALIDSOCKET 2 result g snprintf char helpful packet PACKETLENGTH adb transport serial templace 15 serial number length serial number if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 8 result adb send sock helpful packet if result errmsg print ERROR Error while setting adb transport for s helpful packet closesocket sock return EXITCODEGENERIC result g snprintf char helpful packet PACKETLENGTH adb check port templace strlen adb check port templace 6 strlen pid pid if result 0 result PACKETLENGTH errmsg print ERROR Error while completing adb packet closesocket sock return EXITCODEBADSIZEOFASSEMBLEDADBPACKET 9 response adb send and read sock helpful packet helpful packet sizeof helpful packet data length closesocket sock if response disable interface 1 else response data length 0 data str strchr response n if data str sscanf data str s s pid 1 strcmp pid 9 22 A8 0 verbose print VERBOSE Btsnoop Net Port for s is s n serial number pid 9 else disable interface 1 verbose print VERBOSE Btsnoop Net Port for s is unknown n serial number else disable interface 1 verbose print VERBOSE Android Bluetooth application PID for s is unknown n serial number if disable interface new interface extcap conf INTERFACEANDROIDBLUETOOTHBTSNOOPNET model name serial number Android Bluetooth Btsnoop Net return static inline void vc1 pred mv intfr V C1 Context v int n int dmv x int dmv y int mvn int r x int r y uint8 t is intra Mpeg Enc Context s v s int xy wrap off 0 int A 2 B 2 C 2 int px py int a valid 0 b valid 0 c valid 0 int field a field b field c int total valid num samefield num oppfield int pos c pos b n adj wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture motion val 0 xy 0 0 s mv 0 n 1 s current picture motion val 0 xy 1 0 s current picture motion val 1 xy 0 0 s current picture motion val 1 xy 1 0 if mvn 1 s current picture motion val 0 xy 1 0 0 s current picture motion val 0 xy 1 1 0 s current picture motion val 0 xy wrap 0 0 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy wrap 1 0 0 s current picture motion val 0 xy wrap 1 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture motion val 1 xy 1 0 0 s current picture motion val 1 xy 1 1 0 s current picture motion val 1 xy wrap 0 0 s current picture motion val 1 xy wrap 1 0 s current picture motion val 1 xy wrap 1 0 0 s current picture motion val 1 xy wrap 1 1 0 return off n 0 n 1 1 1 if s mb x n 1 n 3 if v blk mv type xy v blk mv type xy v blk mv type xy 1 A 0 s current picture motion val 0 xy 1 0 A 1 s current picture motion val 0 xy 1 1 a valid 1 else A 0 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 1 off wrap 0 1 1 A 1 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 off wrap 1 1 1 a valid 1 if n 1 v is intra s mb x 1 a valid 0 A 0 A 1 0 else A 0 A 1 0 B 0 B 1 C 0 C 1 0 if n 0 n 1 v blk mv type xy if s first slice line if v is intra s mb x s mb stride b valid 1 n adj n 2 pos b s block index n adj 2 wrap if v blk mv type pos b v blk mv type xy n adj n 2 n 1 B 0 s current picture motion val 0 s block index n adj 2 wrap 0 B 1 s current picture motion val 0 s block index n adj 2 wrap 1 if v blk mv type pos b v blk mv type xy B 0 B 0 s current picture motion val 0 s block index n adj 2 2 wrap 0 1 1 B 1 B 1 s current picture motion val 0 s block index n adj 2 2 wrap 1 1 1 if s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 2 pos c s block index 2 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 2 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index n adj 2 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index n adj 2 2 wrap 2 1 1 if s mb x s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 3 pos c s block index 3 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 1 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index 1 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index 1 2 wrap 2 1 1 else c valid 0 else pos b s block index 1 b valid 1 B 0 s current picture motion val 0 pos b 0 B 1 s current picture motion val 0 pos b 1 pos c s block index 0 c valid 1 C 0 s current picture motion val 0 pos c 0 C 1 s current picture motion val 0 pos c 1 total valid a valid b valid c valid if s mb x n 1 n 3 A 0 A 1 0 if s first slice line v blk mv type xy s first slice line n 2 B 0 B 1 C 0 C 1 0 if v blk mv type xy if s mb width 1 px B 0 py B 1 else if total valid 2 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if total valid if a valid px A 0 py A 1 if b valid px B 0 py B 1 if c valid px C 0 py C 1 else px py 0 else if a valid field a A 1 4 1 0 else field a 0 if b valid field b B 1 4 1 0 else field b 0 if c valid field c C 1 4 1 0 else field c 0 num oppfield field a field b field c num samefield total valid num oppfield if total valid 3 if num samefield 3 num oppfield 3 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if num samefield num oppfield px field a A 0 B 0 py field a A 1 B 1 else px field a A 0 B 0 py field a A 1 B 1 else if total valid 2 if num samefield num oppfield if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else px py 0 else if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else if total valid 1 px a valid A 0 b valid B 0 C 0 py a valid A 1 b valid B 1 C 1 else px py 0 s mv 0 n 0 s current picture motion val 0 xy 0 px dmv x r x r x 1 1 r x s mv 0 n 1 s current picture motion val 0 xy 1 py dmv y r y r y 1 1 r y if mvn 1 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 1 s current picture motion val 0 xy 1 else if mvn 2 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s mv 0 n 1 0 s mv 0 n 0 s mv 0 n 1 1 s mv 0 n 1 static int optimize b MACROBLOCK mb int plane int block TXSIZE tx size int ctx MACROBLOCKD const xd mb e mbd struct macroblock plane const p mb plane plane struct macroblockd plane const pd xd plane plane const int ref is inter block xd mi 0 src mi mbmi vp9 token state tokens 1025 2 unsigned best index 1025 2 uint8 t token cache 1024 const tran low t const coeff BLOCKOFFSET mb plane plane coeff block tran low t const qcoeff BLOCKOFFSET p qcoeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block const int eob p eobs block const PLANETYPE type pd plane type const int default eob 16 tx size 1 const int mul 1 tx size TX 32 X32 const int16 t dequant ptr pd dequant const uint8 t const band translate get band translate tx size const scan order const so get scan xd tx size type block const int16 t const scan so scan const int16 t const nb so neighbors int next eob sz 0 int64 t rdmult mb rdmult plane rd mult type rddiv mb rddiv int64 t rd cost0 rd cost1 int rate0 rate1 error0 error1 t0 t1 int best band pt i final eob assert type plane type plane assert eob default eob if ref rdmult rdmult 9 4 tokens eob 0 rate 0 tokens eob 0 error 0 tokens eob 0 next default eob tokens eob 0 token EOBTOKEN tokens eob 0 qc 0 tokens eob 1 tokens eob 0 for i 0 i eob i token cache scan i vp9 pt energy class vp9 dct value tokens ptr qcoeff scan i token for i eob i 0 int base bits d2 dx const int rc scan i int x qcoeff rc if x int shortcut 0 error0 tokens next 0 error error1 tokens next 1 error rate0 tokens next 0 rate rate1 tokens next 1 rate t0 vp9 dct value tokens ptr x token if next default eob band band translate i 1 pt trellis get coeff context scan nb i t0 token cache rate0 mb token costs tx size type ref band 0 pt tokens next 0 token rate1 mb token costs tx size type ref band 0 pt tokens next 1 token UPDATERDCOST best rd cost1 rd cost0 base bits vp9 dct value cost ptr x dx mul dqcoeff rc coeff rc d2 dx dx tokens i 0 rate base bits best rate1 rate0 tokens i 0 error d2 best error1 error0 tokens i 0 next next tokens i 0 token t0 tokens i 0 qc x best index i 0 best rate0 tokens next 0 rate rate1 tokens next 1 rate if abs x dequant ptr rc 0 abs coeff rc mul abs x dequant ptr rc 0 abs coeff rc mul dequant ptr rc 0 shortcut 1 else shortcut 0 if shortcut sz x 0 x 2 sz 1 if x t0 tokens next 0 token EOBTOKENEOBTOKENZEROTOKEN t1 tokens next 1 token EOBTOKENEOBTOKENZEROTOKEN else t0 t1 vp9 dct value tokens ptr x token if next default eob band band translate i 1 if t0 EOBTOKEN pt trellis get coeff context scan nb i t0 token cache rate0 mb token costs tx size type ref band x pt tokens next 0 token if t1 EOBTOKEN pt trellis get coeff context scan nb i t1 token cache rate1 mb token costs tx size type ref band x pt tokens next 1 token UPDATERDCOST best rd cost1 rd cost0 base bits vp9 dct value cost ptr x if shortcut dx dequant ptr rc 0 sz sz d2 dx dx tokens i 1 rate base bits best rate1 rate0 tokens i 1 error d2 best error1 error0 tokens i 1 next next tokens i 1 token best t1 t0 tokens i 1 qc x best index i 1 best next i else band band translate i 1 t0 tokens next 0 token t1 tokens next 1 token if t0 EOBTOKEN tokens next 0 rate mb token costs tx size type ref band 1 0 t0 tokens next 0 token ZEROTOKEN if t1 EOBTOKEN tokens next 1 rate mb token costs tx size type ref band 1 0 t1 tokens next 1 token ZEROTOKEN best index i 0 best index i 1 0 band band translate i 1 rate0 tokens next 0 rate rate1 tokens next 1 rate error0 tokens next 0 error error1 tokens next 1 error t0 tokens next 0 token t1 tokens next 1 token rate0 mb token costs tx size type ref band 0 ctx t0 rate1 mb token costs tx size type ref band 0 ctx t1 UPDATERDCOST best rd cost1 rd cost0 final eob 1 vpx memset qcoeff 0 sizeof qcoeff 16 tx size 2 vpx memset dqcoeff 0 sizeof dqcoeff 16 tx size 2 for i next i eob i next const int x tokens i best qc const int rc scan i if x final eob i qcoeff rc x dqcoeff rc x dequant ptr rc 0 mul next tokens i best next best best index i best final eob mb plane plane eobs block final eob return final eob void ff fix long p mvs Mpeg Enc Context s Motion Est Context const c s me const int f code s f code int y range assert s pict type AVPICTURETYPEP range s out format FMTMPE G1 s msmpeg4 version 8 16 f code assert range 16 s msmpeg4 version assert range 256 s codec id AVCODECIDMPE G2 VIDEO s avctx strict std compliance FFCOMPLIANCENORMAL if c avctx me range range c avctx me range range c avctx me range if s flags CODECFLAG 4 MV const int wrap s b8 stride for y 0 y s mb height y int xy y 2 wrap int i y s mb stride int x for x 0 x s mb width x if s mb type i CANDIDATEMBTYPEINTE R4 V int block for block 0 block 4 block int off block 1 block 1 wrap int mx s current picture motion val 0 xy off 0 int my s current picture motion val 0 xy off 1 if mx range mx range my range my range s mb type i CANDIDATEMBTYPEINTE R4 V s mb type i CANDIDATEMBTYPEINTRA s current picture mb type i CANDIDATEMBTYPEINTRA xy 2 i static void read intra frame mode info V P9 COMMON const cm MACROBLOCKD const xd int mi row int mi col vp9 reader r MODEINFO const mi xd mi 0 MBMODEINFO const mbmi mi mbmi const MODEINFO above mi xd mi cm mi stride const MODEINFO left mi xd left available xd mi 1 NULL const BLOCKSIZE bsize mbmi sb type int i mbmi segment id read intra segment id cm xd mi row mi col r mbmi skip read skip cm xd mbmi segment id r mbmi tx size read tx size cm xd cm tx mode bsize 1 r mbmi ref frame 0 INTRAFRAME mbmi ref frame 1 NONE switch bsize case BLOCK 4 X4 for i 0 i 4 i mi bmi i as mode read intra mode r get y mode probs mi above mi left mi i mbmi mode mi bmi 3 as mode break case BLOCK 4 X8 mi bmi 0 as mode mi bmi 2 as mode read intra mode r get y mode probs mi above mi left mi 0 mi bmi 1 as mode mi bmi 3 as mode mbmi mode read intra mode r get y mode probs mi above mi left mi 1 break case BLOCK 8 X4 mi bmi 0 as mode mi bmi 1 as mode read intra mode r get y mode probs mi above mi left mi 0 mi bmi 2 as mode mi bmi 3 as mode mbmi mode read intra mode r get y mode probs mi above mi left mi 2 break default mbmi mode read intra mode r get y mode probs mi above mi left mi 0 mbmi uv mode read intra mode r vp9 kf uv mode prob mbmi mode void jpc qmfb split col jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZE jpc fix t buf splitbuf register jpc fix t srcptr register jpc fix t dstptr register int n register int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr srcptr dstptr srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr srcptr dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr srcptr dstptr stride srcptr if buf splitbuf jas free buf static void vdpau h264 set reference frames AV Codec Context avctx H264 Context const h avctx priv data AVVDPAU Context hwctx avctx hwaccel context Vdp Picture Info H264 info hwctx info h264 int list Vdp Reference Frame H264 rf info reference Frames 0 list 2 list Picture lp list h long ref h short ref int i ls list 16 h short ref count for i 0 i ls i Picture pic lp i Vdp Reference Frame H264 rf2 Vdp Video Surface surface ref int pic frame idx if pic pic f reference continue pic frame idx pic long ref pic pic id pic frame num surface ref ff vdpau get surface id pic rf2 info reference Frames 0 while rf2 rf if rf2 surface surface ref rf2 is long term pic long ref rf2 frame idx pic frame idx break rf2 if rf2 rf rf2 top is reference pic f reference PICTTOPFIELDVDPTRUEVDPFALSE rf2 bottom is reference pic f reference PICTBOTTOMFIELDVDPTRUEVDPFALSE continue if rf info reference Frames H264 RFCOUNT continue vdpau h264 set rf rf pic pic f reference rf for rf info reference Frames H264 RFCOUNT rf vdpau h264 clear rf rf static int archive read format cpio read header struct archive read a struct archive entry entry struct cpio cpio const void h struct archive string conv sconv size t namelength size t name pad int r cpio struct cpio a format data sconv cpio opt sconv if sconv NULL if cpio init default conversion cpio sconv default archive string default conversion for read a archive cpio init default conversion 1 sconv cpio sconv default r cpio read header a cpio entry namelength name pad if r ARCHIVEWARN return r h archive read ahead a namelength name pad NULL if h NULL return ARCHIVEFATAL if archive entry copy pathname l entry const char h namelength sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Pathname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Pathname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN cpio entry offset 0 archive read consume a namelength name pad if archive entry filetype entry AEIFLNK if cpio entry bytes remaining 1024 1024 archive set error a archive ENOMEM Rejecting malformed cpio archive symlink contents exceed 1 megabyte return ARCHIVEFATAL h archive read ahead a size t cpio entry bytes remaining NULL if h NULL return ARCHIVEFATAL if archive entry copy symlink l entry const char h size t cpio entry bytes remaining sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Linkname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Linkname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN archive read consume a cpio entry bytes remaining cpio entry bytes remaining 0 if namelength 11 strcmp const char h TRAILER 0 archive clear error a archive return ARCHIVEEOF if record hardlink a cpio entry ARCHIVEOK return ARCHIVEFATAL return r static inline void vc1 pred b mv intfi V C1 Context v int n int dmv x int dmv y int mv1 int pred flag int dir v bmvtype BMVTYPEBACKWARD 1 0 Mpeg Enc Context s v s int mb pos s mb x s mb y s mb stride if v bmvtype BMVTYPEDIRECT int total opp k f if s next picture f mb type mb pos v mb off MBTYPEINTRA s mv 0 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 1 s quarter sample total opp v mv f next 0 s block index 0 v blocks off v mv f next 0 s block index 1 v blocks off v mv f next 0 s block index 2 v blocks off v mv f next 0 s block index 3 v blocks off f total opp 2 1 0 else s mv 0 0 0 s mv 0 0 1 0 s mv 1 0 0 s mv 1 0 1 0 f 0 v ref field type 0 v ref field type 1 v cur field type f for k 0 k 4 k s current picture f motion val 0 s block index k v blocks off 0 s mv 0 0 0 s current picture f motion val 0 s block index k v blocks off 1 s mv 0 0 1 s current picture f motion val 1 s block index k v blocks off 0 s mv 1 0 0 s current picture f motion val 1 s block index k v blocks off 1 s mv 1 0 1 v mv f 0 s block index k v blocks off f v mv f 1 s block index k v blocks off f return if v bmvtype BMVTYPEINTERPOLATED vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 pred flag 0 0 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 pred flag 1 1 return if dir vc1 pred mv v n dmv x 1 dmv y 1 mv1 v range x v range y v mb type 0 pred flag 1 1 if n 3 mv1 vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 0 0 else vc1 pred mv v n dmv x 0 dmv y 0 mv1 v range x v range y v mb type 0 pred flag 0 0 if n 3 mv1 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 0 1 static int cyuv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cyuv Decode Context s avctx priv data unsigned char y plane unsigned char u plane unsigned char v plane int y ptr int u ptr int v ptr const signed char y table const signed char buf 0 const signed char u table const signed char buf 16 const signed char v table const signed char buf 32 unsigned char y pred u pred v pred int stream ptr unsigned char cur byte int pixel groups int ret if avctx codec id AVCODECIDAURA y table u table u table v table if buf size 48 s height s width 3 4 av log avctx AVLOGERROR got a buffer with d bytes when d were expected n buf size 48 s height s width 3 4 return AVERRORINVALIDDATA stream ptr 48 if s frame data 0 avctx release buffer avctx s frame s frame buffer hints FFBUFFERHINTSVALID s frame reference 0 if ret ff get buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret y plane s frame data 0 u plane s frame data 1 v plane s frame data 2 for y ptr 0 u ptr 0 v ptr 0 y ptr s height s frame linesize 0 y ptr s frame linesize 0 s width u ptr s frame linesize 1 s width 4 v ptr s frame linesize 2 s width 4 cur byte buf stream ptr u plane u ptr u pred cur byte 0x F0 y plane y ptr y pred cur byte 0x0 F 4 cur byte buf stream ptr v plane v ptr v pred cur byte 0x F0 y pred y table cur byte 0x0 F y plane y ptr y pred cur byte buf stream ptr y pred y table cur byte 0x0 F y plane y ptr y pred y pred y table cur byte 0x F0 4 y plane y ptr y pred pixel groups s width 4 1 while pixel groups cur byte buf stream ptr u pred u table cur byte 0x F0 4 u plane u ptr u pred y pred y table cur byte 0x0 F y plane y ptr y pred cur byte buf stream ptr v pred v table cur byte 0x F0 4 v plane v ptr v pred y pred y table cur byte 0x0 F y plane y ptr y pred cur byte buf stream ptr y pred y table cur byte 0x0 F y plane y ptr y pred y pred y table cur byte 0x F0 4 y plane y ptr y pred got frame 1 AV Frame data s frame return buf size void vp9 xform quant fp MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize fp 32x32 coeff 1024 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize fp coeff 256 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize fp coeff 64 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize fp coeff 16 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break static void evhttp maybe add content length header struct evkeyvalq headers long content length if evhttp find header headers Transfer Encoding NULL evhttp find header headers Content Length NULL char len 12 evutil snprintf len sizeof len ld content length evhttp add header headers Content Length len int ff alloc picture Mpeg Enc Context s Picture pic int shared const int big mb num s mb stride s mb height 1 1 const int mb array size s mb stride s mb height const int b8 array size s b8 stride s mb height 2 const int b4 array size s b4 stride s mb height 4 int i int r 1 if shared assert pic f data 0 assert pic f type 0 pic f type FFBUFFERTYPESHARED pic f type FFBUFFERTYPESHARED else assert pic f data 0 if alloc frame buffer s pic 0 return 1 s linesize pic f linesize 0 s uvlinesize pic f linesize 1 if pic f qscale table NULL if s encoding FFALLOCZORGOTO s avctx pic mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mc mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mb mean mb array size sizeof int8 t fail FFALLOCZORGOTO s avctx pic f mbskip table mb array size sizeof uint8 t 2 fail FFALLOCZORGOTO s avctx pic qscale table base big mb num s mb stride sizeof uint8 t fail FFALLOCZORGOTO s avctx pic mb type base big mb num s mb stride sizeof uint32 t fail pic f mb type pic mb type base 2 s mb stride 1 pic f qscale table pic qscale table base 2 s mb stride 1 if s out format FMT H264 for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b4 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 2 else if s out format FMT H263 s encoding s avctx debug FFDEBUGMV s avctx debug mv for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b8 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 3 if s avctx debug FFDEBUGDCTCOEFFFFALLOCZORGOTO s avctx pic f dct coeff 64 mb array size sizeof int16 t 6 fail pic f qstride s mb stride FFALLOCZORGOTO s avctx pic f pan scan 1 sizeof AV Pan Scan fail pic owner2 s return 0 fail if r 0 free frame buffer s pic return 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt LOCO Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data int decoded ret if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p key frame 1 switch l mode case LOCOCYU Y2 case LOCOYU Y2 case LOCOUYVY decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height p linesize 1 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height p linesize 2 buf buf size 1 break case LOCOCY V12 case LOCOY V12 decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf buf size 1 break case LOCOCRGB case LOCORGB decoded loco decode plane l p data 0 p linesize 0 avctx height 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 2 avctx width avctx height p linesize 0 buf buf size 3 break case LOCORGBA decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 1 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 2 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 3 avctx width avctx height p linesize 0 buf buf size 4 break got frame 1 return buf size buf too small av log avctx AVLOGERROR Input data too small n return static int sipr decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Sipr Context ctx avctx priv data AV Frame frame data const uint8 t buf avpkt data Sipr Parameters parm const Sipr Mode Param mode par modes ctx mode Get Bit Context gb float samples int subframe size ctx mode MODE 16k LSUBFR 16k SUBFRSIZE int i ret ctx avctx avctx if avpkt size mode par bits per frame 3 av log avctx AVLOGERROR Error processing packet packet size d too small n avpkt size return 1 frame nb samples mode par frames per packet subframe size mode par subframe count if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame data 0 init get bits gb buf mode par bits per frame for i 0 i mode par frames per packet i decode parameters parm gb mode par ctx decode frame ctx parm samples samples subframe size mode par subframe count got frame ptr 1 return mode par bits per frame 3 static int chacha20 poly1305 ctrl EVPCIPHERCTX ctx int type int arg void ptr EVPCHACHAAEADCTX actx aead data ctx switch type case EVPCTRLINIT if actx NULL actx ctx cipher data OPENSSL zalloc sizeof actx Poly1305 ctx size if actx NULLEV Perr EVPFCHACH A20 POL Y1305 CTRLEVPRINITIALIZATIONERROR return 0 actx len aad 0 actx len text 0 actx aad 0 actx mac inited 0 actx tag len 0 actx nonce len 12 actx tls payload length NOTLSPAYLOADLENGTH return 1 case EVPCTRLCOPY if actx EVPCIPHERCTX dst EVPCIPHERCTX ptr dst cipher data OPENSSL memdup actx sizeof actx Poly1305 ctx size if dst cipher data NULLEV Perr EVPFCHACH A20 POL Y1305 CTRLEVPRCOPYERROR return 0 return 1 case EVPCTRLAEADSETIVLEN if arg 0 arg CHACHACTRSIZE return 0 actx nonce len arg return 1 case EVPCTRLAEADSETIVFIXED if arg 12 return 0 actx nonce 0 actx key counter 1 CHACHA U8 TO U32 unsigned char ptr actx nonce 1 actx key counter 2 CHACHA U8 TO U32 unsigned char ptr 4 actx nonce 2 actx key counter 3 CHACHA U8 TO U32 unsigned char ptr 8 return 1 case EVPCTRLAEADSETTAG if arg 0 arg POL Y1305 BLOCKSIZE return 0 if ptr NULL memcpy actx tag ptr arg actx tag len arg return 1 case EVPCTRLAEADGETTAG if arg 0 arg POL Y1305 BLOCKSIZE ctx encrypt return 0 memcpy ptr actx tag arg return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 unsigned int len unsigned char aad ptr temp POL Y1305 BLOCKSIZE len aad EVPAEADTL S1 AADLEN 2 8 aad EVPAEADTL S1 AADLEN 1 if ctx encrypt if len POL Y1305 BLOCKSIZE return 0 len POL Y1305 BLOCKSIZE memcpy temp aad EVPAEADTL S1 AADLEN 2 aad temp temp EVPAEADTL S1 AADLEN 2 unsigned char len 8 temp EVPAEADTL S1 AADLEN 1 unsigned char len actx tls payload length len actx key counter 1 actx nonce 0 actx key counter 2 actx nonce 1 CHACHA U8 TO U32 aad actx key counter 3 actx nonce 2 CHACHA U8 TO U32 aad 4 actx mac inited 0 chacha20 poly1305 cipher ctx NULL aad EVPAEADTL S1 AADLEN return POL Y1305 BLOCKSIZE case EVPCTRLAEADSETMACKEY return 1 default return 1 static void super block yrd V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t psse BLOCKSIZE bs int64 t txfm cache TXMODES int64 t ref best rd MACROBLOCKD xd x e mbd int64 t sse int64 t ret sse psse psse sse assert bs xd mi 0 mbmi sb type if cpi sf tx size search method USELARGESTALL xd lossless vpx memset txfm cache 0 TXMODES sizeof int64 t choose largest tx size cpi x rate distortion skip ret sse ref best rd bs else choose tx size from rd cpi x rate distortion skip ret sse txfm cache ref best rd bs static Py Object get value Py Object self const char buffer int position int type int max Py Object as class unsigned char tz aware unsigned char uuid subtype struct module state state GETSTATE self Py Object value Py Object error switch type case 1 double d if max 8 goto invalid memcpy d buffer position 8 value Py Float From Double d if value return NULL position 8 break case 2 case 14 int value length int buffer position 0 1 if max value length goto invalid position 4 value Py Unicode Decode UT F8 buffer position value length strict if value return NULL position value length 1 break case 3 int size memcpy size buffer position 4 if max size goto invalid value elements to dict self buffer position 4 size 5 as class tz aware uuid subtype if value return NULL if strcmp buffer position 5 ref 0 Py Object dbref Py Object collection Py Dict Get Item String value ref Py Object id Py Dict Get Item String value id Py Object database Py Dict Get Item String value db Py INCREF collection Py Dict Del Item String value ref if id NULL id Py None Py INCREF id else Py INCREF id Py Dict Del Item String value id if database NULL database Py None Py INCREF database else Py INCREF database Py Dict Del Item String value db dbref Py Object Call Function Obj Args state DB Ref collection id database value NULL Py DECREF value value dbref Py DECREF id Py DECREF collection Py DECREF database if value return NULL position size break case 4 int size end memcpy size buffer position 4 if max size goto invalid end position size 1 position 4 value Py List New 0 if value return NULL while position end Py Object to append int type int buffer position int key size strlen buffer position position key size 1 to append get value self buffer position type max key size as class tz aware uuid subtype if to append Py DECREF value return NULL Py List Append value to append Py DECREF to append position break case 5 Py Object data Py Object st int length subtype memcpy length buffer position 4 if max length goto invalid subtype unsigned char buffer position 4 value Py Bytes From String And Size buffer position 5 length position length 5 break if subtype 2 data Py Bytes From String And Size buffer position 9 length 4 else data Py Bytes From String And Size buffer position 5 length data Py String From String And Size buffer position 9 length 4 else data Py String From String And Size buffer position 5 length return static void single motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv MACROBLOCKD xd x e mbd const V P9 COMMON cm cpi common MBMODEINFO mbmi xd mi 0 mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 int bestsme INTMAX int step param int sadpb x sadperbit16 MV mvp full int ref mbmi ref frame 0 MV ref mv mbmi ref mvs ref 0 as mv int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref MV pred mv 3 pred mv 0 mbmi ref mvs ref 0 as mv pred mv 1 mbmi ref mvs ref 1 as mv pred mv 2 x pred mv ref if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv if cpi sf mv auto mv step size cm show frame step param vp9 init search range x max mv context ref cpi mv step param 2 else step param cpi mv step param if cpi sf adaptive motion search bsize BLOCK 64 X64 int boffset 2 b width log2 BLOCK 64 X64 MIN b height log2 bsize b width log2 bsize step param MAX step param boffset if cpi sf adaptive motion search int bwl b width log2 bsize int bhl b height log2 bsize int i int tlevel x pred mv sad ref bwl bhl 4 if tlevel 5 step param 2 for i LASTFRAME i ALTREFFRAME cm show frame i if x pred mv sad ref 3 x pred mv sad i x pred mv ref row 0 x pred mv ref col 0 tmp mv as int INVALIDMV if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return mvp full pred mv x mv best ref index ref mvp full col 3 mvp full row 3 bestsme vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis cpi find fractional mv step x tmp mv as mv ref mv cm allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 rate mv vp9 mv bit cost tmp mv as mv ref mv x nmvjointcost x mvcost MVCOSTWEIGHT if cpi sf adaptive motion search x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i static P Gconn connect DB Archive Handle AH const char reqdb const char requser PQ Exp Buffer Data connstr P Gconn new Conn const char newdb const char newuser char password bool new pass if reqdb newdb P Qdb AH connection else newdb reqdb if requser strlen requser 0 newuser P Quser AH connection else newuser requser ahlog AH 1 connecting to database s as user s n newdb newuser password AH saved Password pg strdup AH saved Password NULL if AH prompt Password TRIYES password NULL password simple prompt Password 100 false if password NULL exit horribly modulename out of memory n init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr newdb do const char keywords 7 const char values 7 keywords 0 host values 0 P Qhost AH connection keywords 1 port values 1 P Qport AH connection keywords 2 user values 2 newuser keywords 3 password values 3 password keywords 4 dbname values 4 connstr data keywords 5 fallback application name values 5 progname keywords 6 NULL values 6 NULL new pass false new Conn P Qconnectdb Params keywords values true if new Conn exit horribly modulename failed to reconnect to database n if P Qstatus new Conn CONNECTIONBAD if P Qconnection Needs Password new Conn exit horribly modulename could not reconnect to database s P Qerror Message new Conn P Qfinish new Conn if password fprintf stderr Password incorrect n fprintf stderr Connecting to s as s n newdb newuser if password free password if AH prompt Password TRINO password simple prompt Password 100 false else exit horribly modulename connection needs password n if password NULL exit horribly modulename out of memory n new pass true while new pass if P Qconnection Used Password new Conn if AH saved Password free AH saved Password AH saved Password pg strdup P Qpass new Conn if password free password term PQ Exp Buffer connstr check database version AHP Qset Notice Processor new Conn notice processor NULL return new Conn void ff vdpau h264 picture complete H264 Context h struct vdpau render state render render struct vdpau render state h cur pic ptr f data 0 assert render render info h264 slice count h slice num if render info h264 slice count 1 return render info h264 is reference h cur pic ptr reference 3 VDPTRUEVDPFALSE render info h264 field pic flag h picture structure PICTFRAME render info h264 bottom field flag h picture structure PICTBOTTOMFIELD render info h264 num ref frames h sps ref frame count render info h264 mb adaptive frame field flag h sps mb aff render info h264 field pic flag render info h264 constrained intra pred flag h pps constrained intra pred render info h264 weighted pred flag h pps weighted pred render info h264 weighted bipred idc h pps weighted bipred idc render info h264 frame mbs only flag h sps frame mbs only flag render info h264 transform 8x8 mode flag h pps transform 8x8 mode render info h264 chroma qp index offset h pps chroma qp index offset 0 render info h264 second chroma qp index offset h pps chroma qp index offset 1 render info h264 pic init qp minus26 h pps init qp 26 render info h264 num ref idx l0 active minus1 h pps ref count 0 1 render info h264 num ref idx l1 active minus1 h pps ref count 1 1 render info h264 log2 max frame num minus4 h sps log2 max frame num 4 render info h264 pic order cnt type h sps poc type render info h264 log2 max pic order cnt lsb minus4 h sps poc type 0 h sps log2 max poc lsb 4 render info h264 delta pic order always zero flag h sps delta pic order always zero flag render info h264 direct 8x8 inference flag h sps direct 8x8 inference flag render info h264 entropy coding mode flag h pps cabac render info h264 pic order present flag h pps pic order present render info h264 deblocking filter control present flag h pps deblocking filter parameters present render info h264 redundant pic cnt present flag h pps redundant pic cnt present memcpy render info h264 scaling lists 4x4 h pps scaling matrix4 sizeof render info h264 scaling lists 4x4 memcpy render info h264 scaling lists 8x8 0 h pps scaling matrix8 0 sizeof render info h264 scaling lists 8x8 0 memcpy render info h264 scaling lists 8x8 1 h pps scaling matrix8 3 sizeof render info h264 scaling lists 8x8 0 ff h264 draw horiz band h 0 h avctx height render bitstream buffers used 0 static void set block size V P9 COMP const cpi int mi row int mi col BLOCKSIZE bsize if cpi common mi cols mi col cpi common mi rows mi row MACROBLOCKD const xd cpi mb e mbd set modeinfo offsets cpi common xd mi row mi col xd mi 0 src mi mbmi sb type bsize duplicate mode info in sb cpi common xd mi row mi col bsize static int dump tablespaces char ts where MYSQLROW row MYSQLRES tableres char buf FNREFLENDYNAMICSTRING sqlbuf int first 0 char extra format UNDOBUFFERSIZE char ubs char endsemi DBUGENTER dump tablespaces mysql query mysql set optimizer switch semijoin off init dynamic string checked sqlbuf SELECTLOGFILEGROUPNAMEFILENAMETOTALEXTENTSINITIALSIZEENGINEEXTRAFROMINFORMATIONSCHEMAFILESWHEREFILETYPEUNDOLOGANDFILENAMEISNOTNULL 256 1024 if ts where dynstr append checked sqlbuf ANDLOGFILEGROUPNAMEINSELECTDISTINCTLOGFILEGROUPNAMEFROMINFORMATIONSCHEMAFILESWHEREFILETYPEDATAFILE dynstr append checked sqlbuf ts where dynstr append checked sqlbuf dynstr append checked sqlbuf GROUPBYLOGFILEGROUPNAMEFILENAMEENGINEORDERBYLOGFILEGROUPNAME if mysql query mysql sqlbuf str tableres mysql store result mysql dynstr free sqlbuf if mysql errno mysql ERBADTABLEERROR mysql errno mysql ERBADDBERROR mysql errno mysql ERUNKNOWNTABLE fprintf md result file n n Not dumping tablespaces as no INFORMATIONSCHEMAFILES table on this server n n check io md result file DBUGRETURN 0 fprintf stderr s Error s when trying to dump tablespaces n my progname short mysql error mysql DBUGRETURN 1 buf 0 0 while row mysql fetch row tableres if strcmp buf row 0 0 first 1 if first print comment md result file 0 n n Logfile group s n n fix for comment row 0 fprintf md result file n CREATE else fprintf md result file n ALTER fprintf md result file LOGFILEGROUP s n ADDUNDOFILE s n row 0 row 1 if first ubs strstr row 5 extra format if ubs break ubs strlen extra format endsemi strstr ubs if endsemi endsemi 0 0 fprintf md result file UNDOBUFFERSIZE s n ubs fprintf md result file INITIALSIZE s n ENGINE s n row 3 row 4 check io md result file if first first 0 strxmov buf row 0 Null S dynstr free sqlbuf mysql free result tableres init dynamic string checked sqlbuf SELECTDISTINCTTABLESPACENAMEFILENAMELOGFILEGROUPNAMEEXTENTSIZEINITIALSIZEENGINEFROMINFORMATIONSCHEMAFILESWHEREFILETYPEDATAFILE 256 1024 if ts where dynstr append checked sqlbuf ts where dynstr append checked sqlbuf ORDERBYTABLESPACENAMELOGFILEGROUPNAME if mysql query with error report mysql tableres sqlbuf str dynstr free sqlbuf DBUGRETURN 1 buf 0 0 while row mysql fetch row tableres if strcmp buf row 0 0 first 1 if first print comment md result file 0 n n Tablespace s n n fix for comment row 0 fprintf md result file n CREATE else fprintf md result file n ALTER fprintf md result file TABLESPACE s n ADDDATAFILE s n row 0 row 1 if first fprintf md result file USELOGFILEGROUP s n EXTENTSIZE s n row 2 row 3 fprintf md result file INITIALSIZE s n ENGINE s n row 4 row 5 check io md result file if first first 0 strxmov buf row 0 Null S mysql free result tableres dynstr free sqlbuf mysql query mysql set optimizer switch default DBUGRETURN 0 static void encode superblock V P9 COMP cpi TOKENEXTRA t int output enabled int mi row int mi col BLOCKSIZE bsize PICKMODECONTEXT ctx V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MODEINFO mi 8x8 xd mi MODEINFO mi mi 8x8 0 MBMODEINFO mbmi mi mbmi const int seg skip vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP const int mis cm mi stride const int mi width num 8x8 blocks wide lookup bsize const int mi height num 8x8 blocks high lookup bsize x skip recode x select tx size mbmi sb type BLOCK 8 X8 cpi oxcf aq mode COMPLEXITYAQ cpi oxcf aq mode CYCLICREFRESHAQ cpi sf allow skip recode if x skip recode cpi sf use nonrd pick mode vpx memset x skip txfm 0 sizeof x skip txfm x skip optimize ctx is coded ctx is coded 1 x use lp32x32fdct cpi sf use lp32x32fdct x skip encode output enabled cpi sf skip encode frame x q index QIDXSKIPTHRESH if x skip encode return set ref ptrs cm xd mbmi ref frame 0 mbmi ref frame 1 cpi zbin mode boost get zbin mode boost mbmi cpi zbin mode boost enabled vp9 update zbin extra cpi x if is inter block mbmi int plane mbmi skip 1 for plane 0 plane MAXMBPLANE plane vp9 encode intra block plane x MAX bsize BLOCK 8 X8 plane if output enabled sum intra stats cm counts mi vp9 tokenize sb cpi t output enabled MAX bsize BLOCK 8 X8 else int ref const int is compound has second ref mbmi for ref 0 ref 1 is compound ref Y V12 BUFFERCONFIG cfg get ref frame buffer cpi mbmi ref frame ref vp9 setup pre planes xd ref cfg mi row mi col xd block refs ref sf if cpi sf reuse inter pred sby seg skip vp9 build inter predictors sby xd mi row mi col MAX bsize BLOCK 8 X8 vp9 build inter predictors sbuv xd mi row mi col MAX bsize BLOCK 8 X8 if x skip mbmi skip 1 vp9 encode sb x MAX bsize BLOCK 8 X8 vp9 tokenize sb cpi t output enabled MAX bsize BLOCK 8 X8 else mbmi skip 1 if output enabled seg skip cm counts skip vp9 get skip context xd 1 reset skip context xd MAX bsize BLOCK 8 X8 if output enabled if cm tx mode TXMODESELECT mbmi sb type BLOCK 8 X8 is inter block mbmi mbmi skip seg skip get tx counts max txsize lookup bsize vp9 get tx size context xd cm counts tx mbmi tx size else int x y TXSIZE tx size if is inter block mi mbmi tx size MIN tx mode to biggest tx size cm tx mode max txsize lookup bsize else tx size bsize BLOCK 8 X8 mbmi tx size TX 4 X4 for y 0 y mi height y for x 0 x mi width x if mi col x cm mi cols mi row y cm mi rows mi 8x8 mis y x mbmi tx size tx size static void predict and reconstruct intra block int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct intra args const args struct intra args arg V P9 COMMON const cm args cm MACROBLOCKD const xd args xd struct macroblockd plane const pd xd plane plane MODEINFO const mi xd mi 0 const PREDICTIONMODE mode plane 0 get y mode mi block mi mbmi uv mode int x y uint8 t dst txfrm block to raster xy plane bsize tx size block x y dst pd dst buf 4 y pd dst stride 4 x vp9 predict intra block xd block tx size 1 b width log2 plane bsize tx size mode dst pd dst stride dst pd dst stride x y plane if mi mbmi skip const int eob vp9 decode block tokens cm xd plane block plane bsize x y tx size args r inverse transform block xd plane block tx size dst pd dst stride eob void vp9 predict intra block const MACROBLOCKD xd int block idx int bwl in TXSIZE tx size PREDICTIONMODE mode const uint8 t ref int ref stride uint8 t dst int dst stride int aoff int loff int plane const int bwl bwl in tx size const int wmask 1 bwl 1 const int have top block idx bwl xd up available const int have left block idx wmask xd left available const int have right block idx wmask wmask const int x aoff 4 const int y loff 4 assert bwl 0 build intra predictors high xd ref ref stride dst dst stride mode tx size have top have left have right x y plane xd bd return void ff MPV common defaults Mpeg Enc Context s s y dc scale table s c dc scale table ff mpeg1 dc scale table s chroma qscale table ff default chroma qscale table s progressive frame 1 s progressive sequence 1 s picture structure PICTFRAME s coded picture number 0 s picture number 0 s input picture number 0 s picture in gop number 0 s f code 1 s b code 1 s picture range start 0 s picture range end MAXPICTURECOUNT s slice context count 1 static void build inter predictors for planes MACROBLOCKD xd BLOCKSIZE bsize int mi row int mi col int plane from int plane to int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane plane from plane plane to plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 src mi mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static void first pass motion search V P9 COMP cpi MACROBLOCK x const MV ref mv MV best mv int best motion err MACROBLOCKD const xd x e mbd MV tmp mv 0 0 MV ref mv full ref mv row 3 ref mv col 3 int num00 tmp err n const BLOCKSIZE bsize xd mi 0 src mi mbmi sb type vp9 variance fn ptr t v fn ptr cpi fn ptr bsize const int new mv mode penalty NEWMVMODEPENALTY int step param 3 int further steps MAXMVSEARCHSTEPS 1 step param const int sr get search range cpi common step param sr further steps sr v fn ptr vf get block variance fn bsize tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv n num00 num00 0 while n further steps n if num00 num00 else tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param n x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv void vp9 xform quant fp MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize fp 32x32 coeff 1024 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize fp coeff 256 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize fp coeff 64 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize fp coeff 16 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break int Get Certificate Failure JNI Env env const Java Param Ref jclass obj const Java Param Ref jobject java web contents enum Certificate Failure NONE 0 CERTIFICATEFAILUNSPECIFIED 1 CERTIFICATEFAILUNTRUSTED 2 CERTIFICATEFAILREVOKED 3 CERTIFICATEFAILNOTYETVALID 4 CERTIFICATEFAILEXPIRED 5 CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS 6 content Web Contents web contents content Web Contents From Java Web Contents java web contents content Navigation Entry entry web contents Get Controller Get Visible Entry if entry return NONE const content SSL Status ssl entry Get SSL switch ssl security style case content SECURITYSTYLEWARNING case content SECURITYSTYLEUNKNOWN case content SECURITYSTYLEUNAUTHENTICATED return NONE case content SECURITYSTYLEAUTHENTICATIONBROKEN case content SECURITYSTYLEAUTHENTICATED if net Is Cert Status Error ssl cert status if ssl cert status net CERTSTATUSAUTHORITYINVALID return CERTIFICATEFAILUNTRUSTED if ssl cert status net CERTSTATUSREVOKED return CERTIFICATEFAILREVOKED if ssl cert status net CERTSTATUSDATEINVALID return CERTIFICATEFAILEXPIRED if ssl cert status net CERTSTATUSUNABLETOCHECKREVOCATION return CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS return CERTIFICATEFAILUNSPECIFIED if ssl content status content SSL Status DISPLAYEDINSECURECONTENT return CERTIFICATEFAILUNSPECIFIED return static void adjust arnr filter V P9 COMP cpi int distance int group boost int arnr frames int arnr strength const V P9 Encoder Config const oxcf cpi oxcf const int frames after arf vp9 lookahead depth cpi lookahead distance 1 int frames fwd cpi oxcf arnr max frames 1 1 int frames bwd int q frames strength if frames fwd frames after arf frames fwd frames after arf if frames fwd distance frames fwd distance frames bwd frames fwd if frames bwd distance frames bwd oxcf arnr max frames 1 0x1 frames frames bwd 1 frames fwd if cpi common current video frame 1 q int vp9 convert qindex to q cpi rc avg frame qindex INTERFRAME else q int vp9 convert qindex to q cpi rc avg frame qindex KEYFRAME if q 16 strength oxcf arnr strength else strength oxcf arnr strength 16 q 2 if strength 0 strength 0 if frames group boost 150 frames group boost 150 frames frames 1 if strength group boost 300 strength group boost 300 if cpi oxcf pass 2 cpi multi arf allowed const GFGROUP const gf group cpi twopass gf group if gf group rf level gf group index GFARFSTD strength 1 arnr frames frames arnr strength strength void do exec struct st command command int error char buf 512 FILE res file char cmd command first argument DYNAMICSTRING ds cmd DYNAMICSTRING ds sorted ds result DBUGENTER do exec DBUGPRINT enter cmd s cmd while cmd my isspace charset info cmd cmd if cmd report or die Missing argument in exec return command last argument command end init dynamic string ds cmd 0 command query len 256 256 do eval ds cmd cmd command end is windows if builtin echo 0 strncmp cmd echo 4 0 replace ds cmd echo 4 builtin echo strlen builtin echo while replace ds cmd 3 4 3 0 DBUGPRINT info Executing s as s command first argument ds cmd str if res file my popen ds cmd r dynstr free ds cmd if command abort on error report or die popen s r failed command first argument return ds result ds res if display result sorted init dynamic string ds sorted 1024 1024 ds result ds sorted while fgets buf sizeof buf res file if disable result log buf strlen buf 1 0 DBUGPRINT exec result s buf else replace dynstr append ds result buf error pclose res file if display result sorted dynstr append sorted ds res ds sorted 0 dynstr free ds sorted if error 0 uint status WEXITSTATUS error int i if command abort on error report or die exec of s failed error d status d errno d n Output from before failure n s n ds cmd str error status errno ds res str dynstr free ds cmd return DBUGPRINT info error d status d error status i match expected error command status NULL if i 0 DBUGPRINT info command s failed with expected error d command first argument status else dynstr free ds cmd if command expected errors count 0 report or die command s failed with wrong error d command first argument status else if command expected errors err 0 type ERRERRNO command expected errors err 0 code errnum 0 log msg exec of s failed error d errno d ds cmd str error errno dynstr free ds cmd report or die command s succeeded should have failed with errno d command first argument command expected errors err 0 code errnum dynstr free ds cmd static void encode sb rt V P9 COMP cpi const Tile Info const tile TOKENEXTRA tp int mi row int mi col int output enabled BLOCKSIZE bsize PCTREE pc tree V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const int bsl b width log2 bsize hbs 1 bsl 4 int ctx PARTITIONTYPE partition BLOCKSIZE subsize if mi row cm mi rows mi col cm mi cols return if bsize BLOCK 8 X8 const int idx str xd mi stride mi row mi col MODEINFO mi 8x8 cm mi idx str src mi ctx partition plane context xd mi row mi col bsize subsize mi 8x8 0 src mi mbmi sb type else ctx 0 subsize BLOCK 4 X4 partition partition lookup bsl subsize if output enabled bsize BLOCK 4 X4 cm counts partition ctx partition switch partition case PARTITIONNONE encode b rt cpi tile tp mi row mi col output enabled subsize pc tree none break case PARTITIONVERT encode b rt cpi tile tp mi row mi col output enabled subsize pc tree vertical 0 if mi col hbs cm mi cols bsize BLOCK 8 X8 encode b rt cpi tile tp mi row mi col hbs output enabled subsize pc tree vertical 1 break case PARTITIONHORZ encode b rt cpi tile tp mi row mi col output enabled subsize pc tree horizontal 0 if mi row hbs cm mi rows bsize BLOCK 8 X8 encode b rt cpi tile tp mi row hbs mi col output enabled subsize pc tree horizontal 1 break case PARTITIONSPLIT subsize get subsize bsize PARTITIONSPLIT encode sb rt cpi tile tp mi row mi col output enabled subsize pc tree split 0 encode sb rt cpi tile tp mi row mi col hbs output enabled subsize pc tree split 1 encode sb rt cpi tile tp mi row hbs mi col output enabled subsize pc tree split 2 encode sb rt cpi tile tp mi row hbs mi col hbs output enabled subsize pc tree split 3 break default assert Invalid partition type break if partition PARTITIONSPLIT bsize BLOCK 8 X8 update partition context xd mi row mi col subsize bsize static gboolean qio channel websock source check G Source source QIO Channel Websock Source wsource QIO Channel Websock Source source GIO Condition cond 0 if wsource wioc rawinput offset wsource wioc io eof cond GIOIN if wsource wioc rawoutput offset QIOCHANNELWEBSOCKMAXBUFFER cond GIOOUT return cond wsource condition void ff release unused pictures Mpeg Enc Context s int remove current int i for i 0 i MAXPICTURECOUNT i if s picture i reference remove current s picture i s current picture ptr ff mpeg unref picture s s picture i static int cavs decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AVS Context h avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data uint32 t stc 1 int input size const uint8 t buf end const uint8 t buf ptr if buf size 0 if h low delay h DPB 0 f data 0 got frame 1 picture h DPB 0 f if h cur f data 0 avctx release buffer avctx h cur f FFSWAPAVS Frame h cur h DPB 0 return 0 buf ptr buf buf end buf buf size for buf ptr avpriv mpv find start code buf ptr buf end stc if stc 0x FFFFF E00 buf ptr buf end return FFMAX 0 buf ptr buf input size buf end buf ptr 8 switch stc case CAVSSTARTCODE init get bits h gb buf ptr input size decode seq header h break case PICISTARTCODE if h got keyframe if h DPB 0 f data 0 avctx release buffer avctx h DPB 0 f if h DPB 1 f data 0 avctx release buffer avctx h DPB 1 f h got keyframe 1 case PICPBSTARTCODE got frame 0 if h got keyframe break init get bits h gb buf ptr input size h stc stc if decode pic h break got frame 1 if h cur f pict type AVPICTURETYPEB if h DPB 1 f data 0 picture h DPB 1 f else got frame 0 else picture h cur f break case EXTSTARTCODE break case USERSTARTCODE break default if stc SLICEMAXSTARTCODE init get bits h gb buf ptr input size decode slice header h h gb break static void pk transaction authorize actions finished cb G Object source object G Async Result res struct Authorize Actions Data data const gchar action id NULL Pk Transaction Private priv data transaction priv g autoptr G Error error NULL g autoptr Polkit Authorization Result result NULL g assert data actions data actions len 0 action id g ptr array index data actions 0 result polkit authority check authorization finish priv authority res error if g cancellable is cancelled priv cancellable priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED The authentication was cancelled due to a timeout pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if result NULL g autofree gchar message NULL priv waiting for auth FALSE g warning failed to check for auth s error message pk transaction status changed emit data transaction PKSTATUSENUMFINISHED message g strdup printf Failed to check for authentication s error message pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED message pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if polkit authorization result get is authorized result if g strcmp0 action id org freedesktop packagekit package install 0 pk bitfield contain priv cached transaction flags PKTRANSACTIONFLAGENUMALLOWREINSTALL g debug allowing just reinstallation pk bitfield add priv cached transaction flags PKTRANSACTIONFLAGENUMJUSTREINSTALL else priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED Failed to obtain authentication pk transaction finished emit data transaction PKEXITENUMFAILED 0 syslog LOGAUTHLOGNOTICE uid i failed to obtain auth priv uid goto out if data actions len 1 priv waiting for auth FALSE pk transaction set state data transaction PKTRANSACTIONSTATEREADY syslog LOGAUTHLOGINFO uid i obtained auth for s priv uid action id else g ptr array remove index data actions 0 pk transaction authorize actions data transaction data role data actions out g ptr array unref data actions g free data static void vc1 decode b mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i j int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 0 int val int first block 1 int dst idx off int fwd int dmv x 2 dmv y 2 pred flag 2 int bmvtype BMVTYPEBACKWARD int idx mbmode interpmvp mquant v pq s mb intra 0 idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 0 0 s current picture motion val 1 s block index 0 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 v mb type 0 s block index i s mb intra v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i if v rangeredfrm for j 0 j 64 j s block i j 1 off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if v fmb is raw fwd v forward mb plane mb pos get bits1 gb else fwd v forward mb plane mb pos if idx mbmode 5 dmv x 0 dmv x 1 dmv y 0 dmv y 1 0 pred flag 0 pred flag 1 0 if fwd bmvtype BMVTYPEFORWARD else bmvtype decode012 gb switch bmvtype case 0 bmvtype BMVTYPEBACKWARD break case 1 bmvtype BMVTYPEDIRECT break case 2 bmvtype BMVTYPEINTERPOLATED interpmvp get bits1 gb v bmvtype bmvtype if bmvtype BMVTYPEDIRECT idx mbmode 1 get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD if bmvtype BMVTYPEINTERPOLATED interpmvp get mvdata interlaced v dmv x 1 dmv y 1 pred flag 1 if bmvtype BMVTYPEDIRECT dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 0 0 vc1 pred b mv intfi v 0 dmv x dmv y 1 pred flag vc1 b mc v dmv x dmv y bmvtype BMVTYPEDIRECT bmvtype mb has coeffs idx mbmode 2 else if fwd bmvtype BMVTYPEFORWARD v bmvtype bmvtype v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x 0 dmv y 0 pred flag 0 0 dmv x 1 dmv y 1 pred flag 1 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x bmvtype BMVTYPEBACKWARD dmv y bmvtype BMVTYPEBACKWARD pred flag bmvtype BMVTYPEBACKWARD vc1 pred b mv intfi v i dmv x dmv y 0 pred flag vc1 mc 4mv luma v i bmvtype BMVTYPEBACKWARD else if i 4 vc1 mc 4mv chroma v bmvtype BMVTYPEBACKWARD mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAYNULL if v ttmbf ttmb 8 ttmb 1 first block 0 static void super block uvrd const V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skippable int64 t sse BLOCKSIZE bsize int64 t ref best rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const TXSIZE uv tx size get uv tx size mbmi xd plane 1 int plane int pnrate 0 pnskip 1 int64 t pndist 0 pnsse 0 if ref best rd 0 goto term if is inter block mbmi int plane for plane 1 plane MAXMBPLANE plane vp9 subtract plane x bsize plane rate 0 distortion 0 sse 0 skippable 1 for plane 1 plane MAXMBPLANE plane txfm rd in plane x pnrate pndist pnskip pnsse ref best rd plane bsize uv tx size cpi sf use fast coef costing if pnrate INTMAX goto term rate pnrate distortion pndist sse pnsse skippable pnskip return term rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 return int ff rv34 decode frame AV Codec Context avctx void data int got picture ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size R V34 Dec Context r avctx priv data Mpeg Enc Context s r s AV Frame pict data Slice Info si int i int slice count const uint8 t slices hdr NULL int last 0 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got picture ptr 1 return 0 if avctx slice count slice count buf 1 slices hdr buf 4 buf 8 slice count buf size 1 8 slice count else slice count avctx slice count if get slice offset avctx slices hdr 0 0 get slice offset avctx slices hdr 0 buf size av log avctx AVLOGERROR Slice offset is invalid n return AVERRORINVALIDDATA init get bits s gb buf get slice offset avctx slices hdr 0 buf size get slice offset avctx slices hdr 0 8 if r parse slice header r r s gb si 0 si start av log avctx AVLOGERROR First slice header is incorrect n return AVERRORINVALIDDATA if s last picture ptr s last picture ptr f data 0 si type AVPICTURETYPEB av log avctx AVLOGERROR Invalid decoder state B frame without reference data n return AVERRORINVALIDDATA if avctx skip frame AVDISCARDNONREF si type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY si type AVPICTURETYPEI avctx skip frame AVDISCARDALL return avpkt size if si start 0 if s mb num left 0 av log avctx AVLOGERROR New frame but still d MB left s mb num left ff er frame end s er ff MPV frame end s if s width si width s height si height int err av log s avctx AVLOGWARNING Changing dimensions to dx d n si width si height s width si width s height si height avcodec set dimensions s avctx s width s height if err ff MPV common frame size change s 0 return err if err rv34 decoder realloc r 0 return err s pict type si type si type AVPICTURETYPEI if ff MPV frame start s s avctx 0 return 1 ff mpeg er frame start s if r tmp b block base int i r tmp b block base av malloc s linesize 48 for i 0 i 2 i r tmp b block y i r tmp b block base i 16 s linesize for i 0 i 4 i r tmp b block uv i r tmp b block base 32 s linesize i 1 8 s uvlinesize i 1 16 r cur pts si pts if s pict type AVPICTURETYPEB r last pts r next pts r next pts r cur pts else int refdist GETPTSDIFF r next pts r last pts int dist0 GETPTSDIFF r cur pts r last pts int dist1 GETPTSDIFF r next pts r cur pts if refdist r mv weight1 r mv weight2 r weight1 r weight2 8192 r scaled weight 0 else r mv weight1 dist0 14 refdist r mv weight2 dist1 14 refdist if r mv weight1 r mv weight2 511 r weight1 r mv weight1 r weight2 r mv weight2 r scaled weight 0 else r weight1 r mv weight1 9 r weight2 r mv weight2 9 r scaled weight 1 s mb x s mb y 0 ff thread finish setup s avctx else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log s avctx AVLOGERROR Decoder needs full frames in frame multithreading mode start MB is d n si start return AVERRORINVALIDDATA for i 0 i slice count i int offset get slice offset avctx slices hdr i int size if i 1 slice count size buf size offset else size get slice offset avctx slices hdr i 1 offset if offset 0 offset buf size av log avctx AVLOGERROR Slice offset is invalid n break r si end s mb width s mb height s mb num left r s mb x r s mb y r s mb width r si start if i 1 slice count if get slice offset avctx slices hdr i 1 0 get slice offset avctx slices hdr i 1 buf size av log avctx AVLOGERROR Slice offset is invalid n break init get bits s gb buf get slice offset avctx slices hdr i 1 buf size get slice offset avctx slices hdr i 1 8 if r parse slice header r r s gb si 0 if i 2 slice count size get slice offset avctx slices hdr i 2 offset else size buf size offset else r si end si start if size 0 size buf size offset av log avctx AVLOGERROR Slice size is invalid n break last rv34 decode slice r r si end buf offset size if last break if s current picture ptr if last if r loop filter r loop filter r s mb height 1 got picture ptr finish frame avctx pict else if HAVETHREADS s avctx active thread type FFTHREADFRAME av log avctx AVLOGINFO marking unfished frame as finished n ff er frame end s er ff MPV frame end s s mb num left 0 ff thread report progress s current picture ptr f INTMAX 0 return AVERRORINVALIDDATA return avpkt size static int mpeg decode frame AV Codec Context avctx void data int got output AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg1 Context s avctx priv data AV Frame picture data Mpeg Enc Context s2 s mpeg enc ctx av dlog avctx fill buffer n if buf size 0 buf size 4 AVR B32 buf SEQENDCODE if s2 low delay 0 s2 next picture ptr int ret av frame ref picture s2 next picture ptr f if ret 0 return ret s2 next picture ptr NULL got output 1 return buf size if s2 flags CODECFLAGTRUNCATED int next ff mpeg1 find frame end s2 parse context buf buf size NULL if ff combine frame s2 parse context next const uint8 t buf buf size 0 return buf size if s mpeg enc ctx allocated 0 avctx codec tag AVR L32 VC R2 vcr2 init sequence avctx s slice count 0 if avctx extradata s extradata decoded int ret decode chunks avctx picture got output avctx extradata avctx extradata size s extradata decoded 1 if ret 0 avctx err recognition AVEFEXPLODE return ret return decode chunks avctx picture got output buf buf size void vp9 vaq frame setup V P9 COMP cpi V P9 COMMON cm cpi common struct segmentation seg cm seg const double base q vp9 convert qindex to q cm base qindex const int base rdmult vp9 compute rd mult cpi cm base qindex cm y dc delta q int i if cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame cpi rc is src frame alt ref vp9 enable segmentation seg vp9 clearall segfeatures seg seg abs delta SEGMENTDELTADATA vp9 clear system state for i ENERGYMIN i ENERGYMAX i int qindex delta segment rdmult if QRATIO i 1 RDMULTRATIO i 1 continue qindex delta vp9 compute qdelta cpi rc base q base q QRATIO i vp9 set segdata seg SEGMENTID i SEGLVLALTQ qindex delta vp9 enable segfeature seg SEGMENTID i SEGLVLALTQ segment rdmult vp9 compute rd mult cpi cm base qindex qindex delta cm y dc delta q RDMULTRATIO i double segment rdmult base rdmult static void slurm rpc submit batch job slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESSDEFTIMERS uint32 t job id 0 priority 0 struct job record job ptr NULL slurm msg t response msg submit response msg t submit msg job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info gid t gid g slurm auth get gid msg auth cred slurmctld config auth info char err msg NULL job submit user msg NULL bool reject job false STARTTIMER debug2 Processing RPCREQUESTSUBMITBATCHJOB from uid d uid if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if error code valid id REQUESTSUBMITBATCHJOB job desc msg uid gid reject job true goto send msg if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTSUBMITBATCHJOB lacks alloc node from uid d uid dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if error code reject job true goto send msg throttle start active rpc cnt lock slurmctld job write lock STARTTIMER if fed mgr fed rec if fed mgr job allocate msg job desc msg false uid msg protocol version job id error code err msg reject job true else job desc msg pack job offset NOVAL error code job allocate job desc msg job desc msg immediate false NULL 0 uid job ptr err msg msg protocol version if job ptr error code job ptr job state JOBFAILED reject job true else job id job ptr job id priority job ptr priority if job desc msg immediate error code SLURMSUCCESS error code ESLURMCANNOTSTARTIMMEDIATELY reject job true unlock slurmctld job write lock throttle fini active rpc cnt send msg ENDTIME R2 slurm rpc submit batch job if reject job info s s func slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else info s Job Id u Init Prio u s func job id priority TIMESTR submit msg job id job id submit msg step id SLURMBATCHSCRIPT submit msg error code error code submit msg job submit user msg job submit user msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg conn msg conn response msg msg type RESPONSESUBMITBATCHJOB response msg data submit msg slurm send node msg msg conn fd response msg schedule job save schedule node save queue job scheduler xfree err msg xfree job submit user msg static int h261 decode mb H261 Context h Mpeg Enc Context const s h s int i cbp xy cbp 63 do h mba diff get vlc2 s gb h261 mba vlc table H261 MBAVLCBITS 2 if h mba diff MBASTARTCODE h gob start code skipped 1 return SLICEEND while h mba diff MBASTUFFING if h mba diff 0 if get bits left s gb 7 return SLICEEND av log s avctx AVLOGERROR illegal mba at d d n s mb x s mb y return SLICEERROR h mba diff 1 h current mba h mba diff if h current mba MBASTUFFING return SLICEERROR s mb x h gob number 1 2 11 h current mba 1 11 s mb y h gob number 1 2 3 h current mba 1 11 xy s mb x s mb y s mb stride ff init block index s ff update block index s h mtype get vlc2 s gb h261 mtype vlc table H261 MTYPEVLCBITS 2 h mtype h261 mtype map h mtype if ISQUANT h mtype ff set qscale s get bits s gb 5 s mb intra ISINTR A4x4 h mtype if IS 16 X16 h mtype if h current mba 1 h current mba 12 h current mba 23 h mba diff 1 h current mv x 0 h current mv y 0 h current mv x decode mv component s gb h current mv x h current mv y decode mv component s gb h current mv y else h current mv x 0 h current mv y 0 if HASCBP h mtype cbp get vlc2 s gb h261 cbp vlc table H261 CBPVLCBITS 2 1 if s mb intra s current picture mb type xy MBTYPEINTRA goto intra s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 s mv 0 0 0 h current mv x 2 s mv 0 0 1 h current mv y 2 intra if s mb intra HASCBP h mtype s dsp clear blocks s block 0 for i 0 i 6 i if h261 decode block h s block i i cbp 32 0 return SLICEERROR cbp cbp else for i 0 i 6 i s block last index i 1 ff MPV decode mb s s block return static int decode udvm multitype operand guint8 buff guint operand address guint16 value guint test bits guint bytecode guint offset operand address guint16 operand guint32 result guint8 temp data guint16 temp data16 guint16 memmory addr 0 value 0 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 0xc0 6 switch test bits case 0 operand buff operand address value operand offset break case 1 memmory addr bytecode 0x3f 2 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset break case 2 test bits bytecode 0xe0 5 if test bits 5 temp data buff operand address 0x1f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data value operand offset offset 2 else test bits bytecode 0xf0 4 if test bits 9 temp data buff operand address 0x0f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 61440 value operand offset offset 2 else test bits bytecode 0x08 3 if test bits 1 result 1 buff operand address 0x07 8 operand result 0xffff value operand offset else test bits bytecode 0x0e 1 if test bits 3 result 1 buff operand address 0x01 6 operand result 0xffff value operand offset else offset temp data16 buff operand address 1 0xffff 8 temp data16 temp data16 buff operand address 2 0xffff if bytecode 0x01 1 memmory addr temp data16 temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 break case 3 test bits bytecode 0x20 5 if test bits 1 operand buff operand address 0x1f 65504 value operand offset else memmory addr buff operand address 0x1f memmory addr memmory addr 8 memmory addr memmory addr buff operand address 1 0xffff temp data16 buff memmory addr 8 temp data16 temp data16 buff memmory addr 1 0xffff value temp data16 offset offset 2 default break return offset void vp9 loop filter frame mt Y V12 BUFFERCONFIG frame V P9 Decoder pbi V P9 COMMON cm int frame filter level int y only V P9 Lf Sync const lf sync pbi lf row sync const V P9 Worker Interface const winterface vp9 get worker interface const int sb rows mi cols aligned to sb cm mi rows MIBLOCKSIZELO G2 const int tile cols 1 cm log2 tile cols const int num workers MIN pbi max threads 1 tile cols int i if frame filter level return if lf sync sync range cm last height cm height vp9 loop filter dealloc lf sync vp9 loop filter alloc lf sync cm sb rows cm width vp9 loop filter frame init cm frame filter level vpx memset lf sync cur sb col 1 sizeof lf sync cur sb col sb rows for i 0 i num workers i V P9 Worker const worker pbi tile workers i Tile Worker Data const tile data Tile Worker Data worker data1 LF Worker Data const lf data tile data lfdata worker hook V P9 Worker Hook loop filter row worker lf data frame buffer frame lf data cm cm vp9 copy lf data planes pbi mb plane lf data start i lf data stop sb rows lf data y only y only lf data lf sync lf sync lf data num lf workers num workers if i num workers 1 winterface execute worker else winterface launch worker for i 0 i num workers i winterface sync pbi tile workers i static void build inter predictors MACROBLOCKD xd int plane int block int bw int bh int x int y int w int h int mi x int mi y struct macroblockd plane const pd xd plane plane const MODEINFO mi xd mi 0 const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter int ref for ref 0 ref 1 is compound ref const struct scale factors const sf xd block refs ref sf struct buf 2d const pre buf pd pre ref struct buf 2d const dst buf pd dst uint8 t const dst dst buf buf dst buf stride y x const MV mv mi mbmi sb type BLOCK 8 X8 average split mvs pd mi ref block mi mbmi mv ref as mv const MV mv q4 clamp mv to umv border sb xd mv bw bh pd subsampling x pd subsampling y uint8 t pre M V32 scaled mv int xs ys subpel x subpel y if vp9 is scaled sf pre pre buf buf scaled buffer offset x y pre buf stride sf scaled mv vp9 scale mv mv q4 mi x x mi y y sf xs sf x step q4 ys sf y step q4 else pre pre buf buf y pre buf stride x scaled mv row mv q4 row scaled mv col mv q4 col xs ys 16 subpel x scaled mv col SUBPELMASK subpel y scaled mv row SUBPELMASK pre scaled mv row SUBPELBITS pre buf stride scaled mv col SUBPELBITS inter predictor pre pre buf stride dst dst buf stride subpel x subpel y sf w h ref kernel xs ys static int testit struct test case struct tc int retval wordexp t we sav we char dummy int bzzzt 0 int start offs 0 int i if tc env setenv var tc env 1 else unsetenv var if tc ifs setenv IFS tc ifs 1 else unsetenv IFS sav we we wordc 99 sav we we wordv dummy sav we we offs 3 we sav we printf Test d s tests tc words if tc flags WRDENOCMD registered forks 0 if tc flags WRDEAPPEND if wordexp pre1 pre2 we tc flags WRDEAPPEND 0 printf FAILED setup n return 1 retval wordexp tc words we tc flags if tc flags WRDENOCMD registered forks 0 printf FAILED fork called for WRDENOCMD n return 1 if tc flags WRDEDOOFFS start offs sav we we offs if retval tc retval retval 0 we we wordc tc wordc bzzzt 1 else if retval 0 for i 0 i start offs i if we we wordv i NULL bzzzt 1 break for i 0 i we we wordc i if we we wordv i start offs NULL strcmp tc wordv i we we wordv i start offs 0 bzzzt 1 break if bzzzt printf FAILED n printf Test words s need retval d wordc Zd n tc words tc retval tc wordc if start offs 0 printf preceded by d NUL Ls n start offs printf Got retval d wordc Zd retval we we wordc if retval 0 retval WRDENOSPACE for i 0 i we we wordc start offs i if we we wordv i NULL printf NULL else printf s we we wordv i printf n else if retval 0 retval WRDENOSPACE we we wordc sav we we wordc we we wordv sav we we wordv we we offs sav we we offs bzzzt 1 printf FAILED to restore wordexp t members n else printf OK n if retval 0 retval WRDENOSPACE wordfree we return bzzzt static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w AV Frame pic avctx coded frame const uint8 t src avpkt data uint8 t Y1 Y2 UV int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 3 2 16 av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 if AVR L32 src 0x01000002 av log ask for sample avctx Unknown frame header X n AVR L32 src return AVERRORPATCHWELCOME src 16 Y1 pic data 0 Y2 pic data 0 pic linesize 0 U pic data 1 V pic data 2 for h 0 h avctx height h 2 for w 0 w avctx width w 2 AVCOP Y16 Y1 w src AVCOP Y16 Y2 w src 2 U w 1 src 4 0x80 V w 1 src 5 0x80 src 6 Y1 pic linesize 0 1 Y2 pic linesize 0 1 U pic linesize 1 V pic linesize 2 got frame 1 AV Frame data pic return avpkt size static void rv30 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int loc lim cur lim left lim 0 top lim 0 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if mb x left lim rv30 loop filt lim s current picture ptr f qscale table mb pos 1 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize 4 mb x for i mb x i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if i r deblock coefs mb pos 1 1 ij 3 loc lim left lim else if i r deblock coefs mb pos 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter Y 1 s linesize loc lim for k 0 k 2 k int cur cbp left cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if mb x left cbp r cbp chroma mb pos 1 k 4 0x F for j 0 j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize 4 mb x for i mb x i 2 i C 4 int ij i j 1 loc lim 0 if cur cbp 1 ij loc lim cur lim else if i left cbp 1 ij 1 loc lim left lim else if i cur cbp 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter C 1 s uvlinesize loc lim mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if row top lim rv30 loop filt lim s current picture ptr f qscale table mb pos s mb stride for j 4 row j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if j r deblock coefs mb pos s mb stride 1 ij 12 loc lim top lim else if j r deblock coefs mb pos 1 ij 4 loc lim cur lim if loc lim rv30 weak loop filter Y s linesize 1 loc lim for k 0 k 2 k int cur cbp top cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if row top cbp r cbp chroma mb pos s mb stride k 4 0x F for j 4 row j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize for i 0 i 2 i C 4 int ij i j 1 loc lim 0 if r cbp chroma mb pos 1 ij loc lim cur lim else if j top cbp 1 ij 2 loc lim top lim else if j cur cbp 1 ij 2 loc lim cur lim if loc lim rv30 weak loop filter C s uvlinesize 1 loc lim void ff h263 update motion val Mpeg Enc Context s const int mb xy s mb y s mb stride s mb x const int wrap s b8 stride const int xy s block index 0 s current picture f mbskip table mb xy s mb skipped if s mv type MVTYPE 8 X8 int motion x motion y if s mb intra motion x 0 motion y 0 else if s mv type MVTYPE 16 X16 motion x s mv 0 0 0 motion y s mv 0 0 1 else int i motion x s mv 0 0 0 s mv 0 1 0 motion y s mv 0 0 1 s mv 0 1 1 motion x motion x 1 motion x 1 for i 0 i 2 i s p field mv table i 0 mb xy 0 s mv 0 i 0 s p field mv table i 0 mb xy 1 s mv 0 i 1 s current picture f ref index 0 4 mb xy s current picture f ref index 0 4 mb xy 1 s field select 0 0 s current picture f ref index 0 4 mb xy 2 s current picture f ref index 0 4 mb xy 3 s field select 0 1 s current picture f motion val 0 xy 0 motion x s current picture f motion val 0 xy 1 motion y s current picture f motion val 0 xy 1 0 motion x s current picture f motion val 0 xy 1 1 motion y s current picture f motion val 0 xy wrap 0 motion x s current picture f motion val 0 xy wrap 1 motion y s current picture f motion val 0 xy 1 wrap 0 motion x s current picture f motion val 0 xy 1 wrap 1 motion y if s encoding if s mv type MVTYPE 8 X8 s current picture f mb type mb xy MBTYPE L0 MBTYPE 8x8 else if s mb intra s current picture f mb type mb xy MBTYPEINTRA else s current picture f mb type mb xy MBTYPE L0 MBTYPE 16x16 P Gconn Get Connection void P Gconn tmpconn int argcount 7 int i const char keywords const char values const char tmpparam bool need password P Qconninfo Option conn opts NULLP Qconninfo Option conn opt char err msg NULL i 0 if connection string conn opts P Qconninfo Parse connection string err msg if conn opts NULL fprintf stderr s s progname err msg exit 1 for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 argcount keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 keywords i conn opt keyword values i conn opt val i else keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values keywords i dbname values i dbname NULL replication dbname i keywords i replication values i dbname NULL true database i keywords i fallback application name values i progname i if dbhost keywords i host values i dbhost i if dbuser keywords i user values i dbuser i if dbport keywords i port values i dbport i need password dbgetpassword 1 dbpassword NULL do if need password if dbpassword free dbpassword dbpassword simple prompt Password 100 false need password false if dbpassword keywords i password values i dbpassword else keywords i NULL values i NULL tmpconn P Qconnectdb Params keywords values true if tmpconn fprintf stderr s could not connect to server n progname exit 1 if P Qstatus tmpconn CONNECTIONBADP Qconnection Needs Password tmpconn dbgetpassword 1 P Qfinish tmpconn need password true while need password if P Qstatus tmpconn CONNECTIONOK fprintf stderr s could not connect to server s progname P Qerror Message tmpconn P Qfinish tmpconn free values free keywords if conn opts P Qconninfo Free conn opts return NULL free values free keywords if conn opts P Qconninfo Free conn opts tmpparam P Qparameter Status tmpconn integer datetimes if tmpparam fprintf stderr s could not determine server setting for integer datetimes n progname P Qfinish tmpconn exit 1 fprintf stderr s integer datetimes compile flag does not match server n progname P Qfinish tmpconn exit 1 static VALUE int ossl asn1 decode0 cons unsigned char pp long max len long length long offset int depth int yield int j int tag VALUE tc long num read VALUE value asn1data ary int infinite long available len off offset infinite j 0x21 ary rb ary new available len infinite max len length while available len 0 long inner read 0 value ossl asn1 decode0 pp available len off depth 1 yield inner read num read inner read available len inner read rb ary push ary value if infinite NU M2 INT ossl asn1 get tag value VAS N1 EOC ossl asn1 get tag class value sym UNIVERSAL break if tc sym UNIVERSALVALUE args 4 int not sequence or set not sequence or set tag VAS N1 SEQUENCE tag VAS N1 SET if not sequence or set if infinite asn1data rb obj alloc c AS N1 Constructive else ossl raise e AS N1 Error invalid non infinite tag return Qnil else VALUE klass ossl asn1 info tag klass asn1data rb obj alloc klass args 0 ary args 1 IN T2 NUM tag args 2 Qnil args 3 tc ossl asn1 initialize 4 args asn1data else asn1data rb obj alloc c AS N1 Data ossl asn1data initialize asn1data ary IN T2 NUM tag tc if infinite ossl asn1 set infinite length asn1data Qtrue else ossl asn1 set infinite length asn1data Qfalse offset off return asn1data void http suite void http base test http bad header test http parse query test http basic test http connection test 0 http connection test 1 http close detection 0 http close detection 1 http bad request http post test http failure test http highport test http dispatcher test http multi line header test http negative content length test http chunked test http terminate chunked test static int skip check Mpeg Enc Context s Picture p Picture ref int x y plane int score 0 int64 t score64 0 for plane 0 plane 3 plane const int stride p f linesize plane const int bw plane 1 2 for y 0 y s mb height bw y for x 0 x s mb width bw x int off p f type FFBUFFERTYPESHARED 0 16 uint8 t dptr p f data plane 8 x y stride off uint8 t rptr ref f data plane 8 x y stride int v s dsp frame skip cmp 1 s dptr rptr stride 8 switch s avctx frame skip exp case 0 score FFMAX score v break case 1 score FFABS v break case 2 score v v break case 3 score64 FFABS v v int64 t v break case 4 score64 v v int64 t v v break if score score64 score if score64 s avctx frame skip threshold return 1 if score64 s avctx frame skip factor int64 t s lambda 8 return 1 return 0 static int rpza decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Rpza Context s avctx priv data int ret s buf buf s size buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret rpza decode stream s if ret av frame ref data s frame 0 return ret got frame 1 return buf size static void fill decode neighbors H264 Context h int mb type const int mb xy h mb xy int topleft xy top xy topright xy left xy LEFTMBS static const uint8 t left block options 4 32 0 1 2 3 7 10 8 11 3 0 4 3 1 4 3 2 4 3 3 4 1 4 4 1 8 4 1 5 4 1 9 4 2 2 3 3 8 11 8 11 3 2 4 3 2 4 3 3 4 3 3 4 1 5 4 1 9 4 1 5 4 1 9 4 0 0 1 1 7 10 7 10 3 0 4 3 0 4 3 1 4 3 1 4 1 4 4 1 8 4 1 4 4 1 8 4 0 2 0 2 7 10 7 10 3 0 4 3 2 4 3 0 4 3 2 4 1 4 4 1 8 4 1 4 4 1 8 4 h topleft partition 1 top xy mb xy h mb stride MBFIELD topleft xy top xy 1 topright xy top xy 1 left xy LBOT left xy LTOP mb xy 1 h left block left block options 0 if FRAMEMBAFF const int left mb field flag ISINTERLACED h cur pic f mb type mb xy 1 const int curr mb field flag ISINTERLACED mb type if h mb y 1 if left mb field flag curr mb field flag left xy LBOT left xy LTOP mb xy h mb stride 1 if curr mb field flag left xy LBOT h mb stride h left block left block options 3 else topleft xy h mb stride h topleft partition 0 h left block left block options 1 else if curr mb field flag topleft xy h mb stride h cur pic f mb type top xy 1 7 1 1 topright xy h mb stride h cur pic f mb type top xy 1 7 1 1 top xy h mb stride h cur pic f mb type top xy 7 1 1 if left mb field flag curr mb field flag if curr mb field flag left xy LBOT h mb stride h left block left block options 3 else h left block left block options 2 h topleft mb xy topleft xy h top mb xy top xy h topright mb xy topright xy h left mb xy LTOP left xy LTOP h left mb xy LBOT left xy LBOT h topleft type h cur pic f mb type topleft xy h top type h cur pic f mb type top xy h topright type h cur pic f mb type topright xy h left type LTOP h cur pic f mb type left xy LTOP h left type LBOT h cur pic f mb type left xy LBOT if FMO if h slice table topleft xy h slice num h topleft type 0 if h slice table top xy h slice num h top type 0 if h slice table left xy LTOP h slice num h left type LTOP h left type LBOT 0 else if h slice table topleft xy h slice num h topleft type 0 if h slice table top xy h slice num h top type 0 if h slice table left xy LTOP h slice num h left type LTOP h left type LBOT 0 if h slice table topright xy h slice num h topright type 0 static V P9 DENOISERDECISION perform motion compensation V P9 DENOISER denoiser MACROBLOCK mb BLOCKSIZE bs int increase denoising int mi row int mi col PICKMODECONTEXT ctx int motion magnitude int mv col mv row int sse diff ctx zeromv sse ctx newmv sse MVREFERENCEFRAME frame MACROBLOCKD filter mbd mb e mbd MBMODEINFO mbmi filter mbd mi 0 mbmi MBMODEINFO saved mbmi int i j struct buf 2d saved dst MAXMBPLANE struct buf 2d saved pre MAXMBPLANE 2 saved mbmi mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j saved pre i j filter mbd plane i pre j saved dst i filter mbd plane i dst mv col ctx best sse mv as mv col mv row ctx best sse mv as mv row motion magnitude mv row mv row mv col mv col frame ctx best reference frame if frame INTRAFRAME sse diff sse diff thresh bs increase denoising mv row mv col mbmi ref frame 0 ctx best reference frame mbmi mode ctx best sse inter mode mbmi mv 0 ctx best sse mv else frame ctx best zeromv reference frame mbmi ref frame 0 ctx best zeromv reference frame mbmi mode ZEROMV mbmi mv 0 as int 0 ctx best sse inter mode ZEROMV ctx best sse mv as int 0 ctx newmv sse ctx zeromv sse for j 0 j 2 j filter mbd plane 0 pre j buf block start denoiser running avg y frame y buffer denoiser running avg y frame y stride mi row mi col filter mbd plane 0 pre j stride denoiser running avg y frame y stride filter mbd plane 1 pre j buf block start denoiser running avg y frame u buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 1 pre j stride denoiser running avg y frame uv stride filter mbd plane 2 pre j buf block start denoiser running avg y frame v buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 2 pre j stride denoiser running avg y frame uv stride filter mbd plane 0 dst buf block start denoiser mc running avg y y buffer denoiser mc running avg y y stride mi row mi col filter mbd plane 0 dst stride denoiser mc running avg y y stride filter mbd plane 1 dst buf block start denoiser mc running avg y u buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 1 dst stride denoiser mc running avg y uv stride filter mbd plane 2 dst buf block start denoiser mc running avg y v buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 2 dst stride denoiser mc running avg y uv stride vp9 build inter predictors sby filter mbd mv row mv col bs mbmi saved mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j filter mbd plane i pre j saved pre i j filter mbd plane i dst saved dst i mv row ctx best sse mv as mv row mv col ctx best sse mv as mv col if ctx newmv sse sse thresh bs increase denoising return COPYBLOCK if mv row mv row mv col mv col noise motion thresh bs increase denoising return COPYBLOCK return static void rv40 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int alpha beta beta Y beta C int q int mbtype 4 int mb strong 4 int clip 4 int cbp 4 int uvcbp 4 2 unsigned mvmasks 4 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r cbp luma mb pos r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int y h deblock y v deblock int c v deblock 2 c h deblock 2 int clip left int avail 4 unsigned y to deblock int c to deblock 2 q s current picture ptr f qscale table mb pos alpha rv40 alpha tab q beta rv40 beta tab q beta Y beta C beta 3 if s width s height 176 144 beta Y beta avail 0 1 avail 1 row avail 2 mb x avail 3 row s mb height 1 for i 0 i 4 i if avail i int pos mb pos neighbour offs x i neighbour offs y i s mb stride mvmasks i r deblock coefs pos mbtype i s current picture ptr f mb type pos cbp i r cbp luma pos uvcbp i 0 r cbp chroma pos 0x F uvcbp i 1 r cbp chroma pos 4 else mvmasks i 0 mbtype i mbtype 0 cbp i 0 uvcbp i 0 uvcbp i 1 0 mb strong i ISINTRA mbtype i ISSEPARATEDC mbtype i clip i rv40 filter clip tbl mb strong i 1 q y to deblock mvmasks POSCUR mvmasks POSBOTTOM 16 y h deblock y to deblock cbp POSCUR 4 MASKYTOPROW cbp POSTOPMASKYLASTROW 12 y v deblock y to deblock cbp POSCUR 1 MASKYLEFTCOL cbp POSLEFTMASKYRIGHTCOL 3 if mb x y v deblock MASKYLEFTCOL if row y h deblock MASKYTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM y h deblock MASKYTOPROW 16 for i 0 i 2 i c to deblock i uvcbp POSBOTTOM i 4 uvcbp POSCUR i c v deblock i c to deblock i uvcbp POSCUR i 1 MASKCLEFTCOL uvcbp POSLEFT i MASKCRIGHTCOL 1 c h deblock i c to deblock i uvcbp POSTOP i MASKCLASTROW 2 uvcbp POSCUR i 2 if mb x c v deblock i MASKCLEFTCOL if row c h deblock i MASKCTOPROW if row s mb height 1 mb strong POSCUR mb strong POSBOTTOM c h deblock i MASKCTOPROW 4 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j int clip cur y to deblock MASKCUR ij clip POSCUR 0 int dither j ij i 4 if y h deblock MASKBOTTOM ij rv40 adaptive loop filter r rdsp Y 4 s linesize s linesize dither y to deblock MASKBOTTOM ij clip POSCUR 0 clip cur alpha beta beta Y 0 0 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 else clip left y to deblock MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 0 1 if j y h deblock MASKCUR i mb strong POSCUR mb strong POSTOP rv40 adaptive loop filter r rdsp Y s linesize dither clip cur mvmasks POSTOPMASKTOP i clip POSTOP 0 alpha beta beta Y 0 1 0 if y v deblock MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left mvmasks POSLEFTMASKRIGHT j clip POSLEFT 0 rv40 adaptive loop filter r rdsp Y s linesize dither clip cur clip left alpha beta beta Y 0 1 1 for k 0 k 2 k for j 0 j 2 j C s current picture ptr f data k 1 mb x 8 row 8 j 4 s uvlinesize for i 0 i 2 i C 4 int ij i j 2 int clip cur c to deblock k MASKCUR ij clip POSCUR 0 if c h deblock k MASKCUR ij 2 int clip bot c to deblock k MASKCUR ij 2 clip POSCUR 0 rv40 adaptive loop filter r rdsp C 4 s uvlinesize s uvlinesize i 8 clip bot clip cur alpha beta beta C 1 0 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT if i clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 else clip left c to deblock k MASKCUR ij 1 clip POSCUR 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 0 1 if j c h deblock k MASKCUR ij mb strong POSCUR mb strong POSTOP int clip top uvcbp POSTOP k MASKCUR ij 2 clip POSTOP 0 rv40 adaptive loop filter r rdsp C s uvlinesize i 8 clip cur clip top alpha beta beta C 1 1 0 if c v deblock k MASKCUR ij i mb strong POSCUR mb strong POSLEFT clip left uvcbp POSLEFT k MASKCUR 2 j 1 clip POSLEFT 0 rv40 adaptive loop filter r rdsp C s uvlinesize j 8 clip cur clip left alpha beta beta C 1 1 1 static void slurm rpc allocate pack slurm msg t msg static int select serial 1 static int active rpc cnt 0 int error code SLURMSUCCESS inx pack cnt 1 DEFTIMERS job desc msg t job desc msg List job req list List msg data slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint32 t job uid NOVAL struct job record job ptr first job ptr NULL char err msg NULL job submit user msg NULL List Iterator iter bool priv user List submit job list NULL uint32 t pack job id 0 pack job offset 0 hostset t jobid hostset NULL char tmp str 32 List resp NULL slurm addr t resp addr char resp host 16 uint16 t port STARTTIMER if select serial 1 if xstrcmp slurmctld conf select type select serial select serial 0 else select serial 1 if slurmctld config submissions disabled select serial 1 info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED goto send msg if sched backfill error code ESLURMNOTSUPPORTED goto send msg if job req list list count job req list 0 info REQUESTJOBPACKALLOCATION from uid d with empty job list uid error code SLURMERROR goto send msg if slurm get peer addr msg conn fd resp addr 0 slurm get ip str resp addr port resp host sizeof resp host else info REQUESTJOBPACKALLOCATION from uid d can t get peer addr uid error code SLURMERROR goto send msg debug2 sched Processing RPCREQUESTJOBPACKALLOCATION from uid d uid pack cnt list count job req list job submit user msg xmalloc sizeof char pack cnt priv user validate slurm user uid submit job list list create NULL throttle start active rpc cnt lock slurmctld job write lock inx 0 iter list iterator create job req list while job desc msg job desc msg t list next iter if job uid NOVAL job uid job desc msg user id if uid job desc msg user id priv user error code ESLURMUSERIDMISSING error Security violation REQUESTJOBPACKALLOCATION from uid d uid break if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTJOBPACKALLOCATION lacks alloc node from uid d uid break if job desc msg array inx error code ESLURMINVALIDARRAY break if job desc msg immediate error code ESLURMCANNOTSTARTIMMEDIATELY break job desc msg pack job offset pack job offset error code validate job create req job desc msg uid job submit user msg inx if error code break error code ESLURMRESERVATIONBUSY error attempt to nest ALPS allocation on s d by uid d job desc msg alloc node job desc msg alloc sid uid break job ptr NULL if job desc msg resp host job desc msg resp host xstrdup resp host if pack job offset job desc msg mail type 0 xfree job desc msg mail user job desc msg pack job offset pack job offset error code job allocate job desc msg false false NULL true uid job ptr err msg msg protocol version if job ptr if error code SLURMSUCCESS error code SLURMERROR break if error code job ptr job state JOBFAILED break error code SLURMSUCCESS if pack job id 0 pack job id job ptr job id first job ptr job ptr snprintf tmp str sizeof tmp str u job ptr job id if jobid hostset hostset insert jobid hostset tmp str else jobid hostset hostset create tmp str job ptr pack job id pack job id job ptr pack job offset pack job offset list append submit job list job ptr static void preview obmc Mpeg Enc Context s Get Bit Context gb s gb int cbpc i pred x pred y mx my int16 t mot val const int xy s mb x 1 s mb y s mb stride const int stride s b8 stride 2 for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x assert s pict type AVPICTURETYPEP do if get bits1 s gb mot val s current picture motion val 0 s block index 0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride 0 mot val 1 mot val 3 mot val 1 stride mot val 3 stride 0 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 while cbpc 20 if cbpc 4 s current picture mb type xy MBTYPEINTRA else get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpc 8 if s modified quant if get bits1 s gb skip bits s gb 1 else skip bits s gb 5 else skip bits s gb 2 if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 mot val ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my end for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x s gb gb static void parse mb skip Wmv2 Context w int mb x mb y Mpeg Enc Context const s w s uint32 t const mb type s current picture ptr mb type w skip type get bits s gb 2 switch w skip type case SKIPTYPENONE for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEMPEG for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEROW for mb y 0 mb y s mb height mb y if get bits1 s gb for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPECOL for mb x 0 mb x s mb width mb x if get bits1 s gb for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break static int combined motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv int64 t best rd sofar MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 const int step param cpi sf mv fullpel search step param const int sadpb x sadperbit16 MV mvp full const int ref mbmi ref frame 0 const MV ref mv mbmi ref mvs ref 0 as mv int dis int rate mode const int tmp col min x mv col min const int tmp col max x mv col max const int tmp row min x mv row min const int tmp row max x mv row max int rv 0 int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref if cpi common show frame x pred mv sad ref 3 x pred mv sad LASTFRAME return rv if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv assert x mv best ref index ref 2 if x mv best ref index ref 2 mvp full mbmi ref mvs ref x mv best ref index ref as mv else mvp full x pred mv ref mvp full col 3 mvp full row 3 vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 0 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max mvp full row tmp mv as mv row 8 mvp full col tmp mv as mv col 8 rate mv vp9 mv bit cost mvp full ref mv x nmvjointcost x mvcost MVCOSTWEIGHT rate mode cpi inter mode cost mbmi mode context ref INTEROFFSETNEWMV rv RDCOST x rdmult x rddiv rate mv rate mode 0 best rd sofar if rv cpi find fractional mv step x tmp mv as mv ref mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return rv static void fill colmap H264 Context h int map 2 16 32 int list int field int colfield int mbafi Picture const ref1 h ref list 1 0 int j old ref rfield int start mbafi 16 0 int end mbafi 16 2 h ref count 0 h ref count 0 int interl mbafi h picture structure PICTFRAME memset map list 0 sizeof map list for rfield 0 rfield 2 rfield for old ref 0 old ref ref1 ref count colfield list old ref int poc ref1 ref poc colfield list old ref if interl poc 3 else if interl poc 3 3 poc poc 3 rfield 1 for j start j end j if 4 h ref list 0 j frame num h ref list 0 j reference 3 poc int cur ref mbafi j 16 field j if ref1 mbaff map list 2 old ref rfield field 16 cur ref if rfield field interl map list old ref cur ref break static void rv34 pred mv R V34 Dec Context r int block type int subblock no int dmv no Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j int mx my int avail r avail cache avail indexes subblock no int c off part sizes w block type mv pos subblock no 1 subblock no 1 s b8 stride if subblock no 3 c off 1 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail c off 4 if avail 4 avail 1 r rv30 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride c off 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride c off 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv dmv no 0 my r dmv dmv no 1 for j 0 j part sizes h block type j for i 0 i part sizes w block type i s current picture ptr f motion val 0 mv pos i j s b8 stride 0 mx s current picture ptr f motion val 0 mv pos i j s b8 stride 1 my static int wma decode superframe AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size WMA Codec Context s avctx priv data int nb frames bit offset i pos len ret uint8 t q float samples int samples offset tprintf avctx decode superframe n if buf size 0 s last superframe len 0 return 0 if buf size avctx block align av log avctx AVLOGERROR Input packet size too small d d n buf size avctx block align return AVERRORINVALIDDATA buf size avctx block align init get bits s gb buf buf size 8 if s use bit reservoir skip bits s gb 4 nb frames get bits s gb 4 s last superframe len 0 else nb frames 1 frame nb samples nb frames s frame len if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame extended data samples offset 0 if s use bit reservoir bit offset get bits s gb s byte offset bits 3 if bit offset get bits left s gb av log avctx AVLOGERROR Invalid last frame bit offset d buf size d d n bit offset get bits left s gb buf size goto fail if s last superframe len 0 if s last superframe len bit offset 7 3 MAXCODEDSUPERFRAMESIZE goto fail q s last superframe s last superframe len len bit offset while len 7 q get bits s gb 8 len 8 if len 0 q get bits s gb len 8 len memset q 0 FFINPUTBUFFERPADDINGSIZE init get bits s gb s last superframe s last superframe len 8 bit offset if s last bitoffset 0 skip bits s gb s last bitoffset if wma decode frame s samples samples offset 0 goto fail samples offset s frame len nb frames pos bit offset 4 4 s byte offset bits 3 if pos MAXCODEDSUPERFRAMESIZE 8 pos buf size 8 return AVERRORINVALIDDATA init get bits s gb buf pos 3 buf size pos 3 8 len pos 7 if len 0 skip bits s gb len s reset block lengths 1 for i 0 i nb frames i if wma decode frame s samples samples offset 0 goto fail samples offset s frame len pos get bits count s gb bit offset 4 4 s byte offset bits 3 7 s last bitoffset pos 7 pos 3 len buf size pos if len MAXCODEDSUPERFRAMESIZE len 0 av log s avctx AVLOGERROR len d invalid n len goto fail s last superframe len len memcpy s last superframe buf pos len else if wma decode frame s samples samples offset 0 goto fail samples offset s frame len av dlog s avctx d d d d outbytes td eaten d n s frame len bits s block len bits s frame len s block len int8 t samples int8 t data avctx block align got frame ptr 1 return avctx block align fail s last superframe len 0 return 1 static int vc1 decode intra block V C1 Context v int16 t block 64 int n int coded int mquant int codingset Get Bit Context gb v s gb Mpeg Enc Context s v s int dc pred dir 0 int i int16 t dc val int16 t ac val ac val2 int dcdiff int mb pos s mb x s mb y s mb stride int a avail v a avail c avail v c avail int use pred s ac pred int scale int q1 q2 0 s dsp clear block block mquant mquant 1 0 mquant 31 31 mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant if n 4 dcdiff get vlc2 s gb ff msmp4 dc luma vlc s dc table index table DCVLCBITS 3 else dcdiff get vlc2 s gb ff msmp4 dc chroma vlc s dc table index table DCVLCBITS 3 if dcdiff 0 av log s avctx AVLOGERROR Illegal DCVLC n return 1 if dcdiff if dcdiff 119 if mquant 1 dcdiff get bits gb 10 else if mquant 2 dcdiff get bits gb 9 else dcdiff get bits gb 8 else if mquant 1 dcdiff dcdiff 2 get bits gb 2 3 else if mquant 2 dcdiff dcdiff 1 get bits1 gb 1 if get bits1 gb dcdiff dcdiff dcdiff vc1 pred dc v s v overlap mquant n a avail c avail dc val dc pred dir dc val dcdiff if n 4 block 0 dcdiff s y dc scale else block 0 dcdiff s c dc scale i 1 if a avail dc pred dir 1 if c avail dc pred dir 0 if a avail c avail use pred 0 ac val s ac val 0 0 s block index n 16 ac val2 ac val scale mquant 2 v halfpq if dc pred dir ac val 16 else ac val 16 s block wrap n q1 s current picture qscale table mb pos if dc pred dir c avail mb pos q2 s current picture qscale table mb pos 1 if dc pred dir a avail mb pos s mb stride q2 s current picture qscale table mb pos s mb stride if dc pred dir n 1 q2 q1 if dc pred dir n 2 q2 q1 if n 3 q2 q1 if coded int last 0 skip value int k while last vc1 decode ac coeff v last skip value codingset i skip if i 63 break if v fcm PROGRESSIVE block v zz 8x8 0 i value else if use pred v fcm ILACEFRAME if dc pred dir block v zz 8x8 2 i value else block v zz 8x8 3 i value else block v zzi 8x8 i value if use pred if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA if dc pred dir for k 1 k 8 k block k v left blk sh ac val k q2 ff vc1 dqscale q1 1 0x20000 18 else for k 1 k 8 k block k v top blk sh ac val k 8 q2 ff vc1 dqscale q1 1 0x20000 18 else if dc pred dir for k 1 k 8 k block k v left blk sh ac val k else for k 1 k 8 k block k v top blk sh ac val k 8 for k 1 k 8 k ac val2 k block k v left blk sh ac val2 k 8 block k v top blk sh for k 1 k 64 k if block k block k scale if v pquantizer block k block k 0 mquant mquant if use pred i 63 else int k memset ac val2 0 16 2 if dc pred dir if use pred memcpy ac val2 ac val 8 2 if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA for k 1 k 8 k ac val2 k ac val2 k q2 ff vc1 dqscale q1 1 0x20000 18 else if use pred memcpy ac val2 8 ac val 8 8 2 if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA for k 1 k 8 k ac val2 k 8 ac val2 k 8 q2 ff vc1 dqscale q1 1 0x20000 18 if use pred if dc pred dir for k 1 k 8 k block k v left blk sh ac val2 k scale if v pquantizer block k v left blk sh block k v left blk sh block k v left blk sh 0 mquant mquant else for k 1 k 8 k block k v top blk sh ac val2 k 8 scale if v pquantizer block k v top blk sh block k v top blk sh block k v top blk sh 0 mquant mquant i 63 s block last index n i return 0 static double eqjoinsel semi Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 Rel Opt Info inner rel double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid Oid Is Valid operator get opcode operator Invalid Oid if vardata2 rel nd2 Min nd2 vardata2 rel rows nd2 Min nd2 inner rel rows if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Oid Is Valid operator Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double matchfreq1 uncertainfrac uncertain int i nmatches clamped nvalues2 clamped nvalues2 Min nvalues2 nd2 fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 clamped nvalues2 sizeof bool nmatches 0 for i 0 i nvalues1 i int j for j 0 j clamped nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true nmatches break matchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 pfree hasmatch1 pfree hasmatch2 if isdefault1 isdefault2 nd1 nmatches nd2 nmatches if nd1 nd2 nd2 0 uncertainfrac 1 0 else uncertainfrac nd2 nd1 else uncertainfrac 0 5 uncertain 1 0 matchfreq1 nullfrac1 CLAMPPROBABILITY uncertain selec matchfreq1 uncertainfrac uncertain else double nullfrac1 stats1 stats1 stanullfrac 0 0 if isdefault1 isdefault2 if nd1 nd2 nd2 0 selec 1 0 nullfrac1 else selec nd2 nd1 1 0 nullfrac1 else selec 0 5 1 0 nullfrac1 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic data const uint8 t psrc avpkt data uint16 t y u v int aligned width avctx width 47 48 48 int stride aligned width 8 3 if avpkt size stride avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA if ret ff get buffer avctx pic 0 0 return ret y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 pic pict type AVPICTURETYPEI pic key frame 1 val av le2ne32 src a val 0x3 FF b val 10 0x3 FF c val 20 0x3 static gint dissect adb tvbuff t tvb packet info pinfo proto tree tree void data proto item main item proto tree main tree proto item arg0 item proto tree arg0 tree proto item arg1 item proto tree arg1 tree proto item magic item proto item crc item proto tree crc tree NULL proto item sub item gint offset 0 guint32 command guint32 arg0 guint32 arg1 guint32 data length 0 guint32 crc32 0 usb conv info t usb conv info NULL wmem tree key t key 5 guint32 interface id guint32 bus id guint32 device address guint32 side id guint32 frame number gboolean is command TRUE gboolean is next fragment FALSE gboolean is service FALSE gint proto gint direction P2 PDIRUNKNOWN wmem tree t wmem tree command data t command data NULL service data t service data NULL col set str pinfo cinfo COLPROTOCOLADB col clear pinfo cinfo COLINFO main item proto tree add item tree proto adb tvb offset 1 ENCNA main tree proto item add subtree main item ett adb frame number pinfo num proto gint GPOINTERTOINT wmem list frame data wmem list tail pinfo layers if proto proto usb proto gint GPOINTERTOINT wmem list frame data wmem list frame prev wmem list tail pinfo layers if proto proto usb usb conv info usb conv info t data DISSECTORASSERT usb conv info direction usb conv info direction else if proto proto tcp if pinfo destport ADBTCPPORT direction P2 PDIRSENT else direction P2 PDIRRECV else return offset if pinfo phdr presence flags WTAPHASINTERFACEID interface id pinfo phdr interface id else interface id 0 if proto proto usb bus id usb conv info bus id device address usb conv info device address key 0 length 1 key 0 key interface id key 1 length 1 key 1 key bus id key 2 length 1 key 2 key device address key 3 length 0 key 3 key NULL else key 0 length 1 key 0 key interface id key 1 length 1 key 2 length 1 if direction P2 PDIRSENT key 1 key pinfo srcport key 2 key pinfo destport else key 1 key pinfo destport key 2 key pinfo srcport key 3 length 0 key 3 key NULL wmem tree wmem tree t wmem tree lookup32 array command info key if wmem tree command data command data t wmem tree lookup32 le wmem tree frame number if command data command data completed in frame frame number command data command in frame frame number if command data command in frame frame number is command FALSE is next fragment TRUE data length command data data length crc32 command data crc32 if direction P2 PDIRSENT if command data command ACLSE side id command data arg1 else side id command data arg0 else if command data command AOKAY side id command data arg1 else side id command data arg1 key 3 length 1 key 3 key side id key 4 length 0 key 4 key NULL wmem tree wmem tree t wmem tree lookup32 array service info key if wmem tree service data service data t wmem tree lookup32 le wmem tree frame number if service data command data command AOPEN is service TRUE if command data command data completed in frame frame number command data if tvb reported length tvb 24 is command FALSE else if tvb reported length tvb 24 command tvb get letohl tvb offset if command ASYNC command ACLSE command AWRTE command AAUTH command ACNXN command AOPEN command AOKAY is command FALSE else if command 0x FFFFFFFF tvb get letohl tvb offset 20 is command FALSE if is command data length tvb get letohl tvb offset 12 crc32 tvb get letohl tvb offset 16 if command AOPEN is service TRUE if service data command data command AOPEN is next fragment sub item proto tree add string main tree hf service tvb offset 0 service data service PROTOITEMSETGENERATED sub item if service data sub item proto tree add uint main tree hf service start in frame tvb offset 0 service data start in frame PROTOITEMSETGENERATED sub item if service data close local in frame max in frame sub item proto tree add uint main tree hf close local in frame tvb offset 0 service data close local in frame PROTOITEMSETGENERATED sub item if service data close remote in frame max in frame sub item proto tree add uint main tree hf close remote in frame tvb offset 0 service data close remote in frame PROTOITEMSETGENERATED sub item if is command proto tree add item main tree hf command tvb offset 4 ENCLITTLEENDIAN command tvb get letohl tvb offset offset 4 col append str pinfo cinfo COLINFO val to str const command command vals Unknown command arg0 item proto tree add item main tree hf argument 0 tvb offset 4 ENCLITTLEENDIAN arg0 tree proto item add subtree arg0 item ett adb arg0 arg0 tvb get letohl tvb offset offset 4 arg1 item proto tree add item main tree hf argument 1 tvb offset 4 ENCLITTLEENDIAN arg1 tree proto item add subtree arg1 item ett adb arg1 arg1 tvb get letohl tvb offset offset 4 switch command case ACNXN proto tree add item arg0 tree hf version tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf max data tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO version u u u max data u tvb get guint8 tvb offset 5 tvb get guint8 tvb offset 6 tvb get letohs tvb offset 7 tvb get letohl tvb offset 4 break case AAUTH proto tree add item arg0 tree hf auth type tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf zero tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO type s 0 val to str const tvb get letohl tvb offset 8 auth type vals Unknown break case AOPEN proto tree add item arg0 tree hf local id tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf zero tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO local u 0 tvb get letohl tvb offset 8 break case AWRTE proto tree add item arg0 tree hf zero tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf remote id tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO 0 remote u tvb get letohl tvb offset 4 break case ACLSE case AOKAY proto tree add item arg0 tree hf local id tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf remote id tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO local u remote u tvb get letohl tvb offset 8 tvb get letohl tvb offset 4 break case ASYNC proto tree add item arg0 tree hf online tvb offset 8 4 ENCLITTLEENDIAN proto tree add item arg1 tree hf sequence tvb offset 4 4 ENCLITTLEENDIAN col append fstr pinfo cinfo COLINFO online s sequence u tvb get letohl tvb offset 8 Yes No tvb get letohl tvb offset 4 break proto tree add item main tree hf data length tvb offset 4 ENCLITTLEENDIAN offset 4 if data length 0 col append fstr pinfo cinfo COLINFO length u data length crc item proto tree add item main tree hf data crc32 tvb offset 4 ENCLITTLEENDIAN crc tree proto item add subtree crc item ett adb crc crc32 tvb get letohl tvb offset offset 4 magic item proto tree add item main tree hf magic tvb offset 4 ENCLITTLEENDIAN if tvb get letohl tvb offset 0x FFFFFFFF command proto tree expert tree expert tree proto item add subtree magic item ett adb magic proto tree add expert expert tree pinfo ei invalid magic tvb offset 4 if pinfo fd flags visited save command command arg0 arg1 data length crc32 service data proto data pinfo service data command data offset 4 if pinfo fd flags visited command data if command data command in frame frame number is command FALSE is next fragment TRUE data length command data data length crc32 command data crc32 if command data command in frame frame number tvb captured length tvb data length command data command in frame frame number tvb captured length tvb data length 24 command data reassemble data length command data data length command data completed in frame frame number if is next fragment command data sub item proto tree add uint main tree hf command in frame tvb offset 0 command data command in frame PROTOITEMSETGENERATED sub item sub item proto tree add uint main tree hf command tvb offset 0 command data command PROTOITEMSETGENERATED sub item sub item proto tree add uint main tree hf data length tvb offset 0 command data data length PROTOITEMSETGENERATED sub item crc item proto tree add uint main tree hf data crc32 tvb offset 0 command data crc32 crc tree proto item add subtree crc item ett adb crc PROTOITEMSETGENERATED crc item if command data command data completed in frame frame number sub item proto tree add uint main tree hf completed in frame tvb offset 0 command data completed in frame PROTOITEMSETGENERATED sub item if tvb captured length remaining tvb offset 0 is command data length 0 guint32 crc 0 guint32 i offset if pinfo fd flags visited command data command data reassemble data length command data data length guint chunklen tvb captured length remaining tvb offset if chunklen command data data length command data reassemble data length chunklen command data data length command data reassemble data length command data reassemble error in frame frame number tvb memcpy tvb command data reassemble data command data reassemble data length offset chunklen command data reassemble data length chunklen if command data reassemble data length command data data length command data completed in frame frame number if frame number command data reassemble error in frame proto tree add expert main tree pinfo ei invalid data tvb offset 1 if pinfo fd flags visited command data command data reassemble data length command data data length data length guint32 tvb captured length remaining tvb offset proto tree add item main tree hf data fragment tvb offset 1 ENCNA col append str pinfo cinfo COLINFO Data Fragment offset tvb captured length tvb if service data command data command data reassemble data length command data data length frame number command data completed in frame tvbuff t next tvb adb service data t adb service data next tvb tvb new child real data tvb command data reassemble data command data reassemble data length command data reassemble data length add new data source pinfo next tvb ADB Reassembled Data adb service data service service data service adb service data direction direction adb service data session key length 3 adb service data session key guint32 wmem alloc wmem packet scope adb service data session key length sizeof guint32 adb service data session key 0 interface id if proto proto usb adb service data session key 1 usb conv info bus id adb service data session key 2 usb conv info device address else if direction P2 PDIRSENT adb service data session key 1 pinfo srcport adb service data session key 2 pinfo destport else adb service data session key 1 pinfo destport adb service data session key 2 pinfo srcport call dissector with data adb service handle next tvb pinfo tree adb service data else for i offset 0 i offset data length i offset crc tvb get guint8 tvb offset i offset if crc32 0 crc32 crc proto tree add expert crc tree pinfo ei invalid crc tvb offset 1 if is service proto tree add item main tree hf service tvb offset 1 ENCASCIIENCNA if pinfo fd flags visited service data service data service tvb get stringz enc wmem file scope tvb offset NULLENCASCII col append fstr pinfo cinfo COLINFO Service s tvb get stringz enc wmem packet scope tvb offset NULLENCASCII offset tvb captured length tvb else if command data command data command ACNXN gchar info gint len info tvb get stringz enc wmem packet scope tvb offset len ENCASCII col append fstr pinfo cinfo COLINFO Connection Info s info proto tree add item main tree hf connection info tvb offset len ENCASCIIENCNA offset len else col append str pinfo cinfo COLINFO Data if service data tvbuff t next tvb adb service data t adb service data adb service data service service data service adb service data direction direction adb service data session key length 3 adb service data session key guint32 wmem alloc wmem packet scope adb service data session key length sizeof guint32 adb service data session key 0 interface id if proto proto usb adb service data session key 1 usb conv info bus id adb service data session key 2 usb conv info device address else if direction P2 PDIRSENT adb service data session key 1 pinfo srcport adb service data session key 2 pinfo destport else adb service data session key 1 pinfo destport adb service data session key 2 pinfo srcport next tvb tvb new subset tvb offset tvb captured length remaining tvb offset tvb captured length remaining tvb offset call dissector with data adb service handle next tvb pinfo tree adb service data else proto item data item gchar data str data item proto tree add item main tree hf data tvb offset data length ENCNA data str tvb format text tvb offset data length proto item append text data item s data str col append fstr pinfo cinfo COLINFO Raw s data str offset tvb captured length tvb return offset void ff init qscale tab Mpeg Enc Context s int8 t const qscale table s current picture f qscale table int i for i 0 i s mb num i unsigned int lam s lambda table s mb index2xy i int qp lam 139 FFLAMBDASCALE 64 FFLAMBDASHIFT 7 qscale table s mb index2xy i av clip qp s avctx qmin s avctx qmax static void create new objects void int dbnum prep status Restoring database schemas in the new cluster n for dbnum 0 dbnum old cluster dbarr ndbs dbnum char sql file name MAXPGPATH log file name MAXPGPATH Db Info old db old cluster dbarr dbs dbnum PQ Exp Buffer Data connstr escaped connstr init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr old db db name init PQ Exp Buffer escaped connstr append Shell String escaped connstr connstr data term PQ Exp Buffer connstr pg log PGSTATUS s old db db name snprintf sql file name sizeof sql file name DBDUMPFILEMASK old db db oid snprintf log file name sizeof log file name DBDUMPLOGFILEMASK old db db oid parallel exec prog log file name NULL s pg restore s exit on error verbose dbname s s new cluster bindir cluster conn opts new cluster escaped connstr data sql file name term PQ Exp Buffer escaped connstr while reap child true true end progress output check ok if GETMAJORVERSION old cluster major version 903 set frozenxids true get db and rel infos new cluster void jas malloc size t size void result JASDBGLOG 101 jas malloc zu n size result malloc size JASDBGLOG 100 jas malloc zu p n size result return result static void pass1 vpx image t raw FILE infile const char outfile name const Vpx Interface encoder const vpx codec enc cfg t cfg Vpx Video Info info encoder fourcc cfg g w cfg g h cfg g timebase num cfg g timebase den Vpx Video Writer writer NULL vpx codec ctx t codec int frame count 0 writer vpx video writer open outfile name k Container IVF info if writer die Failed to open s for writing outfile name if vpx codec enc init codec encoder codec interface cfg 0 die codec codec Failed to initialize encoder while vpx img read raw infile frame count encode frame codec raw frame count 1 0 VPXDLGOODQUALITY writer while encode frame codec NULL 1 1 0 VPXDLGOODQUALITY writer printf n if vpx codec destroy codec die codec codec Failed to destroy codec vpx video writer close writer printf Pass 1 complete Processed d frames n frame count static inline void vc1 pred b mv intfi V C1 Context v int n int dmv x int dmv y int mv1 int pred flag int dir v bmvtype BMVTYPEBACKWARD 1 0 Mpeg Enc Context s v s int mb pos s mb x s mb y s mb stride if v bmvtype BMVTYPEDIRECT int total opp k f if s next picture f mb type mb pos v mb off MBTYPEINTRA s mv 0 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 1 s quarter sample total opp v mv f next 0 s block index 0 v blocks off v mv f next 0 s block index 1 v blocks off v mv f next 0 s block index 2 v blocks off v mv f next 0 s block index 3 v blocks off f total opp 2 1 0 else s mv 0 0 0 s mv 0 0 1 0 s mv 1 0 0 s mv 1 0 1 0 f 0 v ref field type 0 v ref field type 1 v cur field type f for k 0 k 4 k s current picture f motion val 0 s block index k v blocks off 0 s mv 0 0 0 s current picture f motion val 0 s block index k v blocks off 1 s mv 0 0 1 s current picture f motion val 1 s block index k v blocks off 0 s mv 1 0 0 s current picture f motion val 1 s block index k v blocks off 1 s mv 1 0 1 v mv f 0 s block index k v blocks off f v mv f 1 s block index k v blocks off f return if v bmvtype BMVTYPEINTERPOLATED vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 pred flag 0 0 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 pred flag 1 1 return if dir vc1 pred mv v n dmv x 1 dmv y 1 mv1 v range x v range y v mb type 0 pred flag 1 1 if n 3 mv1 vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 0 0 else vc1 pred mv v n dmv x 0 dmv y 0 mv1 v range x v range y v mb type 0 pred flag 0 0 if n 3 mv1 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 0 1 static int mpeg4 decode partitioned mb Mpeg Enc Context s int16 t block 6 64 int cbp mb type const int xy s mb x s mb y s mb stride mb type s current picture f mb type xy cbp s cbp table xy s use intra dc vlc s qscale s intra dc threshold if s current picture f qscale table xy s qscale ff set qscale s s current picture f qscale table xy if s pict type AVPICTURETYPEP s pict type AVPICTURETYPES int i for i 0 i 4 i s mv 0 i 0 s current picture f motion val 0 s block index i 0 s mv 0 i 1 s current picture f motion val 0 s block index i 1 s mb intra ISINTRA mb type if ISSKIP mb type for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s mcsel 1 s mb skipped 0 else s mcsel 0 s mb skipped 1 else if s mb intra s ac pred ISACPRED s current picture f mb type xy else if s mb intra s mv dir MVDIRFORWARD if IS 8 X8 mb type s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 else s mb intra 1 s ac pred ISACPRED s current picture f mb type xy if ISSKIP mb type int i s dsp clear blocks s block 0 for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 s mb intra s rvlc 0 av log s avctx AVLOGERROR texture corrupted at d d d n s mb x s mb y s mb intra return 1 cbp cbp if s mb num left 0 if mpeg4 is resync s return SLICEEND else return SLICENOEND else if mpeg4 is resync s const int delta s mb x 1 s mb width 2 1 if s cbp table xy delta return SLICEEND return static int qtrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Qtrle Context s avctx priv data int header start line int height row ptr int has palette 0 int ret bytestream2 init s g avpkt data avpkt size if ret ff reget buffer avctx s frame 0 av log s avctx AVLOGERROR reget buffer failed n return ret if avpkt size 8 goto done bytestream2 seek s g 4 SEEKSET header bytestream2 get be16 s g if header 0x0008 if avpkt size 14 goto done start line bytestream2 get be16 s g bytestream2 skip s g 2 height bytestream2 get be16 s g bytestream2 skip s g 2 else start line 0 height s avctx height row ptr s frame linesize 0 start line switch avctx bits per coded sample case 1 case 33 qtrle decode 1bpp s row ptr height break case 2 case 34 qtrle decode 2n4bpp s row ptr height 2 has palette 1 break case 4 case 36 qtrle decode 2n4bpp s row ptr height 4 has palette 1 break case 8 case 40 qtrle decode 8bpp s row ptr height has palette 1 break case 16 qtrle decode 16bpp s row ptr height break case 24 qtrle decode 24bpp s row ptr height break case 32 qtrle decode 32bpp s row ptr height break default av log s avctx AVLOGERROR Unsupported colorspace d bits sample n avctx bits per coded sample break if has palette const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE done if ret av frame ref data s frame 0 return ret got frame 1 return avpkt size static int lag decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Lagarith Context l avctx priv data AV Frame const p l picture uint8 t frametype 0 uint32 t offset gu 0 offset bv 0 offset ry 9 uint32 t offs 4 uint8 t srcs 4 dst int i j planes 3 AV Frame picture data if p data 0 ff thread release buffer avctx p p reference 0 p key frame 1 frametype buf 0 offset gu AVR L32 buf 1 offset bv AVR L32 buf 5 switch frametype case FRAMESOLIDRGBA avctx pix fmt AVPIXFMTRG B32 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 dst p data 0 for j 0 j avctx height j for i 0 i avctx width i AVW N32 dst i 4 offset gu dst p linesize 0 break case FRAMEARITHRGBA avctx pix fmt AVPIXFMTRG B32 planes 4 offset ry 4 offs 3 AVR L32 buf 9 case FRAMEARITHRG B24 case FRAMEURG B24 if frametype FRAMEARITHRG B24 frametype FRAMEURG B24 avctx pix fmt AVPIXFMTRG B24 if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 offs 0 offset bv offs 1 offset gu offs 2 offset ry if l rgb planes l rgb stride FFALIGN avctx width 16 l rgb planes av malloc l rgb stride avctx height planes 1 if l rgb planes av log avctx AVLOGERROR cannot allocate temporary buffer n return AVERRORENOMEM for i 0 i planes i srcs i l rgb planes i 1 l rgb stride avctx height l rgb stride if offset ry buf size offset gu buf size offset bv buf size planes 4 offs 3 buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA for i 0 i planes i lag decode arith plane l srcs i avctx width avctx height l rgb stride buf offs i buf size offs i dst p data 0 for i 0 i planes i srcs i l rgb planes i l rgb stride avctx height for j 0 j avctx height j for i 0 i avctx width i uint8 t r g b a r srcs 0 i g srcs 1 i b srcs 2 i r g b g if frametype FRAMEARITHRGBA a srcs 3 i AVW N32 dst i 4 MKBETAG a r g b else dst i 3 0 r dst i 3 1 g dst i 3 2 b dst p linesize 0 for i 0 i planes i srcs i l rgb stride break case FRAMEARITHYU Y2 avctx pix fmt AVPIXFMTYU V422 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 1 avctx width 2 avctx height p linesize 1 buf offset gu buf size offset gu lag decode arith plane l p data 2 avctx width 2 avctx height p linesize 2 buf offset bv buf size offset bv break case FRAMEARITHY V12 avctx pix fmt AVPIXFMTYU V420 P if ff thread get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return 1 if offset ry buf size offset gu buf size offset bv buf size av log avctx AVLOGERROR Invalid frame offsets n return AVERRORINVALIDDATA lag decode arith plane l p data 0 avctx width avctx height p linesize 0 buf offset ry buf size offset ry lag decode arith plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf offset gu buf size offset gu lag decode arith plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf offset bv buf size offset bv break default av log avctx AVLOGERROR Unsupported Lagarith frame type x n frametype return 1 picture p got frame 1 return buf size static int mpeg4 decode partition b Mpeg Enc Context s int mb count int mb num 0 static const int8 t quant tab 4 1 2 1 2 s mb x s resync mb x s first slice line 1 for s mb y s resync mb y mb num mb count s mb y ff init block index s for mb num mb count s mb x s mb width s mb x const int xy s mb x s mb y s mb stride mb num ff update block index s if s mb x s resync mb x s mb y s resync mb y 1 s first slice line 0 if s pict type AVPICTURETYPEI int ac pred get bits1 s gb int cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERROR cbpy corrupted at d d n s mb x s mb y return 1 s cbp table xy cbpy 2 s current picture mb type xy ac pred MBTYPEACPRED else if ISINTRA s current picture mb type xy int dir 0 i int ac pred get bits1 s gb int cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy corrupted at d d n s mb x s mb y return 1 if s cbp table xy 8 ff set qscale s s qscale quant tab get bits s gb 2 s current picture qscale table xy s qscale for i 0 i 6 i int dc pred dir int dc mpeg4 decode dc s i dc pred dir if dc 0 av log s avctx AVLOGERRORDC corrupted at d d n s mb x s mb y return 1 dir 1 if dc pred dir dir 1 s cbp table xy 3 s cbp table xy cbpy 2 s current picture mb type xy ac pred MBTYPEACPRED s pred dir table xy dir else if ISSKIP s current picture mb type xy s current picture qscale table xy s qscale s cbp table xy 0 else int cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORP cbpy corrupted at d d n s mb x s mb y return 1 if s cbp table xy 8 ff set qscale s s qscale quant tab get bits s gb 2 s current picture qscale table xy s qscale s cbp table xy 3 s cbp table xy cbpy 0xf 2 if mb num mb count return 0 s mb x 0 return 0 static int mpeg decode frame AV Codec Context avctx void data int got output AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg1 Context s avctx priv data AV Frame picture data Mpeg Enc Context s2 s mpeg enc ctx av dlog avctx fill buffer n if buf size 0 buf size 4 AVR B32 buf SEQENDCODE if s2 low delay 0 s2 next picture ptr int ret av frame ref picture s2 next picture ptr f if ret 0 return ret s2 next picture ptr NULL got output 1 return buf size if s2 flags CODECFLAGTRUNCATED int next ff mpeg1 find frame end s2 parse context buf buf size NULL if ff combine frame s2 parse context next const uint8 t buf buf size 0 return buf size if s mpeg enc ctx allocated 0 avctx codec tag AVR L32 VC R2 vcr2 init sequence avctx s slice count 0 if avctx extradata s extradata decoded int ret decode chunks avctx picture got output avctx extradata avctx extradata size s extradata decoded 1 if ret 0 avctx err recognition AVEFEXPLODE return ret return decode chunks avctx picture got output buf buf size static char rfc2047 decode word const char s size t len enum Content Encoding enc const char it s const char end s len if enc ENCQUOTEDPRINTABLE struct Buffer buf 0 for it end it if it mutt buffer addch buf else if it it 1 127 hexval it 1 1 it 2 127 hexval it 2 1 mutt buffer addch buf hexval it 1 4 hexval it 2 it 2 else mutt buffer addch buf it mutt buffer addch buf 0 return buf data else if enc ENCBAS E64 const int olen 3 len 4 1 char out mutt mem malloc olen int dlen mutt b64 decode out it olen if dlen 1 FREE out return NULL out dlen 0 return out assert 0 return void PNGAPI png set PLTE png structp png ptr png infop info ptr png colorp palette int num palette png uint 32 max palette length png debug1 1 in s storage function PLTE if png ptr NULL info ptr NULL return max palette length info ptr color type PNGCOLORTYPEPALETTE 1 info ptr bit depth PNGMAXPALETTELENGTH if num palette 0 num palette int max palette length if info ptr color type PNGCOLORTYPEPALETTE png error png ptr Invalid palette length else png warning png ptr Invalid palette length return png memcpy png ptr palette palette num palette png sizeof png color info ptr palette png ptr palette info ptr num palette png ptr num palette png uint 16 num palette static int archive read format cpio read header struct archive read a struct archive entry entry struct cpio cpio const void h struct archive string conv sconv size t namelength size t name pad int r cpio struct cpio a format data sconv cpio opt sconv if sconv NULL if cpio init default conversion cpio sconv default archive string default conversion for read a archive cpio init default conversion 1 sconv cpio sconv default r cpio read header a cpio entry namelength name pad if r ARCHIVEWARN return r h archive read ahead a namelength name pad NULL if h NULL return ARCHIVEFATAL if archive entry copy pathname l entry const char h namelength sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Pathname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Pathname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN cpio entry offset 0 archive read consume a namelength name pad if archive entry filetype entry AEIFLNK if cpio entry bytes remaining 1024 1024 archive set error a archive ENOMEM Rejecting malformed cpio archive symlink contents exceed 1 megabyte return ARCHIVEFATAL h archive read ahead a size t cpio entry bytes remaining NULL if h NULL return ARCHIVEFATAL if archive entry copy symlink l entry const char h size t cpio entry bytes remaining sconv 0 if errno ENOMEM archive set error a archive ENOMEM Can t allocate memory for Linkname return ARCHIVEFATAL archive set error a archive ARCHIVEERRNOFILEFORMAT Linkname can t be converted from s to current locale archive string conversion charset name sconv r ARCHIVEWARN archive read consume a cpio entry bytes remaining cpio entry bytes remaining 0 if namelength 11 strcmp const char h TRAILER 0 archive clear error a archive return ARCHIVEEOF if record hardlink a cpio entry ARCHIVEOK return ARCHIVEFATAL return r void ff MPV common end Mpeg Enc Context s int i if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i s slice context count 1 else free duplicate context s av freep s parse context buffer s parse context buffer size 0 av freep s bitstream buffer s allocated bitstream buffer size 0 av freep s avctx stats out av freep s ac stats av freep s q intra matrix av freep s q inter matrix av freep s q intra matrix16 av freep s q inter matrix16 av freep s input picture av freep s reordered input picture av freep s dct offset if s picture s avctx internal is copy for i 0 i s picture count i free picture s s picture i av freep s picture free context frame s if s avctx active thread type FFTHREADFRAME avcodec default free buffers s avctx s context initialized 0 s last picture ptr s next picture ptr s current picture ptr NULL s linesize s uvlinesize 0 static int sdp parse fmtp config h264 AV Format Context s AV Stream stream Payload Context h264 data const char attr const char value AV Codec Parameters par stream codecpar if strcmp attr packetization mode av log s AVLOGDEBUGRTP Packetization Mode d n atoi value h264 data packetization mode atoi value if h264 data packetization mode 1 av log s AVLOGERROR Interleaved RTP mode is not supported yet n else if strcmp attr profile level id if strlen value 6 parse profile level id s h264 data value else if strcmp attr sprop parameter sets int ret if value strlen value 1 av log s AVLOGWARNING Missing PPS in sprop parameter sets ignoring n return 0 par extradata size 0 av freep par extradata ret ff h264 parse sprop parameter sets s par extradata par extradata size value av log s AVLOGDEBUG Extradata set to p size d n par extradata par extradata size return ret return 0 int encode const char string struct filter op fop char p memset fop 0 sizeof struct filter op if strncmp string 0x 2 isxdigit int string 2 fop op test value strtoul string NULL 16 return ESUCCESS else if isdigit int string 0 fop op test value strtoul string NULL 10 return ESUCCESS else if string 0 string strlen string 1 struct ip addr ipaddr p strchr string 1 p 0 if ip addr pton string 1 ipaddr ESUCCESS switch ntohs ipaddr addr type case AFINET fop op test value ntohl ipaddr addr32 0 break case AFINE T6 ip addr cpy u char fop op test ipaddr ipaddr break default return EFATAL else return EFATAL return ESUCCESS else if string 0 string strlen string 1 p strchr string 1 p 0 fop op test string u char strdup string 1 fop op test slen strescape char fop op test string char fop op test string return ESUCCESS else if isalpha int string 0 return get constant string fop op test value return static int64 t rd pick intra sub 8x8 y mode V P9 COMP cpi MACROBLOCK mb int rate int rate y int64 t distortion int64 t best rd int i j const MACROBLOCKD const xd mb e mbd MODEINFO const mic xd mi 0 const MODEINFO above mi xd mi xd mi stride const MODEINFO left mi xd left available xd mi 1 NULL const BLOCKSIZE bsize xd mi 0 mbmi sb type const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize int idx idy int cost 0 int64 t total distortion 0 int tot rate y 0 int64 t total rd 0 ENTROPYCONTEXT t above 4 t left 4 const int bmode costs cpi mbmode cost vpx memcpy t above xd plane 0 above context sizeof t above vpx memcpy t left xd plane 0 left context sizeof t left for idy 0 idy 2 idy num 4x4 blocks high for idx 0 idx 2 idx num 4x4 blocks wide PREDICTIONMODE best mode DCPRED int r INTMAX ry INTMAX int64 t d IN T64 MAX this rd IN T64 MAX i idy 2 idx if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi i const PREDICTIONMODEL vp9 left block mode mic left mi i bmode costs cpi y mode costs AL this rd rd pick intra4x4block cpi mb i best mode bmode costs t above idx t left idy r ry d bsize best rd total rd if this rd best rd total rd return IN T64 MAX total rd this rd cost r total distortion d tot rate y ry mic bmi i as mode best mode for j 1 j num 4x4 blocks high j mic bmi i j 2 as mode best mode for j 1 j num 4x4 blocks wide j mic bmi i j as mode best mode if total rd best rd return IN T64 MAX rate cost rate y tot rate y distortion total distortion mic mbmi mode mic bmi 3 as mode return RDCOST mb rdmult mb rddiv cost total distortion static int vble decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VBLE Context ctx avctx priv data AV Frame pic avctx coded frame Get Bit Context gb const uint8 t src avpkt data int version int offset 0 int width uv avctx width 2 height uv avctx height 2 pic reference 0 if pic data 0 avctx release buffer avctx pic if ff get buffer avctx pic 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI version AVR L32 src if version 1 av log avctx AVLOGWARNING Unsupported VBLE Version d n version init get bits gb src 4 avpkt size 4 8 if vble unpack ctx gb 0 av log avctx AVLOGERROR Invalid Code n return AVERRORINVALIDDATA vble restore plane ctx 0 offset avctx width avctx height if ctx avctx flags CODECFLAGGRAY offset avctx width avctx height vble restore plane ctx 1 offset width uv height uv offset width uv height uv vble restore plane ctx 2 offset width uv height uv got frame 1 AV Frame data pic return avpkt size int ff MPV frame start Mpeg Enc Context s AV Codec Context avctx int i ret Picture pic s mb skipped 0 if s out format FMT H264 s codec id AVCODECIDSV Q3 if s pict type AVPICTURETYPEB s last picture ptr s last picture ptr s next picture ptr s last picture ptr f data 0 ff mpeg unref picture s s last picture ptr if s encoding for i 0 i MAXPICTURECOUNT i if s picture i s last picture ptr s picture i s next picture ptr s picture i reference s picture i needs realloc if avctx active thread type FFTHREADFRAME av log avctx AVLOGERROR releasing zombie picture n ff mpeg unref picture s s picture i if s encoding ff release unused pictures s 1 if s current picture ptr s current picture ptr f data 0 NULL pic s current picture ptr else i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i pic s picture i pic reference 0 if s droppable if s codec id AVCODECID H264 pic reference s picture structure else if s pict type AVPICTURETYPEB pic reference 3 pic f coded picture number s coded picture number if ff alloc picture s pic 0 0 return 1 s current picture ptr pic s current picture ptr f top field first s top field first if s codec id AVCODECIDMPE G1 VIDEO s codec id AVCODECIDMPE G2 VIDEO if s picture structure PICTFRAME s current picture ptr f top field first s picture structure PICTTOPFIELD s first field s current picture ptr f interlaced frame s progressive frame s progressive sequence s current picture ptr field picture s picture structure PICTFRAME s current picture ptr f pict type s pict type s current picture ptr f key frame s pict type AVPICTURETYPEI ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret if s codec id AVCODECID H264 s pict type AVPICTURETYPEB s last picture ptr s next picture ptr if s droppable s next picture ptr s current picture ptr av dlog s avctx L p N p C p L p N p C p type d drop d n s last picture ptr s next picture ptr s current picture ptr s last picture ptr s last picture ptr f data 0 NULL s next picture ptr s next picture ptr f data 0 NULL s current picture ptr s current picture ptr f data 0 NULL s pict type s droppable if s codec id AVCODECID H264 if s last picture ptr NULL s last picture ptr f data 0 NULL s pict type AVPICTURETYPEI s picture structure PICTFRAME int h chroma shift v chroma shift av pix fmt get chroma sub sample s avctx pix fmt h chroma shift v chroma shift if s pict type AVPICTURETYPEI av log avctx AVLOGERROR warning first frame is no keyframe n else if s picture structure PICTFRAME av log avctx AVLOGINFO allocate dummy last picture for field based first keyframe n i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s last picture ptr s picture i if ff alloc picture s s last picture ptr 0 0 s last picture ptr NULL return 1 memset s last picture ptr f data 0 0 avctx height s last picture ptr f linesize 0 memset s last picture ptr f data 1 0x80 avctx height v chroma shift s last picture ptr f linesize 1 memset s last picture ptr f data 2 0x80 avctx height v chroma shift s last picture ptr f linesize 2 ff thread report progress s last picture ptr tf INTMAX 0 ff thread report progress s last picture ptr tf INTMAX 1 if s next picture ptr NULL s next picture ptr f data 0 NULL s pict type AVPICTURETYPEB i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s next picture ptr s picture i if ff alloc picture s s next picture ptr 0 0 s next picture ptr NULL return 1 ff thread report progress s next picture ptr tf INTMAX 0 ff thread report progress s next picture ptr tf INTMAX 1 if s codec id AVCODECID H264 if s last picture ptr ff mpeg unref picture s s last picture if s last picture ptr f data 0 ret ff mpeg ref picture s s last picture s last picture ptr 0 return ret if s next picture ptr ff mpeg unref picture s s next picture if s next picture ptr f data 0 ret ff mpeg ref picture s s next picture s next picture ptr 0 return ret assert s pict type AVPICTURETYPEI s last picture ptr s last picture ptr f data 0 if s picture structure PICTFRAME s out format FMT H264 int i for i 0 i 4 i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture f linesize i s current picture f linesize i 2 s last picture f linesize i 2 s next picture f linesize i 2 s err recognition avctx err recognition if s mpeg quant s codec id AVCODECIDMPE G2 VIDEO s dct unquantize intra s dct unquantize mpeg2 intra s dct unquantize inter s dct unquantize mpeg2 inter else if s out format FMT H263 s out format FMT H261 s dct unquantize intra s dct unquantize h263 intra s dct unquantize inter s dct unquantize h263 inter else s dct unquantize intra s dct unquantize mpeg1 intra s dct unquantize inter s dct unquantize mpeg1 inter if s dct error sum assert s avctx noise reduction s encoding update noise reduction s if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration return ff xvmc field start s avctx return 0 int vp9 bigdia search const MACROBLOCK x MV ref mv int search param int sad per bit int do init search int sad list const vp9 variance fn ptr t vfp int use mvcost const MV center mv MV best mv static const int bigdia num candidates MAXPATTERNSCALES 4 8 8 8 8 8 8 8 8 8 8 static const MV bigdia candidates MAXPATTERNSCALESMAXPATTERNCANDIDATES 0 1 1 0 0 1 1 0 1 1 0 2 1 1 2 0 1 1 0 2 1 1 2 0 2 2 0 4 2 2 4 0 2 2 0 4 2 2 4 0 4 4 0 8 4 4 8 0 4 4 0 8 4 4 8 0 8 8 0 16 8 8 16 0 8 8 0 16 8 8 16 0 16 16 0 32 16 16 32 0 16 16 0 32 16 16 32 0 32 32 0 64 32 32 64 0 32 32 0 64 32 32 64 0 64 64 0 128 64 64 128 0 64 64 0 128 64 64 128 0 128 128 0 256 128 128 256 0 128 128 0 256 128 128 256 0 256 256 0 512 256 256 512 0 256 256 0 512 256 256 512 0 512 512 0 1024 512 512 1024 0 512 512 0 1024 512 512 1024 0 return vp9 pattern search x ref mv search param sad per bit do init search sad list vfp use mvcost center mv best mv bigdia num candidates bigdia candidates static int temporal filter find matching mb c V P9 COMP cpi uint8 t arf frame buf uint8 t frame ptr buf int stride MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const MVSPEEDFEATURES const mv sf cpi sf mv int step param int sadpb x sadperbit16 int bestsme INTMAX int distortion unsigned int sse int sad list 5 MV best ref mv1 0 0 MV best ref mv1 full MV ref mv x e mbd mi 0 src mi bmi 0 as mv 0 as mv struct buf 2d src x plane 0 src struct buf 2d pre xd plane 0 pre 0 best ref mv1 full col best ref mv1 col 3 best ref mv1 full row best ref mv1 row 3 x plane 0 src buf arf frame buf x plane 0 src stride stride xd plane 0 pre 0 buf frame ptr buf xd plane 0 pre 0 stride stride step param mv sf reduce first step size step param MIN step param MAXMVSEARCHSTEPS 2 vp9 hex search x best ref mv1 full step param sadpb 1 cond sad list cpi sad list cpi fn ptr BLOCK 16 X16 0 best ref mv1 ref mv bestsme cpi find fractional mv step x ref mv best ref mv1 cpi common allow high precision mv x errorperbit cpi fn ptr BLOCK 16 X16 0 mv sf subpel iters per step cond sad list cpi sad list NULLNULL distortion sse NULL 0 0 x plane 0 src src xd plane 0 pre 0 pre return bestsme static int rv34 set deblock coef R V34 Dec Context r Mpeg Enc Context s r s int hmvmask 0 vmvmask 0 i j int midx s mb x 2 s mb y 2 s b8 stride int16 t motion val 2 s current picture ptr f motion val 0 midx for j 0 j 16 j 8 for i 0 i 2 i if is mv diff gt 3 motion val i 1 vmvmask 0x11 j i 2 if j s mb y is mv diff gt 3 motion val i s b8 stride hmvmask 0x03 j i 2 motion val s b8 stride if s first slice line hmvmask 0x000 F if s mb x vmvmask 0x1111 if r rv30 vmvmask vmvmask 0x4444 1 hmvmask hmvmask 0x0 F00 4 if s mb x r deblock coefs s mb x 1 s mb y s mb stride vmvmask 0x1111 3 if s first slice line r deblock coefs s mb x s mb y 1 s mb stride hmvmask 0x F 12 return hmvmask vmvmask static enum nss status getanswer r const querybuf answer int anslen const char qname int qtype struct hostent result char buffer size t buflen int errnop int h errnop int map int32 t ttlp char canonp struct host data char aliases MAXNRALIASES unsigned char host addr 16 char h addr ptrs 0 host data int linebuflen const HEADER hp const u char end of message cp int n ancount qdcount int haveanswer had error char bp ap hap char tbuf MAXDNAME const char tname int name ok const char u char packtmp NSMAXCDNAME int have to map 0 uintptr t pad uintptr t buffer alignof struct host data buffer pad buflen buflen pad buflen pad 0 if glibc unlikely buflen sizeof struct host data too small errnop ERANGE h errnop NETDBINTERNAL return NSSSTATUSTRYAGAIN host data struct host data buffer linebuflen buflen sizeof struct host data if buflen sizeof struct host data linebuflen linebuflen INTMAX tname qname result h name NULL end of message answer buf anslen switch qtype case TA case TAAAA name ok res hnok break case TPTR name ok res dnok break default errnop ENOENT return NSSSTATUSUNAVAIL hp answer hdr ancount ntohs hp ancount qdcount ntohs hp qdcount cp answer buf HFIXEDSZ if builtin expect qdcount 1 1 h errnop NORECOVERY return NSSSTATUSUNAVAIL if sizeof struct host data ancount 1 sizeof char buflen goto too small bp char host data h addr ptrs ancount 1 linebuflen ancount 1 sizeof char n ns name unpack answer buf end of message cp packtmp sizeof packtmp if n 1 ns name ntop packtmp bp linebuflen 1 if builtin expect errno 0 EMSGSIZE goto too small n 1 if n 0 bp 0 bp 0 0 if builtin expect n 0 name ok bp 0 errno EBADMSG 0 errnop errno h errnop NORECOVERY return NSSSTATUSUNAVAIL cp n QFIXEDSZ if qtype TA qtype TAAAA n strlen bp 1 if n MAXHOSTNAMELEN h errnop NORECOVERY errnop ENOENT return NSSSTATUSTRYAGAIN result h name bp bp n linebuflen n if linebuflen 0 goto too small qname result h name ap host data aliases ap NULL result h aliases host data aliases hap host data h addr ptrs hap NULL result h addr list host data h addr ptrs haveanswer 0 had error 0 while ancount 0 cp end of message had error 0 int type class n ns name unpack answer buf end of message cp packtmp sizeof packtmp if n 1 ns name ntop packtmp bp linebuflen 1 if builtin expect errno 0 EMSGSIZE goto too small n 1 if glibc unlikely n 0 name ok bp 0 had error continue cp n if glibc unlikely cp 10 end of message had error continue type ns get16 cp cp IN T16 SZ class ns get16 cp cp IN T16 SZ int32 t ttl ns get32 cp cp IN T32 SZ n ns get16 cp cp IN T16 SZ if glibc unlikely class CIN cp n continue if qtype TA qtype TAAAA type TCNAME if ttlp NULL ttl ttlp ttlp ttl if ap host data aliases MAXNRALIASES 1 continue n dn expand answer buf end of message cp tbuf sizeof tbuf if glibc unlikely n 0 name ok tbuf 0 had error continue cp n ap bp n strlen bp 1 if builtin expect n 0 MAXHOSTNAMELEN had error continue bp n linebuflen n n strlen tbuf 1 if glibc unlikely n linebuflen goto too small if builtin expect n 0 MAXHOSTNAMELEN had error continue result h name bp bp mempcpy bp tbuf n linebuflen n continue if qtype TPTR type TCNAME n dn expand answer buf end of message cp tbuf sizeof tbuf if glibc unlikely n 0 res dnok tbuf 0 had error continue cp n n strlen tbuf 1 if glibc unlikely n linebuflen goto too small if builtin expect n 0 MAXHOSTNAMELEN had error continue tname bp bp mempcpy bp tbuf n linebuflen n continue if type TA qtype TAAAA map have to map 1 else if glibc unlikely type qtype if res options RESUSEDNSSEC 0 syslog LOGNOTICELOGAUTH gethostby getanswer asked for s s s got type s qname p class CIN p type qtype p type type cp n continue switch type case TPTR if glibc unlikely strcasecmp tname bp 0 syslog LOGNOTICELOGAUTH Asked For Got qname bp cp n continue n ns name unpack answer buf end of message cp packtmp sizeof packtmp if n 1 ns name ntop packtmp bp linebuflen 1 if builtin expect errno 0 EMSGSIZE goto too small n 1 if glibc unlikely n 0 res hnok bp 0 had error break result h name bp if have to map n strlen bp 1 if glibc unlikely n MAXHOSTNAMELEN had error break bp n linebuflen n if map v4v6 hostent result bp linebuflen goto too small h errnop NETDBSUCCESS return NSSSTATUSSUCCESS case TA case TAAAA if builtin expect strcasecmp result h name bp 0 0 syslog LOGNOTICELOGAUTH Asked For Got result h name bp cp n continue if n result h length cp n continue if haveanswer int nn if ttlp NULL ttl ttlp ttlp ttl if canonp NULL canonp bp result h name bp nn strlen bp 1 bp nn linebuflen nn linebuflen sizeof align u long bp sizeof align bp sizeof align u long bp sizeof align if glibc unlikely n linebuflen goto too small bp mempcpy hap bp cp n cp n linebuflen n break default abort if had error 0 haveanswer if haveanswer 0 ap NULL hap NULL n strlen qname 1 if n linebuflen goto too small if n MAXHOSTNAMELEN goto no recovery result h name bp bp mempcpy bp qname n linebuflen n if have to map if map v4v6 hostent result bp linebuflen goto too small h errnop NETDBSUCCESS return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Prores Context ctx avctx priv data AV Frame picture avctx coded frame const uint8 t buf avpkt data int buf size avpkt size int frame hdr size pic num pic data size if buf size 28 buf size AVR B32 buf AVR B32 buf 4 FRAMEID av log avctx AVLOGERROR invalid frame n return AVERRORINVALIDDATAMOVEDATAPTR 8 frame hdr size decode frame header ctx buf buf size avctx if frame hdr size 0 return AVERRORINVALIDDATAMOVEDATAPTR frame hdr size if picture data 0 avctx release buffer avctx picture picture reference 0 if ff get buffer avctx picture 0 return 1 for pic num 0 ctx picture interlaced frame pic num 1 pic num pic data size decode picture header ctx buf buf size avctx if pic data size 0 return AVERRORINVALIDDATA if decode picture ctx pic num avctx return 1 MOVEDATAPTR pic data size got frame 1 AV Frame data avctx coded frame return avpkt size int main int argc char argv const char globfile one two three NULL char tmpdir 32 struct passwd pw const char cwd int test int fail 0 int i struct test case struct ts if argc 1 command line test argv 1 return 0 cwd getcwd NULL 0 tmpnam tmpdir if mkdir tmpdir SIRWXU chdir tmpdir return 1 else int fd for i 0 globfile i i if fd creat globfile i SIRUSRSIWUSR 1 close fd return 1 if app register atfork register fork NULLNULL 0 printf Failed to register fork handler n return 1 for test 0 test case test retval 1 test if testit test case test fail pw getpwnam root if pw NULL ts retval 0 ts env NULL ts words root ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail ts retval 0 ts env pw pw dir ts words var root x ts flags 0 ts wordc 1 ts wordv 0 x ts ifs IFS if testit ts fail setenv HOME dummy home 1 ts retval 0 ts env NULL ts words foo ts flags 0 ts wordc 2 ts wordv 0 dummy home ts wordv 1 dummy home foo ts ifs IFS if testit ts fail pw getpwuid getuid if pw NULL unsetenv HOME ts retval 0 ts env NULL ts words ts flags 0 ts wordc 1 ts wordv 0 pw pw dir ts ifs IFS if testit ts fail puts tests completed now cleaning up for i 0 globfile i i remove globfile i if cwd NULL cwd chdir cwd rmdir tmpdir printf tests failed d n fail return fail 0 static int dissect diameter base framed ipv6 prefix tvbuff t tvb packet info pinfo U proto tree tree void data diam sub dis t diam sub dis diam sub dis t data guint8 prefix len prefix len bytes proto tree add item tree hf framed ipv6 prefix reserved tvb 0 1 ENCBIGENDIAN proto tree add item tree hf framed ipv6 prefix length tvb 1 1 ENCBIGENDIAN prefix len tvb get guint8 tvb 1 prefix len bytes prefix len 8 if prefix len 8 prefix len bytes proto tree add item tree hf framed ipv6 prefix bytes tvb 2 prefix len bytes ENCNA if prefix len bytes 16 proto tree add item tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes ENCNA else struct e in6 addr value address addr memset value bytes 0 sizeof value tvb memcpy tvb guint8 value bytes 2 prefix len bytes value bytes prefix len bytes value bytes prefix len bytes 0xff prefix len 8 proto tree add ipv6 tree hf framed ipv6 prefix ipv6 tvb 2 prefix len bytes value set address addr ATI Pv6 16 value bytes diam sub dis avp str wmem strdup printf wmem packet scope s u address to str wmem packet scope addr prefix len return prefix len bytes 2 static char rfc2047 decode word const char s size t len enum Content Encoding enc const char it s const char end s len if enc ENCQUOTEDPRINTABLE struct Buffer buf 0 for it end it if it mutt buffer addch buf else if it it 1 127 hexval it 1 1 it 2 127 hexval it 2 1 mutt buffer addch buf hexval it 1 4 hexval it 2 it 2 else mutt buffer addch buf it mutt buffer addch buf 0 return buf data else if enc ENCBAS E64 const int olen 3 len 4 1 char out mutt mem malloc olen int dlen mutt b64 decode out it olen if dlen 1 FREE out return NULL out dlen 0 return out assert 0 return static void render slice Vp3 Decode Context s int slice int x y i j fragment int16 t block s block int motion x 0xdeadbeef motion y 0xdeadbeef int motion halfpel index uint8 t motion source int plane first pixel if slice s c superblock height return for plane 0 plane 3 plane uint8 t output plane s current frame data plane s data offset plane uint8 t last plane s last frame data plane s data offset plane uint8 t golden plane s golden frame data plane s data offset plane int stride s current frame linesize plane int plane width s width plane s chroma x shift int plane height s height plane s chroma y shift int8 t motion val 2 s motion val plane int sb x sb y slice plane s chroma y shift int slice height sb y 1 plane s chroma y shift int slice width plane s c superblock width s y superblock width int fragment width s fragment width plane int fragment height s fragment height plane int fragment start s fragment start plane int do await plane HAVETHREADS s avctx active thread type FFTHREADFRAME if s flipped image stride stride if CONFIGGRAY plane s avctx flags CODECFLAGGRAY continue for sb y slice height sb y for sb x 0 sb x slice width sb x for j 0 j 16 j x 4 sb x hilbert offset j 0 y 4 sb y hilbert offset j 1 fragment y fragment width x i fragment start fragment if x fragment width y fragment height continue first pixel 8 y stride 8 x if do await s all fragments i coding method MODEINTRA await reference row s s all fragments i motion val fragment 1 16 y s chroma y shift if s all fragments i coding method MODECOPY if s all fragments i coding method MODEUSINGGOLDEN s all fragments i coding method MODEGOLDENMV motion source golden plane else motion source last plane motion source first pixel motion halfpel index 0 if s all fragments i coding method MODEINTRA s all fragments i coding method MODEUSINGGOLDEN int src x src y motion x motion val fragment 0 motion y motion val fragment 1 src x motion x 1 8 x src y motion y 1 8 y motion halfpel index motion x 0x01 motion source motion x 1 motion halfpel index motion y 0x01 1 motion source motion y 1 stride if src x 0 src y 0 src x 9 plane width src y 9 plane height uint8 t temp s edge emu buffer if stride 0 temp 8 stride s vdsp emulated edge mc temp motion source stride 9 9 src x src y plane width plane height motion source temp if s all fragments i coding method MODEINTRA if motion halfpel index 3 s dsp put no rnd pixels tab 1 motion halfpel index output plane first pixel motion source stride 8 else int d motion x motion y 31 s vp3dsp put no rnd pixels l2 output plane first pixel motion source d motion source stride 1 d stride 8 if s all fragments i coding method MODEINTRA int index index vp3 dequant s s all fragments i plane 0 block if index 63 continue s vp3dsp idct put output plane first pixel stride block else int index vp3 dequant s s all fragments i plane 1 block if index 63 continue if index 0 s vp3dsp idct add output plane first pixel stride block else s vp3dsp idct dc add output plane first pixel stride block else s dsp put pixels tab 1 0 output plane first pixel last plane first pixel stride 8 if s skip loop filter apply loop filter s plane 4 sb y sb y FFMIN 4 sb y 3 fragment height 1 vp3 draw horiz band s FFMIN 32 s chroma y shift slice 1 16 s height 16 static int rv34 decode inter mb header R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s Get Bit Context gb s gb int mb pos s mb x s mb y s mb stride int i t r block type r decode mb info r if r block type 1 return 1 s current picture ptr mb type mb pos rv34 mb type to lavc r block type r mb type mb pos r block type if r block type R V34 MBSKIP if s pict type AVPICTURETYPEP r mb type mb pos R V34 MBP 16x16 if s pict type AVPICTURETYPEB r mb type mb pos R V34 MBBDIRECT r is16 ISINTR A16x16 s current picture ptr mb type mb pos rv34 decode mv r r block type if r block type R V34 MBSKIP fill rectangle intra types 4 4 r intra types stride 0 sizeof intra types 0 return 0 r chroma vlc 1 r luma vlc 0 if ISINTRA s current picture ptr mb type mb pos if r is16 t get bits gb 2 fill rectangle intra types 4 4 r intra types stride t sizeof intra types 0 r luma vlc 2 else if r decode intra types r gb intra types 0 return 1 r luma vlc 1 r chroma vlc 0 r cur vlcs choose vlc set r si quant r si vlc set 0 else for i 0 i 16 i intra types i 3 i 2 r intra types stride 0 r cur vlcs choose vlc set r si quant r si vlc set 1 if r mb type mb pos R V34 MBPMI X16x16 r is16 1 r chroma vlc 1 r luma vlc 2 r cur vlcs choose vlc set r si quant r si vlc set 0 return rv34 decode cbp gb r cur vlcs r is16 static int isoent gen joliet identifier struct archive write a struct isoent isoent struct idr idr struct iso9660 iso9660 struct isoent np unsigned char p size t l int r size t ffmax parent len static const struct archive rb tree ops rb ops isoent cmp node joliet isoent cmp key joliet if isoent children cnt 0 return 0 iso9660 a format data if iso9660 opt joliet OPTJOLIETLONGNAME ffmax 206 else ffmax 128 r idr start a idr isoent children cnt int ffmax 6 2 rb ops if r 0 return r parent len 1 for np isoent np parent np np np parent parent len np mb len 1 for np isoent children first np NULL np np chnext unsigned char dot int ext off noff weight size t lt if l np file basename utf16 length ffmax l ffmax p malloc l 1 2 if p NULL archive set error a archive ENOMEM Can t allocate memory return ARCHIVEFATAL memcpy p np file basename utf16 s l p l 0 p l 1 0 np identifier char p lt l dot p l weight 0 while lt 0 if joliet allowed char p 0 p 1 archive be16enc p 0x005 F else if p 0 0 p 1 0x2 E dot p p 2 lt 2 ext off int dot unsigned char np identifier np ext off ext off np ext len int l ext off np id len int l if np file basename utf16 length ffmax if archive strncpy l iso9660 mbs const char np identifier l iso9660 sconv from utf16be 0 errno ENOMEM archive set error a archive errno No memory return ARCHIVEFATAL np mb len int iso9660 mbs length if np mb len int np file basename length weight np mb len else np mb len int np file basename length if parent len 240 np mb len 240 parent len np mb len 240 archive set error a archive ARCHIVEERRNOMISC The regulation of Joliet extensions A length of a full pathname of s is longer than 240 bytes p d b d archive entry pathname np file entry int parent len int np mb len return ARCHIVEFATAL if l ffmax noff ext off 6 else if l ffmax 2 noff ext off 4 else if l ffmax 4 noff ext off 2 else noff ext off idr register idr np weight noff idr resolve idr idr set num beutf16 return static inline void vc1 pred mv intfr V C1 Context v int n int dmv x int dmv y int mvn int r x int r y uint8 t is intra Mpeg Enc Context s v s int xy wrap off 0 int A 2 B 2 C 2 int px py int a valid 0 b valid 0 c valid 0 int field a field b field c int total valid num samefield num oppfield int pos c pos b n adj wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture motion val 0 xy 0 0 s mv 0 n 1 s current picture motion val 0 xy 1 0 s current picture motion val 1 xy 0 0 s current picture motion val 1 xy 1 0 if mvn 1 s current picture motion val 0 xy 1 0 0 s current picture motion val 0 xy 1 1 0 s current picture motion val 0 xy wrap 0 0 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy wrap 1 0 0 s current picture motion val 0 xy wrap 1 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture motion val 1 xy 1 0 0 s current picture motion val 1 xy 1 1 0 s current picture motion val 1 xy wrap 0 0 s current picture motion val 1 xy wrap 1 0 s current picture motion val 1 xy wrap 1 0 0 s current picture motion val 1 xy wrap 1 1 0 return off n 0 n 1 1 1 if s mb x n 1 n 3 if v blk mv type xy v blk mv type xy v blk mv type xy 1 A 0 s current picture motion val 0 xy 1 0 A 1 s current picture motion val 0 xy 1 1 a valid 1 else A 0 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 1 off wrap 0 1 1 A 1 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 off wrap 1 1 1 a valid 1 if n 1 v is intra s mb x 1 a valid 0 A 0 A 1 0 else A 0 A 1 0 B 0 B 1 C 0 C 1 0 if n 0 n 1 v blk mv type xy if s first slice line if v is intra s mb x s mb stride b valid 1 n adj n 2 pos b s block index n adj 2 wrap if v blk mv type pos b v blk mv type xy n adj n 2 n 1 B 0 s current picture motion val 0 s block index n adj 2 wrap 0 B 1 s current picture motion val 0 s block index n adj 2 wrap 1 if v blk mv type pos b v blk mv type xy B 0 B 0 s current picture motion val 0 s block index n adj 2 2 wrap 0 1 1 B 1 B 1 s current picture motion val 0 s block index n adj 2 2 wrap 1 1 1 if s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 2 pos c s block index 2 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 2 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index n adj 2 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index n adj 2 2 wrap 2 1 1 if s mb x s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 3 pos c s block index 3 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 1 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index 1 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index 1 2 wrap 2 1 1 else c valid 0 else pos b s block index 1 b valid 1 B 0 s current picture motion val 0 pos b 0 B 1 s current picture motion val 0 pos b 1 pos c s block index 0 c valid 1 C 0 s current picture motion val 0 pos c 0 C 1 s current picture motion val 0 pos c 1 total valid a valid b valid c valid if s mb x n 1 n 3 A 0 A 1 0 if s first slice line v blk mv type xy s first slice line n 2 B 0 B 1 C 0 C 1 0 if v blk mv type xy if s mb width 1 px B 0 py B 1 else if total valid 2 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if total valid if a valid px A 0 py A 1 if b valid px B 0 py B 1 if c valid px C 0 py C 1 else px py 0 else if a valid field a A 1 4 1 0 else field a 0 if b valid field b B 1 4 1 0 else field b 0 if c valid field c C 1 4 1 0 else field c 0 num oppfield field a field b field c num samefield total valid num oppfield if total valid 3 if num samefield 3 num oppfield 3 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if num samefield num oppfield px field a A 0 B 0 py field a A 1 B 1 else px field a A 0 B 0 py field a A 1 B 1 else if total valid 2 if num samefield num oppfield if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else px py 0 else if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else if total valid 1 px a valid A 0 b valid B 0 C 0 py a valid A 1 b valid B 1 C 1 else px py 0 s mv 0 n 0 s current picture motion val 0 xy 0 px dmv x r x r x 1 1 r x s mv 0 n 1 s current picture motion val 0 xy 1 py dmv y r y r y 1 1 r y if mvn 1 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 1 s current picture motion val 0 xy 1 else if mvn 2 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s mv 0 n 1 0 s mv 0 n 0 s mv 0 n 1 1 s mv 0 n 1 static int vc1 decode p mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int val int first block 1 int dst idx off int pred flag int block cbp 0 pat block tt 0 int idx mbmode 0 mquant v pq idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 v mb type 0 s block index i 1 dst idx i 2 val cbp 5 i 1 v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if idx mbmode 5 dmv x dmv y pred flag 0 if idx mbmode 1 get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v 0 dmv x dmv y 1 v range x v range y v mb type 0 pred flag 0 vc1 mc 1mv v 0 mb has coeffs idx mbmode 2 else v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x dmv y pred flag 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v i dmv x dmv y 0 v range x v range y v mb type 0 pred flag 0 vc1 mc 4mv luma v i 0 else if i 4 vc1 mc 4mv chroma v 0 mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 if s mb x s mb width 1 memmove v is intra base v is intra sizeof v is intra base 0 s mb stride return 0 static void preview obmc Mpeg Enc Context s Get Bit Context gb s gb int cbpc i pred x pred y mx my int16 t mot val const int xy s mb x 1 s mb y s mb stride const int stride s b8 stride 2 for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x assert s pict type AVPICTURETYPEP do if get bits1 s gb mot val s current picture motion val 0 s block index 0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride 0 mot val 1 mot val 3 mot val 1 stride mot val 3 stride 0 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 while cbpc 20 if cbpc 4 s current picture mb type xy MBTYPEINTRA else get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpc 8 if s modified quant if get bits1 s gb skip bits s gb 1 else skip bits s gb 5 else skip bits s gb 2 if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 mot val ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my end for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x s gb gb static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Nuv Context c avctx priv data AV Frame picture data int orig size buf size int keyframe int result init frame avctx frame number enum NUVUNCOMPRESSED 0 NUVRTJPEG 1 NUVRTJPEGINLZO 2 NUVLZO 3 NUVBLACKNNUVCOPYLASTL comptype if buf size 12 av log avctx AVLOGERROR coded frame too small n return AVERRORINVALIDDATA if buf 0 D buf 1 R int ret buf buf 12 buf size 12 ret get quant avctx c buf buf size if ret 0 return ret ff rtjpeg decode init c rtj c dsp c width c height c lq c cq return orig size if buf 0 V buf size 12 av log avctx AVLOGERROR not a nuv video frame n return AVERRORINVALIDDATA comptype buf 1 switch comptype case NUVRTJPEGINLZO case NUVRTJPEG keyframe buf 2 break case NUVCOPYLAST keyframe 0 break default keyframe 1 break buf buf 12 buf size 12 if comptype NUVRTJPEGINLZO comptype NUVLZO int outlen c decomp size inlen buf size if av lzo1x decode c decomp buf outlen buf inlen av log avctx AVLOGERROR error during lzo decompression n buf c decomp buf buf size c decomp size if c codec frameheader int w h q if buf size RTJPEGHEADERSIZE buf 4 RTJPEGHEADERSIZE buf 5 RTJPEGFILEVERSION av log avctx AVLOGERROR invalid nuv video frame n return AVERRORINVALIDDATA w AVR L16 buf 6 h AVR L16 buf 8 q buf 10 if result codec reinit avctx w h q 0 return result buf buf RTJPEGHEADERSIZE buf size RTJPEGHEADERSIZE if keyframe av frame unref c pic init frame 1 result ff reget buffer avctx c pic if result 0 av log avctx AVLOGERROR get buffer failed n return result if init frame memset c pic data 0 0 avctx height c pic linesize 0 memset c pic data 1 0x80 avctx height c pic linesize 1 2 memset c pic data 2 0x80 avctx height c pic linesize 2 2 c pic pict type keyframe AVPICTURETYPEIAVPICTURETYPEP c pic key frame keyframe switch comptype case NUVLZO case NUVUNCOMPRESSED int height c height if buf size c width height 3 2 av log avctx AVLOGERROR uncompressed frame too short n height buf size c width 3 2 copy frame c pic buf c width height break case NUVRTJPEGINLZO case NUVRTJPEG ff rtjpeg decode frame yuv420 c rtj c pic buf buf size break case NUVBLACK memset c pic data 0 0 c width c height memset c pic data 1 128 c width c height 4 memset c pic data 2 128 c width c height 4 break case NUVCOPYLAST break default av log avctx AVLOGERROR unknown compression n return AVERRORINVALIDDATA if result av frame ref picture c pic 0 return result got frame 1 return orig size int petite inflate2x 1to9 char buf uint32 t minrva uint32 t bufsz struct cli exe section sections unsigned int sectcount uint32 t Imagebase uint32 t pep int desc int version uint32 t Res Rva uint32 t Res Size char adjbuf buf minrva char packed NULL uint32 t thisrva 0 bottom 0 enc ep 0 irva 0 workdone 0 grown 0x355 skew 0x35 int j 0 oob mangled 0 check4resources 0 struct cli exe section usects NULL void tmpsct NULL if version 2 packed adjbuf sections sectcount 1 rva 0x1b8 if version 1 packed adjbuf sections sectcount 1 rva 0x178 grown 0x323 skew 0x34 while 1 char ssrc ddst uint32 t size srva int backbytes oldback backsize addsize if CLIISCONTAINED buf bufsz packed 4 if usects free usects return 1 srva cli readint32 packed if srva int t upd 1 if j 0 return 1 while upd upd 0 for t 0 t j 1 t uint32 t trva trsz tvsz if usects t rva usects t 1 rva continue trva usects t rva trsz usects t rsz tvsz usects t vsz usects t rva usects t 1 rva usects t rsz usects t 1 rsz usects t vsz usects t 1 vsz usects t 1 rva trva usects t 1 rsz trsz usects t 1 vsz tvsz upd 1 for t 0 t j 1 t if usects t vsz usects t 1 rva usects t rva usects t vsz usects t 1 rva usects t rva if enc ep uint32 t virtaddr pep 5 Imagebase tmpep int rndm 0 dummy 1 char thunk adjbuf irva char imports if version 2 while dummy CLIISCONTAINED buf bufsz thunk 4 uint32 t api if cli readint32 thunk workdone 1 break imports adjbuf cli readint32 thunk thunk 4 dummy 0 while CLIISCONTAINED buf bufsz imports 4 dummy 0 imports 4 if api cli readint32 imports 4 dummy 1 break if api api 0x80000000 mangled rndm 0 api virtaddr virtaddr 5 rndm virtaddr 7 else api 0xbff01337 if sections sectcount 1 rva Imagebase api enc ep if api virtaddr enc ep tmpep enc ep 0xfffffff8 3 0x1fffffff enc ep enc ep 7 29 tmpep else workdone 1 enc ep pep 5 enc ep if workdone 1 cli dbgmsg Petite Old EP x n enc ep else enc ep usects 0 rva cli dbgmsg Petite In troubles while attempting to decrypt old EP using bogus x n enc ep for t 0 t j t usects t raw t 0 usects t 1 raw usects t 1 rsz 0 if usects t rsz 0 if CLIISCONTAINED buf bufsz buf usects t raw usects t rsz memmove buf usects t raw adjbuf usects t rva usects t rsz else cli dbgmsg Petite Skipping section d Raw x R Size x n t usects t raw usects t rsz usects t raw t 0 usects t 1 raw 0 usects t rsz 0 cli dbgmsg Petite Sections dump n for t 0 t j t cli dbgmsg Petite SECT d RVA x V Size x R Offset x R Size x n t usects t rva usects t vsz usects t raw usects t rsz if cli rebuildpe buf usects j Imagebase enc ep Res Rva Res Size desc cli dbgmsg Petite Rebuilding failed n free usects return 1 free usects return 0 size srva 0x7fffffff if srva size check4resources 0 if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 bottom cli readint32 packed 8 4 ssrc adjbuf cli readint32 packed 4 size 1 4 ddst adjbuf cli readint32 packed 8 size 1 4 if CLIISCONTAINED buf bufsz ssrc size 4 CLIISCONTAINED buf bufsz ddst size 4 if usects free usects return 1 memmove ddst ssrc size 4 packed 0x0c else uint32 t check1 check2 uint8 t mydl 0 uint8 t goback unsigned int q if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 size cli readint32 packed 4 thisrva cli readint32 packed 8 packed 0x10 if j 96 cli dbgmsg Petite maximum number of sections exceeded giving up n free usects return 1 if tmpsct cli realloc usects sizeof struct cli exe section j 1 if usects free usects return 1 usects struct cli exe section tmpsct usects j rva thisrva usects j rsz size if int bottom thisrva 0 usects j vsz bottom thisrva else usects j vsz size usects j raw 0 if size j continue ssrc adjbuf srva ddst adjbuf thisrva for q 0 q sectcount q if CLIISCONTAINED sections q rva sections q vsz usects j rva usects j vsz continue if check4resources usects j rva sections q rva usects j rsz thisrva sections q rva size break if q sectcount free usects return 1 j if size 0x10000 check1 0x0 FFFF C060 check2 0x0 FFFFF C60 goback 5 else if size 0x40000 check1 0x0 FFF F8180 check2 0x0 FFFF F980 goback 7 else check1 0x0 FFF F8300 check2 0x0 FFFFF B00 goback 8 if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 size ddst ssrc backbytes 0 oldback 0 while size 0 oob doubledl ssrc mydl buf bufsz if oob 1 free usects return 1 if oob if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 ddst char ssrc size 0xff size else addsize 0 backbytes while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backbytes 3 if backbytes 0 backsize goback do if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob backsize while backsize backbytes 0xffffffff addsize 1 backbytes int check2 backbytes int check1 oldback backbytes else backsize backbytes 1 backbytes oldback if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if backsize backsize while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backsize 2 backsize addsize size backsize if CLIISCONTAINED buf bufsz ddst backsize CLIISCONTAINED buf bufsz ddst backbytes backsize free usects return 1 while backsize ddst ddst backbytes ddst backbytes 0 backsize 0 if j int strippetite 0 uint32 t reloc if usects j 1 rsz grown CLIISCONTAINED buf bufsz ddst grown 5 0x4f 8 cli readint32 ddst grown 5 0x4f 0x645ec033 cli readint32 ddst grown 5 0x4f 4 0x1b8b188b reloc 0 strippetite 1 if strippetite usects j 1 rsz grown skew CLIISCONTAINED buf bufsz ddst grown 5 0x4f skew 8 cli readint32 ddst grown 5 0x4f skew 0x645ec033 cli readint32 ddst grown 5 0x4f 4 skew 0x1b8b188b reloc skew strippetite 1 if strippetite CLIISCONTAINED buf bufsz ddst grown 0x0f 8 reloc 8 uint32 t test1 test2 test1 cli readint32 ddst grown 0x0f 8 reloc 0x9d6661aa test2 cli readint32 ddst grown 0x0f 4 reloc 0xe908c483 cli dbgmsg Petite Found petite code in sect d x Let s strip it n j 1 usects j 1 rva if test1 test2 CLIISCONTAINED buf bufsz ddst grown 0x0f reloc 0x1c0 0x0f 4 irva cli readint32 ddst grown 0x121 reloc enc ep cli readint32 ddst grown 0x0f reloc test1 mangled uint32 t cli readint32 ddst grown 0x1c0 reloc 0x90909090 cli dbgmsg Petite Encrypted EP x Array of imports x n enc ep irva usects j 1 rsz grown reloc check4resources static int dissect ipmi trace tvbuff t tvb packet info pinfo proto tree tree void data U guint block type chn num data type tmp tvbuff t next tvb if tvb captured length tvb 11 call data dissector tvb pinfo tree return tvb captured length tvb tmp tvb get guint8 tvb 0 block type tmp 4 3 chn num tmp 0x F data type tvb get guint8 tvb 7 col add fstr pinfo cinfo COLDEFSRC Channel d chn num col add str pinfo cinfo COLPROTOCOL val to str data type str protocol types Reserved 0x 02x col clear pinfo cinfo COLINFO if block type HP M2 TRACEPACKETDATA col set str pinfo cinfo COLINFO Trace Packet Data else if block type HP M2 CHNSTATENOTIFY col set str pinfo cinfo COLINFO Channel State Change Notification else if block type HP M2 EMBEDASCIIMSG char str 257 guint str len tvb get guint8 tvb 10 if str len tvb memcpy tvb str 11 str len str str len 0 col add str pinfo cinfo COLINFO str else col set str pinfo cinfo COLINFO Reserved if tree proto item ti proto tree trace tree proto tree stamp tree nstime t timestamp ti proto tree add item tree proto ipmi trace tvb 0 1 ENCNA trace tree proto item add subtree ti ett ipmi trace proto tree add bitmask trace tree tvb 0 hf trace block type ett trace block type bits trace block type ENCLITTLEENDIAN timestamp secs tvb get letohl tvb 1 timestamp nsecs int tvb get letohs tvb 5 1000000 ti proto tree add time trace tree hf trace timestamp tvb 1 6 timestamp stamp tree proto item add subtree ti ett trace timestamp proto tree add item stamp tree hf trace timestamp sec tvb 1 4 ENCLITTLEENDIAN proto tree add item stamp tree hf trace timestamp msec tvb 5 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data type tvb 7 1 ENCLITTLEENDIAN if data type IPMIPROTOIPMB 1 0 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits ipmb protocol data ENCLITTLEENDIAN else if data type IPMIPROTOKCS data type IPMIPROTOSMIC data type IPMIPROTOBT 10 data type IPMIPROTOBT 15 proto tree add bitmask trace tree tvb 8 hf trace protocol data ett trace protocol data bits host protocol data ENCLITTLEENDIAN else proto tree add item trace tree hf trace protocol data tvb 8 2 ENCLITTLEENDIAN proto tree add item trace tree hf trace data len tvb 10 1 ENCLITTLEENDIAN next tvb tvb new subset remaining tvb 11 if block type HP M2 TRACEPACKETDATA ipmi dissect arg t arg arg context IPMIENONE arg channel chn num arg flags tvb get guint8 tvb 8 if dissector try uint new proto dissector table data type next tvb pinfo tree TRUE arg call data dissector next tvb pinfo tree else if block type HP M2 CHNSTATENOTIFY data type IPMIPROTOIPMB 1 0 dissect ipmb state notify next tvb tree else call data dissector next tvb pinfo tree return tvb captured length tvb Selectivity scalararraysel containment Planner Info root Node leftop Node rightop Oid elemtype bool is Equality bool use Or int var Relid Selectivity selec Variable Stat Data vardata Datum constval Type Cache Entry typentry Fmgr Info cmpfunc examine variable root rightop var Relid vardata if vardata rel Release Variable Stats vardata return 1 0 if Is A leftop Const Release Variable Stats vardata return 1 0 if Const leftop constisnull Release Variable Stats vardata return Selectivity 0 0 constval Const leftop constvalue typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid Release Variable Stats vardata return 1 0 cmpfunc typentry cmp proc finfo if is Equality use Or use Or if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata cmpfunc fn oid Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if use Or get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 if use Or selec mcelem array contain overlap selec values nvalues numbers nnumbers constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec values nvalues numbers nnumbers constval 1 hist nhist OIDARRAYCONTAINEDOP cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc selec 1 0 stats stanullfrac else if use Or selec mcelem array contain overlap selec NULL 0 NULL 0 constval 1 OIDARRAYCONTAINSOP cmpfunc else selec mcelem array contained selec NULL 0 NULL 0 constval 1 NULL 0 OIDARRAYCONTAINEDOP cmpfunc Release Variable Stats vardata if is Equality selec 1 0 selec CLAMPPROBABILITY selec return selec void ff h264 direct ref list init H264 Context const h Picture const ref1 h ref list 1 0 Picture const cur h cur pic ptr int list j field int sidx h picture structure 1 1 int ref1sidx ref1 reference 1 1 for list 0 list 2 list cur ref count sidx list h ref count list for j 0 j h ref count list j cur ref poc sidx list j 4 h ref list list j frame num h ref list list j reference 3 if h picture structure PICTFRAME memcpy cur ref count 1 cur ref count 0 sizeof cur ref count 0 memcpy cur ref poc 1 cur ref poc 0 sizeof cur ref poc 0 cur mbaff FRAMEMBAFF h col fieldoff 0 if h picture structure PICTFRAME int cur poc h cur pic ptr poc int col poc h ref list 1 field poc h col parity FFABS col poc 0 cur poc FFABS col poc 1 cur poc ref1sidx sidx h col parity else if h picture structure h ref list 1 0 reference h ref list 1 0 mbaff h col fieldoff 2 h ref list 1 0 reference 3 if h slice type nos AVPICTURETYPEB h direct spatial mv pred return for list 0 list 2 list fill colmap h h map col to list0 list sidx ref1sidx 0 if FRAMEMBAFF for field 0 field 2 field fill colmap h h map col to list0 field field list field field 1 static unsigned int do 16x16 motion iteration V P9 COMP cpi const MV ref mv MV dst mv int mb row int mb col MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const MVSPEEDFEATURES const mv sf cpi sf mv const vp9 variance fn ptr t v fn ptr cpi fn ptr BLOCK 16 X16 const int tmp col min x mv col min const int tmp col max x mv col max const int tmp row min x mv row min const int tmp row max x mv row max MV ref full int sad list 5 int step param mv sf reduce first step size step param MIN step param MAXMVSEARCHSTEPS 2 vp9 set mv search range x ref mv ref full col ref mv col 3 ref full row ref mv row 3 vp9 hex search x ref full step param x errorperbit 0 cond sad list cpi sad list v fn ptr 0 ref mv dst mv int distortion unsigned int sse cpi find fractional mv step x dst mv ref mv cpi common allow high precision mv x errorperbit v fn ptr 0 mv sf subpel iters per step cond sad list cpi sad list NULLNULL distortion sse NULL 0 0 xd mi 0 src mi mbmi mode NEWMV xd mi 0 src mi mbmi mv 0 as mv dst mv vp9 build inter predictors sby xd mb row mb col BLOCK 16 X16 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max return vp9 sad16x16 x plane 0 src buf x plane 0 src stride xd plane 0 dst buf xd plane 0 dst stride static void preview obmc Mpeg Enc Context s Get Bit Context gb s gb int cbpc i pred x pred y mx my int16 t mot val const int xy s mb x 1 s mb y s mb stride const int stride s b8 stride 2 for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x assert s pict type AVPICTURETYPEP do if get bits1 s gb mot val s current picture motion val 0 s block index 0 mot val 0 mot val 2 mot val 0 stride mot val 2 stride 0 mot val 1 mot val 3 mot val 1 stride mot val 3 stride 0 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 while cbpc 20 if cbpc 4 s current picture mb type xy MBTYPEINTRA else get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpc 8 if s modified quant if get bits1 s gb skip bits s gb 1 else skip bits s gb 5 else skip bits s gb 2 if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 mot val ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 mot val 0 mot val 2 mot val 0 stride mot val 2 stride mx mot val 1 mot val 3 mot val 1 stride mot val 3 stride my else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my end for i 0 i 4 i s block index i 2 for i 4 i 6 i s block index i 1 s mb x s gb gb static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint32 t src const uint32 t avpkt data AV Frame pic avctx coded frame int width avctx width int y 0 uint16 t ydst udst vdst yend int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 8 3 av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA if avpkt size avctx width avctx height 8 3 av log ask for sample avctx Probably padded data n pic reference 0 if ret ff get buffer avctx pic 0 return ret ydst uint16 t pic data 0 udst uint16 t pic data 1 vdst uint16 t pic data 2 yend ydst width pic pict type AVPICTURETYPEI pic key frame 1 for uint32 t v av be2ne32 src udst v 16 0x FF C0 ydst v 6 0x FF C0 vdst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 6 0x FF C0 ydst v 4 0x FF C0 v av be2ne32 src vdst v 16 0x FF C0 ydst v 6 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 vdst v 6 0x FF C0 ydst v 4 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break got frame 1 AV Frame data avctx coded frame return avpkt size static int64 t rd pick intra sub 8x8 y mode V P9 COMP cpi MACROBLOCK mb int rate int rate y int64 t distortion int64 t best rd int i j const MACROBLOCKD const xd mb e mbd MODEINFO const mic xd mi 0 const MODEINFO above mi xd mi xd mi stride const MODEINFO left mi xd left available xd mi 1 NULL const BLOCKSIZE bsize xd mi 0 mbmi sb type const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize int idx idy int cost 0 int64 t total distortion 0 int tot rate y 0 int64 t total rd 0 ENTROPYCONTEXT t above 4 t left 4 const int bmode costs cpi mbmode cost vpx memcpy t above xd plane 0 above context sizeof t above vpx memcpy t left xd plane 0 left context sizeof t left for idy 0 idy 2 idy num 4x4 blocks high for idx 0 idx 2 idx num 4x4 blocks wide PREDICTIONMODE best mode DCPRED int r INTMAX ry INTMAX int64 t d IN T64 MAX this rd IN T64 MAX i idy 2 idx if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi i const PREDICTIONMODEL vp9 left block mode mic left mi i bmode costs cpi y mode costs AL this rd rd pick intra4x4block cpi mb i best mode bmode costs t above idx t left idy r ry d bsize best rd total rd if this rd best rd total rd return IN T64 MAX total rd this rd cost r total distortion d tot rate y ry mic bmi i as mode best mode for j 1 j num 4x4 blocks high j mic bmi i j 2 as mode best mode for j 1 j num 4x4 blocks wide j mic bmi i j as mode best mode if total rd best rd return IN T64 MAX rate cost rate y tot rate y distortion total distortion mic mbmi mode mic bmi 3 as mode return RDCOST mb rdmult mb rddiv cost total distortion int ff h264 execute ref pic marking H264 Context h MMCO mmco int mmco count int i av uninit j int current ref assigned 0 err 0 Picture av uninit pic if h avctx debug FFDEBUGMMCO mmco count 0 av log h avctx AVLOGDEBUG no mmco here n for i 0 i mmco count i int av uninit structure av uninit frame num if h avctx debug FFDEBUGMMCO av log h avctx AVLOGDEBUG mmco d d d n h mmco i opcode h mmco i short pic num h mmco i long arg if mmco i opcode MMCOSHOR T2 UNUSED mmco i opcode MMCOSHOR T2 LONG frame num pic num extract h mmco i short pic num structure pic find short h frame num j if pic if mmco i opcode MMCOSHOR T2 LONG h long ref mmco i long arg h long ref mmco i long arg frame num frame num av log h avctx AVLOGERROR mmco unref short failure n err AVERRORINVALIDDATA continue switch mmco i opcode case MMCOSHOR T2 UNUSED if h avctx debug FFDEBUGMMCO av log h avctx AVLOGDEBUG mmco unref short d count d n h mmco i short pic num h short ref count remove short h frame num structure PICTFRAME break case MMCOSHOR T2 LONG if h long ref mmco i long arg pic remove long h mmco i long arg 0 remove short at index h j h long ref mmco i long arg pic if h long ref mmco i long arg h long ref mmco i long arg long ref 1 h long ref count break case MMCOLON G2 UNUSED j pic num extract h mmco i long arg structure pic h long ref j if pic remove long h j structure PICTFRAME else if h avctx debug FFDEBUGMMCO av log h avctx AVLOGDEBUG mmco unref long failure n break case MMCOLONG if h long ref mmco i long arg h cur pic ptr remove long h mmco i long arg 0 h long ref mmco i long arg h cur pic ptr h long ref mmco i long arg long ref 1 h long ref count h cur pic ptr f reference h picture structure current ref assigned 1 break case MMCOSETMAXLONG assert mmco i long arg 16 for j mmco i long arg j 16 j remove long h j 0 break case MMCORESET while h short ref count remove short h h short ref 0 frame num 0 for j 0 j 16 j remove long h j 0 h frame num h cur pic ptr frame num 0 h mmco reset 1 h cur pic ptr mmco reset 1 break default assert 0 if current ref assigned if h short ref count h short ref 0 h cur pic ptr h cur pic ptr f reference PICTFRAME else if h cur pic ptr long ref av log h avctx AVLOGERROR illegal short term reference assignment for second field in complementary field pair first field is long term n err AVERRORINVALIDDATA else pic remove short h h cur pic ptr frame num 0 if pic av log h avctx AVLOGERROR illegal short term buffer state detected n err AVERRORINVALIDDATA if h short ref count memmove h short ref 1 h short ref 0 h short ref count sizeof Picture h short ref 0 h cur pic ptr h short ref count h cur pic ptr f reference h picture structure if h long ref count h short ref count h short ref 0 h cur pic ptr h sps ref frame count av log h avctx AVLOGERROR number of reference frames d d exceeds max d probably corrupt input discarding one n h long ref count h short ref count h sps ref frame count err AVERRORINVALIDDATA if h long ref count h short ref count for i 0 i 16 i if h long ref i break assert i 16 remove long h i 0 else pic h short ref h short ref count 1 remove short h pic frame num 0 print short term h print long term h return h avctx err recognition AVEFEXPLODE err 0 void jpc qmfb split colres jpc fix t a int numrows int numcols int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr numcols srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr numcols if buf splitbuf jas free buf static int v410 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame pic data uint8 t src avpkt data uint16 t y u v uint32 t val int i j if avpkt size 4 avctx height avctx width av log avctx AVLOGERROR Insufficient input data n return AVERROREINVAL if ff get buffer avctx pic 0 0 av log avctx AVLOGERROR Could not allocate buffer n return AVERRORENOMEM pic key frame 1 pic pict type AVPICTURETYPEI y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 for i 0 i avctx height i for j 0 j avctx width j val AVR L32 src u j val 2 0x3 FF y j val 12 0x3 FF v j val 22 src 4 y pic linesize 0 1 u pic linesize 1 1 v pic linesize 2 1 got frame 1 return avpkt size int ff h264 decode mb cabac H264 Context h int mb xy int mb type partition count cbp 0 int dct8x8 allowed h pps transform 8x8 mode int decode chroma h sps chroma format idc 1 h sps chroma format idc 2 const int pixel shift h pixel shift mb xy h mb xy h mb x h mb y h mb stride tprintf h avctx pic d mb d d n h frame num h mb x h mb y if h slice type nos AVPICTURETYPEI int skip if FRAMEMBAFF h mb y 1 1 h prev mb skipped skip h next mb skipped else skip decode cabac mb skip h h mb x h mb y if skip if FRAMEMBAFF h mb y 1 0 h cur pic mb type mb xy MBTYPESKIP h next mb skipped decode cabac mb skip h h mb x h mb y 1 if h next mb skipped h mb mbaff h mb field decoding flag decode cabac field decoding flag h decode mb skip h h cbp table mb xy 0 h chroma pred mode table mb xy 0 h last qscale diff 0 return 0 if FRAMEMBAFF if h mb y 1 0 h mb mbaff h mb field decoding flag decode cabac field decoding flag h h prev mb skipped 0 fill decode neighbors h MBFIELD if h slice type nos AVPICTURETYPEB int ctx 0 assert h slice type nos AVPICTURETYPEB if ISDIRECT h left type LTOP 1 ctx if ISDIRECT h top type 1 ctx if get cabac noinline h cabac h cabac state 27 ctx mb type 0 else if get cabac noinline h cabac h cabac state 27 3 mb type 1 get cabac noinline h cabac h cabac state 27 5 else int bits bits get cabac noinline h cabac h cabac state 27 4 3 bits get cabac noinline h cabac h cabac state 27 5 2 bits get cabac noinline h cabac h cabac state 27 5 1 bits get cabac noinline h cabac h cabac state 27 5 if bits 8 mb type bits 3 else if bits 13 mb type decode cabac intra mb type h 32 0 goto decode intra mb else if bits 14 mb type 11 else if bits 15 mb type 22 else bits bits 1 get cabac noinline h cabac h cabac state 27 5 mb type bits 4 partition count b mb type info mb type partition count mb type b mb type info mb type type else if h slice type nos AVPICTURETYPEP if get cabac noinline h cabac h cabac state 14 0 if get cabac noinline h cabac h cabac state 15 0 mb type 3 get cabac noinline h cabac h cabac state 16 else mb type 2 get cabac noinline h cabac h cabac state 17 partition count p mb type info mb type partition count mb type p mb type info mb type type else mb type decode cabac intra mb type h 17 0 goto decode intra mb else mb type decode cabac intra mb type h 3 1 if h slice type AVPICTURETYPESI mb type mb type assert h slice type nos AVPICTURETYPEI decode intra mb partition count 0 cbp i mb type info mb type cbp h intra16x16 pred mode i mb type info mb type pred mode mb type i mb type info mb type type if MBFIELD mb type MBTYPEINTERLACED h slice table mb xy h slice num if ISINTRAPCM mb type const int mb size ff h264 mb sizes h sps chroma format idc h sps bit depth luma 3 const uint8 t ptr ptr h cabac bytestream if h cabac low 0x1 ptr if CABACBITS 16 if h cabac low 0x1 FF ptr if int h cabac bytestream end ptr mb size return 1 h intra pcm ptr ptr ptr mb size ff init cabac decoder h cabac ptr h cabac bytestream end ptr h cbp table mb xy 0xf7ef h chroma pred mode table mb xy 0 h cur pic qscale table mb xy 0 memset h non zero count mb xy 16 48 h cur pic mb type mb xy mb type h last qscale diff 0 return 0 fill decode caches h mb type if ISINTRA mb type int i pred mode if ISINTR A4x4 mb type if dct8x8 allowed get cabac noinline h cabac h cabac state 399 h neighbor transform size mb type MBTYPE 8x8 DCT for i 0 i 16 i 4 int pred pred intra mode h i int mode decode cabac mb intra4x4 pred mode h pred fill rectangle h intra4x4 pred mode cache scan8 i 2 2 8 mode 1 else for i 0 i 16 i int pred pred intra mode h i h intra4x4 pred mode cache scan8 i decode cabac mb intra4x4 pred mode h pred av dlog h avctx i4x4 pred d mode d n pred h intra4x4 pred mode cache scan8 i write back intra pred mode h if ff h264 check intra4x4 pred mode h 0 return 1 else h intra16x16 pred mode ff h264 check intra pred mode h h intra16x16 pred mode 0 if h intra16x16 pred mode 0 return 1 if decode chroma h chroma pred mode table mb xy pred mode decode cabac mb chroma pre mode h pred mode ff h264 check intra pred mode h pred mode 1 if pred mode 0 return 1 h chroma pred mode pred mode else h chroma pred mode DC 128 PRE D8x8 else if partition count 4 int i j sub partition count 4 list ref 2 4 if h slice type nos AVPICTURETYPEB for i 0 i 4 i h sub mb type i decode cabac b mb sub type h sub partition count i b sub mb type info h sub mb type i partition count h sub mb type i b sub mb type info h sub mb type i type if ISDIRECT h sub mb type 0 h sub mb type 1 h sub mb type 2 h sub mb type 3 ff h264 pred direct motion h mb type h ref cache 0 scan8 4 h ref cache 1 scan8 4 h ref cache 0 scan8 12 h ref cache 1 scan8 12 PARTNOTAVAILABLE for i 0 i 4 i fill rectangle h direct cache scan8 4 i 2 2 8 h sub mb type i 1 0x FF 1 else for i 0 i 4 i h sub mb type i decode cabac p mb sub type h sub partition count i p sub mb type info h sub mb type i partition count h sub mb type i p sub mb type info h sub mb type i type for list 0 list h list count list for i 0 i 4 i if ISDIRECT h sub mb type i continue if ISDIR h sub mb type i 0 list int rc h ref count list MBMBAFF if rc 1 ref list i decode cabac mb ref h list 4 i if ref list i unsigned rc av log h avctx AVLOGERROR Reference d d n ref list i rc return 1 else ref list i 0 else ref list i 1 h ref cache list scan8 4 i 1 h ref cache list scan8 4 i 8 h ref cache list scan8 4 i 9 ref list i if dct8x8 allowed dct8x8 allowed get dct8x8 allowed h for list 0 list h list count list for i 0 i 4 i h ref cache list scan8 4 i h ref cache list scan8 4 i 1 if ISDIRECT h sub mb type i fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 continue if ISDIR h sub mb type i 0 list ISDIRECT h sub mb type i const int sub mb type h sub mb type i const int block width sub mb type MBTYPE 16x16 MBTYPE 16x8 2 1 for j 0 j sub partition count i j int mpx mpy int mx my const int index 4 i block width j int16 t mv cache 2 h mv cache list scan8 index uint8 t mvd cache 2 h mvd cache list scan8 index pred motion h index block width list h ref cache list scan8 index mx my DECODECABACMBMVD h list index tprintf h avctx final mv d d n mx my if ISSUB 8 X8 sub mb type mv cache 1 0 mv cache 8 0 mv cache 9 0 mx mv cache 1 1 mv cache 8 1 mv cache 9 1 my mvd cache 1 0 mvd cache 8 0 mvd cache 9 0 mpx mvd cache 1 1 mvd cache 8 1 mvd cache 9 1 mpy else if ISSUB 8 X4 sub mb type mv cache 1 0 mx mv cache 1 1 my mvd cache 1 0 mpx mvd cache 1 1 mpy else if ISSUB 4 X8 sub mb type mv cache 8 0 mx mv cache 8 1 my mvd cache 8 0 mpx mvd cache 8 1 mpy mv cache 0 0 mx mv cache 0 1 my mvd cache 0 0 mpx mvd cache 0 1 mpy else fill rectangle h mv cache list scan8 4 i 2 2 8 0 4 fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 else if ISDIRECT mb type ff h264 pred direct motion h mb type fill rectangle h mvd cache 0 scan8 0 4 4 8 0 2 fill rectangle h mvd cache 1 scan8 0 4 4 8 0 2 dct8x8 allowed h sps direct 8x8 inference flag else int list i if IS 16 X16 mb type for list 0 list h list count list if ISDIR mb type 0 list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 0 if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 4 4 8 ref 1 for list 0 list h list count list if ISDIR mb type 0 list int mx my mpx mpy pred motion h 0 4 list h ref cache list scan8 0 mx my DECODECABACMBMVD h list 0 tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 4 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 4 4 8 pack16to32 mx my 4 else if IS 16 X8 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 8 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 16 i 4 2 8 ref 1 else fill rectangle h ref cache list scan8 0 16 i 4 2 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 16x8 motion h 8 i list h ref cache list scan8 0 16 i mx my DECODECABACMBMVD h list 8 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 16 i 4 2 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 16 i 4 2 8 0 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 0 4 else assert IS 8 X16 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 4 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 2 i 2 4 8 ref 1 else fill rectangle h ref cache list scan8 0 2 i 2 4 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 8x16 motion h i 4 list h ref cache list scan8 0 2 i mx my DECODECABACMBMVD h list 4 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 2 i 2 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 2 i 2 4 8 0 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 0 4 if ISINTER mb type h chroma pred mode table mb xy 0 write back motion h mb type if ISINTR A16x16 mb type cbp decode cabac mb cbp luma h if decode chroma cbp decode cabac mb cbp chroma h 4 h cbp table mb xy h cbp cbp if dct8x8 allowed cbp 15 ISINTRA mb type mb type MBTYPE 8x8 DCT get cabac noinline h cabac h cabac state 399 h neighbor transform size if CHROM A444 IS 8x8 DCT mb type int i uint8 t nnz cache h non zero count cache for i 0 i 2 i if h left type LEFT i IS 8x8 DCT h left type LEFT i nnz cache 3 8 1 2 8 i nnz cache 3 8 2 2 8 i nnz cache 3 8 6 2 8 i nnz cache 3 8 7 2 8 i nnz cache 3 8 11 2 8 i nnz cache 3 8 12 2 8 i ISINTRA mb type 64 0 if h top type IS 8x8 DCT h top type uint32 t top empty CABACISINTRA mb type 0 0x40404040 AVW N32 A nnz cache 4 8 0 top empty AVW N32 A nnz cache 4 8 5 top empty AVW N32 A nnz cache 4 8 10 top empty h cur pic mb type mb xy mb type if cbp ISINTR A16x16 mb type const uint8 t scan scan8x8 const uint32 t qmul if ISINTERLACED mb type scan8x8 h qscale h field scan8x8 h field scan8x8 q0 scan h qscale h field scan h field scan q0 else scan8x8 h qscale h zigzag scan8x8 h zigzag scan8x8 q0 scan h qscale h zigzag scan h zigzag scan q0 if get cabac noinline h cabac h cabac state 60 h last qscale diff 0 int val 1 int ctx 2 const int max qp 51 6 h sps bit depth luma 8 while get cabac noinline h cabac h cabac state 60 ctx ctx 3 val if val 2 max qp av log h avctx AVLOGERROR cabac decode of qscale diff failed at d d n h mb x h mb y return 1 if val 0x01 val val 1 1 else val val 1 1 h last qscale diff val h qscale val if unsigned h qscale max qp if h qscale 0 h qscale max qp 1 else h qscale max qp 1 h chroma qp 0 get chroma qp h 0 h qscale h chroma qp 1 get chroma qp h 1 h qscale else h last qscale diff 0 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 0 if CHROM A444 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 1 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 2 else if CHROM A422 if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc 422 h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma422 dc scan 8 if cbp 0x20 int c i i8x8 for c 0 c 2 c int16 t mb h mb 16 16 16 c pixel shift qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i8x8 0 i8x8 2 i8x8 for i 0 i 4 i const int index 16 16 c 8 i8x8 i decode cabac residual nondc h mb 4 index scan 1 qmul 15 mb 16 pixel shift else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma dc scan 4 if cbp 0x20 int c i for c 0 c 2 c qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i 0 i 4 i const int index 16 16 c i decode cabac residual nondc h h mb 16 index pixel shift 4 index scan 1 qmul 15 else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else fill rectangle h non zero count cache scan8 0 4 4 8 0 1 fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 h last qscale diff 0 h cur pic qscale table mb xy h qscale write back non zero count h return 0 static void rv34 pred mv rv3 R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j k int mx my int avail r avail cache avail indexes 0 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail 4 2 if avail 4 avail 1 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride 2 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 2 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv 0 0 my r dmv 0 1 for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k s current picture ptr f motion val k mv pos i j s b8 stride 0 mx s current picture ptr f motion val k mv pos i j s b8 stride 1 my int EVP Encrypt Update EVPCIPHERCTX ctx unsigned char out int outl const unsigned char in int inl int i j bl if ctx cipher flags EVPCIPHFLAGCUSTOMCIPHER i ctx cipher do cipher ctx out in inl if i 0 return 0 else outl i return 1 if inl 0 outl 0 return inl 0 if ctx buf len 0 inl ctx block mask 0 if ctx cipher do cipher ctx out in inl outl inl return 1 else outl 0 return 0 i ctx buf len bl ctx cipher block size OPENSSL assert bl int sizeof ctx buf if i 0 if bl i inl memcpy ctx buf i in inl ctx buf len inl outl 0 return 1 else j bl i memcpy ctx buf i in j if ctx cipher do cipher ctx out ctx buf bl return 0 inl j in j out bl outl bl else outl 0 i inl bl 1 inl i if inl 0 if ctx cipher do cipher ctx out in inl return 0 outl inl if i 0 memcpy ctx buf in inl i ctx buf len i return 1 int16 t ff h263 pred motion Mpeg Enc Context s int block int dir int px int py int wrap int16 t ABC mot val 2 static const int off 4 2 1 1 1 wrap s b8 stride mot val s current picture motion val dir s block index block A mot val 1 if s first slice line block 3 if block 0 if s mb x s resync mb x px py 0 else if s mb x 1 s resync mb x s h263 pred C mot val off block wrap if s mb x 0 px C 0 py C 1 else px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else if block 1 if s mb x 1 s resync mb x s h263 pred C mot val off block wrap px mid pred A 0 0 C 0 py mid pred A 1 0 C 1 else px A 0 py A 1 else B mot val wrap C mot val off block wrap if s mb x s resync mb x A 0 A 1 0 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else B mot val wrap C mot val off block wrap px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val static void encode block pass1 int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg MACROBLOCK const x MACROBLOCK arg MACROBLOCKD const xd x e mbd struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block int i j uint8 t dst txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j pd dst stride 4 i vp9 xform quant x plane block plane bsize tx size if p eobs block 0 x itxm add dqcoeff dst pd dst stride p eobs block static void block rd txfm int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct rdcost block args args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi int64 t rd1 rd2 rd if args skip return if is inter block mbmi vp9 encode block intra x plane block plane bsize tx size mbmi skip dist block plane block tx size args else if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args else if x skip txfm plane 2 block tx size 1 2 tran low t const coeff BLOCKOFFSET x plane plane coeff block tran low t const dqcoeff BLOCKOFFSET xd plane plane dqcoeff block vp9 xform quant dc x plane block plane bsize tx size args sse x bsse plane 2 block tx size 1 4 args dist args sse if x plane plane eobs block args dist args sse coeff 0 coeff 0 coeff 0 dqcoeff 0 coeff 0 dqcoeff 0 2 else x plane plane eobs block 0 args sse x bsse plane 2 block tx size 1 4 args dist args sse else vp9 xform quant x plane block plane bsize tx size dist block plane block tx size args rate block plane block plane bsize tx size args rd1 RDCOST x rdmult x rddiv args rate args dist rd2 RDCOST x rdmult x rddiv 0 args sse rd MIN rd1 rd2 if plane 0 x zcoeff blk tx size block x plane plane eobs block rd1 rd2 xd lossless args this rate args rate args this dist args dist args this sse args sse args this rd rd if args this rd args best rd args skip 1 return static guint32 dissect minivideopacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet gboolean rtp marker proto item item ts tvb get ntohs tvb offset rtp marker ts 0x8000 TRUEFALSE ts 0x8000 iax packet iax2 get packet data for minipacket pinfo scallno TRUE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add item iax2 tree hf iax2 minividts tvb offset 2 ENCBIGENDIAN iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts proto tree add item iax2 tree hf iax2 minividmarker tvb offset 2 ENCBIGENDIAN else iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini video packet source call d timestamp ums s scallno ts rtp marker Mark dissect payload tvb offset pinfo iax2 tree main tree ts TRUE iax packet iax packet first time FALSE return offset static void encode breakout test V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col MVREFERENCEFRAME ref frame PREDICTIONMODE this mode unsigned int var y unsigned int sse y struct buf 2d yv12 mb MAXMBPLANE int rate int64 t dist MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi const BLOCKSIZE uv size get plane block size bsize xd plane 1 unsigned int var var y sse sse y unsigned int thresh ac unsigned int thresh dc if x encode breakout 0 const unsigned int max thresh 36000 const unsigned int min thresh MIN unsigned int x encode breakout 4 max thresh thresh ac xd plane 0 dequant 1 xd plane 0 dequant 1 9 thresh ac clamp thresh ac min thresh max thresh thresh ac b width log2 bsize b height log2 bsize thresh dc xd plane 0 dequant 0 xd plane 0 dequant 0 6 else thresh ac 0 thresh dc 0 if var thresh ac sse var thresh dc unsigned int sse u sse v unsigned int var u var v if x encode breakout 0 xd plane 1 pre 0 yv12 mb ref frame 1 xd plane 2 pre 0 yv12 mb ref frame 2 vp9 build inter predictors sbuv xd mi row mi col bsize var u cpi fn ptr uv size vf x plane 1 src buf x plane 1 src stride xd plane 1 dst buf xd plane 1 dst stride sse u if var u 4 thresh ac sse u var u thresh dc var v cpi fn ptr uv size vf x plane 2 src buf x plane 2 src stride xd plane 2 dst buf xd plane 2 dst stride sse v if var v 4 thresh ac sse v var v thresh dc x skip 1 rate cpi inter mode cost mbmi mode context ref frame INTEROFFSET this mode dist sse 4 int ff MPV common frame size change Mpeg Enc Context s int i err 0 if s slice context count 1 for i 0 i s slice context count i free duplicate context s thread context i for i 1 i s slice context count i av freep s thread context i else free duplicate context s if err free context frame s 0 return err if s picture for i 0 i MAXPICTURECOUNT i s picture i needs realloc 1 s last picture ptr s next picture ptr s current picture ptr NULL if s codec id AVCODECIDMPE G2 VIDEO s progressive sequence s mb height s height 31 32 2 else if s codec id AVCODECID H264 s mb height s height 15 16 if s width s height av image check size s width s height 0 s avctx return AVERRORINVALIDDATA if err init context frame s goto fail s thread context 0 s if s width s height int nb slices s slice context count if nb slices 1 for i 1 i nb slices i s thread context i av malloc sizeof Mpeg Enc Context memcpy s thread context i s sizeof Mpeg Enc Context for i 0 i nb slices i if init duplicate context s thread context i 0 goto fail s thread context i start mb y s mb height i nb slices 2 nb slices s thread context i end mb y s mb height i 1 nb slices 2 nb slices else if init duplicate context s 0 goto fail s start mb y 0 s end mb y s mb height s slice context count nb slices return 0 fail ff MPV common end s return err static int idcin decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Idcin Context s avctx priv data const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULLAV Frame frame data int ret s buf buf s size buf size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR id CIN Video get buffer failed n return ret idcin decode vlcs s frame if pal frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy frame data 1 s pal AVPALETTESIZE got frame 1 return buf size uint8 t jbig2 decode gray scale image Jbig2 Ctx ctx Jbig2 Segment segment const byte data const size t size bool GSMMR uint32 t GSW uint32 t GSH uint32 t GSBPP bool GSUSESKIP Jbig2 Image GSKIP int GSTEMPLATE Jbig2 Arith Cx GB stats uint8 t GSVALSNULL size t consumed bytes 0 int i j code stride int x y Jbig2 Image GSPLANES Jbig2 Generic Region Params rparams Jbig2 Word Stream ws NULL Jbig2 Arith State as NULLGSPLANES jbig2 new ctx Jbig2 Image GSBPP if GSPLANESNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate d bytes for GSPLANESGSBPP return NULL for i 0 i GSBPP i GSPLANES i jbig2 image new ctx GSWGSH if GSPLANES i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate dx d image for GSPLANESGSWGSH for j i 1 j 0 j jbig2 image release ctx GSPLANES j jbig2 free ctx allocator GSPLANES return NULL rparams MMRGSMMR rparams GBTEMPLATEGSTEMPLATE rparams TPGDON 0 rparams USESKIPGSUSESKIP rparams gbat 0 GSTEMPLATE 1 3 2 rparams gbat 1 1 rparams gbat 2 3 rparams gbat 3 1 rparams gbat 4 2 rparams gbat 5 2 rparams gbat 6 2 rparams gbat 7 2 if GSMMR code jbig2 decode halftone mmr ctx rparams data size GSPLANESGSBPP 1 consumed bytes else ws jbig2 word stream buf new ctx data size if ws NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate ws in jbig2 decode gray scale image goto cleanup as jbig2 arith new ctx ws if as NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate as in jbig2 decode gray scale image goto cleanup code jbig2 decode generic region ctx segment rparams as GSPLANESGSBPP 1 GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup j GSBPP 2 while j 0 if GSMMR code jbig2 decode halftone mmr ctx rparams data consumed bytes size consumed bytes GSPLANES j consumed bytes else code jbig2 decode generic region ctx segment rparams as GSPLANES j GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup stride GSPLANES 0 stride for i 0 i stride GSH i GSPLANES j data i GSPLANES j 1 data i j GSVALS jbig2 new ctx uint8 t GSW if GSVALSNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSW goto cleanup for i 0 i GSW i GSVALS i jbig2 new ctx uint8 t GSH if GSVALS i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSHGSW for j i 1 j 0 j jbig2 free ctx allocator GSVALS j jbig2 free ctx allocator GSVALSGSVALSNULL goto cleanup for x 0 x GSW x for y 0 y GSH y GSVALS x y 0 for j 0 j GSBPP j GSVALS x y jbig2 image get pixel GSPLANES j x y j cleanup if GSMMR jbig2 free ctx allocator as jbig2 word stream buf free ctx ws for i 0 i GSBPP i jbig2 image release ctx GSPLANES i jbig2 free ctx allocator GSPLANES return static int truespeech decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size TS Context c avctx priv data int i j int16 t samples int iterations ret iterations buf size 32 if iterations av log avctx AVLOGERROR Too small input buffer d bytes need at least 32 bytes n buf size return 1 frame nb samples iterations 240 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 memset samples 0 iterations 240 sizeof samples for j 0 j iterations j truespeech read frame c buf buf 32 truespeech correlate filter c truespeech filters merge c for i 0 i 4 i truespeech apply twopoint filter c i truespeech place pulses c samples i truespeech update filters c samples i truespeech synth c samples i samples 60 truespeech save prevvec c got frame ptr 1 return buf size static int get delta struct rev info revs struct remote lock lock int i struct commit commit struct object list p objects int count 0 while commit get revision revs NULL p process tree commit tree p commit object flags LOCAL if commit object flags UNINTERESTING count add send request commit object lock for i 0 i revs pending nr i struct object array entry entry revs pending objects i struct object obj entry item const char name entry name if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN p add one object obj p continue if obj type OBJTREE p process tree struct tree obj p continue if obj type OBJBLOB p process blob struct blob obj p continue die unknown pending object s s oid to hex obj oid name while objects if objects item flags UNINTERESTING count add send request objects item lock objects objects next return count static int msvideo1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Msvideo1 Context s avctx priv data s buf buf s size buf size s frame reference 1 s frame buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if avctx reget buffer avctx s frame av log s avctx AVLOGERROR reget buffer failed n return 1 if s mode 8bit const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal memcpy s pal pal AVPALETTESIZE s frame palette has changed 1 if s mode 8bit msvideo1 decode 8bit s else msvideo1 decode 16bit s got frame 1 AV Frame data s frame return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Zmbv Context const c avctx priv data int zret ZOK int len buf size int hi ver lo ver ret uint8 t tmp if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret c flags buf 0 buf len if c flags ZMBVKEYFRAME hi ver buf 0 lo ver buf 1 c comp buf 2 c fmt buf 3 c bw buf 4 c bh buf 5 c decode intra NULL c decode xor NULL buf 6 len 6 av log avctx AVLOGDEBUG Flags X ver i i comp i fmt i blk ix i n c flags hi ver lo ver c comp c fmt c bw c bh if hi ver 0 lo ver 1 av log ask for sample avctx Unsupported version i i n hi ver lo ver return AVERRORPATCHWELCOME if c bw 0 c bh 0 av log ask for sample avctx Unsupported block size ix i n c bw c bh return AVERRORPATCHWELCOME if c comp 0 c comp 1 av log ask for sample avctx Unsupported compression type i n c comp return AVERRORPATCHWELCOME switch c fmt case ZMBVFMT 8 BPP c bpp 8 c decode intra zmbv decode intra c decode xor zmbv decode xor 8 break case ZMBVFMT 15 BPP case ZMBVFMT 16 BPP c bpp 16 c decode intra zmbv decode intra c decode xor zmbv decode xor 16 break c decode intra zmbv decode intra c decode xor zmbv decode xor 24 break c decode intra zmbv decode intra c decode xor zmbv decode xor 32 break default c decode intra NULL c decode xor NULL av log ask for sample avctx Unsupported for now format i n c fmt return AVERRORPATCHWELCOME zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN tmp av realloc c cur avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c cur tmp tmp av realloc c prev avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c prev tmp c bx c width c bw 1 c bw c by c height c bh 1 c bh if c decode intra NULL av log avctx AVLOGERROR Error Got no format or no keyframe n return AVERRORINVALIDDATA if c comp 0 memcpy c decomp buf buf len c decomp size 1 else c zstream total in c zstream total out 0 c zstream next in buf c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZSYNCFLUSH if zret ZOK zret ZSTREAMEND av log avctx AVLOGERROR inflate error d n zret return AVERRORINVALIDDATA c decomp len c zstream total out if c flags ZMBVKEYFRAME c pic key frame 1 c pic pict type AVPICTURETYPEI c decode intra c else c pic key frame 0 c pic pict type AVPICTURETYPEP if c decomp len c decode xor c uint8 t out src int i j out c pic data 0 src c cur switch c fmt case ZMBVFMT 8 BPP for j 0 j c height j for i 0 i c width i out i 3 0 c pal src 3 0 out i 3 1 c pal src 3 1 out i 3 2 c pal src 3 2 src out c pic linesize 0 break case ZMBVFMT 15 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x7 C00 7 out i 3 1 tmp 0x03 E0 2 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break case ZMBVFMT 16 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x F800 8 out i 3 1 tmp 0x07 E0 3 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break j c height j memcpy out src c width 3 src c width 3 out c pic linesize 0 break j c height j for i 0 i c width i uint32 t tmp AVR L32 src src 4 AVW B24 out i 3 tmp out c pic linesize 0 break default av log avctx AVLOGERROR Cannot handle format i n c fmt FFSWAP uint8 t c cur c prev got frame 1 AV Frame data c pic return buf size void configure buffer updates V P9 COMP cpi TWOPASS const twopass cpi twopass cpi rc is src frame alt ref 0 switch twopass gf group update type twopass gf group index case KFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 1 break case LFUPDATE cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 break case GFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 0 break case OVERLAYUPDATE cpi refresh last frame 0 cpi refresh golden frame 1 cpi refresh alt ref frame 0 cpi rc is src frame alt ref 1 break case ARFUPDATE cpi refresh last frame 0 cpi refresh golden frame 0 cpi refresh alt ref frame 1 break default assert 0 break if is two pass svc cpi if cpi svc temporal layer id 0 cpi refresh last frame 0 cpi refresh golden frame 0 if cpi svc layer context cpi svc spatial layer id gold ref idx 0 cpi refresh golden frame 0 if cpi alt ref source NULL cpi refresh alt ref frame 0 static int gsm decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data int res Get Bit Context gb const uint8 t buf avpkt data int buf size avpkt size int16 t samples if buf size avctx block align av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA frame nb samples avctx frame size if res ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return res samples int16 t frame data 0 switch avctx codec id case AVCODECIDGSM init get bits gb buf buf size 8 if get bits gb 4 0xd av log avctx AVLOGWARNING Missing GSM magic n res gsm decode block avctx samples gb if res 0 return res break case AVCODECIDGSMMS res ff msgsm decode block avctx samples buf if res 0 return res got frame ptr 1 return avctx block align static void choose tx size from rd V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t psse int64 t tx cache TXMODES int64 t ref best rd BLOCKSIZE bs const TXSIZE max tx size max txsize lookup bs V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi vp9 prob skip prob vp9 get skip prob cm xd int r TXSIZES 2 s TXSIZES int64 t d TXSIZES sse TXSIZES int64 t rd TXSIZES 2 IN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAX int n m int s0 s1 const TXSIZE max mode tx size tx mode to biggest tx size cm tx mode int64 t best rd IN T64 MAXTXSIZE best tx max tx size const vp9 prob tx probs get tx probs2 max tx size xd cm fc tx probs assert skip prob 0 s0 vp9 cost bit skip prob 0 s1 vp9 cost bit skip prob 1 for n max tx size n 0 n txfm rd in plane x r n 0 d n s n sse n ref best rd 0 bs n cpi sf use fast coef costing r n 1 r n 0 if r n 0 INTMAX for m 0 m n n int max tx size m if m n r n 1 vp9 cost zero tx probs m else r n 1 vp9 cost one tx probs m if d n IN T64 MAX rd n 0 rd n 1 IN T64 MAX else if s n rd n 0 rd n 1 RDCOST x rdmult x rddiv s1 d n else rd n 0 RDCOST x rdmult x rddiv r n 0 s0 d n rd n 1 RDCOST x rdmult x rddiv r n 1 s0 d n if cpi sf tx size search breakout rd n 1 IN T64 MAX n int max tx size rd n 1 rd n 1 1 s n 1 break if rd n 1 best rd best tx n best rd rd n 1 mbmi tx size cm tx mode TXMODESELECT best tx MIN max tx size max mode tx size distortion d mbmi tx size rate r mbmi tx size cm tx mode TXMODESELECT skip s mbmi tx size psse sse mbmi tx size tx cache ONLY 4 X4 rd TX 4 X4 0 tx cache ALLOW 8 X8 rd TX 8 X8 0 tx cache ALLOW 16 X16 rd MIN max tx size TX 16 X16 0 tx cache ALLOW 32 X32 rd MIN max tx size TX 32 X32 0 if max tx size TX 32 X32 best tx TX 32 X32 tx cache TXMODESELECT rd TX 32 X32 1 else if max tx size TX 16 X16 best tx TX 16 X16 tx cache TXMODESELECT rd TX 16 X16 1 else if rd TX 8 X8 1 rd TX 4 X4 1 tx cache TXMODESELECT rd TX 8 X8 1 else tx cache TXMODESELECT rd TX 4 X4 1 int process netbios name const guchar name ptr char name ret int name ret len int i int name type name ptr NETBIOSNAMELEN 1 guchar name char static const char hex digits 16 0 1 2 3 4 5 6 7 8 9 a b c d e f for i 0 i NETBIOSNAMELEN 1 i name char name ptr if name char name char if name ret len 0 name ret name char else if name ret len 0 name ret if name ret len 0 name ret hex digits name char 4 if name ret len 0 name ret hex digits name char 0x0 F if name ret len 0 name ret name ret 0 name ret for i 0 i NETBIOSNAMELEN 1 i if name ret name ret 1 0 break name ret return name type void ff xvmc decode mb Mpeg Enc Context s Xv MC Macro Block mv block struct xvmc pix fmt render int i cbp blocks per mb const int mb xy s mb y s mb stride s mb x if s encoding av log s avctx AVLOGERRORXVMC doesn t support encoding n return if s mb intra s last dc 0 s last dc 1 s last dc 2 128 s intra dc precision s mb skipped 0 s current picture qscale table mb xy s qscale render struct xvmc pix fmt s current picture f data 2 assert render assert render xvmc id AVXVMCID assert render mv blocks mv block render mv blocks render start mv blocks num render filled mv blocks num mv block x s mb x mv block y s mb y mv block dct type s interlaced dct if s mb intra mv block macroblock type XVMCMBTYPEINTRA else mv block macroblock type XVMCMBTYPEPATTERN if s mv dir MVDIRFORWARD mv block macroblock type XVMCMBTYPEMOTIONFORWARD mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 mv block PMV 1 0 0 s mv 0 1 0 mv block PMV 1 0 1 s mv 0 1 1 if s mv dir MVDIRBACKWARD mv block macroblock type XVMCMBTYPEMOTIONBACKWARD mv block PMV 0 1 0 s mv 1 0 0 mv block PMV 0 1 1 s mv 1 0 1 mv block PMV 1 1 0 s mv 1 1 0 mv block PMV 1 1 1 s mv 1 1 1 switch s mv type case MVTYPE 16 X16 mv block motion type XVMCPREDICTIONFRAME break case MVTYPE 16 X8 mv block motion type XVMCPREDICTION 16x8 break case MVTYPEFIELD mv block motion type XVMCPREDICTIONFIELD if s picture structure PICTFRAME mv block PMV 0 0 1 1 mv block PMV 1 0 1 1 mv block PMV 0 1 1 1 mv block PMV 1 1 1 1 break case MVTYPEDMV mv block motion type XVMCPREDICTIONDUALPRIME if s picture structure PICTFRAME mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 1 mv block PMV 0 1 0 s mv 0 0 0 mv block PMV 0 1 1 s mv 0 0 1 1 mv block PMV 1 0 0 s mv 0 2 0 mv block PMV 1 0 1 s mv 0 2 1 1 mv block PMV 1 1 0 s mv 0 3 0 mv block PMV 1 1 1 s mv 0 3 1 1 else mv block PMV 0 1 0 s mv 0 2 0 mv block PMV 0 1 1 s mv 0 2 1 break default assert 0 mv block motion vertical field select 0 if s mv type MVTYPEFIELD s mv type MVTYPE 16 X8 mv block motion vertical field select s field select 0 0 mv block motion vertical field select s field select 1 0 1 mv block motion vertical field select s field select 0 1 2 mv block motion vertical field select s field select 1 1 3 mv block index render next free data block num blocks per mb 6 if s chroma format 2 blocks per mb 4 1 s chroma format cbp 0 for i 0 i blocks per mb i cbp cbp if s block last index i 0 cbp if s flags CODECFLAGGRAY if s mb intra for i 4 i blocks per mb i memset s pblocks i 0 sizeof s pblocks i if render unsigned intra s pblocks i 0 1 10 else cbp 0xf blocks per mb 4 blocks per mb 4 mv block coded block pattern cbp if cbp 0 mv block macroblock type XVMCMBTYPEPATTERN for i 0 i blocks per mb i if s block last index i 0 if s mb intra render idct render unsigned intra s pblocks i 0 1 10 if render idct s dsp idct s pblocks i if s avctx xvmc acceleration 1 memcpy render data blocks render next free data block num 64 s pblocks i sizeof s pblocks i render next free data block num render filled mv blocks num assert render filled mv blocks num render allocated mv blocks assert render next free data block num render allocated data blocks if render filled mv blocks num render allocated mv blocks ff mpeg draw horiz band s 0 0 void vp9 xform quant fp MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize fp 32x32 coeff 1024 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize fp coeff 256 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize fp coeff 64 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize fp coeff 16 x skip block p zbin p round fp p quant fp p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break static guint32 dissect minivideopacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet gboolean rtp marker proto item item ts tvb get ntohs tvb offset rtp marker ts 0x8000 TRUEFALSE ts 0x8000 iax packet iax2 get packet data for minipacket pinfo scallno TRUE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add item iax2 tree hf iax2 minividts tvb offset 2 ENCBIGENDIAN iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts proto tree add item iax2 tree hf iax2 minividmarker tvb offset 2 ENCBIGENDIAN else iax2 add ts fields pinfo iax2 tree tvb iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini video packet source call d timestamp ums s scallno ts rtp marker Mark dissect payload tvb offset pinfo iax2 tree main tree ts TRUE iax packet iax packet first time FALSE return offset static int dvvideo close AV Codec Context c DV Video Context s c priv data av frame unref s picture return 0 static int imc decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int ret i IMC Context q avctx priv data LOCALALIGNED 16 uint16 t buf16 IMCBLOCKSIZE 2 if buf size IMCBLOCKSIZE avctx channels av log avctx AVLOGERROR frame too small n return AVERRORINVALIDDATA frame nb samples COEFFS if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for i 0 i avctx channels i q out samples float frame extended data i q dsp bswap16 buf buf16 const uint16 t buf IMCBLOCKSIZE 2 init get bits q gb const uint8 t buf16 IMCBLOCKSIZE 8 buf IMCBLOCKSIZE if ret imc decode block avctx q i 0 return ret if avctx channels 2 q fdsp butterflies float float frame extended data 0 float frame extended data 1 COEFFS got frame ptr 1 return IMCBLOCKSIZE avctx channels static ulong get sort uint count va list args va start args count ulong sort 0 DBUGASSERT count 4 while count char start str va arg args char uint chars 0 uint wild pos 0 if start str for str str if str wild prefix str 1 str else if str wild many str wild one wild pos uint str start 1 if wild pos 1 str wild many str 0 wild pos break chars 128 sort sort 8 wild pos min wild pos 127 chars va end args return sort static double eqjoinsel semi Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 Rel Opt Info inner rel double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid Oid Is Valid operator get opcode operator Invalid Oid if vardata2 rel nd2 Min nd2 vardata2 rel rows nd2 Min nd2 inner rel rows if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Oid Is Valid operator Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double matchfreq1 uncertainfrac uncertain int i nmatches clamped nvalues2 clamped nvalues2 Min nvalues2 nd2 fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 clamped nvalues2 sizeof bool nmatches 0 for i 0 i nvalues1 i int j for j 0 j clamped nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true nmatches break matchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 pfree hasmatch1 pfree hasmatch2 if isdefault1 isdefault2 nd1 nmatches nd2 nmatches if nd1 nd2 nd2 0 uncertainfrac 1 0 else uncertainfrac nd2 nd1 else uncertainfrac 0 5 uncertain 1 0 matchfreq1 nullfrac1 CLAMPPROBABILITY uncertain selec matchfreq1 uncertainfrac uncertain else double nullfrac1 stats1 stats1 stanullfrac 0 0 if isdefault1 isdefault2 if nd1 nd2 nd2 0 selec 1 0 nullfrac1 else selec nd2 nd1 1 0 nullfrac1 else selec 0 5 1 0 nullfrac1 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static void gtkui inject user int side size t len len strescape injectbuf injectbuf if side 1 side 2 user inject injectbuf len curr conn side static int truemotion1 decode header True Motion1 Context s int i ret int width shift 0 int new pix fmt struct frame header header uint8 t header buffer 128 0 const uint8 t sel vector table header header size s buf 0 5 s buf 0 3 0x7f if s buf 0 0x10 av log s avctx AVLOGERROR invalid header size d n s buf 0 return AVERRORINVALIDDATA for i 1 i header header size i header buffer i 1 s buf i s buf i 1 header compression header buffer 0 header deltaset header buffer 1 header vectable header buffer 2 header ysize AVR L16 header buffer 3 header xsize AVR L16 header buffer 5 header checksum AVR L16 header buffer 7 header version header buffer 9 header header type header buffer 10 header flags header buffer 11 header control header buffer 12 if header version 2 if header header type 3 av log s avctx AVLOGERROR invalid header type d n header header type return AVERRORINVALIDDATA else if header header type 2 header header type 3 s flags header flags if s flags FLAGINTERFRAME s flags FLAGKEYFRAME else s flags FLAGKEYFRAME else s flags FLAGKEYFRAME if s flags FLAGSPRITE av log ask for sample s avctx SPRITE frame found n return AVERRORPATCHWELCOME else s w header xsize s h header ysize if header header type 2 if s w 213 s h 176 s flags FLAGINTERPOLATED av log ask for sample s avctx INTERPOLATION selected n if header compression 17 av log s avctx AVLOGERROR invalid compression type d n header compression return AVERRORINVALIDDATA if header deltaset s last deltaset header vectable s last vectable select delta tables s header deltaset if header compression 1 header header type sel vector table pc tbl2 else if header vectable 0 header vectable 4 sel vector table tables header vectable 1 else av log s avctx AVLOGERROR invalid vector table id d n header vectable return AVERRORINVALIDDATA if compression types header compression algorithm ALGORG B24 H new pix fmt AVPIXFMTRG B32 width shift 1 else new pix fmt AVPIXFMTRG B555 s w width shift if ret av image check size s w s h 0 s avctx 0 return ret if s w s avctx width s h s avctx height new pix fmt s avctx pix fmt av frame unref s frame s avctx sample aspect ratio AV Rational 1 width shift 1 s avctx pix fmt new pix fmt avcodec set dimensions s avctx s w s h av fast malloc s vert pred s vert pred size s avctx width sizeof unsigned int s mb change bits row size s avctx width 2 width shift 7 3 if header deltaset s last deltaset header vectable s last vectable if compression types header compression algorithm ALGORG B24 H gen vector table24 s sel vector table else if s avctx pix fmt AVPIXFMTRG B555 gen vector table15 s sel vector table else gen vector table16 s sel vector table s mb change bits s buf header header size if s flags FLAGKEYFRAME s index stream s mb change bits else s index stream s mb change bits s mb change bits row size s avctx height 2 s index stream size s size s index stream s buf s last deltaset header deltaset s last vectable header vectable s compression header compression s block width compression types header compression block width s block height compression types header compression block height s block type compression types header compression block type if s avctx debug FFDEBUGPICTINFO av log s avctx AVLOGINFO tables d d c d dx d t d s s s s n s last deltaset s last vectable s compression s block width s block height s block type s flags FLAGKEYFRAMEKEY s flags FLAGINTERFRAMEINTER s flags FLAGSPRITESPRITE s flags FLAGINTERPOLATEDINTERPOL return header header size static int vorbis decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size vorbis context vc avctx priv data AV Frame frame data Get Bit Context gb vc gb float channel ptrs 255 int i len ret av dlog NULL packet length d n buf size frame nb samples vc blocksize 1 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if vc audio channels 8 for i 0 i vc audio channels i channel ptrs i float frame extended data i else for i 0 i vc audio channels i int ch ff vorbis channel layout offsets vc audio channels 1 i channel ptrs ch float frame extended data i init get bits gb buf buf size 8 if len vorbis parse audio packet vc channel ptrs 0 return len if vc first frame vc first frame 1 got frame ptr 0 return buf size av dlog NULL parsed d bytes d bits returned d samples ch bits n get bits count gb 8 get bits count gb 8 len frame nb samples len got frame ptr 1 return buf size static int mss4 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S4 Context c avctx priv data Get Bit Context gb Get Byte Context bc uint8 t dst 3 int width height quality frame type int x y i mb width mb height blk type int ret if buf size HEADERSIZE av log avctx AVLOGERROR Frame should have at least d bytes got d instead n HEADERSIZE buf size return AVERRORINVALIDDATA bytestream2 init bc buf buf size width bytestream2 get be16 bc height bytestream2 get be16 bc bytestream2 skip bc 2 quality bytestream2 get byte bc frame type bytestream2 get byte bc if width avctx width height avctx height av log avctx AVLOGERROR Invalid frame dimensions dx d n width height return AVERRORINVALIDDATA if quality 1 quality 100 av log avctx AVLOGERROR Invalid quality setting d n quality return AVERRORINVALIDDATA if frame type 3 frame type 3 av log avctx AVLOGERROR Invalid frame type d n frame type return AVERRORINVALIDDATA if frame type SKIPFRAME bytestream2 get bytes left bc av log avctx AVLOGERROR Empty frame found but it is not a skip frame n return AVERRORINVALIDDATA if ret ff reget buffer avctx c pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pic key frame frame type INTRAFRAME c pic pict type frame type INTRAFRAMEAVPICTURETYPEIAVPICTURETYPEP if frame type SKIPFRAME got frame 1 if ret av frame ref data c pic 0 return ret return buf size if c quality quality c quality quality for i 0 i 2 i ff mss34 gen quant mat c quant mat i quality i init get bits gb buf HEADERSIZE buf size HEADERSIZE 8 mb width FFALIGN width 16 4 mb height FFALIGN height 16 4 dst 0 c pic data 0 dst 1 c pic data 1 dst 2 c pic data 2 memset c prev vec 0 sizeof c prev vec for y 0 y mb height y memset c dc cache 0 sizeof c dc cache for x 0 x mb width x blk type decode012 gb switch blk type case DCTBLOCK if mss4 decode dct block c gb dst x y 0 av log avctx AVLOGERROR Error decoding DCT block d d n x y return AVERRORINVALIDDATA break case IMAGEBLOCK if mss4 decode image block c gb dst x y 0 av log avctx AVLOGERROR Error decoding VQ block d d n x y return AVERRORINVALIDDATA break case SKIPBLOCK if frame type INTRAFRAME av log avctx AVLOGERROR Skip block in intra frame n return AVERRORINVALIDDATA break if blk type DCTBLOCK mss4 update dc cache c x dst 0 c pic linesize 0 16 dst 1 c pic linesize 1 16 dst 2 c pic linesize 2 16 if ret av frame ref data c pic 0 return ret got frame 1 return buf size static void joint motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mv frame mv int mi row int mi col int mv single newmv MAXREFFRAMES int rate mv const int pw 4 num 4x4 blocks wide lookup bsize const int ph 4 num 4x4 blocks high lookup bsize MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi const int refs 2 mbmi ref frame 0 mbmi ref frame 1 0 0 mbmi ref frame 1 int mv ref mv 2 int ite ref uint8 t second pred vpx memalign 16 pw ph sizeof uint8 t const Interp Kernel kernel vp9 get interp kernel mbmi interp filter struct buf 2d backup yv12 2 MAXMBPLANE struct buf 2d scaled first yv12 xd plane 0 pre 0 int last besterr 2 INTMAXINTMAX const Y V12 BUFFERCONFIG const scaled ref frame 2 vp9 get scaled ref frame cpi mbmi ref frame 0 vp9 get scaled ref frame cpi mbmi ref frame 1 for ref 0 ref 2 ref ref mv ref mbmi ref mvs refs ref 0 if scaled ref frame ref int i for i 0 i MAXMBPLANE i backup yv12 ref i xd plane i pre ref vp9 setup pre planes xd ref scaled ref frame ref mi row mi col NULL frame mv refs ref as int single newmv refs ref as int for ite 0 ite 4 ite struct buf 2d ref yv12 2 int bestsme INTMAX int sadpb x sadperbit16 MV tmp mv int search range 3 int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int id ite 2 ref yv12 0 xd plane 0 pre 0 ref yv12 1 xd plane 0 pre 1 vp9 build inter predictor ref yv12 id buf ref yv12 id stride second pred pw frame mv refs id as mv xd block refs id sf pw ph 0 kernel MVPRECISION Q3 mi col MISIZE mi row MISIZE if id xd plane 0 pre 0 ref yv12 id vp9 set mv search range x ref mv id as mv tmp mv frame mv refs id as mv tmp mv col 3 tmp mv row 3 bestsme vp9 refining search 8p c x tmp mv sadpb search range cpi fn ptr bsize ref mv id as mv second pred if bestsme INTMAX bestsme vp9 get mvpred av var x tmp mv ref mv id as mv second pred cpi fn ptr bsize 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis unsigned int sse bestsme cpi find fractional mv step x tmp mv ref mv id as mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize 0 cpi sf mv subpel iters per step NULL x nmvjointcost x mvcost dis sse second pred pw ph if id xd plane 0 pre 0 scaled first yv12 if bestsme last besterr id frame mv refs id as mv tmp mv last besterr id bestsme else break rate mv 0 for ref 0 ref 2 ref if scaled ref frame ref int i for i 0 i MAXMBPLANE i xd plane i pre ref backup yv12 ref i rate mv vp9 mv bit cost frame mv refs ref as mv mbmi ref mvs refs ref 0 as mv x nmvjointcost x mvcost MVCOSTWEIGHT vpx free second pred static void examine simple variable Planner Info root Var var Variable Stat Data vardata Range Tbl Entry rte root simple rte array var varno Assert Is A rte Range Tbl Entry if get relation stats hook get relation stats hook root rte var varattno vardata if Heap Tuple Is Valid vardata stats Tuple vardata freefunc elog ERROR no function provided to release variable stats with else if rte rtekind RTERELATION vardata stats Tuple Search Sys Cache3 STATRELATTINH Object Id Get Datum rte relid Int16 Get Datum var varattno Bool Get Datum rte inh vardata freefunc Release Sys Cache if Heap Tuple Is Valid vardata stats Tuple vardata acl ok pg class aclcheck rte relid Get User Id ACLSELECTACLCHECKOK pg attribute aclcheck rte relid var varattno Get User Id ACLSELECTACLCHECKOK else vardata acl ok true else if rte rtekind RTESUBQUERY rte inh Query subquery rte subquery Rel Opt Info rel Target Entry ste if var varattno Invalid Attr Number return if subquery set Operations subquery group Clause return rel find base rel root var varno if rel subroot NULL return Assert Is A rel subroot Planner Info subquery rel subroot parse Assert Is A subquery Query ste get tle by resno subquery target List var varattno if ste NULL ste resjunk elog ERROR subquery s does not have attribute d rte eref aliasname var varattno var Var ste expr if subquery distinct Clause if list length subquery distinct Clause 1 target Is In Sort List ste Invalid Oid subquery distinct Clause vardata isunique true return if rte security barrier return if var Is A var Var var varlevelsup 0 examine simple variable rel subroot var vardata else static void LMBCS Open Worker U Converter this U Converter Load Args p Args U Error Code err ulmbcs byte t Opt Group U Converter Data LMBCS extra Info this extra Info U Converter Data LMBCS uprv malloc sizeof U Converter Data LMBCS if extra Info NULLU Converter Name Pieces stack Pieces U Converter Load Args stack Args int32 t sizeof U Converter Load Args ulmbcs byte t i uprv memset extra Info 0 sizeof U Converter Data LMBCS stack Args only Test Is Loadable p Args only Test Is Loadable for i 0 i ULMBCSGRPLASTUSUCCESS err i if Opt Group Byte To CP Name i NULL extra Info Opt Grp Converter i ucnv load Shared Data Opt Group Byte To CP Name i stack Pieces stack Args err if UFAILURE err p Args only Test Is Loadable LMBCS Close this return extra Info Opt Group Opt Group extra Info locale Converter Index Find LMBCS Locale p Args locale else err static void test read format mtree1 void const char reffile test read format mtree mtree char buff 16 struct archive entry ae struct archive a FILE f static const long long max int64 long long 1 62 1 long long 1 62 time t min time volatile time t t extract reference file reffile assert Make Dir dir 0775 assert Make Dir dir2 0775 assert a archive read new NULL assert Equal Int A a ARCHIVEOK archive read support filter all a assert Equal Int A a ARCHIVEOK archive read support format all a assert Equal Int A a ARCHIVEOK archive read set options a mtree checkfs assert Equal Int A a ARCHIVEOK archive read open filename a reffile 11 f fopen file wb assert f NULL assert Equal Int 3 fwrite hi n 1 3 f fclose f assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal Int archive format a ARCHIVEFORMATMTREE assert Equal String archive entry pathname ae file assert Equal Int archive entry uid ae 18 assert Equal Int AEIFREG archive entry filetype ae assert Equal Int archive entry mode ae AEIFREG 0123 assert Equal Int archive entry size ae 3 assert Equal Int 3 archive read data a buff 3 assert Equal Mem buff hi n 3 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir assert Equal Int AEIFDIR archive entry filetype ae assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir file with space assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae file with space assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 dir3a assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 dir3a indir3a assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 fullindir2 assert Equal Int archive entry mode ae AEIFREG 0644 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 indir2 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 dir3b assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 dir3b indir3b assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae notindir assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 emptyfile assert Equal Int archive entry size ae 0 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 smallfile assert Equal Int archive entry size ae 1 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 toosmallfile assert Equal Int archive entry size ae 1 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 bigfile assert Equal Int archive entry size ae max int64 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 toobigfile assert Equal Int archive entry size ae max int64 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 veryoldfile min time archive entry mtime ae assert min time 0 t min time 1 assert t 0 assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEOK archive read next header a ae assert Equal String archive entry pathname ae dir2 toooldfile assert Equal Int archive entry mtime ae min time assert Equal Int archive entry is encrypted ae 0 assert Equal Int A a archive read has encrypted entries a ARCHIVEREADFORMATENCRYPTIONUNSUPPORTED assert Equal Int A a ARCHIVEEOF archive read next header a ae assert Equal Int 19 archive file count a assert Equal Int ARCHIVEOK archive read close a assert Equal Int ARCHIVEOK archive read free a static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size Qdraw Context const a avctx priv data AV Frame const p a pic uint8 t outdata int colors int i ret uint32 t pal int r g b if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 outdata a pic data 0 if buf end buf 0x68 4 return AVERRORINVALIDDATA buf 0x68 colors AVR B32 buf buf 4 if colors 0 colors 256 av log avctx AVLOGERROR Error color count i 0x X n colors colors return AVERRORINVALIDDATA if buf end buf colors 1 8 return AVERRORINVALIDDATA pal uint32 t p data 1 for i 0 i colors i unsigned int idx idx AVR B16 buf buf 2 if idx 255 av log avctx AVLOGERROR Palette index out of range u n idx buf 6 continue r buf buf g buf buf b buf buf pal idx r 16 g 8 b p palette has changed 1 if buf end buf 18 return AVERRORINVALIDDATA buf 18 for i 0 i avctx height i int size left code pix const uint8 t next uint8 t out int tsize 0 out outdata size AVR B16 buf buf 2 if buf end buf size return AVERRORINVALIDDATA left size next buf size while left 0 code buf if code 0x80 pix buf if out 257 code outdata a pic linesize 0 break memset out pix 257 code out 257 code tsize 257 code left 2 else if out code outdata a pic linesize 0 break if buf end buf code 1 return AVERRORINVALIDDATA memcpy out buf code 1 out code 1 buf code 1 left 2 code tsize code 1 buf next outdata a pic linesize 0 got frame 1 AV Frame data a pic return buf size static void parse content type struct message search context ctx struct message header line hdr struct rfc822 parser context parser string t content type rfc822 parser init parser hdr full value hdr full value len NULL rfc822 skip lwsp parser content type t str new 64 void rfc822 parse content type parser content type ctx content type text strncasecmp str c content type text 5 0 strncasecmp str c content type message 8 0 rfc822 parser deinit parser static int cinepak decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int ret 0 buf size avpkt size Cinepak Context s avctx priv data s data buf s size buf size if ret ff reget buffer avctx s frame av log avctx AVLOGERROR reget buffer failed n return ret if s palette video const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE cinepak decode s if s palette video memcpy s frame data 1 s pal AVPALETTESIZE if ret av frame ref data s frame 0 return ret got frame 1 return buf size static int slice end AV Codec Context avctx AV Frame pict Mpeg1 Context s1 avctx priv data Mpeg Enc Context s s1 mpeg enc ctx if s1 mpeg enc ctx allocated s current picture ptr return 0 if s avctx hwaccel if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode picture n if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s if s first field ff er frame end s er ff MPV frame end s if s pict type AVPICTURETYPEB s low delay int ret av frame ref pict s current picture ptr f if ret 0 return ret ff print debug info s s current picture ptr else if avctx active thread type FFTHREADFRAME s picture number if s last picture ptr NULL int ret av frame ref pict s last picture ptr f if ret 0 return ret ff print debug info s s last picture ptr return 1 else return 0 void vp9 init quantizer V P9 COMP cpi V P9 COMMON const cm cpi common QUANTS const quants cpi quants int i q quant for q 0 q QINDEXRANGE q const int qzbin factor q 0 64 vp9 dc quant q 0 148 84 80 const int qrounding factor q 0 64 48 for i 0 i 2 i int qrounding factor fp i 0 48 42 if q 0 qrounding factor fp 64 quant i 0 vp9 dc quant q cm y dc delta q vp9 ac quant q 0 invert quant quants y quant q i quants y quant shift q i quant quants y quant fp q i 1 16 quant quants y round fp q i qrounding factor fp quant 7 quants y zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants y round q i qrounding factor quant 7 cm y dequant q i quant quant i 0 vp9 dc quant q cm uv dc delta q vp9 ac quant q cm uv ac delta q invert quant quants uv quant q i quants uv quant shift q i quant quants uv quant fp q i 1 16 quant quants uv round fp q i qrounding factor fp quant 7 quants uv zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants uv round q i qrounding factor quant 7 cm uv dequant q i quant for i 2 i 8 i quants y quant q i quants y quant q 1 quants y quant fp q i quants y quant fp q 1 quants y round fp q i quants y round fp q 1 quants y quant shift q i quants y quant shift q 1 quants y zbin q i quants y zbin q 1 quants y round q i quants y round q 1 cm y dequant q i cm y dequant q 1 quants uv quant q i quants uv quant q 1 quants uv quant fp q i quants uv quant fp q 1 quants uv round fp q i quants uv round fp q 1 quants uv quant shift q i quants uv quant shift q 1 quants uv zbin q i quants uv zbin q 1 quants uv round q i quants uv round q 1 cm uv dequant q i cm uv dequant q 1 static inline void vc1 pred mv intfr V C1 Context v int n int dmv x int dmv y int mvn int r x int r y uint8 t is intra Mpeg Enc Context s v s int xy wrap off 0 int A 2 B 2 C 2 int px py int a valid 0 b valid 0 c valid 0 int field a field b field c int total valid num samefield num oppfield int pos c pos b n adj wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture motion val 0 xy 0 0 s mv 0 n 1 s current picture motion val 0 xy 1 0 s current picture motion val 1 xy 0 0 s current picture motion val 1 xy 1 0 if mvn 1 s current picture motion val 0 xy 1 0 0 s current picture motion val 0 xy 1 1 0 s current picture motion val 0 xy wrap 0 0 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy wrap 1 0 0 s current picture motion val 0 xy wrap 1 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture motion val 1 xy 1 0 0 s current picture motion val 1 xy 1 1 0 s current picture motion val 1 xy wrap 0 0 s current picture motion val 1 xy wrap 1 0 s current picture motion val 1 xy wrap 1 0 0 s current picture motion val 1 xy wrap 1 1 0 return off n 0 n 1 1 1 if s mb x n 1 n 3 if v blk mv type xy v blk mv type xy v blk mv type xy 1 A 0 s current picture motion val 0 xy 1 0 A 1 s current picture motion val 0 xy 1 1 a valid 1 else A 0 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 1 off wrap 0 1 1 A 1 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 off wrap 1 1 1 a valid 1 if n 1 v is intra s mb x 1 a valid 0 A 0 A 1 0 else A 0 A 1 0 B 0 B 1 C 0 C 1 0 if n 0 n 1 v blk mv type xy if s first slice line if v is intra s mb x s mb stride b valid 1 n adj n 2 pos b s block index n adj 2 wrap if v blk mv type pos b v blk mv type xy n adj n 2 n 1 B 0 s current picture motion val 0 s block index n adj 2 wrap 0 B 1 s current picture motion val 0 s block index n adj 2 wrap 1 if v blk mv type pos b v blk mv type xy B 0 B 0 s current picture motion val 0 s block index n adj 2 2 wrap 0 1 1 B 1 B 1 s current picture motion val 0 s block index n adj 2 2 wrap 1 1 1 if s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 2 pos c s block index 2 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 2 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index n adj 2 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index n adj 2 2 wrap 2 1 1 if s mb x s mb width 1 if v is intra s mb x s mb stride 1 c valid 1 n adj 3 pos c s block index 3 2 wrap 2 if v blk mv type pos c v blk mv type xy n adj n 1 C 0 s current picture motion val 0 s block index n adj 2 wrap 2 0 C 1 s current picture motion val 0 s block index n adj 2 wrap 2 1 if v blk mv type pos c v blk mv type xy C 0 1 C 0 s current picture motion val 0 s block index 1 2 wrap 2 0 1 C 1 1 C 1 s current picture motion val 0 s block index 1 2 wrap 2 1 1 else c valid 0 else pos b s block index 1 b valid 1 B 0 s current picture motion val 0 pos b 0 B 1 s current picture motion val 0 pos b 1 pos c s block index 0 c valid 1 C 0 s current picture motion val 0 pos c 0 C 1 s current picture motion val 0 pos c 1 total valid a valid b valid c valid if s mb x n 1 n 3 A 0 A 1 0 if s first slice line v blk mv type xy s first slice line n 2 B 0 B 1 C 0 C 1 0 if v blk mv type xy if s mb width 1 px B 0 py B 1 else if total valid 2 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if total valid if a valid px A 0 py A 1 if b valid px B 0 py B 1 if c valid px C 0 py C 1 else px py 0 else if a valid field a A 1 4 1 0 else field a 0 if b valid field b B 1 4 1 0 else field b 0 if c valid field c C 1 4 1 0 else field c 0 num oppfield field a field b field c num samefield total valid num oppfield if total valid 3 if num samefield 3 num oppfield 3 px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if num samefield num oppfield px field a A 0 B 0 py field a A 1 B 1 else px field a A 0 B 0 py field a A 1 B 1 else if total valid 2 if num samefield num oppfield if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else px py 0 else if field a a valid px A 0 py A 1 else if field b b valid px B 0 py B 1 else if c valid px C 0 py C 1 else if total valid 1 px a valid A 0 b valid B 0 C 0 py a valid A 1 b valid B 1 C 1 else px py 0 s mv 0 n 0 s current picture motion val 0 xy 0 px dmv x r x r x 1 1 r x s mv 0 n 1 s current picture motion val 0 xy 1 py dmv y r y r y 1 1 r y if mvn 1 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 s current picture motion val 0 xy 1 s current picture motion val 0 xy wrap 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy wrap 1 1 s current picture motion val 0 xy 1 else if mvn 2 s current picture motion val 0 xy 1 0 s current picture motion val 0 xy 0 s current picture motion val 0 xy 1 1 s current picture motion val 0 xy 1 s mv 0 n 1 0 s mv 0 n 0 s mv 0 n 1 1 s mv 0 n 1 static int g722 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt G722 Context c avctx priv data AV Frame frame data int16 t out buf int j ret const int skip 8 c bits per codeword const int16 t quantizer table low inv quants skip Get Bit Context gb frame nb samples avpkt size 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out buf int16 t frame data 0 init get bits gb avpkt data avpkt size 8 for j 0 j avpkt size j int ilow ihigh rlow rhigh dhigh int xout1 xout2 ihigh get bits gb 2 ilow get bits gb 6 skip skip bits gb skip rlow av clip c band 0 scale factor quantizer table ilow 10 c band 0 s predictor 16384 16383 ff g722 update low predictor c band 0 ilow 2 skip dhigh c band 1 scale factor ff g722 high inv quant ihigh 10 rhigh av clip dhigh c band 1 s predictor 16384 16383 ff g722 update high predictor c band 1 dhigh ihigh c prev samples c prev samples pos rlow rhigh c prev samples c prev samples pos rlow rhigh ff g722 apply qmf c prev samples c prev samples pos 24 xout1 xout2 out buf av clip int16 xout1 11 out buf av clip int16 xout2 11 if c prev samples pos PREVSAMPLESBUFSIZE memmove c prev samples c prev samples c prev samples pos 22 22 sizeof c prev samples 0 c prev samples pos 22 got frame ptr 1 return avpkt size static int aasc decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Aasc Context s avctx priv data int compr i stride ret if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret compr AVR L32 buf buf 4 buf size 4 switch compr case 0 stride avctx width 3 3 3 for i avctx height 1 i 0 i memcpy s frame data 0 i s frame linesize 0 buf avctx width 3 buf stride break case 1 bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame 8 s gb break default av log avctx AVLOGERROR Unknown compression type d n compr return AVERRORINVALIDDATA got frame 1 if ret av frame ref data s frame 0 return ret return buf size int ff MPV frame start Mpeg Enc Context s AV Codec Context avctx int i ret Picture pic s mb skipped 0 if s out format FMT H264 s codec id AVCODECIDSV Q3 if s pict type AVPICTURETYPEB s last picture ptr s last picture ptr s next picture ptr s last picture ptr f data 0 ff mpeg unref picture s s last picture ptr if s encoding for i 0 i MAXPICTURECOUNT i if s picture i s last picture ptr s picture i s next picture ptr s picture i reference s picture i needs realloc if avctx active thread type FFTHREADFRAME av log avctx AVLOGERROR releasing zombie picture n ff mpeg unref picture s s picture i if s encoding ff release unused pictures s 1 if s current picture ptr s current picture ptr f data 0 NULL pic s current picture ptr else i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i pic s picture i pic reference 0 if s droppable if s codec id AVCODECID H264 pic reference s picture structure else if s pict type AVPICTURETYPEB pic reference 3 pic f coded picture number s coded picture number if ff alloc picture s pic 0 0 return 1 s current picture ptr pic s current picture ptr f top field first s top field first if s codec id AVCODECIDMPE G1 VIDEO s codec id AVCODECIDMPE G2 VIDEO if s picture structure PICTFRAME s current picture ptr f top field first s picture structure PICTTOPFIELD s first field s current picture ptr f interlaced frame s progressive frame s progressive sequence s current picture ptr field picture s picture structure PICTFRAME s current picture ptr f pict type s pict type s current picture ptr f key frame s pict type AVPICTURETYPEI ff mpeg unref picture s s current picture if ret ff mpeg ref picture s s current picture s current picture ptr 0 return ret if s codec id AVCODECID H264 s pict type AVPICTURETYPEB s last picture ptr s next picture ptr if s droppable s next picture ptr s current picture ptr av dlog s avctx L p N p C p L p N p C p type d drop d n s last picture ptr s next picture ptr s current picture ptr s last picture ptr s last picture ptr f data 0 NULL s next picture ptr s next picture ptr f data 0 NULL s current picture ptr s current picture ptr f data 0 NULL s pict type s droppable if s codec id AVCODECID H264 if s last picture ptr NULL s last picture ptr f data 0 NULL s pict type AVPICTURETYPEI s picture structure PICTFRAME int h chroma shift v chroma shift av pix fmt get chroma sub sample s avctx pix fmt h chroma shift v chroma shift if s pict type AVPICTURETYPEI av log avctx AVLOGERROR warning first frame is no keyframe n else if s picture structure PICTFRAME av log avctx AVLOGINFO allocate dummy last picture for field based first keyframe n i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s last picture ptr s picture i if ff alloc picture s s last picture ptr 0 0 s last picture ptr NULL return 1 memset s last picture ptr f data 0 0 avctx height s last picture ptr f linesize 0 memset s last picture ptr f data 1 0x80 avctx height v chroma shift s last picture ptr f linesize 1 memset s last picture ptr f data 2 0x80 avctx height v chroma shift s last picture ptr f linesize 2 ff thread report progress s last picture ptr tf INTMAX 0 ff thread report progress s last picture ptr tf INTMAX 1 if s next picture ptr NULL s next picture ptr f data 0 NULL s pict type AVPICTURETYPEB i ff find unused picture s 0 if i 0 av log s avctx AVLOGERROR no frame buffer available n return i s next picture ptr s picture i if ff alloc picture s s next picture ptr 0 0 s next picture ptr NULL return 1 ff thread report progress s next picture ptr tf INTMAX 0 ff thread report progress s next picture ptr tf INTMAX 1 if s codec id AVCODECID H264 if s last picture ptr ff mpeg unref picture s s last picture if s last picture ptr f data 0 ret ff mpeg ref picture s s last picture s last picture ptr 0 return ret if s next picture ptr ff mpeg unref picture s s next picture if s next picture ptr f data 0 ret ff mpeg ref picture s s next picture s next picture ptr 0 return ret assert s pict type AVPICTURETYPEI s last picture ptr s last picture ptr f data 0 if s picture structure PICTFRAME s out format FMT H264 int i for i 0 i 4 i if s picture structure PICTBOTTOMFIELD s current picture f data i s current picture f linesize i s current picture f linesize i 2 s last picture f linesize i 2 s next picture f linesize i 2 s err recognition avctx err recognition if s mpeg quant s codec id AVCODECIDMPE G2 VIDEO s dct unquantize intra s dct unquantize mpeg2 intra s dct unquantize inter s dct unquantize mpeg2 inter else if s out format FMT H263 s out format FMT H261 s dct unquantize intra s dct unquantize h263 intra s dct unquantize inter s dct unquantize h263 inter else s dct unquantize intra s dct unquantize mpeg1 intra s dct unquantize inter s dct unquantize mpeg1 inter if s dct error sum assert s avctx noise reduction s encoding update noise reduction s if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration return ff xvmc field start s avctx return 0 void vp9 set rd speed thresholds sub8x8 V P9 COMP cpi const SPEEDFEATURES const sf cpi sf RDOPT const rd cpi rd int i for i 0 i MAXREFS i rd thresh mult sub8x8 i cpi oxcf mode BEST 500 0 rd thresh mult sub8x8 THRLAST 2500 rd thresh mult sub8x8 THRGOLD 2500 rd thresh mult sub8x8 THRALTR 2500 rd thresh mult sub8x8 THRINTRA 2500 rd thresh mult sub8x8 THRCOMPLA 4500 rd thresh mult sub8x8 THRCOMPGA 4500 for i 0 i MAXREFS i if sf disable split mask 1 i rd thresh mult sub8x8 i INTMAX if cpi ref frame flags V P9 LASTFLAG rd thresh mult sub8x8 THRLASTINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult sub8x8 THRGOLDINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult sub8x8 THRALTRINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult sub8x8 THRCOMPLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult sub8x8 static int userauth hostbased struct ssh ssh Authctxt authctxt ssh authctxt struct sshbuf b struct sshkey key NULL char pkalg cuser chost u char pkblob sig size t alen blen slen int r pktype authenticated 0 if authctxt valid debug2 s disabled because of invalid user func return 0 if r sshpkt get cstring ssh pkalg alen 0 r sshpkt get string ssh pkblob blen 0 r sshpkt get cstring ssh chost NULL 0 r sshpkt get cstring ssh cuser NULL 0 r sshpkt get string ssh sig slen 0 fatal s packet parsing s func ssh err r debug s cuser s chost s pkalg s slen zu func cuser chost pkalg slen sshbuf dump data sig siglen stderr if pktype KEYUNSPEC logit s unsupported public key algorithm s func pkalg goto done if r sshkey from blob pkblob blen key 0 error s key from blob s func ssh err r goto done if key NULL error s cannot decode key s func pkalg goto done if key type pktype error s type mismatch for decoded key received d expected d func key type pktype goto done if sshkey type plain key type KEYRSA ssh compat SSHBUGRSASIGM D5 0 error Refusing RSA key because peer uses unsafe signature format goto done if match pattern list pkalg options hostbased key types 0 1 logit s key type s not in Hostbased Accepted Key Types func sshkey type key goto done if b sshbuf new NULL fatal s sshbuf new failed func if r sshbuf put string b session id2 session id2 len 0 r sshbuf put u8 b SS H2 MSGUSERAUTHREQUEST 0 r sshbuf put cstring b authctxt user 0 r sshbuf put cstring b authctxt service 0 r sshbuf put cstring b hostbased 0 r sshbuf put string b pkalg alen 0 r sshbuf put string b pkblob blen 0 r sshbuf put cstring b chost 0 r sshbuf put cstring b cuser 0 fatal s buffer error s func ssh err r authenticated 0 if PRIVSEP hostbased key allowed authctxt pw cuser chost key PRIVSEP sshkey verify key sig slen sshbuf ptr b sshbuf len b pkalg ssh compat 0 authenticated 1 auth2 record key authctxt authenticated key sshbuf free b done debug2 s authenticated d func authenticated sshkey free key free pkalg free pkblob free cuser free chost free sig return authenticated static int vorbis decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size vorbis context vc avctx priv data AV Frame frame data Get Bit Context gb vc gb float channel ptrs 255 int i len ret av dlog NULL packet length d n buf size frame nb samples vc blocksize 1 2 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if vc audio channels 8 for i 0 i vc audio channels i channel ptrs i float frame extended data i else for i 0 i vc audio channels i int ch ff vorbis channel layout offsets vc audio channels 1 i channel ptrs ch float frame extended data i init get bits gb buf buf size 8 if len vorbis parse audio packet vc channel ptrs 0 return len if vc first frame vc first frame 1 got frame ptr 0 return buf size av dlog NULL parsed d bytes d bits returned d samples ch bits n get bits count gb 8 get bits count gb 8 len frame nb samples len got frame ptr 1 return buf size static int16 t wmv2 pred motion Wmv2 Context w int px int py Mpeg Enc Context const s w s int xy wrap diff type int16 t ABC mot val wrap s b8 stride xy s block index 0 mot val s current picture motion val 0 xy A s current picture motion val 0 xy 1 B s current picture motion val 0 xy wrap C s current picture motion val 0 xy 2 wrap if s mb x s first slice line s mspel w top left mv flag diff FFMAXFFABSA 0 B 0 FFABSA 1 B 1 else diff 0 if diff 8 type get bits1 s gb else type 2 if type 0 px A 0 py A 1 else if type 1 px B 0 py B 1 else if s first slice line px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 return mot val int petite inflate2x 1to9 char buf uint32 t minrva uint32 t bufsz struct cli exe section sections unsigned int sectcount uint32 t Imagebase uint32 t pep int desc int version uint32 t Res Rva uint32 t Res Size char adjbuf buf minrva char packed NULL uint32 t thisrva 0 bottom 0 enc ep 0 irva 0 workdone 0 grown 0x355 skew 0x35 int j 0 oob mangled 0 check4resources 0 struct cli exe section usects NULL void tmpsct NULL if version 2 packed adjbuf sections sectcount 1 rva 0x1b8 if version 1 packed adjbuf sections sectcount 1 rva 0x178 grown 0x323 skew 0x34 while 1 char ssrc ddst uint32 t size srva int backbytes oldback backsize addsize if CLIISCONTAINED buf bufsz packed 4 if usects free usects return 1 srva cli readint32 packed if srva int t upd 1 if j 0 return 1 while upd upd 0 for t 0 t j 1 t uint32 t trva trsz tvsz if usects t rva usects t 1 rva continue trva usects t rva trsz usects t rsz tvsz usects t vsz usects t rva usects t 1 rva usects t rsz usects t 1 rsz usects t vsz usects t 1 vsz usects t 1 rva trva usects t 1 rsz trsz usects t 1 vsz tvsz upd 1 for t 0 t j 1 t if usects t vsz usects t 1 rva usects t rva usects t vsz usects t 1 rva usects t rva if enc ep uint32 t virtaddr pep 5 Imagebase tmpep int rndm 0 dummy 1 char thunk adjbuf irva char imports if version 2 while dummy CLIISCONTAINED buf bufsz thunk 4 uint32 t api if cli readint32 thunk workdone 1 break imports adjbuf cli readint32 thunk thunk 4 dummy 0 while CLIISCONTAINED buf bufsz imports 4 dummy 0 imports 4 if api cli readint32 imports 4 dummy 1 break if api api 0x80000000 mangled rndm 0 api virtaddr virtaddr 5 rndm virtaddr 7 else api 0xbff01337 if sections sectcount 1 rva Imagebase api enc ep if api virtaddr enc ep tmpep enc ep 0xfffffff8 3 0x1fffffff enc ep enc ep 7 29 tmpep else workdone 1 enc ep pep 5 enc ep if workdone 1 cli dbgmsg Petite Old EP x n enc ep else enc ep usects 0 rva cli dbgmsg Petite In troubles while attempting to decrypt old EP using bogus x n enc ep for t 0 t j t usects t raw t 0 usects t 1 raw usects t 1 rsz 0 if usects t rsz 0 if CLIISCONTAINED buf bufsz buf usects t raw usects t rsz memmove buf usects t raw adjbuf usects t rva usects t rsz else cli dbgmsg Petite Skipping section d Raw x R Size x n t usects t raw usects t rsz usects t raw t 0 usects t 1 raw 0 usects t rsz 0 cli dbgmsg Petite Sections dump n for t 0 t j t cli dbgmsg Petite SECT d RVA x V Size x R Offset x R Size x n t usects t rva usects t vsz usects t raw usects t rsz if cli rebuildpe buf usects j Imagebase enc ep Res Rva Res Size desc cli dbgmsg Petite Rebuilding failed n free usects return 1 free usects return 0 size srva 0x7fffffff if srva size check4resources 0 if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 bottom cli readint32 packed 8 4 ssrc adjbuf cli readint32 packed 4 size 1 4 ddst adjbuf cli readint32 packed 8 size 1 4 if CLIISCONTAINED buf bufsz ssrc size 4 CLIISCONTAINED buf bufsz ddst size 4 if usects free usects return 1 memmove ddst ssrc size 4 packed 0x0c else uint32 t check1 check2 uint8 t mydl 0 uint8 t goback unsigned int q if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 size cli readint32 packed 4 thisrva cli readint32 packed 8 packed 0x10 if j 96 cli dbgmsg Petite maximum number of sections exceeded giving up n free usects return 1 if tmpsct cli realloc usects sizeof struct cli exe section j 1 if usects free usects return 1 usects struct cli exe section tmpsct usects j rva thisrva usects j rsz size if int bottom thisrva 0 usects j vsz bottom thisrva else usects j vsz size usects j raw 0 if size j continue ssrc adjbuf srva ddst adjbuf thisrva for q 0 q sectcount q if CLIISCONTAINED sections q rva sections q vsz usects j rva usects j vsz continue if check4resources usects j rva sections q rva usects j rsz thisrva sections q rva size break if q sectcount free usects return 1 j if size 0x10000 check1 0x0 FFFF C060 check2 0x0 FFFFF C60 goback 5 else if size 0x40000 check1 0x0 FFF F8180 check2 0x0 FFFF F980 goback 7 else check1 0x0 FFF F8300 check2 0x0 FFFFF B00 goback 8 if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 size ddst ssrc backbytes 0 oldback 0 while size 0 oob doubledl ssrc mydl buf bufsz if oob 1 free usects return 1 if oob if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 ddst char ssrc size 0xff size else addsize 0 backbytes while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backbytes 3 if backbytes 0 backsize goback do if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob backsize while backsize backbytes 0xffffffff addsize 1 backbytes int check2 backbytes int check1 oldback backbytes else backsize backbytes 1 backbytes oldback if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if backsize backsize while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backsize 2 backsize addsize size backsize if CLIISCONTAINED buf bufsz ddst backsize CLIISCONTAINED buf bufsz ddst backbytes backsize free usects return 1 while backsize ddst ddst backbytes ddst backbytes 0 backsize 0 if j int strippetite 0 uint32 t reloc if usects j 1 rsz grown CLIISCONTAINED buf bufsz ddst grown 5 0x4f 8 cli readint32 ddst grown 5 0x4f 0x645ec033 cli readint32 ddst grown 5 0x4f 4 0x1b8b188b reloc 0 strippetite 1 if strippetite usects j 1 rsz grown skew CLIISCONTAINED buf bufsz ddst grown 5 0x4f skew 8 cli readint32 ddst grown 5 0x4f skew 0x645ec033 cli readint32 ddst grown 5 0x4f 4 skew 0x1b8b188b reloc skew strippetite 1 if strippetite CLIISCONTAINED buf bufsz ddst grown 0x0f 8 reloc 8 uint32 t test1 test2 test1 cli readint32 ddst grown 0x0f 8 reloc 0x9d6661aa test2 cli readint32 ddst grown 0x0f 4 reloc 0xe908c483 cli dbgmsg Petite Found petite code in sect d x Let s strip it n j 1 usects j 1 rva if test1 test2 CLIISCONTAINED buf bufsz ddst grown 0x0f reloc 0x1c0 0x0f 4 irva cli readint32 ddst grown 0x121 reloc enc ep cli readint32 ddst grown 0x0f reloc test1 mangled uint32 t cli readint32 ddst grown 0x1c0 reloc 0x90909090 cli dbgmsg Petite Encrypted EP x Array of imports x n enc ep irva usects j 1 rsz grown reloc check4resources static int set and cost bmi mvs V P9 COMP cpi MACROBLOCKD xd int i PREDICTIONMODE mode int mv this mv 2 int mv frame mv MBMODECOUNTMAXREFFRAMES int mv seg mvs MAXREFFRAMES int mv best ref mv 2 const int mvjcost int mvcost 2 MODEINFO const mic xd mi 0 const MBMODEINFO const mbmi mic mbmi int thismvcost 0 int idx idy const int num 4x4 blocks wide num 4x4 blocks wide lookup mbmi sb type const int num 4x4 blocks high num 4x4 blocks high lookup mbmi sb type const int is compound has second ref mbmi switch mode case NEWMV this mv 0 as int seg mvs mbmi ref frame 0 as int thismvcost vp9 mv bit cost this mv 0 as mv best ref mv 0 as mv mvjcost mvcost MVCOSTWEIGHTSUB if is compound this mv 1 as int seg mvs mbmi ref frame 1 as int thismvcost vp9 mv bit cost this mv 1 as mv best ref mv 1 as mv mvjcost mvcost MVCOSTWEIGHTSUB break case NEARMV case NEARESTMV this mv 0 as int frame mv mode mbmi ref frame 0 as int if is compound this mv 1 as int frame mv mode mbmi ref frame 1 as int break case ZEROMV this mv 0 as int 0 if is compound this mv 1 as int 0 break default break mic bmi i as mv 0 as int this mv 0 as int if is compound mic bmi i as mv 1 as int this mv 1 as int mic bmi i as mode mode for idy 0 idy num 4x4 blocks high idy for idx 0 idx num 4x4 blocks wide idx vpx memcpy mic bmi i idy 2 idx mic bmi i sizeof mic bmi i return cost mv ref cpi mode mbmi mode context mbmi ref frame 0 thismvcost static int decode frame WMA Pro Decode Ctx s AV Frame frame int got frame ptr AV Codec Context avctx s avctx Get Bit Context gb s gb int more frames 0 int len 0 int i ret if s len prefix len get bits gb s log2 frame size av dlog s avctx decoding frame with length x n len if decode tilehdr s s packet loss 1 return 0 if s avctx channels 1 get bits1 gb if get bits1 gb for i 0 i avctx channels avctx channels i skip bits gb 4 if s dynamic range compression s drc gain get bits gb 8 av dlog s avctx drc gain i n s drc gain if get bits1 gb int av unused skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx start skip i n skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx end skip i n skip av dlog s avctx BITSTREAM frame header length was i n get bits count gb s frame offset s parsed all subframes 0 for i 0 i avctx channels i s channel i decoded samples 0 s channel i cur subframe 0 s channel i reuse sf 0 while s parsed all subframes if decode subframe s 0 s packet loss 1 return 0 frame nb samples s samples per frame if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n s packet loss 1 return 0 for i 0 i avctx channels i memcpy frame extended data i s channel i out s samples per frame sizeof s channel i out for i 0 i avctx channels i memcpy s channel i out 0 s channel i out s samples per frame s samples per frame sizeof s channel i out 1 if s skip frame s skip frame 0 got frame ptr 0 else got frame ptr 1 if s len prefix if len get bits count gb s frame offset 2 av log s avctx AVLOGERROR frame i would have to skip i bits n s frame num len get bits count gb s frame offset 1 s packet loss 1 return 0 skip bits long gb len get bits count gb s frame offset 1 else while get bits count gb s num saved bits get bits1 gb 0 more frames get bits1 gb s frame num return more frames static int rc pick q and bounds two pass const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality cpi twopass active worst quality int q if frame is intra only cm vp9 is upper layer key frame cpi if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc active worst quality if cm width cm height 352 288 q adj factor 0 25 q adj factor 0 05 0 001 double cpi twopass kf zeromotion pct q val vp9 convert qindex to q active best quality active best quality vp9 compute qdelta rc q val q val q adj factor else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q else active best quality get gf active quality rc q else if oxcf rc mode VPXQ active best quality cq level else active best quality inter minq active worst quality if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality const GFGROUP const gf group cpi twopass gf group const double rate factor deltas RATEFACTORLEVELS 1 00 1 00 1 50 1 75 2 00 const double rate factor rate factor deltas gf group rf level gf group index int qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality rate factor top index active worst quality qdelta top index top index bottom index top index bottom index q active best quality static int mv refs rt const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 int const motion 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col 1 const motion 1 for i MVREFNEIGHBOURS refmv count i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 if different ref found refmv count for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd return const motion static int dwarf elf object access load section void obj in Dwarf Half section index Dwarf Small section data int error dwarf elf object access internals t obj dwarf elf object access internals t obj in if section index 0 return DWDLVNOENTRY Elf Scn scn 0 Elf Data data 0 scn elf getscn obj elf section index if scn NULL error DWDLEMDE return DWDLVERROR data elf getdata scn NULL if data NULL error DWDLEMDE return DWDLVERROR if data d buf error DWDLEMDE return DWDLVERROR section data data d buf return static void set block thresholds const V P9 COMMON cm RDOPT rd int i bsize segment id for segment id 0 segment id MAXSEGMENTS segment id const int qindex clamp vp9 get qindex cm seg segment id cm base qindex cm y dc delta q 0 MAXQ const int q compute rd thresh factor qindex for bsize 0 bsize BLOCKSIZES bsize const int t q rd thresh block size factor bsize const int thresh max INTMAX t if bsize BLOCK 8 X8 for i 0 i MAXMODES i rd threshes segment id bsize i rd thresh mult i thresh max rd thresh mult i t 4 INTMAX else for i 0 i MAXREFS i rd threshes segment id bsize i rd thresh mult sub8x8 i thresh max rd thresh mult sub8x8 i t 4 static void dec build inter predictors MACROBLOCKD xd int plane int block int bw int bh int x int y int w int h int mi x int mi y struct macroblockd plane const pd xd plane plane const MODEINFO mi xd mi 0 src mi const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter int ref for ref 0 ref 1 is compound ref const struct scale factors const sf xd block refs ref sf struct buf 2d const pre buf pd pre ref struct buf 2d const dst buf pd dst uint8 t const dst dst buf buf dst buf stride y x const MV mv mi mbmi sb type BLOCK 8 X8 average split mvs pd mi ref block mi mbmi mv ref as mv const MV mv q4 clamp mv to umv border sb xd mv bw bh pd subsampling x pd subsampling y M V32 scaled mv int xs ys x0 y0 x0 16 y0 16 frame width frame height buf stride subpel x subpel y uint8 t ref frame buf ptr const Y V12 BUFFERCONFIG ref buf xd block refs ref buf if plane 0 frame width ref buf y crop width frame height ref buf y crop height ref frame ref buf y buffer else frame width ref buf uv crop width frame height ref buf uv crop height ref frame plane 1 ref buf u buffer ref buf v buffer if vp9 is scaled sf int x start xd mb to left edge 3 pd subsampling x int y start xd mb to top edge 3 pd subsampling y x0 16 x start x SUBPELBITS y0 16 y start y SUBPELBITS x0 16 sf scale value x x0 16 sf y0 16 sf scale value y y0 16 sf x0 sf scale value x x start x sf y0 sf scale value y y start y sf scaled mv vp9 scale mv mv q4 mi x x mi y y sf xs sf x step q4 ys sf y step q4 else x0 xd mb to left edge 3 pd subsampling x x y0 xd mb to top edge 3 pd subsampling y y x0 16 x0 SUBPELBITS y0 16 y0 SUBPELBITS scaled mv row mv q4 row scaled mv col mv q4 col xs ys 16 subpel x scaled mv col SUBPELMASK subpel y scaled mv row SUBPELMASK x0 scaled mv col SUBPELBITS y0 scaled mv row SUBPELBITS x0 16 scaled mv col y0 16 scaled mv row buf ptr ref frame y0 pre buf stride x0 buf stride pre buf stride if scaled mv col scaled mv row frame width 0x7 frame height 0x7 int x1 x0 16 w 1 xs SUBPELBITS 1 int y1 y0 16 h 1 ys SUBPELBITS 1 int x pad 0 y pad 0 if subpel x sf x step q4 SUBPELMASK x0 V P9 INTERPEXTEND 1 x1 V P9 INTERPEXTEND x pad 1 if subpel y sf y step q4 SUBPELMASK y0 V P9 INTERPEXTEND 1 y1 V P9 INTERPEXTEND y pad 1 if x0 0 x0 frame width 1 x1 0 x1 frame width 1 y0 0 y0 frame height 1 y1 0 y1 frame height 1 uint8 t buf ptr1 ref frame y0 pre buf stride x0 high build mc border buf ptr1 pre buf stride xd mc buf high x1 x0 1 x0 y0 x1 x0 1 y1 y0 1 frame width frame height buf stride x1 x0 1 buf ptr CONVERTTOBYTEPTR xd mc buf high y pad 3 buf stride x pad 3 else build mc border buf ptr1 pre buf stride xd mc buf x1 x0 1 x0 y0 x1 x0 1 y1 y0 1 frame width frame height buf stride x1 x0 1 buf ptr xd mc buf y pad 3 buf stride x pad 3 buf stride x1 x0 1 buf ptr xd mc buf y pad 3 buf stride x pad 3 high inter predictor buf ptr buf stride dst dst buf stride subpel x subpel y sf w h ref kernel xs ys xd bd else inter predictor buf ptr buf stride dst dst buf stride subpel x subpel y sf w h ref kernel xs ys static int tta decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size TTA Context s avctx priv data int i ret int cur chan 0 framelen s frame length int32 t p if avctx err recognition AVEFCRCCHECK if buf size 4 tta check crc s buf buf size 4 return AVERRORINVALIDDATA init get bits s gb buf buf size 8 frame nb samples framelen if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if s bps 3 s decode buffer int32 t frame data 0 for i 0 i s channels i s ch ctx i predictor 0 ttafilter init s ch ctx i filter ttafilter configs s bps 1 rice init s ch ctx i rice 10 10 i 0 for p s decode buffer p s decode buffer framelen s channels p int32 t predictor s ch ctx cur chan predictor TTA Filter filter s ch ctx cur chan filter TTA Rice rice s ch ctx cur chan rice uint32 t unary depth k int32 t value unary tta get unary s gb if unary 0 depth 0 k rice k0 else depth 1 k rice k1 unary if get bits left s gb k ret AVERRORINVALIDDATA goto error if k if k MINCACHEBITS ret AVERRORINVALIDDATA goto error value unary k get bits s gb k else value unary switch depth case 1 rice sum1 value rice sum1 4 if rice k1 0 rice sum1 shift 16 rice k1 rice k1 else if rice sum1 shift 16 rice k1 1 rice k1 value shift 1 rice k0 default rice sum0 value rice sum0 4 if rice k0 0 rice sum0 shift 16 rice k0 rice k0 else if rice sum0 shift 16 rice k0 1 rice k0 p 1 value 1 value 1 1 ttafilter process filter p case 1 p PRED predictor 4 break case 2 case 3 p PRED predictor 5 break case 4 p predictor break predictor p if cur chan s channels 1 cur chan else if s channels 1 int32 t r p 1 for p r 2 r p s channels r r r 1 r cur chan 0 i if i s last frame length get bits left s gb 8 4 frame nb samples framelen s last frame length break int Get Certificate Failure JNI Env env const Java Param Ref jclass obj const Java Param Ref jobject java web contents enum Certificate Failure NONE 0 CERTIFICATEFAILUNSPECIFIED 1 CERTIFICATEFAILUNTRUSTED 2 CERTIFICATEFAILREVOKED 3 CERTIFICATEFAILNOTYETVALID 4 CERTIFICATEFAILEXPIRED 5 CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS 6 content Web Contents web contents content Web Contents From Java Web Contents java web contents content Navigation Entry entry web contents Get Controller Get Visible Entry if entry return NONE const content SSL Status ssl entry Get SSL switch ssl security style case content SECURITYSTYLEWARNING case content SECURITYSTYLEUNKNOWN case content SECURITYSTYLEUNAUTHENTICATED return NONE case content SECURITYSTYLEAUTHENTICATIONBROKEN case content SECURITYSTYLEAUTHENTICATED if net Is Cert Status Error ssl cert status if ssl cert status net CERTSTATUSAUTHORITYINVALID return CERTIFICATEFAILUNTRUSTED if ssl cert status net CERTSTATUSREVOKED return CERTIFICATEFAILREVOKED if ssl cert status net CERTSTATUSDATEINVALID return CERTIFICATEFAILEXPIRED if ssl cert status net CERTSTATUSUNABLETOCHECKREVOCATION return CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS return CERTIFICATEFAILUNSPECIFIED if ssl content status content SSL Status DISPLAYEDINSECURECONTENT return CERTIFICATEFAILUNSPECIFIED return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Jv Context s avctx priv data int buf size avpkt size const uint8 t buf avpkt data const uint8 t buf end buf buf size int video size video type i j video size AVR L32 buf video type buf 4 buf 5 if video size if avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return 1 if video type 0 video type 1 Get Bit Context gb init get bits gb buf 8 FFMIN video size buf end buf for j 0 j avctx height j 8 for i 0 i avctx width i 8 decode8x8 gb s frame data 0 j s frame linesize 0 i s frame linesize 0 s dsp buf video size else if video type 2 if buf 1 buf end int v buf for j 0 j avctx height j memset s frame data 0 j s frame linesize 0 v avctx width else av log avctx AVLOGWARNING unsupported frame type i n video type return AVERRORINVALIDDATA if buf buf end for i 0 i AVPALETTECOUNT buf 3 buf end i s palette i AVR B24 buf 2 buf 3 s palette has changed 1 if video size s frame key frame 1 s frame pict type AVPICTURETYPEI s frame palette has changed s palette has changed s palette has changed 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size static int bethsoftvid decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Bethsoftvid Context vid avctx priv data char block type uint8 t dst uint8 t frame end int remaining avctx width int wrap to next line int code ret int yoffset if ret ff reget buffer avctx vid frame 0 av log avctx AVLOGERROR reget buffer failed n return ret wrap to next line vid frame linesize 0 avctx width if avpkt side data elems 0 avpkt side data 0 type AVPKTDATAPALETTE bytestream2 init vid g avpkt side data 0 data avpkt side data 0 size if ret set palette vid 0 return ret bytestream2 init vid g avpkt data avpkt size dst vid frame data 0 frame end vid frame data 0 vid frame linesize 0 avctx height switch block type bytestream2 get byte vid g case PALETTEBLOCK got frame 0 if ret set palette vid 0 av log avctx AVLOGERROR error reading palette n return ret return bytestream2 tell vid g case VIDEOYOFFPFRAME yoffset bytestream2 get le16 vid g if yoffset avctx height return AVERRORINVALIDDATA dst vid frame linesize 0 yoffset while code bytestream2 get byte vid g int length code 0x7f while length remaining if code 0x80 bytestream2 get buffer vid g dst remaining else if block type VIDEOIFRAME memset dst bytestream2 peek byte vid g remaining length remaining dst remaining wrap to next line remaining avctx width if dst frame end goto end if code 0x80 bytestream2 get buffer vid g dst length else if block type VIDEOIFRAME memset dst bytestream2 get byte vid g length remaining length dst length end if ret av frame ref data vid frame 0 return ret got frame 1 return avpkt size static int decode tag AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Nelly Moser Decode Context s avctx priv data int blocks i ret float samples flt blocks buf size NELLYBLOCKLEN if blocks 0 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if buf size NELLYBLOCKLEN av log avctx AVLOGWARNING Leftover bytes d n buf size NELLYBLOCKLEN frame nb samples NELLYSAMPLES blocks if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples flt float frame data 0 for i 0 i blocks i nelly decode block s buf samples flt samples flt NELLYSAMPLES buf NELLYBLOCKLEN got frame ptr 1 return buf size static gboolean logcat dump text wtap dumper wdh const struct wtap pkthdr phdr const guint8 pd int err gchar buf gint length gchar priority const struct logger entry log entry struct logger entry pd const struct logger entry v2 log entry v2 struct logger entry v2 pd gint payload length const gchar tag gint32 pid gint32 tid gint32 seconds gint32 milliseconds const gchar msg begin gint msg pre skip gchar log gchar log part gchar log next const union wtap pseudo header pseudo header phdr pseudo header const struct dumper t dumper const struct dumper t wdh priv if phdr rec type RECTYPEPACKET err WTAPERRRECTYPEUNSUPPORTED return FALSE payload length GIN T32 FROMLE log entry len pid GIN T32 FROMLE log entry pid tid GIN T32 FROMLE log entry tid seconds GIN T32 FROMLE log entry sec milliseconds GIN T32 FROMLE log entry nsec 1000000 if pseudo header logcat version 1 priority get priority log entry msg 0 tag log entry msg 1 msg pre skip 1 strlen tag 1 msg begin log entry msg msg pre skip else if pseudo header logcat version 2 priority get priority log entry v2 msg 0 tag log entry v2 msg 1 msg pre skip 1 strlen tag 1 msg begin log entry v2 msg msg pre skip else err WTAPERRUNSUPPORTED return FALSE log g strndup msg begin payload length msg pre skip log next log do log part log next if dumper type DUMPLONG log next NULL else log next strchr log part n if log next NULL log next 0 log next if log next 0 log next NULL buf logcat log dumper seconds milliseconds pid tid priority tag log part if buf g free log return FALSE length guint32 strlen buf if wtap dump file write wdh buf length err g free log return FALSE wdh bytes dumped length while log next NULL g free log return static int cook decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size COOK Context q avctx priv data float samples NULL int i ret int offset 0 int chidx 0 if buf size avctx block align return buf size if q discarded packets 2 frame nb samples q samples per channel if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame extended data q subpacket 0 size avctx block align for i 1 i q num subpackets i q subpacket i size 2 buf avctx block align q num subpackets i q subpacket 0 size q subpacket i size 1 if q subpacket 0 size 0 av log avctx AVLOGDEBUG frame subpacket size total avctx block align n return AVERRORINVALIDDATA for i 0 i q num subpackets i q subpacket i bits per subpacket q subpacket i size 8 q subpacket i bits per subpdiv q subpacket i ch idx chidx av log avctx AVLOGDEBUG subpacket i size i js i i block align i n i q subpacket i size q subpacket i joint stereo offset avctx block align if ret decode subpacket q q subpacket i buf offset samples 0 return ret offset q subpacket i size chidx q subpacket i num channels av log avctx AVLOGDEBUG subpacket i i i n i q subpacket i size 8 get bits count q gb if q discarded packets 2 q discarded packets got frame ptr 0 return avctx block align got frame ptr 1 return avctx block align static int rv34 decode mv R V34 Dec Context r int block type Mpeg Enc Context s r s Get Bit Context gb s gb int i j k l int mv pos s mb x 2 s mb y 2 s b8 stride int next bt memset r dmv 0 sizeof r dmv for i 0 i num mvs block type i r dmv i 0 svq3 get se golomb gb r dmv i 1 svq3 get se golomb gb switch block type case R V34 MBTYPEINTRA case R V34 MBTYPEINTR A16x16 ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride return 0 case R V34 MBSKIP if s pict type AVPICTURETYPEPZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBDIRECT if HAVETHREADS s avctx active thread type FFTHREADFRAME ff thread await progress s next picture ptr f FFMAX 0 s mb y 1 0 next bt s next picture ptr f mb type s mb x s mb y s mb stride if ISINTRA next bt ISSKIP next bt ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride ZER O8x2 s current picture ptr f motion val 1 s mb x 2 s mb y 2 s b8 stride s b8 stride else for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k for l 0 l 2 l s current picture ptr f motion val l mv pos i j s b8 stride k calc add mv r l s next picture ptr f motion val 0 mv pos i j s b8 stride k if IS 16 X8 next bt IS 8 X16 next bt IS 8 X8 next bt rv34 mc 2mv r block type else rv34 mc 2mv skip r ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride break case R V34 MBP 16x16 case R V34 MBPMI X16x16 rv34 pred mv r block type 0 0 rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBFORWARD case R V34 MBBBACKWARD r dmv 1 0 r dmv 0 0 r dmv 1 1 r dmv 0 1 if r rv30 rv34 pred mv rv3 r block type block type R V34 MBBBACKWARD else rv34 pred mv b r block type block type R V34 MBBBACKWARD rv34 mc 1mv r block type 0 0 0 2 2 block type R V34 MBBBACKWARD break case R V34 MBP 16x8 case R V34 MBP 8x16 rv34 pred mv r block type 0 0 rv34 pred mv r block type 1 block type R V34 MBP 16x8 1 if block type R V34 MBP 16x8 rv34 mc 1mv r block type 0 0 0 2 1 0 rv34 mc 1mv r block type 0 8 s b8 stride 2 1 0 if block type R V34 MBP 8x16 rv34 mc 1mv r block type 0 0 0 1 2 0 rv34 mc 1mv r block type 8 0 1 1 2 0 break case R V34 MBBBIDIR rv34 pred mv b r block type 0 rv34 pred mv b r block type 1 rv34 mc 2mv r block type break case R V34 MBP 8x8 for i 0 i 4 i rv34 pred mv r block type i i rv34 mc 1mv r block type i 1 3 i 2 2 i 1 i 1 s b8 stride 1 1 0 break return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Prores Context ctx avctx priv data AV Frame picture avctx coded frame const uint8 t buf avpkt data int buf size avpkt size int frame hdr size pic num pic data size if buf size 28 buf size AVR B32 buf AVR B32 buf 4 FRAMEID av log avctx AVLOGERROR invalid frame n return AVERRORINVALIDDATAMOVEDATAPTR 8 frame hdr size decode frame header ctx buf buf size avctx if frame hdr size 0 return AVERRORINVALIDDATAMOVEDATAPTR frame hdr size if picture data 0 avctx release buffer avctx picture picture reference 0 if ff get buffer avctx picture 0 return 1 for pic num 0 ctx picture interlaced frame pic num 1 pic num pic data size decode picture header ctx buf buf size avctx if pic data size 0 return AVERRORINVALIDDATA if decode picture ctx pic num avctx return 1 MOVEDATAPTR pic data size got frame 1 AV Frame data avctx coded frame return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt LOCO Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data int decoded ret if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p key frame 1 switch l mode case LOCOCYU Y2 case LOCOYU Y2 case LOCOUYVY decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height p linesize 1 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height p linesize 2 buf buf size 1 break case LOCOCY V12 case LOCOY V12 decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf buf size 1 break case LOCOCRGB case LOCORGB decoded loco decode plane l p data 0 p linesize 0 avctx height 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 2 avctx width avctx height p linesize 0 buf buf size 3 break case LOCORGBA decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 1 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 2 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 3 avctx width avctx height p linesize 0 buf buf size 4 break got frame 1 return buf size buf too small av log avctx AVLOGERROR Input data too small n return static inline int h263 mv4 search Mpeg Enc Context s int mx int my int shift Motion Est Context const c s me const int size 1 const int h 8 int block int P 10 2 int dmin sum 0 mx4 sum 0 my4 sum 0 int same 1 const int stride c stride uint8 t mv penalty c current mv penalty init mv4 ref c for block 0 block 4 block int mx4 my4 int pred x4 pred y4 int dmin4 static const int off 4 2 1 1 1 const int mot stride s b8 stride const int mot xy s block index block PLEFT 0 s current picture f motion val 0 mot xy 1 0 PLEFT 1 s current picture f motion val 0 mot xy 1 1 if PLEFT 0 c xmax shift PLEFT 0 c xmax shift if s first slice line block 2 c pred x pred x4 PLEFT 0 c pred y pred y4 PLEFT 1 else PTOP 0 s current picture f motion val 0 mot xy mot stride 0 PTOP 1 s current picture f motion val 0 mot xy mot stride 1 PTOPRIGHT 0 s current picture f motion val 0 mot xy mot stride off block 0 PTOPRIGHT 1 s current picture f motion val 0 mot xy mot stride off block 1 if PTOP 1 c ymax shift PTOP 1 c ymax shift if PTOPRIGHT 0 c xmin shift PTOPRIGHT 0 c xmin shift if PTOPRIGHT 0 c xmax shift PTOPRIGHT 0 c xmax shift if PTOPRIGHT 1 c ymax shift PTOPRIGHT 1 c ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 c pred x pred x4 PMEDIAN 0 c pred y pred y4 PMEDIAN 1 PM V1 0 mx PM V1 1 my dmin4 epzs motion search4 s mx4 my4 P block block s p mv table 1 16 shift dmin4 c sub motion search s mx4 my4 dmin4 block block size h if s dsp me sub cmp 0 s dsp mb cmp 0 int dxy const int offset block 1 block 1 stride 8 uint8 t dest y c scratchpad offset if s quarter sample uint8 t ref c ref block 0 mx4 2 my4 2 stride dxy my4 3 2 mx4 3 if s no rounding s dsp put no rnd qpel pixels tab 1 dxy dest y ref stride else s dsp put qpel pixels tab 1 dxy dest y ref stride else uint8 t ref c ref block 0 mx4 1 my4 1 stride dxy my4 1 1 mx4 1 if s no rounding s dsp put no rnd pixels tab 1 dxy dest y ref stride h else s dsp put pixels tab 1 dxy dest y ref stride h dmin sum mv penalty mx4 pred x4 mv penalty my4 pred y4 c mb penalty factor else dmin sum dmin4 if s quarter sample mx4 sum mx4 2 my4 sum my4 2 else mx4 sum mx4 my4 sum my4 s current picture f motion val 0 s block index block 0 mx4 s current picture f motion val 0 s block index block 1 my4 if mx4 mx my4 my same 0 if same return INTMAX if s dsp me sub cmp 0 s dsp mb cmp 0 dmin sum s dsp mb cmp 0 s s new picture f data 0 s mb x 16 s mb y 16 stride c scratchpad stride 16 if c avctx mb cmp FFCMPCHROMA int dxy int mx my int offset mx ff h263 round chroma mx4 sum my ff h263 round chroma my4 sum dxy my 1 1 mx 1 offset s mb x 8 mx 1 s mb y 8 my 1 s uvlinesize if s no rounding s dsp put no rnd pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put no rnd pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 else s dsp put pixels tab 1 dxy c scratchpad s last picture f data 1 offset s uvlinesize 8 s dsp put pixels tab 1 dxy c scratchpad 8 s last picture f data 2 offset s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 1 s mb x 8 s mb y 8 s uvlinesize c scratchpad s uvlinesize 8 dmin sum s dsp mb cmp 1 s s new picture f data 2 s mb x 8 s mb y 8 s uvlinesize c scratchpad 8 s uvlinesize 8 c pred x mx c pred y my switch c avctx mb cmp 0x FF case FFCMPRD return dmin sum default return dmin sum 11 c mb penalty factor static int rv34 decode intra macroblock R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s int cbp dist int mb pos s mb x s mb y s mb stride memset r avail cache 0 sizeof r avail cache fill rectangle r avail cache 6 2 2 4 1 4 dist s mb x s resync mb x s mb y s resync mb y s mb width if s mb x dist r avail cache 5 r avail cache 9 s current picture ptr mb type mb pos 1 if dist s mb width r avail cache 2 r avail cache 3 s current picture ptr mb type mb pos s mb stride if s mb x 1 s mb width dist s mb width 1 r avail cache 4 s current picture ptr mb type mb pos s mb stride 1 if s mb x dist s mb width r avail cache 1 s current picture ptr mb type mb pos s mb stride 1 s qscale r si quant cbp rv34 decode intra mb header r intra types r cbp luma mb pos cbp r cbp chroma mb pos cbp 16 r deblock coefs mb pos 0x FFFF s current picture ptr qscale table mb pos s qscale if cbp 1 return 1 if r is16 rv34 output i16x16 r intra types cbp return 0 rv34 output intra r intra types cbp return 0 static inline int vc1 pred dc Mpeg Enc Context s int overlap int pq int n int a avail int c avail int16 t dc val ptr int dir ptr int a b c wrap pred int16 t dc val int mb pos s mb x s mb y s mb stride int q1 q2 0 int dqscale index wrap s block wrap n dc val s dc val 0 s block index n c dc val 1 b dc val 1 wrap a dc val wrap q1 s current picture qscale table mb pos dqscale index s y dc scale table q1 1 if dqscale index 0 return 0 if c avail n 1 n 3 q2 s current picture qscale table mb pos 1 if q2 q2 q1 c c s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail n 2 n 3 q2 s current picture qscale table mb pos s mb stride if q2 q2 q1 a a s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail n 3 int off mb pos if n 1 off if n 2 off s mb stride q2 s current picture qscale table off if q2 q2 q1 b b s y dc scale table q2 ff vc1 dqscale dqscale index 0x20000 18 if a avail c avail if abs a b abs b c pred c dir ptr 1 else pred a dir ptr 0 else if a avail pred a dir ptr 0 else if c avail pred c dir ptr 1 else pred 0 dir ptr 1 dc val ptr dc val 0 return pred static void update mbgraph frame stats V P9 COMP cpi MBGRAPHFRAMESTATS stats Y V12 BUFFERCONFIG buf Y V12 BUFFERCONFIG golden ref Y V12 BUFFERCONFIG alt ref MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd V P9 COMMON const cm cpi common int mb col mb row offset 0 int mb y offset 0 arf y offset 0 gld y offset 0 MV gld top mv 0 0 MODEINFO mi local vp9 zero mi local x mv row min BORDERMVPIXELS B16 x mv row max cm mb rows 1 8 BORDERMVPIXELS B16 xd up available 0 xd plane 0 dst stride buf y stride xd plane 0 pre 0 stride buf y stride xd plane 1 dst stride buf uv stride xd mi 0 mi local mi local mbmi sb type BLOCK 16 X16 mi local mbmi ref frame 0 LASTFRAME mi local mbmi ref frame 1 NONE for mb row 0 mb row cm mb rows mb row MV gld left mv gld top mv int mb y in offset mb y offset int arf y in offset arf y offset int gld y in offset gld y offset x mv col min BORDERMVPIXELS B16 x mv col max cm mb cols 1 8 BORDERMVPIXELS B16 xd left available 0 for mb col 0 mb col cm mb cols mb col MBGRAPHMBSTATS mb stats stats mb stats offset mb col update mbgraph mb stats cpi mb stats buf mb y in offset golden ref gld left mv alt ref mb row mb col gld left mv mb stats ref GOLDENFRAME m mv as mv if mb col 0 gld top mv gld left mv xd left available 1 mb y in offset 16 gld y in offset 16 arf y in offset 16 x mv col min 16 x mv col max 16 xd up available 1 mb y offset buf y stride 16 gld y offset golden ref y stride 16 if alt ref arf y offset alt ref y stride 16 x mv row min 16 x mv row max 16 offset cm mb cols static int dissect segment ofstable tvbuff t tvb int offset packet info pinfo U proto tree tree lbmpdm offset table t offset table int encoding proto item subtree item NULL proto tree subtree NULL int datalen 0 int seglen 0 int ofs 0 int field count 0 int idx gint32 id list NULL gint32 ofs list NULL gint32 max index 1 gint32 min offset GMAXIN T32 lbmpdm offset table t ofs table NULL seglen lbmpdm get segment length tvb offset encoding datalen subtree item proto tree add none format tree hf lbmpdm segment tvb offset seglen Offset Table Segment subtree proto item add subtree subtree item ett lbmpdm segment proto tree add item subtree hf lbmpdm segment next hdr tvb offset OLBMPDMSEGHDRTNEXTHDRLLBMPDMSEGHDRTNEXTHDR encoding proto tree add item subtree hf lbmpdm segment flags tvb offset OLBMPDMSEGHDRTFLAGSLLBMPDMSEGHDRTFLAGS encoding proto tree add item subtree hf lbmpdm segment res tvb offset OLBMPDMSEGHDRTRESLLBMPDMSEGHDRTRES encoding proto tree add item subtree hf lbmpdm segment len tvb offset OLBMPDMSEGHDRTLENLLBMPDMSEGHDRTLEN encoding field count datalen LLBMPDMOFFSETENTRYT id list wmem alloc array wmem packet scope gint32 field count ofs list wmem alloc array wmem packet scope gint32 field count for idx 0 idx field count idx id list idx 1 ofs list idx 1 ofs offset LLBMPDMSEGHDRT for idx 0 idx field count idx ofs LLBMPDMOFFSETENTRYT proto item offset item NULL proto tree offset tree NULL offset item proto tree add item subtree hf lbmpdm offset entry tvb ofs LLBMPDMOFFSETENTRYTENCNA offset tree proto item add subtree offset item ett lbmpdm offset entry proto tree add item offset tree hf lbmpdm offset entry id tvb ofs OLBMPDMOFFSETENTRYTIDLLBMPDMOFFSETENTRYTID encoding id list idx gint32 lbmpdm fetch uint32 encoded tvb ofs OLBMPDMOFFSETENTRYTID encoding proto tree add item offset tree hf lbmpdm offset entry offset tvb ofs OLBMPDMOFFSETENTRYTOFFSETLLBMPDMOFFSETENTRYTOFFSET encoding ofs list idx gint32 lbmpdm fetch uint32 encoded tvb ofs OLBMPDMOFFSETENTRYTOFFSET encoding if id list idx 0 ofs list idx 0 THROW Reported Bounds Error if id list idx max index max index id list idx if ofs list idx min offset min offset ofs list idx ofs table wmem new wmem packet scope lbmpdm offset table t ofs table num flds max index 1 ofs table min set offset NULL ofs table offset list wmem alloc array wmem packet scope gint32 ofs table num flds for idx 0 idx int ofs table num flds idx ofs table offset list idx 1 for idx 0 idx field count idx ofs table offset list id list idx ofs list idx if ofs list idx min offset ofs table min set offset ofs table offset list id list idx if offset table NULL offset table ofs table return seglen int vp9 compute rd mult const V P9 COMP cpi int qindex const int q vp9 dc quant qindex 0 int rdmult 88 q q 24 if cpi oxcf pass 2 cpi common frame type KEYFRAME const GFGROUP const gf group cpi twopass gf group const FRAMEUPDATETYPE frame type gf group update type gf group index const int boost index MIN 15 cpi rc gfu boost 100 rdmult rdmult rd frame type factor frame type 7 rdmult rdmult rd boost factor boost index 7 return rdmult static void encode sb rt V P9 COMP cpi const Tile Info const tile TOKENEXTRA tp int mi row int mi col int output enabled BLOCKSIZE bsize PCTREE pc tree V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const int bsl b width log2 bsize hbs 1 bsl 4 int ctx PARTITIONTYPE partition BLOCKSIZE subsize if mi row cm mi rows mi col cm mi cols return if bsize BLOCK 8 X8 const int idx str xd mi stride mi row mi col MODEINFO mi 8x8 cm mi idx str src mi ctx partition plane context xd mi row mi col bsize subsize mi 8x8 0 src mi mbmi sb type else ctx 0 subsize BLOCK 4 X4 partition partition lookup bsl subsize if output enabled bsize BLOCK 4 X4 cm counts partition ctx partition switch partition case PARTITIONNONE encode b rt cpi tile tp mi row mi col output enabled subsize pc tree none break case PARTITIONVERT encode b rt cpi tile tp mi row mi col output enabled subsize pc tree vertical 0 if mi col hbs cm mi cols bsize BLOCK 8 X8 encode b rt cpi tile tp mi row mi col hbs output enabled subsize pc tree vertical 1 break case PARTITIONHORZ encode b rt cpi tile tp mi row mi col output enabled subsize pc tree horizontal 0 if mi row hbs cm mi rows bsize BLOCK 8 X8 encode b rt cpi tile tp mi row hbs mi col output enabled subsize pc tree horizontal 1 break case PARTITIONSPLIT subsize get subsize bsize PARTITIONSPLIT encode sb rt cpi tile tp mi row mi col output enabled subsize pc tree split 0 encode sb rt cpi tile tp mi row mi col hbs output enabled subsize pc tree split 1 encode sb rt cpi tile tp mi row hbs mi col output enabled subsize pc tree split 2 encode sb rt cpi tile tp mi row hbs mi col hbs output enabled subsize pc tree split 3 break default assert Invalid partition type break if partition PARTITIONSPLIT bsize BLOCK 8 X8 update partition context xd mi row mi col subsize bsize static int alloc frame buffer Mpeg Enc Context s Picture pic int r ret if s avctx hwaccel assert pic hwaccel picture private if s avctx hwaccel priv data size pic hwaccel picture private av mallocz s avctx hwaccel priv data size if pic hwaccel picture private av log s avctx AVLOGERROR alloc frame buffer failed hwaccel private data allocation n return 1 pic tf f pic f if s codec id AVCODECIDWM V3 IMAGE s codec id AVCODECIDV C1 IMAGE s codec id AVCODECIDMS S2 r ff thread get buffer s avctx pic tf pic reference AVGETBUFFERFLAGREF 0 else pic f width s avctx width pic f height s avctx height pic f format s avctx pix fmt r avcodec default get buffer2 s avctx pic f 0 if r 0 pic f data 0 av log s avctx AVLOGERROR get buffer failed d p n r pic f data 0 av freep pic hwaccel picture private return 1 if s linesize s linesize pic f linesize 0 s uvlinesize pic f linesize 1 av log s avctx AVLOGERROR get buffer failed stride changed n ff mpeg unref picture s pic return 1 if pic f linesize 1 pic f linesize 2 av log s avctx AVLOGERROR get buffer failed uv stride mismatch n ff mpeg unref picture s pic return 1 if s edge emu buffer ret ff mpv frame size alloc s pic f linesize 0 0 av log s avctx AVLOGERROR get buffer failed to allocate context scratch buffers n ff mpeg unref picture s pic return ret return 0 void safeputs netdissect options ndo const u char s const u int maxlen u int idx 0 while idx maxlen s safeputchar ndo s idx s void vp9 init quantizer V P9 COMP cpi V P9 COMMON const cm cpi common QUANTS const quants cpi quants int i q quant for q 0 q QINDEXRANGE q const int qzbin factor q 0 64 vp9 dc quant q 0 148 84 80 const int qrounding factor q 0 64 48 for i 0 i 2 i int qrounding factor fp i 0 48 42 if q 0 qrounding factor fp 64 quant i 0 vp9 dc quant q cm y dc delta q vp9 ac quant q 0 invert quant quants y quant q i quants y quant shift q i quant quants y quant fp q i 1 16 quant quants y round fp q i qrounding factor fp quant 7 quants y zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants y round q i qrounding factor quant 7 cm y dequant q i quant quant i 0 vp9 dc quant q cm uv dc delta q vp9 ac quant q cm uv ac delta q invert quant quants uv quant q i quants uv quant shift q i quant quants uv quant fp q i 1 16 quant quants uv round fp q i qrounding factor fp quant 7 quants uv zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants uv round q i qrounding factor quant 7 cm uv dequant q i quant for i 2 i 8 i quants y quant q i quants y quant q 1 quants y quant fp q i quants y quant fp q 1 quants y round fp q i quants y round fp q 1 quants y quant shift q i quants y quant shift q 1 quants y zbin q i quants y zbin q 1 quants y round q i quants y round q 1 cm y dequant q i cm y dequant q 1 quants uv quant q i quants uv quant q 1 quants uv quant fp q i quants uv quant fp q 1 quants uv round fp q i quants uv round fp q 1 quants uv quant shift q i quants uv quant shift q 1 quants uv zbin q i quants uv zbin q 1 quants uv round q i quants uv round q 1 cm uv dequant q i cm uv dequant q 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Jv Context s avctx priv data int buf size avpkt size const uint8 t buf avpkt data const uint8 t buf end buf buf size int video size video type i j video size AVR L32 buf video type buf 4 buf 5 if video size if avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return 1 if video type 0 video type 1 Get Bit Context gb init get bits gb buf 8 FFMIN video size buf end buf for j 0 j avctx height j 8 for i 0 i avctx width i 8 decode8x8 gb s frame data 0 j s frame linesize 0 i s frame linesize 0 s dsp buf video size else if video type 2 if buf 1 buf end int v buf for j 0 j avctx height j memset s frame data 0 j s frame linesize 0 v avctx width else av log avctx AVLOGWARNING unsupported frame type i n video type return AVERRORINVALIDDATA if buf buf end for i 0 i AVPALETTECOUNT buf 3 buf end i s palette i AVR B24 buf 2 buf 3 s palette has changed 1 if video size s frame key frame 1 s frame pict type AVPICTURETYPEI s frame palette has changed s palette has changed s palette has changed 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size WORKSTATE ossl statem server pre work SSL s WORKSTATE wst OSSLSTATEM st s statem switch st hand state case TLSSTSWHELLOREQ s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s break case DTLSSTSWHELLOVERIFYREQUEST s shutdown 0 if SSLISDTLS s dtls1 clear record buffer s st use timer 0 break case TLSSTSWSRVRHELLO if SSLISDTLS s st use timer 1 break case TLSSTSWSRVRDONE ifndef OPENSSLNOSCTP if SSLISDTLS s BIO dgram is sctp SSL get wbio s return dtls wait for dry s case TLSSTSWSESSIONTICKET if SSLISDTLS s st use timer 0 break case TLSSTSWCHANGE s session cipher s s3 tmp new cipher if s method ssl3 enc setup key block s ossl statem set error s return WORKERROR if SSLISDTLS s st use timer 0 return WORKFINISHEDCONTINUE case TLSSTOK return tls finish handshake s wst default break return static int restore toc entry Archive Handle AH Toc Entry te bool is parallel Restore Options ropt AH public ropt int status WORKEROK te Reqs reqs bool defn Dumped AH current TE te if toc Entry Is ACL te reqs 0 else reqs te reqs if ropt create DB strcmp te desc DATABASE 0 reqs 0 if ropt suppress Dump Warnings strcmp te desc WARNING 0 if ropt data Only te defn NULL strlen te defn 0 write msg modulename warning from original dump file s n te defn else if te copy Stmt NULL strlen te copy Stmt 0 write msg modulename warning from original dump file s n te copy Stmt defn Dumped false if reqs REQSCHEMA 0 if te namespace ahlog AH 1 creating s s s n te desc te namespace te tag else ahlog AH 1 creating s s n te desc te tag print Toc Entry AH te false false defn Dumped true if strcmp te desc TABLE 0 if AH last Error TE te if ropt no Data For Failed Tables if is parallel status WORKERINHIBITDATA else inhibit data for failed table AH te else if is parallel status WORKERCREATEDONE else mark create done AH te if strcmp te desc DATABASE 0 PQ Exp Buffer Data connstr init PQ Exp Buffer connstr append PQ Exp Buffer Str connstr dbname append Conn Str Val connstr te tag ahlog AH 1 connecting to new database s n te tag reconnect To DBAH te tag ropt dbname connstr data if reqs REQDATA 0 if te had Dumper if AH Print Toc Data Ptr NULL print Toc Entry AH te true false if strcmp te desc BLOBS 0 strcmp te desc BLOBCOMMENTS 0 ahlog AH 1 processing s n te desc select Output Schema AH pg catalog if strcmp te desc BLOBCOMMENTS 0 AH output Kind OUTPUTOTHERDATAAH Print Toc Data Ptr AH te AH output Kind OUTPUTSQLCMDS else disable Triggers If Necessary AH te become Owner AH te select Output Schema AH te namespace ahlog AH 1 processing data for table s s n te namespace te tag if is parallel te created Start Transaction AH public ahprintf AHTRUNCATETABLE s s n n P Qserver Version AH connection 80400 ONLY fmt Id te tag if te copy Stmt strlen te copy Stmt 0 ahprintf AH s te copy Stmt AH output Kind OUTPUTCOPYDATA else AH output Kind OUTPUTOTHERDATAAH Print Toc Data Ptr AH te if AH output Kind OUTPUTCOPYDATA Restoring To DBAH End DB Copy Mode AH public te tag AH output Kind OUTPUTSQLCMDS if is parallel te created Commit Transaction AH public enable Triggers If Necessary AH te else if defn Dumped ahlog AH 1 executing s s n te desc te tag print Toc Entry AH te false false if AH public n errors 0 status WORKEROK status WORKERIGNOREDERRORS return status static int64 t encode inter mb segment V P9 COMP cpi MACROBLOCK x int64 t best yrd int i int labelyrate int64 t distortion int64 t sse ENTROPYCONTEXT ta ENTROPYCONTEXT tl int mi row int mi col int k MACROBLOCKD xd x e mbd struct macroblockd plane const pd xd plane 0 struct macroblock plane const p x plane 0 MODEINFO const mi xd mi 0 src mi const BLOCKSIZE plane bsize get plane block size mi mbmi sb type pd const int width 4 num 4x4 blocks wide lookup plane bsize const int height 4 num 4x4 blocks high lookup plane bsize int idx idy const uint8 t const src p src buf raster block offset BLOCK 8 X8 i p src stride uint8 t const dst pd dst buf raster block offset BLOCK 8 X8 i pd dst stride int64 t thisdistortion 0 thissse 0 int thisrate 0 ref const scan order so vp9 default scan orders TX 4 X4 const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter for ref 0 ref 1 is compound ref const uint8 t pre pd pre ref buf raster block offset BLOCK 8 X8 i pd pre ref stride vp9 build inter predictor pre pd pre ref stride dst pd dst stride mi bmi i as mv ref as mv xd block refs ref sf width height ref kernel MVPRECISION Q3 mi col MISIZE 4 i 2 mi row MISIZE 4 i 2 vp9 subtract block height width raster block offset int16 BLOCK 8 X8 i p src diff 8 src p src stride dst pd dst stride k i for idy 0 idy height 4 idy for idx 0 idx width 4 idx int64 t ssz rd rd1 rd2 tran low t coeff k idy 2 idx coeff BLOCKOFFSET p coeff k x fwd txm4x4 raster block offset int16 BLOCK 8 X8 k p src diff coeff 8 vp9 regular quantize b 4x4 x 0 k so scan so iscan thisdistortion vp9 block error coeff BLOCKOFFSET pd dqcoeff k 16 ssz thissse ssz thisrate cost coeffs x 0 k ta k 1 tl k 1 TX 4 X4 so scan so neighbors cpi sf use fast coef costing rd1 RDCOST x rdmult x rddiv thisrate thisdistortion 2 rd2 RDCOST x rdmult x rddiv 0 thissse 2 rd MIN rd1 rd2 if rd best yrd return IN T64 MAX distortion thisdistortion 2 labelyrate thisrate sse thissse 2 return RDCOST x rdmult x rddiv labelyrate distortion static void setup frame size with refs V P9 COMMON cm struct vp9 read bit buffer rb int width height int found 0 i int has valid ref frame 0 for i 0 i REFSPERFRAME i if vp9 rb read bit rb Y V12 BUFFERCONFIG const buf cm frame refs i buf width buf y crop width height buf y crop height if buf corrupted vpx internal error cm error VPXCODECCORRUPTFRAME Frame reference is corrupt found 1 break if found vp9 read frame size rb width height if width 0 height 0 vpx internal error cm error VPXCODECCORRUPTFRAME Invalid frame size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i has valid ref frame valid ref frame size ref frame buf y crop width ref frame buf y crop height width height if has valid ref frame vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has invalid size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i if valid ref frame img fmt ref frame buf bit depth ref frame buf uv crop width ref frame buf y crop width ref frame buf uv crop height ref frame buf y crop height cm bit depth cm subsampling x cm subsampling y vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has incompatible color space resize context buffers cm width height setup display size cm rb if vp9 realloc frame buffer get frame new buffer cm cm width cm height cm subsampling x cm subsampling y if CONFIGV P9 HIGHBITDEPTH cm use highbitdepth endif V P9 DECBORDERINPIXELS cm frame bufs cm new fb idx raw frame buffer cm get fb cb cm cb priv vpx internal error cm error VPXCODECMEMERROR Failed to allocate frame buffer cm frame bufs cm new fb idx buf bit depth unsigned int cm bit depth static gint detect version wtap wth int err gchar err info gint bytes read guint16 payload length guint16 try header size guint8 buffer gint64 file offset guint32 log length guint32 tag length guint16 tmp file offset file tell wth fh bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 payload length pletoh16 tmp bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 try header size pletoh16 tmp buffer guint8 g malloc 5 4 payload length bytes read file read buffer 5 4 payload length wth fh if bytes read 5 4 payload length if bytes read 4 4 payload length err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD g free buffer return 1 if try header size 24 tag length guint32 strlen buffer 5 4 1 1 log length guint32 strlen buffer 5 4 1 tag length 1 if payload length 1 tag length log length g free buffer return 2 tag length guint32 strlen buffer 4 4 1 1 log length guint32 strlen buffer 4 4 1 tag length 1 if payload length 1 tag length log length if file seek wth fh file offset 4 4 1 tag length log length SEEKSET err 1 g free buffer return 1 g free buffer return 1 g free buffer return 0 static gboolean dissect applemidi heur tvbuff t tvb packet info pinfo proto tree tree void data U guint16 command conversation t p conv rtp dyn payload t rtp dyn payload NULL if tvb length tvb 4 return FALSE if test applemidi tvb command FALSE return FALSE rtp dyn payload rtp dyn payload new rtp dyn payload insert rtp dyn payload 97 rtp midi 10000 rtp add address pinfo pinfo src pinfo srcport 0 APPLEMIDIDISSECTORSHORTNAME pinfo fd num FALSE rtp dyn payload p conv find or create conversation pinfo conversation set dissector p conv applemidi handle dissect applemidi common tvb pinfo tree command return static int dissect udvm reference operand memory guint8 buff guint operand address guint16 value guint result dest guint bytecode guint16 operand guint offset operand address guint test bits guint8 temp data guint16 temp data16 if operand address UDVMMEMORYSIZE return 1 bytecode buff operand address test bits bytecode 7 if test bits 1 test bits bytecode 6 if test bits 2 temp data buff operand address 0x3f operand temp data 8 temp data buff operand address 1 0xffff operand operand temp data operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 2 else operand address operand buff operand address 8 operand operand buff operand address 1 0xffff result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset offset 3 else operand bytecode 0x7f operand operand 2 result dest operand temp data16 buff operand 8 temp data16 temp data16 buff operand 1 0xffff value temp data16 offset if offset UDVMMEMORYSIZE result dest UDVMMEMORYSIZE 1 return 1 return offset void dissect q931 cause ie tvbuff t tvb int offset int len proto tree tree int hf cause value guint8 cause value const value string ie vals gboolean have valid q931 pi save have valid q931 pi have valid q931 pi FALSE dissect q931 cause ie unsafe tvb offset len tree hf cause value cause value ie vals have valid q931 pi have valid q931 pi save static inline void vc1 pred b mv intfi V C1 Context v int n int dmv x int dmv y int mv1 int pred flag int dir v bmvtype BMVTYPEBACKWARD 1 0 Mpeg Enc Context s v s int mb pos s mb x s mb y s mb stride if v bmvtype BMVTYPEDIRECT int total opp k f if s next picture f mb type mb pos v mb off MBTYPEINTRA s mv 0 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 s block index 0 v blocks off 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 s block index 0 v blocks off 1 v bfraction 1 s quarter sample total opp v mv f next 0 s block index 0 v blocks off v mv f next 0 s block index 1 v blocks off v mv f next 0 s block index 2 v blocks off v mv f next 0 s block index 3 v blocks off f total opp 2 1 0 else s mv 0 0 0 s mv 0 0 1 0 s mv 1 0 0 s mv 1 0 1 0 f 0 v ref field type 0 v ref field type 1 v cur field type f for k 0 k 4 k s current picture f motion val 0 s block index k v blocks off 0 s mv 0 0 0 s current picture f motion val 0 s block index k v blocks off 1 s mv 0 0 1 s current picture f motion val 1 s block index k v blocks off 0 s mv 1 0 0 s current picture f motion val 1 s block index k v blocks off 1 s mv 1 0 1 v mv f 0 s block index k v blocks off f v mv f 1 s block index k v blocks off f return if v bmvtype BMVTYPEINTERPOLATED vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 pred flag 0 0 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 pred flag 1 1 return if dir vc1 pred mv v n dmv x 1 dmv y 1 mv1 v range x v range y v mb type 0 pred flag 1 1 if n 3 mv1 vc1 pred mv v 0 dmv x 0 dmv y 0 1 v range x v range y v mb type 0 0 0 else vc1 pred mv v n dmv x 0 dmv y 0 mv1 v range x v range y v mb type 0 pred flag 0 0 if n 3 mv1 vc1 pred mv v 0 dmv x 1 dmv y 1 1 v range x v range y v mb type 0 0 1 static int cng decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data CNG Context p avctx priv data int buf size avpkt size int ret i int16 t buf out float e 1 0 float scaling if avpkt size int dbov avpkt data 0 p target energy 1081109975 pow 10 dbov 10 0 0 75 memset p target refl coef 0 p order sizeof p target refl coef for i 0 i FFMIN avpkt size 1 p order i p target refl coef i avpkt data 1 i 127 128 0 if p inited p energy p energy 2 p target energy 2 for i 0 i p order i p refl coef i 0 6 p refl coef i 0 4 p target refl coef i else p energy p target energy memcpy p refl coef p target refl coef p order sizeof p refl coef p inited 1 make lpc coefs p lpc coef p refl coef p order for i 0 i p order i e 1 0 p refl coef i p refl coef i scaling sqrt e p energy 1081109975 for i 0 i avctx frame size i int r av lfg get p lfg 0xffff 0x8000 p excitation i scaling r ff celp lp synthesis filterf p filter out p order p lpc coef p excitation avctx frame size p order frame nb samples avctx frame size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out int16 t frame data 0 for i 0 i avctx frame size i buf out i p filter out i p order memcpy p filter out p filter out avctx frame size p order sizeof p filter out got frame ptr 1 return buf size void proto register iax2 void static hf register info hf hf iax2 packet type Packet type iax2 packet type FTUIN T8 BASEDECVALS iax packet types 0 Full minivoice minivideo trunk packet HFILL hf iax2 callno Call identifier iax2 call FTUIN T32 BASEDECNULL 0 This is the identifier Wireshark assigns to identify this call It does not correspond to any real field in the protocol HFILL hf iax2 scallno Source call iax2 src call FTUIN T16 BASEDECNULL 0x7 FFF src call holds the number of this call at the packet source pbx HFILL hf iax2 dcallno Destination call iax2 dst call FTUIN T16 BASEDECNULL 0x7 FFF dst call holds the number of this call at the packet destination HFILL hf iax2 retransmission Retransmission iax2 retransmission FTBOOLEAN 16 NULL 0x8000 retransmission is set if this packet is a retransmission of an earlier failed packet HFILL hf iax2 ts Timestamp iax2 timestamp FTUIN T32 BASEDECNULL 0x0 timestamp is the time in ms after the start of this call at which this packet was transmitted HFILL hf iax2 minits Timestamp iax2 timestamp FTUIN T16 BASEDECNULL 0x0 timestamp is the time in ms after the start of this call at which this packet was transmitted HFILL hf iax2 minividts Timestamp iax2 timestamp FTUIN T16 BASEDECNULL 0x7 FFF timestamp is the time in ms after the start of this call at which this packet was transmitted HFILL hf iax2 absts Absolute Time iax2 abstime FTABSOLUTETIMEABSOLUTETIMELOCALNULL 0x0 The absolute time of this packet calculated by adding the IAX timestamp to the start time of this call HFILL hf iax2 lateness Lateness iax2 lateness FTRELATIVETIMEBASENONENULL 0x0 The lateness of this packet compared to its timestamp HFILL hf iax2 minividmarker Marker iax2 video marker FTUIN T16 BASEDECNULL 0x8000 RTP end of frame marker HFILL hf iax2 oseqno Outbound seq no iax2 oseqno FTUIN T16 BASEDECNULL 0x0 oseqno is the sequence no of this packet The first packet has oseqno 0 and subsequent packets increment the oseqno by 1 HFILL hf iax2 iseqno Inbound seq no iax2 iseqno FTUIN T16 BASEDECNULL 0x0 iseqno is the sequence no of the last successfully received packet HFILL hf iax2 type Type iax2 type FTUIN T8 BASEDECBASEEXTSTRING iax frame types ext 0x0 For full IA X2 frames type is the type of frame HFILL hf iax2 csub Unknown subclass iax2 subclass FTUIN T8 BASEDECNULL 0x0 Subclass of unknown type of full IA X2 frame HFILL hf iax2 dtmf csub DTMF subclass digit iax2 dtmf subclass FTSTRINGZBASENONENULL 0x0 DTMF subclass gives the DTMF digit HFILL hf iax2 cmd csub Control subclass iax2 control subclass FTUIN T8 BASEDECBASEEXTSTRING iax cmd subclasses ext 0x0 This gives the command number for a Control packet HFILL hf iax2 iax csub IAX subclass iax2 iax subclass FTUIN T8 BASEDECBASEEXTSTRING iax iax subclasses ext 0x0 IAX subclass gives the command number for IAX signaling packets HFILL hf iax2 voice csub Voice Subclass compressed codec no iax2 voice subclass FTUIN T8 BASEDECNULL 0x0 NULLHFILL hf iax2 voice codec CODEC iax2 voice codec FTUIN T32 BASEHEXBASEEXTSTRING codec types ext 0x0 CODEC gives the codec used to encode audio data HFILL hf iax2 video csub Video Subclass compressed codec no iax2 video subclass FTUIN T8 BASEDECNULL 0x BFNULLHFILL hf iax2 marker Marker iax2 video marker FTBOOLEAN 8 NULL 0x40 RTP end of frame marker HFILL hf iax2 video codec CODEC iax2 video codec FTUIN T32 BASEHEXBASEEXTSTRING codec types ext 0 The codec used to encode video data HFILL hf iax2 modem csub Modem subclass iax2 modem subclass FTUIN T8 BASEDECVALS iax modem subclasses 0x0 Modem subclass gives the type of modem HFILL hf iax2 text csub Text subclass iax2 text subclass FTUIN T8 BASEDECVALS iax text subclasses 0x0 NULLHFILL hf iax2 text text Text iax2 text text FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 html csub HTML subclass iax2 html subclass FTUIN T8 BASEDECVALS iax html subclasses 0x0 NULLHFILL hf iax2 html url HTMLURL iax2 html url FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 trunk ts Timestamp iax2 timestamp FTUIN T32 BASEDECNULL 0x0 timestamp is the time in ms after the start of Command data this call at which this trunk packet was transmitted HFILL hf iax2 trunk metacmd Meta command iax2 trunk metacmd FTUIN T8 BASEDECNULL 0x7 F Meta command indicates whether or not the Meta Frame is a trunk HFILL hf iax2 trunk cmddata Command data iax2 trunk cmddata FTUIN T8 BASEHEXNULL 0x0 Flags for options that apply to a trunked call HFILL hf iax2 trunk cmddata ts Trunk timestamps iax2 trunk cmddata ts FTBOOLEAN 8 NULLIA X2 TRUNKTS True calls do each include their own timestamp HFILL hf iax2 trunk call len Data length iax2 trunk call len FTUIN T16 BASEDECNULL 0x0 Trunk call data length in octets HFILL hf iax2 trunk call scallno Source call number iax2 trunk call scallno FTUIN T16 BASEDECNULL 0x7 FFF Trunk call source call number HFILL hf iax2 trunk call ts Timestamp iax2 trunk call ts FTUIN T16 BASEDECNULL 0x0 timestamp is the time in ms after the start of this call at which this packet was transmitted HFILL hf iax2 trunk call data Data iax2 trunk call payload FTBYTESBASENONENULL 0x0 Payload carried by this trunked packet HFILL hf iax2 trunk ncalls Number of calls iax2 trunk ncalls FTUIN T16 BASEDECNULL 0x0 Number of calls in this trunk packet HFILL hf IAXIEAPPARENTADDRSINFAMILY Family iax2 iax app addr sinfamily FTUIN T16 BASEDECNULL 0 NULLHFILL hf IAXIEAPPARENTADDRSINPORT Port iax2 iax app addr sinport FTUIN T16 BASEDECNULL 0 NULLHFILL hf IAXIEAPPARENTADDRSINADDR Address iax2 iax app addr sinaddr FTI Pv4 BASENONENULL 0 NULLHFILL hf iax2 ies IAXIECALLEDNUMBER Number extension being called iax2 iax called number FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGNUMBER Calling number iax2 iax calling number FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGANI Calling number ANI for billing iax2 iax calling ani FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGNAME Name of caller iax2 iax calling name FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECALLEDCONTEXT Context for number iax2 iax called context FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEUSERNAME Username peer or user for authentication iax2 iax username FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEPASSWORD Password for authentication iax2 iax password FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECAPABILITY Actual codec capability iax2 iax capability FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEFORMAT Desired codec format iax2 iax format FTUIN T32 BASEHEXBASEEXTSTRING codec types ext 0x0 NULLHFILL hf iax2 ies IAXIELANGUAGE Desired language iax2 iax language FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEVERSION Protocol version iax2 iax version FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEADSICPECPEADSI capability iax2 iax cpe adsi FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEDNID Originally dialed DNID iax2 iax dnid FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEAUTHMETHODS Authentication method s iax2 iax auth methods FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECHALLENGE Challenge data for M D5 RSA iax2 iax auth challenge FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEM D5 RESULTM D5 challenge result iax2 iax auth md5 FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIERSARESULTRSA challenge result iax2 iax auth rsa FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEREFRESH When to refresh registration iax2 iax refresh FTIN T16 BASEDECNULL 0x0 NULLHFILL hf iax2 ies IAXIEDPSTATUS Dialplan status iax2 iax dialplan status FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECALLNO Call number of peer iax2 iax call no FTUIN T16 BASEDECNULL 0x0 NULLHFILL hf iax2 ies IAXIECAUSE Cause iax2 iax cause FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEIAXUNKNOWN Unknown IAX command iax2 iax iax unknown FTBYTESBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEMSGCOUNT How many messages waiting iax2 iax msg count FTIN T16 BASEDECNULL 0x0 NULLHFILL hf iax2 ies IAXIEAUTOANSWER Request auto answering iax2 iax autoanswer FTNONEBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEMUSICONHOLD Request musiconhold with QUELCH iax2 iax moh FTNONEBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIETRANSFERID Transfer Request Identifier iax2 iax transferid FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERDNIS Referring DNIS iax2 iax rdnis FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEPROVISIONING Provisioning info iax2 iax provisioning FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEAESPROVISIONINGAES Provisioning info iax2 iax aesprovisioning FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEDATETIME Date Time iax2 iax datetime raw FTUIN T32 BASEDECNULL 0x0 NULLHFILL hf iax2 ie datetime Date Time iax2 iax datetime FTABSOLUTETIMEABSOLUTETIMELOCALNULL 0x0 NULLHFILL hf iax2 ies IAXIEDEVICETYPE Device type iax2 iax devicetype FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIESERVICEIDENT Service identifier iax2 iax serviceident FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEFIRMWAREVER Firmware version iax2 iax firmwarever FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEFWBLOCKDESC Firmware block description iax2 iax fwblockdesc FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEFWBLOCKDATA Firmware block of data iax2 iax fwblockdata FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIEPROVVER Provisioning version iax2 iax provver FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGPRES Calling presentation iax2 iax callingpres FTUIN T8 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGTON Calling type of number iax2 iax callington FTUIN T8 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECALLINGTNS Calling transit network select iax2 iax callingtns FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIESAMPLINGRATE Supported sampling rates iax2 iax samplingrate FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIECAUSECODE Hangup cause iax2 iax causecode FTUIN T8 BASEHEXBASEEXTSTRING iax causecodes ext 0x0 NULLHFILL hf iax2 ies IAXIEENCRYPTION Encryption format iax2 iax encryption FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEENCKEY Encryption key iax2 iax enckey FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIECODECPREFS Codec negotiation iax2 iax codecprefs FTSTRINGBASENONENULL 0x0 NULLHFILL hf iax2 ies IAXIERRJITTER Received jitter as in RF C1889 iax2 iax rrjitter FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERRLOSS Received loss high byte loss pct low 24 bits loss count as in rfc1889 iax2 iax rrloss FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERRPKTS Total frames received iax2 iax rrpkts FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERRDELAY Max playout delay in ms for received frames iax2 iax rrdelay FTUIN T16 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERRDROPPED Dropped frames presumably by jitterbuffer iax2 iax rrdropped FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIERROOO Frame received out of order iax2 iax rrooo FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf iax2 ies IAXIEDATAFORMAT Data call format iax2 iax dataformat FTUIN T32 BASEHEXVALS iax dataformats 0x0 NULLHFILL hf IAXIEUNKNOWNBYTE Unknown iax2 iax unknownbyte FTUIN T8 BASEHEXNULL 0x0 Raw data for unknown I Es HFILL hf IAXIEUNKNOWN I16 Unknown iax2 iax unknownshort FTUIN T16 BASEHEXNULL 0x0 Raw data for unknown I Es HFILL hf IAXIEUNKNOWN I32 Unknown iax2 iax unknownlong FTUIN T32 BASEHEXNULL 0x0 Raw data for unknown I Es HFILL hf IAXIEUNKNOWNBYTES Unknown iax2 iax unknownstring FTSTRINGBASENONENULL 0x0 Raw data for unknown I Es HFILL hf iax2 ie id IE id iax2 ie id FTUIN T8 BASEDECBASEEXTSTRING iax ies type ext 0x0 NULLHFILL hf iax2 length Length iax2 length FTUIN T8 BASEDECNULL 0x0 NULLHFILL hf iax2 cap g723 1 G 723 1 compression iax2 cap g723 1 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT G723 1 NULLHFILL hf iax2 cap gsm GSM compression iax2 cap gsm FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATGSMNULLHFILL hf iax2 cap ulaw Raw mu law data G 711 iax2 cap ulaw FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATULAWNULLHFILL hf iax2 cap alaw Raw A law data G 711 iax2 cap alaw FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATALAWNULLHFILL hf iax2 cap g726 aal2 G 726 compression AA L2 packing iax2 cap g726 aal2 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT G726 AA L2 NULLHFILL hf iax2 cap adpcm ADPCM iax2 cap adpcm FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATADPCMNULLHFILL hf iax2 cap slinear Raw 16 bit Signed Linear 8000 Hz PCM iax2 cap slinear FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATSLINEARNULLHFILL hf iax2 cap lpc10 LP C10 180 samples frame iax2 cap lpc10 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATLP C10 NULLHFILL hf iax2 cap g729a G 729a Audio iax2 cap g729a FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT G729 ANULLHFILL hf iax2 cap speex SPEEX Audio iax2 cap speex FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATSPEEXNULLHFILL hf iax2 cap ilbc i LBC Free compressed Audio iax2 cap ilbc FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATILBCNULLHFILL hf iax2 cap g726 ADPCMG 726 32kbps RF C3551 codeword packing iax2 cap g726 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT G726 NULLHFILL hf iax2 cap g722 G 722 wideband audio iax2 cap g722 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT G722 NULLHFILL hf iax2 cap siren7 G 722 1 also known as Siren7 32kbps assumed iax2 cap siren7 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATSIRE N7 NULLHFILL hf iax2 cap siren14 G 722 1 Annex C also known as Siren14 48kbps assumed iax2 cap siren14 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATSIRE N14 NULLHFILL hf iax2 cap slinear16 Raw 16 bit Signed Linear 16000 Hz PCM iax2 cap slinear16 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATSLINEA R16 NULLHFILL hf iax2 cap jpeg JPEG images iax2 cap jpeg FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATJPEGNULLHFILL hf iax2 cap png PNG images iax2 cap png FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATPNGNULLHFILL hf iax2 cap h261 H 261 video iax2 cap h261 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT H261 NULLHFILL hf iax2 cap h263 H 263 video iax2 cap h263 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT H263 NULLHFILL hf iax2 cap h263 plus H 263 video iax2 cap h263 plus FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT H263 PLUSNULLHFILL hf iax2 cap h264 H 264 video iax2 cap h264 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMAT H264 NULLHFILL hf iax2 cap mpeg4 MPE G4 video iax2 cap mpeg4 FTBOOLEAN 32 TFS tfs supported not supported ASTFORMATM P4 VIDEONULLHFILL hf iax2 fragment unfinished IA X2 fragment unfinished iax2 fragment unfinished FTBYTESBASENONENULL 0x0 NULLHFILL hf iax2 payload data IA X2 payload iax2 payload data FTBYTESBASENONENULL 0x0 NULLHFILL hf iax2 fragments IA X2 Fragments iax2 fragments FTNONEBASENONENULL 0x0 NULLHFILL hf iax2 fragment IA X2 Fragment data iax2 fragment FTFRAMENUMBASENONENULL 0x0 NULLHFILL hf iax2 fragment overlap Fragment overlap iax2 fragment overlap FTBOOLEANBASENONENULL 0x0 Fragment overlaps with other fragments HFILL hf iax2 fragment overlap conflict Conflicting data in fragment overlap iax2 fragment overlap conflict FTBOOLEANBASENONENULL 0x0 Overlapping fragments contained conflicting data HFILL hf iax2 fragment multiple tails Multiple tail fragments found iax2 fragment multipletails FTBOOLEANBASENONENULL 0x0 Several tails were found when defragmenting the packet HFILL hf iax2 fragment too long fragment Fragment too long iax2 fragment toolongfragment FTBOOLEANBASENONENULL 0x0 Fragment contained data past end of packet HFILL hf iax2 fragment error Defragmentation error iax2 fragment error FTFRAMENUMBASENONENULL 0x0 Defragmentation error due to illegal fragments HFILL hf iax2 fragment count Fragment count iax2 fragment count FTUIN T32 BASEDECNULL 0x0 NULLHFILL hf iax2 reassembled in IA X2 fragment reassembled in frame iax2 reassembled in FTFRAMENUMBASENONENULL 0x0 This IA X2 packet is reassembled in this frame HFILL hf iax2 reassembled length Reassembled IA X2 length iax2 reassembled length FTUIN T32 BASEDECNULL 0x0 The total length of the reassembled payload HFILL static gint ett ett iax2 ett iax2 full mini subtree ett iax2 type ett iax2 ie ett iax2 codecs ett iax2 ies apparent addr ett iax2 fragment ett iax2 fragments ett iax2 trunk cmddata ett iax2 trunk call static ei register info ei ei iax too many transfers iax2 too many transfers PIPROTOCOLPIWARN Too many transfers for iax call EXPFILL ei iax circuit id conflict iax2 circuit id conflict PIPROTOCOLPIWARN Circuit ID conflict EXPFILL ei iax peer address unsupported iax2 peer address unsupported PIPROTOCOLPIWARN Peer address unsupported EXPFILL ei iax invalid len iax2 invalid len PIPROTOCOLPIWARN Invalid length EXPFILL ei iax invalid ts iax2 invalid ts PIPROTOCOLPIWARN Invalid timestamp EXPFILL expert module t expert iax memset hf iax2 ies 0xff sizeof hf iax2 ies proto iax2 proto register protocol Inter Asterisk e Xchange v2 IA X2 iax2 proto register field array proto iax2 hf array length hf proto register subtree array ett array length ett expert iax expert register protocol proto iax2 expert register field array expert iax ei array length ei register dissector iax2 dissect iax2 proto iax2 iax2 codec dissector table register dissector table iax2 codec IAX codec number FTUIN T32 BASEHEX iax2 dataformat dissector table register dissector table iax2 dataformat IAX dataformat number FTUIN T32 BASEHEX register init routine iax init protocol register cleanup routine iax cleanup protocol iax2 tap register tap IA X2 static void adjust arnr filter V P9 COMP cpi int distance int group boost int arnr frames int arnr strength const V P9 Encoder Config const oxcf cpi oxcf const int frames after arf vp9 lookahead depth cpi lookahead distance 1 int frames fwd cpi oxcf arnr max frames 1 1 int frames bwd int q frames strength if frames fwd frames after arf frames fwd frames after arf if frames fwd distance frames fwd distance frames bwd frames fwd if frames bwd distance frames bwd oxcf arnr max frames 1 0x1 frames frames bwd 1 frames fwd if cpi common current video frame 1 q int vp9 convert qindex to q cpi rc avg frame qindex INTERFRAME else q int vp9 convert qindex to q cpi rc avg frame qindex KEYFRAME if q 16 strength oxcf arnr strength else strength oxcf arnr strength 16 q 2 if strength 0 strength 0 if frames group boost 150 frames group boost 150 frames frames 1 if strength group boost 300 strength group boost 300 if cpi oxcf pass 2 cpi multi arf allowed const GFGROUP const gf group cpi twopass gf group if gf group rf level gf group index GFARFSTD strength 1 arnr frames frames arnr strength strength static int dtls1 retrieve buffered fragment SSL s int ok pitem item hm fragment frag int al ok 0 do item pqueue peek s d1 buffered messages if item NULL return 0 frag hm fragment item data if frag msg header seq s d1 handshake read seq pqueue pop s d1 buffered messages dtls1 hm fragment free frag pitem free item item NULL frag NULL while item NULL if frag reassembly NULL return 0 if s d1 handshake read seq frag msg header seq unsigned long frag len frag msg header frag len pqueue pop s d1 buffered messages al dtls1 preprocess fragment s frag msg header if al 0 unsigned char p unsigned char s init buf data DTL S1 HMHEADERLENGTH memcpy p frag msg header frag off frag fragment frag msg header frag len dtls1 hm fragment free frag pitem free item if al 0 ok 1 return frag len ssl3 send alert s SS L3 ALFATAL al s init num 0 ok 0 return 1 else return 0 static int amrwb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMRWB Context ctx avctx priv data AV Frame frame data AMRWB Frame cf ctx frame const uint8 t buf avpkt data int buf size avpkt size int expected fr size header size float buf out float spare vector AMRWBSFRSIZE float fixed gain factor float synth fixed vector float synth fixed gain float voice fac stab fac float synth exc AMRWBSFRSIZE float hb exc AMRWBSFRSIZE 16k float hb samples AMRWBSFRSIZE 16k float hb gain int sub i ret frame nb samples 4 AMRWBSFRSIZE 16k if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 header size decode mime header ctx buf if ctx fr cur mode MODESID av log avctx AVLOGERROR Invalid mode d n ctx fr cur mode return AVERRORINVALIDDATA expected fr size cf sizes wb ctx fr cur mode 7 3 1 if buf size expected fr size av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size got frame ptr 0 return AVERRORINVALIDDATA if ctx fr quality ctx fr cur mode MODESID av log avctx AVLOGERROR Encountered a bad or corrupted frame n if ctx fr cur mode MODESID av log missing feature avctx SID mode 1 return AVERRORPATCHWELCOME ff amr bit reorder uint16 t ctx frame sizeof AMRWB Frame buf header size amr bit orderings by mode ctx fr cur mode if ctx fr cur mode MODE 6k60 decode isf indices 36b cf isp id ctx isf cur else decode isf indices 46b cf isp id ctx isf cur isf add mean and past ctx isf cur ctx isf q past ff set min dist lsf ctx isf cur MINISFSPACINGLPORDER 1 stab fac stability factor ctx isf cur ctx isf past final ctx isf cur LPORDER 1 2 0 ff acelp lsf2lspd ctx isp 3 ctx isf cur LPORDER if ctx first frame ctx first frame 0 memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof double interpolate isp ctx isp ctx isp sub4 past for sub 0 sub 4 sub ff amrwb lsp2lpc ctx isp sub ctx lp coef sub LPORDER for sub 0 sub 4 sub const AMRWB Sub Frame cur subframe cf subframe sub float sub buf buf out sub AMRWBSFRSIZE 16k decode pitch vector ctx cur subframe sub decode fixed vector ctx fixed vector cur subframe pul ih cur subframe pul il ctx fr cur mode pitch sharpening ctx ctx fixed vector decode gains cur subframe vq gain ctx fr cur mode fixed gain factor ctx pitch gain 0 ctx fixed gain 0 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c ctx fixed vector ctx fixed vector AMRWBSFRSIZEAMRWBSFRSIZE ctx prediction error ENERGYMEAN energy pred fac voice fac voice factor ctx pitch vector ctx pitch gain 0 ctx fixed vector ctx fixed gain 0 ctx tilt coef voice fac 0 25 0 25 for i 0 i AMRWBSFRSIZE i ctx excitation i ctx pitch gain 0 ctx excitation i ctx fixed gain 0 ctx fixed vector i ctx excitation i truncf ctx excitation i synth fixed gain noise enhancer ctx fixed gain 0 ctx prev tr gain voice fac stab fac synth fixed vector anti sparseness ctx ctx fixed vector spare vector pitch enhancer synth fixed vector voice fac synthesis ctx ctx lp coef sub synth exc synth fixed gain synth fixed vector ctx samples az LPORDER de emphasis ctx samples up UPSMEMSIZE ctx samples az LPORDERPREEMPHFAC ctx demph mem ff acelp apply order 2 transfer function ctx samples up UPSMEMSIZE ctx samples up UPSMEMSIZE hpf zeros hpf 31 poles hpf 31 gain ctx hpf 31 mem AMRWBSFRSIZE upsample 5 4 sub buf ctx samples up UPSFIRSIZEAMRWBSFRSIZE 16k ff acelp apply order 2 transfer function hb samples ctx samples up UPSMEMSIZE hpf zeros hpf 400 poles hpf 400 gain ctx hpf 400 mem AMRWBSFRSIZE hb gain find hb gain ctx hb samples cur subframe hb gain cf vad scaled hb excitation ctx hb exc synth exc hb gain hb synthesis ctx sub ctx samples hb LPORDER 16k hb exc ctx isf cur ctx isf past final hb fir filter hb samples bpf 6 7 coef ctx bpf 6 7 mem ctx samples hb LPORDER 16k if ctx fr cur mode MODE 23k85 hb fir filter hb samples lpf 7 coef ctx lpf 7 mem hb samples for i 0 i AMRWBSFRSIZE 16k i sub buf i sub buf i hb samples i 1 0f 1 15 update sub state ctx memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof ctx isp 3 0 memcpy ctx isf past final ctx isf cur LPORDER sizeof float got frame ptr 1 return expected fr size static P Gconn connect DB Archive Handle AH const char reqdb const char requser PQ Exp Buffer Data connstr P Gconn new Conn const char newdb const char newuser char password bool new pass if reqdb newdb P Qdb AH connection else newdb reqdb if requser strlen requser 0 newuser P Quser AH connection else newuser requser ahlog AH 1 connecting to database s as user s n newdb newuser password AH saved Password pg strdup AH saved Password NULL if AH prompt Password TRIYES password NULL password simple prompt Password 100 false if password NULL exit horribly modulename out of memory n init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr newdb do const char keywords 7 const char values 7 keywords 0 host values 0 P Qhost AH connection keywords 1 port values 1 P Qport AH connection keywords 2 user values 2 newuser keywords 3 password values 3 password keywords 4 dbname values 4 connstr data keywords 5 fallback application name values 5 progname keywords 6 NULL values 6 NULL new pass false new Conn P Qconnectdb Params keywords values true if new Conn exit horribly modulename failed to reconnect to database n if P Qstatus new Conn CONNECTIONBAD if P Qconnection Needs Password new Conn exit horribly modulename could not reconnect to database s P Qerror Message new Conn P Qfinish new Conn if password fprintf stderr Password incorrect n fprintf stderr Connecting to s as s n newdb newuser if password free password if AH prompt Password TRINO password simple prompt Password 100 false else exit horribly modulename connection needs password n if password NULL exit horribly modulename out of memory n new pass true while new pass if P Qconnection Used Password new Conn if AH saved Password free AH saved Password AH saved Password pg strdup P Qpass new Conn if password free password term PQ Exp Buffer connstr check database version AHP Qset Notice Processor new Conn notice processor NULL return new Conn void vp8 mbpost proc across ip c unsigned char src int pitch int rows int cols int flimit int r c i unsigned char s src unsigned char d 16 for r 0 r rows r int sumsq 0 int sum 0 for i 8 i 0 i s i s 0 for i cols i cols 17 i s i s cols 1 for i 8 i 6 i sumsq s i s i sum s i d i 8 0 for c 0 c cols 8 c int x s c 7 s c 8 int y s c 7 s c 8 sum x sumsq x y d c 15 s c if sumsq 15 sum sum flimit d c 15 8 sum s c 4 s c 8 d c 8 15 s pitch void kadmin getprinc int argc char argv kadm5 principal ent rec dprinc krb5 principal princ NULL krb5 error code retval const char polname noexist char canon NULL princstr NULL modprincstr NULL int i size t j if argc 2 argc 3 strcmp terse argv 1 fprintf stderr usage get principal terse principal n return memset dprinc 0 sizeof dprinc retval kadmin parse name argv argc 1 princ if retval com err get principal retval while parsing principal return retval krb5 unparse name context princ canon if retval com err get principal retval while canonicalizing principal goto cleanup retval kadm5 get principal handle princ dprinc KAD M5 PRINCIPALNORMALMASKKAD M5 KEYDATA if retval com err get principal retval while retrieving s canon goto cleanup retval krb5 unparse name context dprinc principal princstr if retval com err get principal retval while unparsing principal goto cleanup retval krb5 unparse name context dprinc mod name modprincstr if retval com err get principal retval while unparsing principal goto cleanup if argc 2 printf Principal s n princstr printf Expiration date s n dprinc princ expire time strdate dprinc princ expire time never printf Last password change s n dprinc last pwd change strdate dprinc last pwd change never printf Password expiration date s n dprinc pw expiration strdate dprinc pw expiration none printf Maximum ticket life s n strdur dprinc max life printf Maximum renewable life s n strdur dprinc max renewable life printf Last modified s s n strdate dprinc mod date modprincstr printf Last successful authentication s n dprinc last success strdate dprinc last success never printf Last failed authentication s n dprinc last failed strdate dprinc last failed never printf Failed password attempts d n dprinc fail auth count printf Number of keys d n dprinc n key data for i 0 i dprinc n key data i krb5 key data key data dprinc key data i char enctype BUFSIZ salttype BUFSIZ if krb5 enctype to name key data key data type 0 FALSE enctype sizeof enctype snprintf enctype sizeof enctype Encryption type 0x x key data key data type 0 printf Key vno d s key data key data kvno enctype if key data key data ver 1 if krb5 salttype to string key data key data type 1 salttype sizeof salttype snprintf salttype sizeof salttype Salt type 0x x key data key data type 1 printf s n salttype else printf no salt n printf M Key vno d n dprinc mkvno printf Attributes for j 0 j sizeof prflags sizeof char j if dprinc attributes krb5 flags 1 j printf s prflags j printf n polname dprinc policy NULL dprinc policy none noexist dprinc policy NULL policy exists dprinc policy does not exist printf Policy s s n polname noexist else printf s t d t d t d t d t s t d t d t d t d t s t d t d t d t d t d princstr dprinc princ expire time dprinc last pwd change dprinc pw expiration dprinc max life modprincstr dprinc mod date dprinc attributes dprinc kvno dprinc mkvno dprinc policy dprinc policy none dprinc max renewable life dprinc last success dprinc last failed dprinc fail auth count dprinc n key data for i 0 i dprinc n key data i printf t d t d t d t d dprinc key data i key data ver dprinc key data i key data kvno dprinc key data i key data type 0 dprinc key data i key data type 1 printf n cleanup krb5 free principal context princ kadm5 free principal ent handle dprinc free canon free princstr free modprincstr static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int field ret AV Frame pic avctx coded frame const uint8 t buf avpkt data const uint8 t buf end buf avpkt size if pic data 0 avctx release buffer avctx pic if avpkt size avctx width 2 avctx height 4 2 8 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if bytestream get le32 buf MKTAGFRW 1 av log avctx AVLOGERROR incorrect marker n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret pic pict type AVPICTURETYPEI pic key frame 1 pic interlaced frame 1 pic top field first 1 for field 0 field 2 field int i int field h avctx height field 1 int field size min field size avctx width 2 field h uint8 t dst pic data 0 if buf end buf 8 return AVERRORINVALIDDATA buf 4 field size bytestream get le32 buf if field size min field size av log avctx AVLOGERROR Field size i is too small required i n field size min field size return AVERRORINVALIDDATA if buf end buf field size av log avctx AVLOGERROR Packet is too small need i have i n field size int buf end buf return AVERRORINVALIDDATA if field dst pic linesize 0 for i 0 i field h i memcpy dst buf avctx width 2 buf avctx width 2 dst pic linesize 0 1 buf field size min field size got frame 1 AV Frame data pic return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VB Dec Context const c avctx priv data AV Frame frame data uint8 t outptr srcptr int i j ret int flags uint32 t size int offset 0 bytestream2 init c stream avpkt data avpkt size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret flags bytestream2 get le16 c stream if flags VBHASGMC i int16 t bytestream2 get le16 c stream j int16 t bytestream2 get le16 c stream offset i j avctx width if flags VBHASVIDEO size bytestream2 get le32 c stream vb decode framedata c offset bytestream2 skip c stream size 4 if flags VBHASPALETTE size bytestream2 get le32 c stream vb decode palette c size memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed flags VBHASPALETTE outptr frame data 0 srcptr c frame for i 0 i avctx height i memcpy outptr srcptr avctx width srcptr avctx width outptr frame linesize 0 FFSWAP uint8 t c frame c prev frame got frame 1 return avpkt size static int rc pick q and bounds two pass const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc const V P9 Encoder Config const oxcf cpi oxcf const int cq level get active cq level rc oxcf int active best quality int active worst quality cpi twopass active worst quality int q if frame is intra only cm vp9 is upper layer key frame cpi if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 active best quality MAX qindex delta qindex rc best quality else double q adj factor 1 0 double q val active best quality get kf active quality rc active worst quality if cm width cm height 352 288 q adj factor 0 25 q adj factor 0 05 0 001 double cpi twopass kf zeromotion pct q val vp9 convert qindex to q active best quality active best quality vp9 compute qdelta rc q val q val q adj factor else if rc is src frame alt ref cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality if oxcf rc mode VPXCQ if q cq level q cq level active best quality get gf active quality rc q active best quality active best quality 15 16 else if oxcf rc mode VPXQ if cpi refresh alt ref frame active best quality cq level else active best quality get gf active quality rc q else active best quality get gf active quality rc q else if oxcf rc mode VPXQ active best quality cq level else active best quality inter minq active worst quality if oxcf rc mode VPXCQ active best quality cq level active best quality cq level active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality const GFGROUP const gf group cpi twopass gf group const double rate factor deltas RATEFACTORLEVELS 1 00 1 00 1 50 1 75 2 00 const double rate factor rate factor deltas gf group rf level gf group index int qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality rate factor top index active worst quality qdelta top index top index bottom index top index bottom index q active best quality static Image Read GIF Image const Image Info image info Exception Info exception int number extensionss 0 Magick Boolean Type status Rectangle Info page register ssize t i register unsigned char p size t delay dispose duration global colors image count iterations one ssize t count opacity unsigned char background c flag global colormap header Max Text Extent magick 12 assert image info const Image Info NULL assert image info signature Magick Signature if image info debug Magick False void Log Magick Event Trace Event Get Magick Module s image info filename assert exception Exception Info NULL assert exception signature Magick Signature image Acquire Image image info status Open Blob image info image Read Binary Blob Mode exception if status Magick False image Destroy Image List image return Image NULL count Read Blob image 6 magick if count 6 Locale N Compare char magick GI F87 5 0 Locale N Compare char magick GI F89 5 0 Throw Reader Exception Corrupt Image Error Improper Image Header page width Read Blob LSB Short image page height Read Blob LSB Short image flag unsigned char Read Blob Byte image background unsigned char Read Blob Byte image c unsigned char Read Blob Byte image one 1 global colors one size t flag 0x07 1 global colormap unsigned char Acquire Quantum Memory size t Magick Max global colors 256 3 UL sizeof global colormap if global colormap unsigned char NULL Throw Reader Exception Resource Limit Error Memory Allocation Failed void Reset Magick Memory global colormap 0 3 Magick Max global colors 256 sizeof global colormap if Bit Set int flag 0x80 0 count Read Blob image size t 3 global colors global colormap if count ssize t 3 global colors global colormap unsigned char Relinquish Magick Memory global colormap Throw Reader Exception Corrupt Image Error Insufficient Image Data In File delay 0 dispose 0 duration 0 iterations 1 opacity 1 image count 0 meta image Acquire Image image info for count Read Blob image 1 c if count 1 break if c unsigned char break if c unsigned char count Read Blob image 1 c if count 1 global colormap unsigned char Relinquish Magick Memory global colormap meta image Destroy Image meta image Throw Reader Exception Corrupt Image Error Unable To Read Extension Block switch c case 0xf9 while Read Blob Block image header 0 dispose size t header 0 2 delay size t header 2 8 header 1 if ssize t header 0 0x01 0x01 opacity ssize t header 3 break case 0xfe char comments size t length comments Acquire String char NULL for length 0 length count count Read Blob Block image header if count 0 break header count 0 void Concatenate String comments const char header void Set Image Property meta image comment comments comments Destroy String comments break case 0xff Magick Boolean Type loop loop Magick False if Read Blob Block image header 0 loop Locale N Compare char header NETSCAP E2 0 11 0 Magick True Magick False if loop Magick False while Read Blob Block image header 0 iterations size t header 2 8 header 1 break else char name Max Text Extent int block length info length reserved length Magick Boolean Type i8bim icc iptc magick String Info profile unsigned char info icc Locale N Compare char header ICCRGB G1012 11 0 Magick True Magick False magick Locale N Compare char header Image Magick 11 0 Magick True Magick False i8bim Locale N Compare char header MG K8 BI M0000 11 0 Magick True Magick False iptc Locale N Compare char header MGKIPT C0000 11 0 Magick True Magick False number extensionss void Log Magick Event Coder Event Get Magick Module Reading GIF application extension info unsigned char Acquire Quantum Memory 255 UL sizeof info if info unsigned char NULL meta image Destroy Image meta image Throw Reader Exception Resource Limit Error Memory Allocation Failed reserved length 255 for info length 0 block length int Read Blob Block image info info length if block length 0 break info length block length if info length reserved length 255 reserved length 4096 info unsigned char Resize Quantum Memory info size t reserved length sizeof info if info unsigned char NULL meta image Destroy Image meta image Throw Reader Exception Resource Limit Error Memory Allocation Failed profile Blob To String Info info size t info length if profile String Info NULL meta image Destroy Image meta image Throw Reader Exception Resource Limit Error Memory Allocation Failed if i8bim Magick False void Copy Magick String name 8bim sizeof name else if icc Magick False void Copy Magick String name icc sizeof name else if iptc Magick False void Copy Magick String name iptc sizeof name else if magick Magick False void Copy Magick String name magick sizeof name meta image gamma String To Double char info 6 char NULL else void Format Locale String name sizeof name gif 11s header info unsigned char Relinquish Magick Memory info if magick Magick False void Set Image Profile meta image name profile profile Destroy String Info profile void Log Magick Event Coder Event Get Magick Module profile name s name break default while Read Blob Block image header 0 break if c unsigned char continue if image count 0 Acquire Next Image image info image if Get Next Image In List image Image NULL image Destroy Image List image global colormap unsigned char Relinquish Magick Memory global colormap return Image NULL image Sync Next Image In List image image count meta image scene image scene void Clone Image Properties image meta image Destroy Image Properties meta image void Clone Image Profiles image meta image Destroy Image Profiles meta image image storage class Pseudo Class image compression LZW Compression page x ssize t Read Blob LSB Short image page y ssize t Read Blob LSB Short image image columns Read Blob LSB Short image image rows Read Blob LSB Short image image depth 8 flag unsigned char Read Blob Byte image image interlace Bit Set int flag 0x40 0 GIF Interlace No Interlace image colors Bit Set int flag 0x80 0 global colors one size t flag 0x07 1 if opacity ssize t image colors opacity 1 image page width page width image page height page height image page y page y image page x page x image delay delay image iterations iterations image ticks per second 100 image dispose Dispose Type dispose image matte opacity 0 Magick True Magick False delay 0 dispose 0 if image columns 0 image rows 0 global colormap unsigned char Relinquish Magick Memory global colormap meta image Destroy Image meta image Throw Reader Exception Corrupt Image Error Negative Or Zero Image Size if Acquire Image Colormap image image colors Magick False global colormap unsigned char Relinquish Magick Memory global colormap meta image Destroy Image meta image Throw Reader Exception Resource Limit Error Memory Allocation Failed if Bit Set int flag 0x80 0 p global colormap for i 0 i ssize t image colors i image colormap i red Scale Char To Quantum p image colormap i green Scale Char To Quantum p image colormap i blue Scale Char To Quantum p if i opacity image colormap i opacity Quantum Transparent Opacity image transparent color image colormap opacity image background color image colormap Magick Min ssize t background ssize t image colors 1 else unsigned char colormap colormap unsigned char Acquire Quantum Memory image colors 3 sizeof colormap if colormap unsigned char NULL global colormap unsigned char Relinquish Magick Memory global colormap meta image Destroy Image meta image Throw Reader Exception Resource Limit Error Memory Allocation Failed count Read Blob image 3 image colors sizeof colormap colormap if count ssize t 3 image colors global colormap unsigned char Relinquish Magick Memory global colormap colormap unsigned char Relinquish Magick Memory colormap meta image Destroy Image meta image Throw Reader Exception Corrupt Image Error Insufficient Image Data In File p colormap for i 0 i ssize t image colors i image colormap i red Scale Char To Quantum p image colormap i green Scale Char To Quantum p image colormap i blue Scale Char To Quantum p if i opacity image colormap i opacity Quantum Transparent Opacity colormap unsigned char Relinquish Magick Memory colormap if image gamma 1 0 for i 0 i ssize t image colors i if Is Gray Pixel image colormap i Magick False break void Set Image Colorspace image i ssize t image colors GRAY Colorspace RGB Colorspace if image info ping Magick False image info number scenes 0 if image scene image info scene image info number scenes 1 break status Set Image Extent image image columns image rows if status Magick False Inherit Exception exception image exception return Destroy Image List image if image info ping Magick False status Ping GIF Image image else status Decode Image image opacity if image info ping Magick False status Magick False global colormap unsigned char Relinquish Magick Memory global colormap meta image Destroy Image meta image Throw Reader Exception Corrupt Image Error Corrupt Image duration image delay image iterations if image info number scenes 0 if image scene image info scene image info number scenes 1 break opacity 1 status Set Image Progress image Load Image Tag Magick Offset Type image scene 1 image scene if status Magick False break image duration duration meta image Destroy Image meta image global colormap unsigned char Relinquish Magick Memory global colormap if image columns 0 image rows 0 Throw Reader Exception Corrupt Image Error Negative Or Zero Image Size void Close Blob image return Get First Image In List image static void generate psnr packet V P9 COMP cpi struct vpx codec cx pkt pkt int i PSNRSTATS psnr calc psnr cpi Source cpi common frame to show psnr for i 0 i 4 i pkt data psnr samples i psnr samples i pkt data psnr sse i psnr sse i pkt data psnr psnr i psnr psnr i pkt kind VPXCODECPSNRPKT vpx codec pkt list add cpi output pkt list pkt static guint32 dissect minipacket tvbuff t tvb guint32 offset guint16 scallno packet info pinfo proto tree iax2 tree proto tree main tree guint32 ts iax packet data iax packet proto item item ts tvb get ntohs tvb offset iax packet iax2 get packet data for minipacket pinfo scallno FALSE if iax2 tree if iax packet call data item proto tree add uint iax2 tree hf iax2 callno tvb 0 4 iax packet call data forward circuit ids 0 PROTOITEMSETGENERATED item proto tree add uint iax2 tree hf iax2 minits tvb offset 2 ts iax2 add ts fields pinfo iax2 tree iax packet guint16 ts else iax2 add ts fields pinfo iax2 tree iax packet guint16 ts offset 2 col add fstr pinfo cinfo COLINFO Mini packet source call d timestamp ums scallno ts dissect payload tvb offset pinfo iax2 tree main tree ts FALSE iax packet iax packet first time FALSE return offset void proto register mswsp void expert module t expert mswsp NULL static hf register info hf hf mswsp hdr Header mswsp hdr FTNONEBASENONENULL 0 Message header HFILL hf mswsp hdr msg Msg id mswsp hdr id FTUIN T32 BASEHEXVALS msg ids 0 Message id HFILL hf mswsp hdr status Status mswsp hdr status FTUIN T32 BASEHEXVALS dcom hresult vals 0 Message Status HFILL hf mswsp hdr checksum checksum mswsp hdr checksum FTUIN T32 BASEHEXNULL 0 Message Checksum HFILL hf mswsp hdr reserved Reserved mswsp hdr reserved FTUIN T32 BASEHEXNULL 0 Reserved bytes HFILL hf mswsp msg msg mswsp msg FTNONEBASENONENULL 0 Message HFILL hf mswsp msg Connect Version Version mswsp Connect version FTUIN T32 BASEHEXVALS version vals 0 OS Version HFILL hf mswsp msg Connect In Client Is Remote Remote mswsp Connect In is Remote FTBOOLEANBASEHEXNULL 0 Client is remote HFILL hf mswsp msg Connect In Blob1 Size mswsp Connect In propset size FTUIN T32 BASEDECNULL 0 Size of Prop Set fields HFILL hf mswsp msg Connect In Machine Name Remote machine mswsp Connect In machine FTSTRINGZBASENONENULL 0 Name of remote machine HFILL hf mswsp msg Connect In User Name User mswsp Connect In user FTSTRINGZBASENONENULL 0 Name of remote user HFILL hf mswsp msg Connect In Prop Sets num Num mswsp Connect In propset num FTUIN T32 BASEDECNULL 0 Number of Property Sets HFILL hf mswsp bool options u Boolean Options mswsp CPM Create Query Row Set Properties u Boolean Options FTUIN T32 BASEHEXNULL 0 Boolean options HFILL hf mswsp bool options cursor Cursor mswsp CPM Create Query Row Set Properties u Boolean Options FTUIN T32 BASEHEXVALS cursor vals 0x0000000007 Cursor Type HFILL hf mswsp bool options async e Asynchronous mswsp CPM Create Query Row Set Properties u Boolean Options e Asyncronous FTBOOLEAN 32 NULL e Asynchronous The client will not wait for execution completion HFILL hf mswsp bool options firstrows e First Rows mswsp CPM Create Query Row Set Properties u Boolean Options e First Rows FTBOOLEAN 32 NULL e First Rows Return the first rows encountered not the best matches HFILL hf mswsp bool options holdrows e Hold Rows mswsp CPM Create Query Row Set Properties u Boolean Options e Hold Rows FTBOOLEAN 32 NULL e Hold Rows The server MUSTNOT discard rows until the client is done with a query HFILL hf mswsp bool options chaptered e Chaptered mswsp CPM Create Query Row Set Properties u Boolean Options e Chaptered FTBOOLEAN 32 NULL e Chaptered The rowset supports chapters HFILL hf mswsp bool options useci e Use CI mswsp CPM Create Query Row Set Properties u Boolean Options e Use CIFTBOOLEAN 32 NULL e Use CI Use the inverted index to evaluate content restrictions even if it is out of date HFILL hf mswsp bool options defertrim e Defer Trimming mswsp CPM Create Query Row Set Properties u Boolean Options e Defer Trimming FTBOOLEAN 32 NULL e Defer Trimming Defer Non indexed trimming operations like scoping or security checking which can be expensive HFILL hf mswsp bool options rowsetevents e Enable Rowset Events mswsp Row Set Properties CPM Create Query u Boolean Options e Enable Rowset Events FTBOOLEAN 32 NULL e Enable Rowset Events Enables storage of rowset events on the server side HFILL hf mswsp bool options dontcomputeexpensive e Do Not Compute Expensive Props mswsp CPM Create Query Row Set Properties u Boolean Options e Do Not Compute Expensive Props FTBOOLEAN 32 NULL e Do Not Compute Expensive Props Prevents computation of expensive properties HFILL hf mswsp guid time low time low mswsp guid time low FTUIN T32 BASEHEXNULL 0 time low value HFILL hf mswsp guid time mid time mid mswsp guid time mid FTUIN T16 BASEHEXNULL 0 time mid value HFILL hf mswsp guid time high time high mswsp guid time high FTUIN T16 BASEHEXNULL 0 time high value HFILL hf mswsp guid time clock hi clock seq hi and reserved mswsp guid time clock high FTUIN T8 BASEHEXNULL 0 time clock high value HFILL hf mswsp guid time clock low clock seq low mswsp guid time clock low FTUIN T8 BASEHEXNULL 0 time clock high low HFILL hf mswsp guid node node mswsp guid node FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp lcid lcid mswsp lcid FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp lcid sortid Sort ID mswsp lcid sortid FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp lcid langid Language ID mswsp lcid langid FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp cscort column column mswsp csort column FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cscort order order mswsp csort order FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cscort individual inidvidual mswsp csort individual FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cscortset count count mswsp csortset count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ctablecolumn vtype v Type mswsp ctablecolumn vtype FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp ctablecolumn aggused Aggreagate Used mswsp ctablecolumn aggused FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn aggtype Aggreagate Type mswsp ctablecolumn aggtype FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp ctablecolumn valused Value Used mswsp ctablecolumn valused FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn valoffset Value Offset mswsp ctablecolumn valused FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn valsize Value Size mswsp ctablecolumn valsize FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn statused Status Used mswsp ctablecolumn statused FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn statoffset Status Offset mswsp ctablecolumn statoffset FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn lenused Length Used mswsp ctablecolumn lenused FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn lenoffset Length Offset mswsp ctablecolumn lenoffset FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp cfullpropspec kind ul Kind mswsp cfullpropspec kind FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cfullpropspec propid propid mswsp cfullpropspec propid FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp cfullpropspec propname propname mswsp cfullpropspec propname FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cproprestrict relop relop mswsp cproprestrict relop FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp ccoercerestrict value value mswsp ccoercerestrict value FTFLOATBASENONENULL 0 NULLHFILL hf mswsp ccontentrestrict cc cc mswsp ccontentrestrict cc FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ccontentrestrict phrase phrase mswsp ccontentrestrict phrase FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp ccontentrestrict method method mswsp ccontentrestrict method FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp natlangrestrict cc cc mswsp ccontentrestrict cc FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp natlangrestrict phrase phrase mswsp ccontentrestrict phrase FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp crestrict ultype ul Type mswsp crestrict ultype FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp crestrict weight Weight mswsp crestrict weight FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crestrictarray count count mswsp crestrictarray count FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp crestrictarray present present mswsp crestrictarray present FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp cnoderestrict cnode Weight mswsp cnoderestrict cnode FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant vtype v Type mswsp cbasestorvariant vtype FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cbasestorvariant vvalue v Value mswsp cbasestorvariant vvalue FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cbasestorvariant vdata1 v Data1 mswsp cbasestorvariant vdata1 FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant vdata2 v Data2 mswsp cbasestorvariant vdata2 FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant num num mswsp cbasestorvariant num FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant cdims c Dims mswsp cbasestorvariant cdims FTUIN T16 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant ffeatures f Features mswsp cbasestorvariant ffeatures FTUIN T16 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant cbelements cb Elements mswsp cbasestorvariant cbelements FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cbasestorvariant rgsabound Rgsabound mswsp cbasestorvariant rgsabound FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cdbcolid ekind e Kind mswsp cdbcolid ekind FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cdbcolid ulid ul Id mswsp cdbcolid ulid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cdbcolid vstring v String mswsp cdbcolid vstring FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cdbprop id Id mswsp cdbprop id FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp cdbprop options Options mswsp cdbprop options FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp cdbprop status Status mswsp cdbprop status FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp cdbpropset cprops c Properties mswsp cdbpropset cprops FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp rangeboundry ultype ul Type mswsp rangeboundry ultype FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp rangeboundry labelpresent label Present mswsp rangeboundry labelpresent FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp rangeboundry cclabel cc Label mswsp rangeboundry cclabel FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp rangeboundry label Label mswsp rangeboundry label FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp crangecategspec crange c Range mswsp crangecategspec crange FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp ccategspec type type mswsp ccategspec type FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp caggregspec type type mswsp caggregspec type FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp caggregspec ccalias cc Alias mswsp caggregspec ccalias FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp caggregspec alias Alias mswsp caggregspec alias FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp caggregspec idcolumn id Column mswsp caggregspec idcolumn FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp caggregset count count mswsp caggregset count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp caggregsortkey order order mswsp caggregsortkey order FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp csortaggregset count count mswsp csortaggregset count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cingroupsortaggregset type Type mswsp cingroupsortaggregset type FTUIN T8 BASEHEXNULL 0 NULLHFILL hf mswsp cingroupsortaggregsets count count mswsp cingroupsortaggregsets count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp categorizationspec cmaxres c Max Results mswsp categorizationspec cmaxres FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowsetprops ulmaxopenrows ul Max Open Rows ignored mswsp crowsetprops ulmaxopenrows FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowsetprops ulmemusage ul Mem Usage ignored mswsp crowsetprops ulmemusage FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowsetprops cmaxresults c Max Results mswsp crowsetprops cmaxresults FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowsetprops ccmdtimeout c Cmd Timeout mswsp crowsetprops ccmdtimeout FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp cpidmapper count count mswsp cpidmapper count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ccolumngroup count count mswsp ccolumngroup count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ccolumngroup grouppid group Pid mswsp ccolumngroup grouppid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ccolumngroup pid pid mswsp ccolumngroup pid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp ccolumngrouparray count count mswsp ccolumngrouparray count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp int32array value value mswsp int32array value FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseeknext cskip cskip mswsp crowseeknext cskip FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekat bmkoffset bmkoffset mswsp crowseekat bmkoffset FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekat skip skip mswsp crowseekat skip FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekat hregion hregion mswsp crowseekat hregion FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekatratio ulnumerator ulnumerator mswsp crowseekatratio ulnumerator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekatratio uldenominator uldenominator mswsp crowseekatratio uldenominator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekatratio hregion hregion mswsp crowseekatratio hregion FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekbybookmark cbookmarks cbookmarks mswsp crowseekbybookmark cbookmarks FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowseekbybookmark maxret maxret mswsp crowseekbybookmark maxret FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp crowvariantinfo count64 count mswsp crowvariantinfo count64 FTUIN T64 BASEDECNULL 0 NULLHFILL hf mswsp arrayvector address64 address of array mswsp arrayvector address64 FTUIN T64 BASEHEXNULL 0 NULLHFILL hf mswsp crowvariantinfo count32 count mswsp crowvariantinfo count32 FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp arrayvector address32 address of array mswsp arrayvector address FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp rowvariant item address64 address mswsp rowvariant item address64 FTUIN T64 BASEHEXNULL 0 NULLHFILL hf mswsp rowvariant item address32 address mswsp rowvariant item address32 FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp rowvariant item value value mswsp rowvariant item value FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp rowvariant vtype vtype mswsp rowvariant vtype FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp rowvariant reserved1 reserved1 mswsp rowvariant reserved1 FTUIN T16 BASEHEXNULL 0 NULLHFILL hf mswsp rowvariant reserved2 reserved2 mswsp rowvariant reserved2 FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp ctablecolumn status status mswsp ctablecolumn name FTSTRINGBASENONENULL 0 NULLHFILL hf mswsp ctablecolumn length length mswsp ctablecolumn length FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcreatequery size size mswsp cpmcreatequery size FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcreatequery ccolumnsetpresent C Column Set Present mswsp cpmcreatequery ccolumnsetpresent FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp msg cpmcreatequery crestrictionpresent C Restriction Present mswsp cpmcreatequery crestrictionpresent FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp msg cpmcreatequery csortpresent C Sort Present mswsp cpmcreatequery csortpresent FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp msg cpmcreatequery ccategpresent C Categorization Set Present mswsp cpmcreatequery ccategpresent FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp msg cpmcreatequery ccateg count count mswsp cpmcreatequery ccateg count FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcreatequery trueseq True Sequential mswsp cpmcreatequery trueseq FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcreatequery workid Work Id mswsp cpmcreatequery trueseq FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcreatequery cursors Cursors mswsp cpmcreatequery cursors FTBYTESSEPSPACENULL 0 NULLHFILL hf mswsp msg cpmgetrows hcursor h Cursor mswsp msg cpmgetrows hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows rowstotransfer c Rows To Transfer mswsp msg cpmgetrows rowstotransfer FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows rowwidth cb Row Width mswsp msg cpmgetrows rowswidth FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows cbseek cb Seek mswsp msg cpmgetrows cbseek FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows cbreserved cb Reserved mswsp msg cpmgetrows cbreserved FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows cbreadbuffer cb Read Buffer mswsp msg cpmgetrows cbreadbuffer FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows ulclientbase ul Client Base mswsp msg cpmgetrows ulclientbase FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp msg cpmgetrows fbwdfetch f Bwd Fetch mswsp msg cpmgetrows fbwdfetch FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows etype e Type mswsp msg cpmgetrows etype FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows chapt chapt mswsp msg cpmgetrows chapt FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrows crowsreturned c Rows Returned mswsp msg cpmgetrows crowsreturned FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished hcursor h Cursor mswsp msg cpmratiofinished hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished fquick f Quick mswsp msg cpmratiofinished fquick FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished ulnumerator ul Numerator mswsp msg cpmratiofinished ulnumerator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished uldenominator ul Denominator mswsp msg cpmratiofinished uldenominator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished crows c Rows mswsp msg cpmratiofinished crows FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmratiofinished fnewrows f New Rows mswsp msg cpmratiofinished fnewrows FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcomparebmk hcursor h Cursor mswsp msg cpmcomparebmk hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcomparebmk chapt chapt mswsp msg cpmcomparebmk chapt FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcomparebmk bmkfirst bmk First mswsp msg cpmcomparebmk bmkfirst FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcomparebmk bmksecond bmk Second mswsp msg cpmcomparebmk bmksecond FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcomparebmk dwcomparison dw Comparison mswsp msg cpmcomparebmk dwcomparison FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetapproxpos hcursor h Cursor mswsp msg cpmgetapproxpos hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetapproxpos chapt chapt mswsp msg cpmgetapproxpos chapt FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetapproxpos bmk bmk mswsp msg cpmgetapproxpos bmk FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetapproxpos numerator numerator mswsp msg cpmgetapproxpos numerator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetapproxpos denominator denominator mswsp msg cpmgetapproxpos denominator FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetbinding hcursor h Cursor mswsp msg cpmsetbinding hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetbinding cbrow c Brow mswsp msg cpmsetbinding cbrow FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetbinding desc cb Binding Desc mswsp msg cpmsetbinding desc FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetbinding dummy dummy mswsp msg cpmsetbinding dummy FTUIN T32 BASEHEXNULL 0 NULLHFILL hf mswsp msg cpmsetbinding ccolumns c Columns mswsp msg cpmsetbinding ccolumns FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetbinding acolumns a Columns mswsp msg cpmsetbinding acolumns FTBYTESSEPDOTNULL 0 NULLHFILL hf mswsp msg cpmsendnotify watchnotify watch Notify mswsp msg cpmsendnotify watchnotify FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetquerystatus hcursor h Cursor mswsp msg cpmquerystatus hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetquerystatus qstatus Q Status mswsp msg cpmquerystatus qstatus FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cbstruct cb Struct mswsp msg cpmcistate cbstruct FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cwordlist cb Word List mswsp msg cpmcistate cbwordlist FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cpersistindex cb Persistent Index mswsp msg cpmcistate cbpersistindex FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cqueries c Queries mswsp msg cpmcistate cqueries FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cfreshtest c Fresh Test mswsp msg cpmcistate cfreshtest FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate dwmergeprogress dw Merge Progress mswsp msg cpmcistate dwmergeprogress FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate estate e State mswsp msg cpmcistate estate FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cfiltereddocs c Filtered Documents mswsp msg cpmcistate cfiltereddocs FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate ctotaldocs c Total Documents mswsp msg cpmcistate ctotaldocs FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cpendingscans c Pending Scans mswsp msg cpmcistate cpendingscans FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate dwindexsize dw Index Size mswsp msg cpmcistate dwindexsize FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate cuniquekeys c Unique Keys mswsp msg cpmcistate cuniquekeys FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate csecqdocuments c Sec Q Documents mswsp msg cpmcistate csecqdocuments FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmcistate dwpropcachesize dw Prop Cache Size mswsp msg cpmcistate dwpropcachesize FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue wid wid mswsp msg cpmfetchvalue wid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue cbsofar cb So Far mswsp msg cpmfetchvalue cbsofar FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue cbpropspec cb Prop Spec mswsp msg cpmfetchvalue cbpropspec FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue cbchunk cb Chunk mswsp msg cpmfetchvalue chunk FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue cbvalue cb Value mswsp msg cpmfetchvalue cbvalue FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue fmoreexists f More Exists mswsp msg cpmfetchvalue fmoreexists FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue fvalueexists f Value Exists mswsp msg cpmfetchvalue fvalueexists FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfetchvalue vvalue vvalue mswsp msg cpmfetchvalue vvalue FTBYTESSEPSPACENULL 0 NULLHFILL hf mswsp msg cpmquerystatusex qstatus q Status mswsp msg cpmquerystatusex qstatus FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex hcursor h Cursor mswsp msg cpmquerystatusex hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex bmk bmk mswsp msg cpmquerystatusex bmk FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex cfiltereddocs c Filtered Documents mswsp msg cpmquerystatusex cfiltereddocs FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex cdocstofilter c Documents To Filter mswsp msg cpmquerystatusex cdocstofilter FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex dwratiodenom dw Ratio Finished Denomenator mswsp msg cpmquerystatusex dwratiodenom FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex dwrationumer dw Ratio Finished Numerator mswsp msg cpmquerystatusex dwrationumer FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex irowbmk i Row Bmk mswsp msg cpmquerystatusex irowbmk FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex crowstotal c Rows Total mswsp msg cpmquerystatusex crowstotal FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex maxrank max Rank mswsp msg cpmquerystatusex maxrank FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex cresultsfound c Results Found mswsp msg cpmquerystatusex cresultsfound FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmquerystatusex whereid where Id mswsp msg cpmquerystatusex whereid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmrestartposition hcursor h Cursor mswsp msg cpmrestartposition hcursor FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmrestartposition chapt chapt mswsp msg cpmrestartposition chapt FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrowsetnotify wid wid mswsp msg cpmgetrowsetnotify wid FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrowsetnotify moreevents more Events mswsp msg cpmgetrowsetnotify moreevents FTBOOLEAN 8 NULL 0x01 NULLHFILL hf mswsp msg cpmgetrowsetnotify eventtype event Type mswsp msg cpmgetrowsetnotify event Type FTUIN T8 BASEDECNULL 0x FENULLHFILL hf mswsp msg cpmgetrowsetnotify rowsetitemstate row Set Item State mswsp msg cpmgetrowsetnotify rowsetitemstate FTUIN T8 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmgetrowsetnotify changeditemstate changed Item State mswsp msg cpmgetrowsetnotify changeditem State FTUIN T8 BASEDECNULL 0 0 HFILL hf mswsp msg cpmgetrowsetnotify rowsetevent row Set Event mswsp msg cpmgetrowsetnotify rowsetevent FTUIN T8 BASEDECNULL 0 0 HFILL hf mswsp msg cpmgetrowsetnotify rowseteventdata1 row Set Eventdata1 mswsp msg cpmgetrowsetnotify rowseteventdata1 FTUIN T64 BASEHEXNULL 0 NULLHFILL hf mswsp msg cpmgetrowsetnotify rowseteventdata2 row Set Eventdata2 mswsp msg cpmgetrowsetnotify rowseteventdata2 FTUIN T64 BASEHEXNULL 0 NULLHFILL hf mswsp msg cpmfindindices cwids c Wids mswsp msg cpmfindindices cwids FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfindindices cdepthprev c Depth Prev mswsp msg cpmfindindices cdepthprev FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmfindindices cdepthnext c Depth Next mswsp msg cpmfindindices cdepthnext FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetscopeprioritization priority priority mswsp msg cpmsetscopeprioritization priority FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetscopeprioritization eventfreq event Frequency mswsp msg cpmsetscopeprioritization eventfreq FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetscopestatisics dwindexitems dw Indexed Items mswsp msg cpmsetscopestatistics dwindexitems FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetscopestatisics dwoutstandingadds dw Outstanding Adds mswsp msg cpmsetscopestatistics dwoutstandingadds FTUIN T32 BASEDECNULL 0 NULLHFILL hf mswsp msg cpmsetscopestatisics dwoutstandingmodifies dw Outstanding Modifies mswsp msg cpmsetscopestatistics dwoutstandingmodifies FTUIN T32 BASEDECNULL 0 NULLHFILL static gint ett ett mswsp ett mswsp hdr ett mswsp msg ett mswsp pad ett mswsp property restriction ett C Restriction Array ett C Base Storage Variant ett C Base Storage Variant Vector ett C Base Storage Variant Array ett C Db Col Id ett GUID ett C Db Prop ett C Db Prop Set ett C Db Prop Set Array ett C Restriction ett C Node Restriction ett C Property Restriction ett C Coercion Restriction ett C Content Restriction ett RANGEBOUNDARY ett C Range Categ Spec ett C Categ Spec ett C Aggreg Spec ett C Aggreg Set ett C Categorization Spec ett C Aggreg Sort Key ett C Sort Aggreg Set ett C In Group Sort Aggreg Set ett C In Group Sort Aggreg Sets ett C Rowset Properties ett C Full Prop Spec ett C Pid Mapper ett C Sort ett C Sort Set ett C Nat Language Restriction ett C Column Group ett C Column Group Array ett LCID ett C Table Column ett Array ett Seek Description ett C Rows Seek Next ett C Rows Seek At ett C Rows Seek At Ratio ett C Rows Seek By Bookmark ett Get Rows Row ett Get Rows Column ett C Row Variant ett C Row Variant Vector ett mswsp bool options ett mswsp uin32 array ett mswsp msg padding ett mswsp msg creusewhere static ei register info ei ei mswsp invalid variant type mswsp invalid variant type PIPROTOCOLPIERROR Invalid variant type EXPFILL ei missing msg context mswsp msg cpmgetrows missing msg context PISEQUENCEPIWARN previous messages needed for context not captured EXPFILL ei mswsp msg cpmsetbinding ccolumns mswsp msg cpmsetbinding ccolumns invalude PIPROTOCOLPIWARN Invalid number of c Columns for packet EXPFILL int i proto mswsp proto register protocol Windows Search Protocol MSWSP mswsp proto register field array proto mswsp hf array length hf proto register subtree array ett array length ett expert mswsp expert register protocol proto mswsp expert register field array expert mswsp ei array length ei for i 0 i int array length Guid Property Set i guids add guid Guid Property Set i guid Guid Property Set i def void vp8 mbpost proc down c unsigned char dst int pitch int rows int cols int flimit int r c i const short rv3 vp8 rv 63 rand for c 0 c cols c unsigned char s dst c int sumsq 0 int sum 0 unsigned char d 16 const short rv2 rv3 c 17 127 for i 8 i 0 i s i pitch s 0 for i rows i rows 17 i s i pitch s rows 1 pitch for i 8 i 6 i sumsq s i pitch s i pitch sum s i pitch for r 0 r rows 8 r sumsq s 7 pitch s 7 pitch s 8 pitch s 8 pitch sum s 7 pitch s 8 pitch d r 15 s 0 if sumsq 15 sum sum flimit d r 15 rv2 r 127 sum s 0 4 if r 8 s 8 pitch d r 8 15 s pitch int ff h264 decode ref pic list reordering H264 Context h int list index pic structure i print short term h print long term h for list 0 list h list count list for i 0 i h ref count list i COPYPICTURE h ref list list i h default ref list list i if get bits1 h gb int pred h curr pic num for index 0 index unsigned int reordering of pic nums idc get ue golomb 31 h gb unsigned int pic id int i Picture ref NULL if reordering of pic nums idc 3 break if index h ref count list av log h avctx AVLOGERROR reference count overflow n return 1 if reordering of pic nums idc 3 if reordering of pic nums idc 2 const unsigned int abs diff pic num get ue golomb h gb 1 int frame num if abs diff pic num h max pic num av log h avctx AVLOGERROR abs diff pic num overflow n return 1 if reordering of pic nums idc 0 pred abs diff pic num else pred abs diff pic num pred h max pic num 1 frame num pic num extract h pred pic structure for i h short ref count 1 i 0 i ref h short ref i assert ref reference assert ref long ref if ref frame num frame num ref reference pic structure break if i 0 ref pic id pred else int long idx pic id get ue golomb h gb long idx pic num extract h pic id pic structure if long idx 31 av log h avctx AVLOGERROR long term pic idx overflow n return 1 ref h long ref long idx assert ref ref reference if ref ref reference pic structure ref pic id pic id assert ref long ref i 0 else i 1 if i 0 av log h avctx AVLOGERROR reference picture missing during reorder n memset h ref list list index 0 sizeof Picture else for i index i 1 h ref count list i if ref long ref h ref list list i long ref ref pic id h ref list list i pic id break for i index i COPYPICTURE h ref list list i h ref list list i 1 COPYPICTURE h ref list list index ref if FIELDPICTURE pic as field h ref list list index pic structure else av log h avctx AVLOGERROR illegal reordering of pic nums idc n return 1 for list 0 list h list count list for index 0 index h ref count list index if h ref list list index f data 0 av log h avctx AVLOGERROR Missing reference picture n if h default ref list list 0 f data 0 COPYPICTURE h ref list list index h default ref list list 0 else return 1 return 0 void merge directory configs apr pool t mp void parent void child directory config parent directory config parent directory config child directory config child directory config merged create directory config mp NULL merged is enabled child is enabled NOTSET parent is enabled child is enabled merged reqbody access child reqbody access NOTSET parent reqbody access child reqbody access merged reqbody buffering child reqbody buffering NOTSET parent reqbody buffering child reqbody buffering merged reqbody inmemory limit child reqbody inmemory limit NOTSET parent reqbody inmemory limit child reqbody inmemory limit merged reqbody limit child reqbody limit NOTSET parent reqbody limit child reqbody limit merged reqbody no files limit child reqbody no files limit NOTSET parent reqbody no files limit child reqbody no files limit merged resbody access child resbody access NOTSET parent resbody access child resbody access merged of limit child of limit NOTSET parent of limit child of limit merged if limit action child if limit action NOTSET parent if limit action child if limit action merged of limit action child of limit action NOTSET parent of limit action child of limit action merged reqintercept oe child reqintercept oe NOTSET parent reqintercept oe child reqintercept oe if child of mime types NOTSETP if child of mime types cleared 1 merged of mime types child of mime types merged of mime types cleared 1 else if parent of mime types NOTSETP merged of mime types child of mime types merged of mime types cleared NOTSET else merged of mime types apr table overlay mp parent of mime types child of mime types if merged of mime types NULL return NULL else if child of mime types cleared 1 merged of mime types cleared 1 else merged of mime types parent of mime types merged of mime types cleared parent of mime types cleared if child debuglog fd NOTSETP merged debuglog name parent debuglog name merged debuglog fd parent debuglog fd else merged debuglog name child debuglog name merged debuglog fd child debuglog fd merged debuglog level child debuglog level NOTSET parent debuglog level child debuglog level merged cookie format child cookie format NOTSET parent cookie format child cookie format merged argument separator child argument separator NOTSET parent argument separator child argument separator merged cookiev0 separator child cookiev0 separator NOTSETP parent cookiev0 separator child cookiev0 separator if child rule inheritance NOTSET child rule inheritance 1 merged rule inheritance parent rule inheritance if child ruleset NULL parent ruleset NULL else if child ruleset NULL copy rules mp parent ruleset merged ruleset child rule exceptions else if parent ruleset NULL merged ruleset phase request headers apr array copy mp child ruleset phase request headers merged ruleset phase request body apr array copy mp child ruleset phase request body merged ruleset phase response headers apr array copy mp child ruleset phase response headers merged ruleset phase response body apr array copy mp child ruleset phase response body merged ruleset phase logging apr array copy mp child ruleset phase logging else copy rules mp parent ruleset merged ruleset child rule exceptions apr array cat merged ruleset phase request headers child ruleset phase request headers apr array cat merged ruleset phase request body child ruleset phase request body apr array cat merged ruleset phase response headers child ruleset phase response headers apr array cat merged ruleset phase response body child ruleset phase response body apr array cat merged ruleset phase logging child ruleset phase logging else merged rule inheritance 0 if child ruleset NULL merged ruleset msre ruleset create child ruleset engine mp merged ruleset phase request headers apr array copy mp child ruleset phase request headers merged ruleset phase request body apr array copy mp child ruleset phase request body merged ruleset phase response headers apr array copy mp child ruleset phase response headers merged ruleset phase response body apr array copy mp child ruleset phase response body merged ruleset phase logging apr array copy mp child ruleset phase logging merged rule exceptions apr array append mp parent rule exceptions child rule exceptions merged hash method apr array append mp parent hash method child hash method merged auditlog flag child auditlog flag NOTSET parent auditlog flag child auditlog flag merged auditlog type child auditlog type NOTSET parent auditlog type child auditlog type merged max rule time child max rule time NOTSET parent max rule time child max rule time merged auditlog dirperms child auditlog dirperms NOTSET parent auditlog dirperms child auditlog dirperms merged auditlog fileperms child auditlog fileperms NOTSET parent auditlog fileperms child auditlog fileperms if child auditlog fd NOTSETP merged auditlog fd child auditlog fd merged auditlog name child auditlog name else merged auditlog fd parent auditlog fd merged auditlog name parent auditlog name if child auditlog2 fd NOTSETP merged auditlog2 fd child auditlog2 fd merged auditlog2 name child auditlog2 name else merged auditlog2 fd parent auditlog2 fd merged auditlog2 name parent auditlog2 name merged auditlog storage dir child auditlog storage dir NOTSETP parent auditlog storage dir child auditlog storage dir merged auditlog parts child auditlog parts NOTSETP parent auditlog parts child auditlog parts merged auditlog relevant regex child auditlog relevant regex NOTSETP parent auditlog relevant regex child auditlog relevant regex merged tmp dir child tmp dir NOTSETP parent tmp dir child tmp dir merged upload dir child upload dir NOTSETP parent upload dir child upload dir merged upload keep files child upload keep files NOTSET parent upload keep files child upload keep files merged upload validates files child upload validates files NOTSET parent upload validates files child upload validates files merged upload filemode child upload filemode NOTSET parent upload filemode child upload filemode merged upload file limit child upload file limit NOTSET parent upload file limit child upload file limit merged data dir child data dir NOTSETP parent data dir child data dir merged webappid child webappid NOTSETP parent webappid child webappid merged sensor id child sensor id NOTSETP parent sensor id child sensor id merged http Blkey child http Blkey NOTSETP parent http Blkey child http Blkey merged content injection enabled child content injection enabled NOTSET parent content injection enabled child content injection enabled merged stream inbody inspection child stream inbody inspection NOTSET parent stream inbody inspection child stream inbody inspection merged stream outbody inspection child stream outbody inspection NOTSET parent stream outbody inspection child stream outbody inspection merged geo child geo NOTSETP parent geo child geo merged gsb child gsb NOTSETP parent gsb child gsb merged u map child u map NOTSETP parent u map child u map merged cache trans child cache trans NOTSET parent cache trans child cache trans merged cache trans incremental child cache trans incremental NOTSET parent cache trans incremental child cache trans incremental merged cache trans min child cache trans min apr size t NOTSET parent cache trans min child cache trans min merged cache trans max child cache trans max apr size t NOTSET parent cache trans max child cache trans max merged cache trans maxitems child cache trans maxitems apr size t NOTSET parent cache trans maxitems child cache trans maxitems merged component signatures apr array append mp parent component signatures child component signatures merged request encoding child request encoding NOTSETP parent request encoding child request encoding merged disable backend compression child disable backend compression NOTSET parent disable backend compression child disable backend compression merged col timeout child col timeout NOTSET parent col timeout child col timeout merged crypto key child crypto key NOTSETP parent crypto key child crypto key merged crypto key len child crypto key len NOTSET parent crypto key len child crypto key len merged crypto key add child crypto key add NOTSET parent crypto key add child crypto key add merged crypto param name child crypto param name NOTSETP parent crypto param name child crypto param name merged hash is enabled child hash is enabled NOTSET parent hash is enabled child hash is enabled merged hash enforcement child hash enforcement NOTSET parent hash enforcement child hash enforcement merged crypto hash href rx child crypto hash href rx NOTSET parent crypto hash href rx child crypto hash href rx merged crypto hash faction rx child crypto hash faction rx NOTSET parent crypto hash faction rx child crypto hash faction rx merged crypto hash location rx child crypto hash location rx NOTSET parent crypto hash location rx child crypto hash location rx merged crypto hash iframesrc rx child crypto hash iframesrc rx NOTSET parent crypto hash iframesrc rx child crypto hash iframesrc rx merged crypto hash framesrc rx child crypto hash framesrc rx NOTSET parent crypto hash framesrc rx child crypto hash framesrc rx merged crypto hash href pm child crypto hash href pm NOTSET parent crypto hash href pm child crypto hash href pm merged crypto hash faction pm child crypto hash faction pm NOTSET parent crypto hash faction pm child crypto hash faction pm merged crypto hash location pm child crypto hash location pm NOTSET parent crypto hash location pm child crypto hash location pm merged crypto hash iframesrc pm child crypto hash iframesrc pm NOTSET parent crypto hash iframesrc pm child crypto hash iframesrc pm merged crypto hash framesrc pm child crypto hash framesrc pm NOTSET parent crypto hash framesrc pm child crypto hash framesrc pm merged xml external entity child xml external entity NOTSET parent xml external entity child xml external entity return merged static Asn1 Generic Decode Asn1 Der Sequence const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length parsed bytes numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SEQUENCE c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size node length d length if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL parsed bytes 0 seq index 0 while parsed bytes d length el max size max size d ptr buffer Asn1 Generic child Decode Asn1 Der Generic d ptr el max size depth seq index errcode if child NULL if errcode errcode 0 Der Free node return NULL break int ret Asn1 Sequence Append node child if ret 1 Der Free child break parsed bytes child length d ptr child length seq index return Asn1 Generic node int ff get qtpalette int codec id AVIO Context pb uint32 t palette int tmp bit depth color table id greyscale i avio seek pb 82 SEEKCUR tmp avio rb16 pb bit depth tmp 0x1 F greyscale tmp 0x20 color table id avio rb16 pb if greyscale codec id AVCODECIDCINEPAK return 0 if bit depth 1 bit depth 2 bit depth 4 bit depth 8 uint32 t color count color start color end uint32 t a r g b if greyscale bit depth 1 color table id int color index color dec color count 1 bit depth color index 255 color dec 256 color count 1 for i 0 i color count i r g b color index palette i 0x FFU 24 r 16 g 8 b color index color dec if color index 0 color index 0 else if color table id const uint8 t color table color count 1 bit depth if bit depth 1 color table ff qt default palette 2 else if bit depth 2 color table ff qt default palette 4 else if bit depth 4 color table ff qt default palette 16 else color table ff qt default palette 256 for i 0 i color count i r color table i 3 0 g color table i 3 1 b color table i 3 2 palette i 0x FFU 24 r 16 g 8 b else color start avio rb32 pb avio rb16 pb color end avio rb16 pb if color start 255 color end 255 for i color start i color end i a avio r8 pb avio r8 pb r avio r8 pb avio r8 pb g avio r8 pb avio r8 pb b avio r8 pb avio r8 pb palette i a 24 r 16 g 8 b return 1 return 0 void ff xvmc decode mb Mpeg Enc Context s Xv MC Macro Block mv block struct xvmc pix fmt render int i cbp blocks per mb const int mb xy s mb y s mb stride s mb x if s encoding av log s avctx AVLOGERRORXVMC doesn t support encoding n return if s mb intra s last dc 0 s last dc 1 s last dc 2 128 s intra dc precision s mb skipped 0 s current picture qscale table mb xy s qscale render struct xvmc pix fmt s current picture f data 2 assert render assert render xvmc id AVXVMCID assert render mv blocks mv block render mv blocks render start mv blocks num render filled mv blocks num mv block x s mb x mv block y s mb y mv block dct type s interlaced dct if s mb intra mv block macroblock type XVMCMBTYPEINTRA else mv block macroblock type XVMCMBTYPEPATTERN if s mv dir MVDIRFORWARD mv block macroblock type XVMCMBTYPEMOTIONFORWARD mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 mv block PMV 1 0 0 s mv 0 1 0 mv block PMV 1 0 1 s mv 0 1 1 if s mv dir MVDIRBACKWARD mv block macroblock type XVMCMBTYPEMOTIONBACKWARD mv block PMV 0 1 0 s mv 1 0 0 mv block PMV 0 1 1 s mv 1 0 1 mv block PMV 1 1 0 s mv 1 1 0 mv block PMV 1 1 1 s mv 1 1 1 switch s mv type case MVTYPE 16 X16 mv block motion type XVMCPREDICTIONFRAME break case MVTYPE 16 X8 mv block motion type XVMCPREDICTION 16x8 break case MVTYPEFIELD mv block motion type XVMCPREDICTIONFIELD if s picture structure PICTFRAME mv block PMV 0 0 1 1 mv block PMV 1 0 1 1 mv block PMV 0 1 1 1 mv block PMV 1 1 1 1 break case MVTYPEDMV mv block motion type XVMCPREDICTIONDUALPRIME if s picture structure PICTFRAME mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 1 mv block PMV 0 1 0 s mv 0 0 0 mv block PMV 0 1 1 s mv 0 0 1 1 mv block PMV 1 0 0 s mv 0 2 0 mv block PMV 1 0 1 s mv 0 2 1 1 mv block PMV 1 1 0 s mv 0 3 0 mv block PMV 1 1 1 s mv 0 3 1 1 else mv block PMV 0 1 0 s mv 0 2 0 mv block PMV 0 1 1 s mv 0 2 1 break default assert 0 mv block motion vertical field select 0 if s mv type MVTYPEFIELD s mv type MVTYPE 16 X8 mv block motion vertical field select s field select 0 0 mv block motion vertical field select s field select 1 0 1 mv block motion vertical field select s field select 0 1 2 mv block motion vertical field select s field select 1 1 3 mv block index render next free data block num blocks per mb 6 if s chroma format 2 blocks per mb 4 1 s chroma format cbp 0 for i 0 i blocks per mb i cbp cbp if s block last index i 0 cbp if s flags CODECFLAGGRAY if s mb intra for i 4 i blocks per mb i memset s pblocks i 0 sizeof s pblocks i if render unsigned intra s pblocks i 0 1 10 else cbp 0xf blocks per mb 4 blocks per mb 4 mv block coded block pattern cbp if cbp 0 mv block macroblock type XVMCMBTYPEPATTERN for i 0 i blocks per mb i if s block last index i 0 if s mb intra render idct render unsigned intra s pblocks i 0 1 10 if render idct s dsp idct s pblocks i if s avctx xvmc acceleration 1 memcpy render data blocks render next free data block num 64 s pblocks i sizeof s pblocks i render next free data block num render filled mv blocks num assert render filled mv blocks num render allocated mv blocks assert render next free data block num render allocated data blocks if render filled mv blocks num render allocated mv blocks ff mpeg draw horiz band s 0 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VB Dec Context const c avctx priv data AV Frame frame data uint8 t outptr srcptr int i j ret int flags uint32 t size int offset 0 bytestream2 init c stream avpkt data avpkt size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret flags bytestream2 get le16 c stream if flags VBHASGMC i int16 t bytestream2 get le16 c stream j int16 t bytestream2 get le16 c stream offset i j avctx width if flags VBHASVIDEO size bytestream2 get le32 c stream vb decode framedata c offset bytestream2 skip c stream size 4 if flags VBHASPALETTE size bytestream2 get le32 c stream vb decode palette c size memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed flags VBHASPALETTE outptr frame data 0 srcptr c frame for i 0 i avctx height i memcpy outptr srcptr avctx width srcptr avctx width outptr frame linesize 0 FFSWAP uint8 t c frame c prev frame got frame 1 return avpkt size static void update state rt V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col int bsize V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const struct segmentation const seg cm seg xd mi 0 src mi ctx mic xd mi 0 src mi xd mi 0 if cpi oxcf aq mode CYCLICREFRESHAQ seg enabled vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 vp9 init plane quantizers cpi x if is inter block mbmi vp9 update mv count cm xd if cm interp filter SWITCHABLE const int pred ctx vp9 get pred context switchable interp xd cm counts switchable interp pred ctx mbmi interp filter x skip ctx skip x skip txfm 0 mbmi segment id 0 ctx skip txfm 0 int64 t vp9 rd pick inter mode sb seg skip V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndistortion BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd so far V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 mbmi unsigned char segment id mbmi segment id const int comp pred 0 int i int64 t best tx diff TXMODES int64 t best pred diff REFERENCEMODES int64 t best filter diff SWITCHABLEFILTERCONTEXTS unsigned int ref costs single MAXREFFRAMES ref costs comp MAXREFFRAMES vp9 prob comp mode p INTERPFILTER best filter SWITCHABLE int64 t this rd IN T64 MAX int rate2 0 const int64 t distortion2 0 x skip encode cpi sf skip encode frame x q index QIDXSKIPTHRESH estimate ref frame costs cm xd segment id ref costs single ref costs comp comp mode p for i 0 i MAXREFFRAMES i x pred sse i INTMAX for i LASTFRAME i MAXREFFRAMES i x pred mv sad i INTMAX returnrate INTMAX assert vp9 segfeature active cm seg segment id SEGLVLSKIP mbmi mode ZEROMV mbmi uv mode DCPRED mbmi ref frame 0 LASTFRAME mbmi ref frame 1 NONE mbmi mv 0 as int 0 x skip 1 rd opt mask filter 0 for i 0 i SWITCHABLEFILTERCONTEXTS i rd opt filter cache i IN T64 MAX if cm interp filter BILINEAR best filter EIGHTTAP if cm interp filter SWITCHABLE x source variance cpi sf disable filter search var thresh int rs int best rs INTMAX for i 0 i SWITCHABLEFILTERS i mbmi interp filter i rs vp9 get switchable rate cpi if rs best rs best rs rs best filter mbmi interp filter if cm interp filter SWITCHABLE mbmi interp filter best filter rate2 vp9 get switchable rate cpi else mbmi interp filter cm interp filter if cm reference mode REFERENCEMODESELECT rate2 vp9 cost bit comp mode p comp pred rate2 ref costs single LASTFRAME this rd RDCOST x rdmult x rddiv rate2 distortion2 returnrate rate2 returndistortion distortion2 if this rd best rd so far return IN T64 MAX assert cm interp filter SWITCHABLE cm interp filter mbmi interp filter update rd thresh fact cpi bsize THRZEROMV vp9 zero best pred diff vp9 zero best filter diff vp9 zero best tx diff if x select tx size swap block ptr x ctx 1 0 0 MAXMBPLANE store coding context x ctx THRZEROMV best pred diff best tx diff best filter diff 0 return this rd static void h245 setup channels packet info pinfo channel info t upcoming channel lcl rtp dyn payload t rtp dyn payload NULL struct srtp info dummy srtp info NULL if upcoming channel lcl return if strcmp upcoming channel lcl data type str t38fax if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 t38 add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num return if upcoming channel lcl rfc2198 0 rtp dyn payload rtp dyn payload new rtp dyn payload insert rtp dyn payload upcoming channel lcl rfc2198 red 8000 if upcoming channel lcl srtp flag dummy srtp info wmem new0 wmem file scope struct srtp info if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 srtp add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num upcoming channel lcl is video rtp dyn payload dummy srtp info if upcoming channel lcl media control addr addr type ATNONE upcoming channel lcl media control addr port 0 rtcp handle srtcp add address pinfo upcoming channel lcl media control addr addr upcoming channel lcl media control addr port 0 H245 pinfo fd num dummy srtp info static void rd auto partition range V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE min block size BLOCKSIZE max block size V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO mi xd mi 0 src mi const int left in image xd left available mi 1 src mi const int above in image xd up available mi xd mi stride src mi const int row8x8 remaining tile mi row end mi row const int col8x8 remaining tile mi col end mi col int bh bw BLOCKSIZE min size BLOCK 4 X4 BLOCKSIZE max size BLOCK 64 X64 int i 0 int bs hist BLOCKSIZES 0 if left in image above in image cm frame type KEYFRAME min size BLOCK 64 X64 max size BLOCK 4 X4 if cm frame type KEYFRAMEMODEINFO prev mi cm prev mip cm mi stride 1 mi row xd mi stride mi col get sb partition size range xd prev mi min size max size bs hist if left in image MODEINFO left sb64 mi mi MIBLOCKSIZE src mi get sb partition size range xd left sb64 mi min size max size bs hist if above in image MODEINFO above sb64 mi mi xd mi stride MIBLOCKSIZE src mi get sb partition size range xd above sb64 mi min size max size bs hist if cpi sf auto min max partition size RELAXEDNEIGHBORINGMINMAX min size min partition size min size max size max partition size max size else if cpi sf auto min max partition size CONSTRAINNEIGHBORINGMINMAX int sum 0 int first moment 0 int second moment 0 int var unnormalized 0 for i 0 i BLOCKSIZES i sum bs hist i first moment bs hist i i second moment bs hist i i i var unnormalized second moment first moment first moment sum if var unnormalized 4 sum int mean first moment sum min size min partition size mean max size max partition size mean else min size min partition size min size max size max partition size max size max size find partition size max size row8x8 remaining col8x8 remaining bh bw min size MIN min size max size if cpi sf use square partition only next square size max size min size min size next square size max size min block size min size max block size max size static inline void set p mv tables Mpeg Enc Context s int mx int my int mv4 const int xy s mb x s mb y s mb stride s p mv table xy 0 mx s p mv table xy 1 my if mv4 int mot xy s block index 0 s current picture motion val 0 mot xy 0 mx s current picture motion val 0 mot xy 1 my s current picture motion val 0 mot xy 1 0 mx s current picture motion val 0 mot xy 1 1 my mot xy s b8 stride s current picture motion val 0 mot xy 0 mx s current picture motion val 0 mot xy 1 my s current picture motion val 0 mot xy 1 0 mx s current picture motion val 0 mot xy 1 1 my void ff h264 fill mbaff ref list H264 Context h int list i j for list 0 list 2 list for i 0 i h ref count list i Picture frame h ref list list i Picture field h ref list list 16 2 i field 0 frame for j 0 j 3 j field 0 f linesize j 1 field 0 f reference PICTTOPFIELD field 0 poc field 0 field poc 0 field 1 field 0 for j 0 j 3 j field 1 f data j frame f linesize j field 1 f reference PICTBOTTOMFIELD field 1 poc field 1 field poc 1 h luma weight 16 2 i list 0 h luma weight 16 2 i 1 list 0 h luma weight i list 0 h luma weight 16 2 i list 1 h luma weight 16 2 i 1 list 1 h luma weight i list 1 for j 0 j 2 j h chroma weight 16 2 i list j 0 h chroma weight 16 2 i 1 list j 0 h chroma weight i list j 0 h chroma weight 16 2 i list j 1 h chroma weight 16 2 i 1 list j 1 h chroma weight i list j 1 Char Driver State qdev init chardev Device State dev static int next serial static int next virtconsole if strncmp dev info name virtio 6 0 return virtcon hds next virtconsole else return serial hds next serial static void encode block int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd struct optimize ctx const ctx args ctx struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block int i j uint8 t dst ENTROPYCONTEXT a l txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j pd dst stride 4 i a ctx ta plane i l ctx tl plane j if x zcoeff blk tx size block plane 0 p eobs block 0 a l 0 return if x skip recode if max txsize lookup plane bsize tx size if x skip txfm plane 2 block tx size 1 0 if x quant fp vp9 xform quant fp x plane block plane bsize tx size else vp9 xform quant x plane block plane bsize tx size else if x skip txfm plane 2 block tx size 1 2 vp9 xform quant dc x plane block plane bsize tx size else p eobs block 0 a l 0 return else vp9 xform quant x plane block plane bsize tx size if x optimize x skip recode x skip optimize const int ctx combine entropy contexts a l a l optimize b x plane block tx size ctx 0 else a l p eobs block 0 if p eobs block args skip 0 if x skip encode p eobs block 0 return switch tx size case TX 32 X32 vp9 idct32x32 add dqcoeff dst pd dst stride p eobs block break case TX 16 X16 vp9 idct16x16 add dqcoeff dst pd dst stride p eobs block break case TX 8 X8 vp9 idct8x8 add dqcoeff dst pd dst stride p eobs block break case TX 4 X4 x itxm add dqcoeff dst pd dst stride p eobs block break default assert 0 Invalid transform size break static int svq1 encode plane SV Q1 Context s int plane unsigned char src plane unsigned char ref plane unsigned char decoded plane int width int height int src stride int stride int x y int i int block width block height int level int threshold 6 uint8 t src s scratchbuf stride 16 const int lambda s picture quality s picture quality 2 FFLAMBDASHIFT threshold 5 QUALITYTHRESHOLD for level 4 level 0 level threshold level threshold level 1 THRESHOLDMULTIPLIER block width width 15 16 block height height 15 16 if s picture pict type AVPICTURETYPEP s m avctx s avctx s m current picture ptr s m current picture s m last picture ptr s m last picture s m last picture f data 0 ref plane s m linesize s m last picture f linesize 0 s m new picture f linesize 0 s m current picture f linesize 0 stride s m width width s m height height s m mb width block width s m mb height block height s m mb stride s m mb width 1 s m b8 stride 2 s m mb width 1 s m f code 1 s m pict type s picture pict type s m me method s avctx me method s m me scene change score 0 s m flags s avctx flags s m lambda s picture quality s m qscale s m lambda 139 FFLAMBDASCALE 64 FFLAMBDASHIFT 7 s m lambda2 s m lambda s m lambda FFLAMBDASCALE 2 FFLAMBDASHIFT if s motion val8 plane s motion val8 plane av mallocz s m b8 stride block height 2 2 2 sizeof int16 t s motion val16 plane av mallocz s m mb stride block height 2 1 2 sizeof int16 t s m mb type s mb type s m current picture mb mean uint8 t s dummy s m current picture mb var uint16 t s dummy s m current picture mc mb var uint16 t s dummy s m current picture f mb type s dummy s m current picture f motion val 0 s motion val8 plane 2 s m p mv table s motion val16 plane s m mb stride 1 s m dsp s dsp ff init me s m s m me dia size s avctx dia size s m first slice line 1 for y 0 y block height y s m new picture f data 0 src y 16 stride s m mb y y for i 0 i 16 i 16 y height i memcpy src i stride src plane i 16 y src stride width for x width x 16 block width x src i stride x src i stride x 1 for i 16 i 16 y 16 block height i memcpy src i stride src i 1 stride 16 block width for x 0 x block width x s m mb x x ff init block index s m ff update block index s m ff estimate p frame motion s m x y s m first slice line 0 ff fix long p mvs s m ff fix long mvs s m NULL 0 s m p mv table s m f code CANDIDATEMBTYPEINTER 0 s m first slice line 1 for y 0 y block height y for i 0 i 16 i 16 y height i memcpy src i stride src plane i 16 y src stride width for x width x 16 block width x src i stride x src i stride x 1 for i 16 i 16 y 16 block height i memcpy src i stride src i 1 stride 16 block width s m mb y y for x 0 x block width x uint8 t reorder buffer 3 6 7 32 int count 3 6 int offset y 16 stride x 16 uint8 t decoded decoded plane offset uint8 t ref ref plane offset int score 4 0 0 0 0 best uint8 t temp s scratchbuf if s pb buf end s pb buf put bits count s pb 3 3000 av log s avctx AVLOGERROR encoded frame too large n return 1 s m mb x x ff init block index s m ff update block index s m if s picture pict type AVPICTURETYPEI s m mb type x y s m mb stride CANDIDATEMBTYPEINTRA for i 0 i 6 i init put bits s reorder pb i reorder buffer 0 i 7 32 if s picture pict type AVPICTURETYPEP const uint8 t vlc ff svq1 block type vlc SV Q1 BLOCKINTRA put bits s reorder pb 5 vlc 1 vlc 0 score 0 vlc 1 lambda score 0 encode block s src 16 x NULL temp stride 5 64 lambda 1 for i 0 i 6 i count 0 i put bits count s reorder pb i flush put bits s reorder pb i else score 0 INTMAX best 0 if s picture pict type AVPICTURETYPEP const uint8 t vlc ff svq1 block type vlc SV Q1 BLOCKINTER int mx my pred x pred y dxy int16 t motion ptr motion ptr ff h263 pred motion s m 0 0 pred x pred y if s m mb type x y s m mb stride CANDIDATEMBTYPEINTER for i 0 i 6 i init put bits s reorder pb i reorder buffer 1 i 7 32 put bits s reorder pb 5 vlc 1 vlc 0 s m pb s reorder pb 5 mx motion ptr 0 my motion ptr 1 assert mx 32 mx 31 assert my 32 my 31 assert pred x 32 pred x 31 assert pred y 32 pred y 31 ff h263 encode motion s m mx pred x 1 ff h263 encode motion s m my pred y 1 s reorder pb 5 s m pb score 1 lambda put bits count s reorder pb 5 dxy mx 1 2 my 1 s dsp put pixels tab 0 dxy temp 16 ref mx 1 stride my 1 stride 16 score 1 encode block s src 16 x temp 16 decoded stride 5 64 lambda 0 best score 1 score 0 vlc ff svq1 block type vlc SV Q1 BLOCKSKIP score 2 s dsp sse 0 NULL src 16 x ref stride 16 score 2 vlc 1 lambda if score 2 score best mx 0 my 0 best 2 s dsp put pixels tab 0 0 decoded ref stride 16 for i 0 i 6 i count 2 i 0 put bits s pb vlc 1 vlc 0 if best 1 for i 0 i 6 i count 1 i put bits count s reorder pb i flush put bits s reorder pb i else motion ptr 0 motion ptr 1 motion ptr 2 motion ptr 3 motion ptr 0 2 s m b8 stride motion ptr 1 2 s m b8 stride motion ptr 2 2 s m b8 stride motion ptr 3 2 s m b8 stride 0 s rd total score best for i 5 i 0 i avpriv copy bits s pb reorder buffer best i count best i if best 0 s dsp put pixels tab 0 0 decoded temp stride 16 s m first slice line 0 return 0 int set wep key char string int bit 0 char p type char tok char s strlen string 1 u char tmp wkey 512 size t tmp wkey len char tmp 128 memset GBLWIFI wkey 0 sizeof GBLWIFI wkey GBLWIFI wkey len 0 strcpy s string p ec strtok s tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key bit atoi p if bit 0 SEMIFATALERROR Unsupported WEP key length tmp wkey len bit 8 WEPIVLEN if bit 64 bit 128 SEMIFATALERROR Unsupported WEP key length p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key type p p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key if type s if strescape char tmp wkey p int tmp wkey len SEMIFATALERROR Specified WEP key length does not match the given string else if type p if bit 64 make key 64 u char p tmp wkey else if bit 128 make key 128 u char p tmp wkey else SEMIFATALERROR Invalid parsing of the WEP key USERMSG Using WEP key s n str tohex tmp wkey tmp wkey len tmp sizeof tmp memcpy GBLWIFI wkey tmp wkey sizeof GBLWIFI wkey GBLWIFI wkey len tmp wkey len return static int cinaudio decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data Cin Audio Context cin avctx priv data const uint8 t buf end buf avpkt size int16 t samples int delta ret frame nb samples avpkt size cin initial decode frame if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 delta cin delta if cin initial decode frame cin initial decode frame 0 delta sign extend AVR L16 buf 16 buf 2 samples delta while buf buf end delta cinaudio delta16 table buf delta av clip int16 delta samples delta cin delta delta got frame ptr 1 return avpkt size static void reindex all databases const char maintenance db const char host const char port const char username enum trivalue prompt password const char progname bool echo bool quiet bool verbose P Gconn conn P Gresult result int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn for i 0 i P Qntuples result i char dbname P Qgetvalue result i 0 if quiet printf s reindexing database s n progname dbname fflush stdout reindex one database dbname dbname DATABASE host port username prompt password progname echo verbose P Qclear result static void main get appheader xd3 stream stream main file ifile main file output main file sfile uint8 t apphead usize t appheadsz int ret if option use appheader return ret xd3 get appheader stream apphead appheadsz if ret 0 return if appheadsz 0 char start char apphead char slash int place 0 char parsed 4 memset parsed 0 sizeof parsed while slash strchr start NULL slash 0 parsed place start start slash 1 parsed place start if place 2 place 4 main get appheader params output parsed 1 output ifile if place 4 main get appheader params sfile parsed 2 0 source ifile option use appheader 0 return int main int argc char argv gpg error t err if argc argc argv if argc unsigned char buffer size t n buflen for argc argc argv err ksba oid from str argv buffer buflen if err fprintf stderr can t convert s s n argv gpg strerror err return 1 printf s argv for n 0 n buflen n printf 02 X buffer n putchar n free buffer else char buffer size t buflen char result buffer read into buffer stdin buflen result ksba oid to str buffer buflen free buffer printf s n result result malloc failed free result return 0 static int yop decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Yop Dec Context s avctx priv data AV Frame frame data int tag firstcolor is odd frame int ret i x y uint32 t palette if avpkt size 4 3 s num pal colors av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA ret ff get buffer avctx frame 0 if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset frame data 1 0 AVPALETTESIZE s dstbuf frame data 0 s dstptr frame data 0 s srcptr avpkt data 4 s src end avpkt data avpkt size s low nibble NULL is odd frame avpkt data 0 firstcolor s first color is odd frame palette uint32 t frame data 1 for i 0 i s num pal colors i s srcptr 3 palette i firstcolor s srcptr 0 18 s srcptr 1 10 s srcptr 2 2 frame palette has changed 1 for y 0 y avctx height y 2 for x 0 x avctx width x 2 if s srcptr avpkt data avpkt size av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA tag yop get next nibble s if tag 0xf ret yop paint block s frame linesize 0 tag if ret 0 return ret else tag yop get next nibble s ret yop copy previous block s frame linesize 0 tag if ret 0 return ret s dstptr 2 s dstptr 2 frame linesize 0 x got frame 1 return avpkt size int main int argc char argv Block Backend blk Block Driver State bs off t dev offset 0 uint16 t nbdflags 0 bool disconnect false const char bindto NULL const char port NULL char sockpath NULL char device NULL off t fd size Qemu Opts sn opts NULL const char sn id or name NULL const char sopt h Vb o p rsn P c dvk e f tl x TD struct option lopt help no argument NULL h version no argument NULLV bind required argument NULL b port required argument NULL p socket required argument NULL k offset required argument NULL o read only no argument NULL r partition required argument NULLP connect required argument NULL c disconnect no argument NULL d snapshot no argument NULL s load snapshot required argument NULL l nocache no argument NULL n cache required argument NULLQEMUNBDOPTCACHE aio required argument NULLQEMUNBDOPTAIO discard required argument NULLQEMUNBDOPTDISCARD detect zeroes required argument NULLQEMUNBDOPTDETECTZEROES shared required argument NULL e format required argument NULL f persistent no argument NULL t verbose no argument NULL v object required argument NULLQEMUNBDOPTOBJECT export name required argument NULL x description required argument NULLD tls creds required argument NULLQEMUNBDOPTTLSCREDS image opts no argument NULLQEMUNBDOPTIMAGEOPTS trace required argument NULLT fork no argument NULLQEMUNBDOPTFORKNULL 0 NULL 0 int ch int opt ind 0 char end int flags BDRVORDWR int partition 1 int ret 0 bool seen cache false bool seen discard false bool seen aio false pthread t client thread const char fmt NULL Error local err NULL Blockdev Detect Zeroes Options detect zeroes BLOCKDEVDETECTZEROESOPTIONSOFFQ Dict options NULL const char export name NULL const char export description NULL const char tlscredsid NULL bool image Opts false bool writethrough true char trace file NULL bool fork process false int old stderr 1 unsigned socket activation struct sigaction sa sigterm memset sa sigterm 0 sizeof sa sigterm sa sigterm sa handler termsig handler sigaction SIGTERM sa sigterm NULL module call init MODULEINITTRACE qcrypto init error fatal module call init MODULEINITQOM qemu add opts qemu object opts qemu add opts qemu trace opts qemu init exec dir argv 0 while ch getopt long argc argv sopt lopt opt ind 1 switch ch case s flags BDRVOSNAPSHOT break case n optarg char none case QEMUNBDOPTCACHE if seen cache error report n and cache can only be specified once exit EXITFAILURE seen cache true if bdrv parse cache mode optarg flags writethrough 1 error report Invalid cache mode s optarg exit EXITFAILURE break case QEMUNBDOPTAIO if seen aio error report aio can only be specified once exit EXITFAILURE seen aio true if strcmp optarg native flags BDRVONATIVEAIO else if strcmp optarg threads else error report invalid aio mode s optarg exit EXITFAILURE break case QEMUNBDOPTDISCARD if seen discard error report discard can only be specified once exit EXITFAILURE seen discard true if bdrv parse discard flags optarg flags 1 error report Invalid discard mode s optarg exit EXITFAILURE break case QEMUNBDOPTDETECTZEROES detect zeroes qapi enum parse Blockdev Detect Zeroes Options lookup optarg BLOCKDEVDETECTZEROESOPTIONSMAXBLOCKDEVDETECTZEROESOPTIONSOFF local err if local err error reportf err local err Failed to parse detect zeroes mode exit EXITFAILURE if detect zeroes BLOCKDEVDETECTZEROESOPTIONSUNMAP flags BDRVOUNMAP error report setting detect zeroes to unmap is not allowed without setting discard operation to unmap exit EXITFAILURE break case b bindto optarg break case p port optarg break case o dev offset strtoll optarg end 0 if end error report Invalid offset s optarg exit EXITFAILURE if dev offset 0 error report Offset must be positive s optarg exit EXITFAILURE break case l if strstart optarg SNAPSHOTOPTBASENULL sn opts qemu opts parse noisily internal snapshot opts optarg false if sn opts error report Failed in parsing snapshot param s optarg exit EXITFAILURE else sn id or name optarg case r nbdflags NBDFLAGREADONLY flags BDRVORDWR break case P partition strtol optarg end 0 if end error report Invalid partition s optarg exit EXITFAILURE if partition 1 partition 8 error report Invalid partition d partition exit EXITFAILURE break case k sockpath optarg if sockpath 0 error report socket path must be absolute exit EXITFAILURE break case d disconnect true break case c device optarg break case e shared strtol optarg end 0 if end error report Invalid shared device number s optarg exit EXITFAILURE if shared 1 error report Shared device number must be greater than 0 exit EXITFAILURE break case f fmt optarg break case t persistent 1 break case x export name optarg break case D export description optarg break case v verbose 1 break case V version argv 0 exit 0 break case h usage argv 0 exit 0 break case error report Try s help for more information argv 0 exit EXITFAILURE case QEMUNBDOPTOBJECT Qemu Opts opts opts qemu opts parse noisily qemu object opts optarg true if opts exit EXITFAILURE break case QEMUNBDOPTTLSCREDS tlscredsid optarg break case QEMUNBDOPTIMAGEOPTS image Opts true break case T g free trace file trace file trace opt parse optarg break case QEMUNBDOPTFORK fork process true break if argc optind 1 error report Invalid number of arguments error printf Try s help for more information n argv 0 exit EXITFAILURE if qemu opts foreach qemu object opts user creatable add opts foreach NULLNULL exit EXITFAILURE if trace init backends exit 1 trace init file trace file qemu set log LOGTRACE socket activation check socket activation if socket activation 0 setup address and port bindto port else const char err msg socket activation validate opts device sockpath bindto port if err msg NULL error report s err msg exit EXITFAILURE if socket activation 1 error report qemu nbd does not support socket activation with s 1 LISTENFDS exit EXITFAILURE if tlscredsid if sockpath error report TLS is only supported with I Pv4 I Pv6 exit EXITFAILURE if device error report TLS is not supported with a host device exit EXITFAILURE if export name export name tlscreds nbd get tls creds tlscredsid local err if local err error report Failed to get TLS creds s error get pretty local err exit EXITFAILURE if disconnect int nbdfd open argv optind ORDWR if nbdfd 0 error report Cannot open s s argv optind strerror errno exit EXITFAILURE nbd disconnect nbdfd close nbdfd printf s disconnected n argv optind return 0 if device verbose fork process int stderr fd 2 pid t pid int ret if qemu pipe stderr fd 0 error report Error setting up communication pipe s strerror errno exit EXITFAILURE pid fork if pid 0 error report Failed to fork s strerror errno exit EXITFAILURE else if pid 0 close stderr fd 0 ret qemu daemon 1 0 old stderr dup STDERRFILENO dup2 stderr fd 1 STDERRFILENO if ret 0 error report Failed to daemonize s strerror errno exit EXITFAILURE close stderr fd 1 else bool errors false char buf close stderr fd 1 buf g malloc 1024 while ret read stderr fd 0 buf 1024 0 errors true ret qemu write full STDERRFILENO buf ret if ret 0 exit EXITFAILURE if ret 0 error report Cannot read from daemon s strerror errno exit EXITFAILURE exit errors if device NULL sockpath NULL sockpath g malloc 128 snprintf sockpath 128 SOCKETPATH basename device if socket activation 0 server ioc qio channel socket new saddr nbd build socket address sockpath bindto port if qio channel socket listen sync server ioc saddr local err 0 object unref OBJECT server ioc error report err local err return 1 else assert socket activation 1 server ioc qio channel socket new fd FIRSTSOCKETACTIVATIONFD local err if server ioc NULL error report Failed to use socket activation s error get pretty local err exit EXITFAILURE if qemu init main loop local err error report err local err exit EXITFAILURE bdrv init atexit bdrv close all srcpath argv optind if image Opts Qemu Opts opts if fmt error report image opts and f are mutually exclusive exit EXITFAILURE opts qemu opts parse noisily file opts srcpath true if opts qemu opts reset file opts exit EXITFAILURE options qemu opts to qdict opts NULL qemu opts reset file opts blk blk new open NULLNULL options flags local err else if fmt options qdict new qdict put str options driver fmt blk blk new open srcpath NULL options flags local err if blk error reportf err local err Failed to blk new open s argv optind exit EXITFAILURE bs blk bs blk blk set enable write cache blk writethrough if sn opts ret bdrv snapshot load tmp bs qemu opt get sn opts SNAPSHOTOPTID qemu opt get sn opts SNAPSHOTOPTNAME local err else if sn id or name ret bdrv snapshot load tmp by id or name bs sn id or name local err if ret 0 error reportf err local err Failed to load snapshot exit EXITFAILURE bs detect zeroes detect zeroes fd size blk getlength blk if fd size 0 error report Failed to determine the image length s strerror fd size exit EXITFAILURE if dev offset fd size error report Offset lld has to be smaller than the image size lld long long int dev offset long long int fd size exit EXITFAILURE fd size dev offset if partition 1 ret find partition blk partition dev offset fd size if ret 0 error report Could not find partition d s partition strerror ret exit EXITFAILURE exp nbd export new bs dev offset fd size nbdflags nbd export closed writethrough NULL local err if exp error report err local err exit EXITFAILURE if export name nbd export set name exp export name nbd export set description exp export description newproto true else if export description error report Export description requires an export name exit EXITFAILURE if device int ret ret pthread create client thread NULL nbd client thread device if ret 0 error report Failed to create client thread s strerror ret exit EXITFAILURE else memset client thread 0 sizeof client thread nbd update server watch if chdir 0 error report Could not chdir to root directory s strerror errno exit EXITFAILURE if fork process dup2 old stderr STDERRFILENO close old stderr state RUNNING do main loop wait false if state TERMINATE state TERMINATING nbd export close exp nbd export put exp exp NULL while state TERMINATED blk unref blk if sockpath unlink sockpath qemu opts del sn opts if device void ret pthread join client thread ret exit ret NULL else exit void ff mpeg4 pred ac Mpeg Enc Context s int16 t block int n int dir int i int16 t ac val ac val1 int8 t const qscale table s current picture f qscale table ac val s ac val 0 0 s block index n 16 ac val1 ac val if s ac pred if dir 0 const int xy s mb x 1 s mb y s mb stride ac val 16 if s mb x 0 s qscale qscale table xy n 1 n 3 for i 1 i 8 i block s dsp idct permutation i 3 ac val i else for i 1 i 8 i block s dsp idct permutation i 3 ROUNDEDDIV ac val i qscale table xy s qscale else const int xy s mb x s mb y s mb stride s mb stride ac val 16 s block wrap n if s mb y 0 s qscale qscale table xy n 2 n 3 for i 1 i 8 i block s dsp idct permutation i ac val i 8 else for i 1 i 8 i block s dsp idct permutation i ROUNDEDDIV ac val i 8 qscale table xy s qscale for i 1 i 8 i ac val1 i block s dsp idct permutation i 3 for i 1 i 8 i ac val1 8 i block s dsp idct permutation i void ff h263 update motion val Mpeg Enc Context s const int mb xy s mb y s mb stride s mb x const int wrap s b8 stride const int xy s block index 0 s current picture f mbskip table mb xy s mb skipped if s mv type MVTYPE 8 X8 int motion x motion y if s mb intra motion x 0 motion y 0 else if s mv type MVTYPE 16 X16 motion x s mv 0 0 0 motion y s mv 0 0 1 else int i motion x s mv 0 0 0 s mv 0 1 0 motion y s mv 0 0 1 s mv 0 1 1 motion x motion x 1 motion x 1 for i 0 i 2 i s p field mv table i 0 mb xy 0 s mv 0 i 0 s p field mv table i 0 mb xy 1 s mv 0 i 1 s current picture f ref index 0 4 mb xy s current picture f ref index 0 4 mb xy 1 s field select 0 0 s current picture f ref index 0 4 mb xy 2 s current picture f ref index 0 4 mb xy 3 s field select 0 1 s current picture f motion val 0 xy 0 motion x s current picture f motion val 0 xy 1 motion y s current picture f motion val 0 xy 1 0 motion x s current picture f motion val 0 xy 1 1 motion y s current picture f motion val 0 xy wrap 0 motion x s current picture f motion val 0 xy wrap 1 motion y s current picture f motion val 0 xy 1 wrap 0 motion x s current picture f motion val 0 xy 1 wrap 1 motion y if s encoding if s mv type MVTYPE 8 X8 s current picture f mb type mb xy MBTYPE L0 MBTYPE 8x8 else if s mb intra s current picture f mb type mb xy MBTYPEINTRA else s current picture f mb type mb xy MBTYPE L0 MBTYPE 16x16 static void ppp hdlc netdissect options ndo const u char p int length u char b s t c int i proto const void se if length 0 return b uint8 t malloc length if b NULL return for s u char p t b i length i 0 i c s if c 0x7d if i 1 i c s 0x20 else continue t c se ndo ndo snapend ndo ndo snapend t length t b if length 1 goto trunc proto b switch proto case PPPIP ip print ndo b 1 length 1 goto cleanup case PPPIP V6 ip6 print ndo b 1 length 1 goto cleanup default break if length 2 goto trunc proto EXTRACT 16 BITS b switch proto case PPPADDRESS 8 PPPCONTROL if length 4 goto trunc proto EXTRACT 16 BITS b 2 handle ppp ndo proto b 4 length 4 break default handle ppp ndo proto b 2 length 2 break cleanup ndo ndo snapend se free b return trunc ndo ndo snapend se free b NDPRINT ndo ppp int main int argc char argv Vpx Video Writer outfile VPXTSMAXLAYERSNULL vpx codec ctx t codec vpx codec enc cfg t cfg int frame cnt 0 vpx image t raw vpx codec err t res unsigned int width unsigned int height int speed int frame avail int got data int flags 0 unsigned int i int pts 0 int frame duration 1 int layering mode 0 int layer flags VPXTSMAXPERIODICITY 0 int flag periodicity 1 vpx svc layer id t layer id 0 0 const Vpx Interface encoder NULLFILE infile NULL struct Rate Control Metrics rc int64 t cx time 0 exec name argv 0 if argc 11 die Usage s infile outfile codec type vp8 vp9 width height rate num rate den speed frame drop threshold mode Rate 0 Rate nlayers 1 n argv 0 encoder get vpx encoder by name argv 3 if encoder die Unsupported codec printf Using s n vpx codec iface name encoder codec interface width strtol argv 4 NULL 0 height strtol argv 5 NULL 0 if width 16 width 2 height 16 height 2 die Invalid resolution d x d width height layering mode strtol argv 10 NULL 0 if layering mode 0 layering mode 12 die Invalid layering mode 0 12 s argv 10 if argc 11 mode to num layers layering mode die Invalid number of arguments if vpx img alloc raw VPXIMGFMT I420 width height 32 die Failed to allocate image width height res vpx codec enc config default encoder codec interface cfg 0 if res printf Failed to get config s n vpx codec err to string res return EXITFAILURE cfg g w width cfg g h height cfg g timebase num strtol argv 6 NULL 0 cfg g timebase den strtol argv 7 NULL 0 speed strtol argv 8 NULL 0 if speed 0 die Invalid speed setting must be positive for i 11 int i 11 mode to num layers layering mode i cfg ts target bitrate i 11 strtol argv i NULL 0 cfg rc dropframe thresh strtol argv 9 NULL 0 cfg rc end usage VPXCBR cfg rc resize allowed 0 cfg rc min quantizer 2 cfg rc max quantizer 56 cfg rc undershoot pct 50 cfg rc overshoot pct 50 cfg rc buf initial sz 500 cfg rc buf optimal sz 600 cfg rc buf sz 1000 cfg g error resilient 1 cfg g lag in frames 0 cfg kf mode VPXKFAUTO cfg kf min dist cfg kf max dist 3000 set temporal layer pattern layering mode cfg layer flags flag periodicity set rate control metrics rc cfg cfg rc target bitrate cfg ts target bitrate cfg ts number layers 1 if infile fopen argv 1 rb die Failed to open s for reading argv 1 for i 0 i cfg ts number layers i char file name PATHMAX Vpx Video Info info info codec fourcc encoder fourcc info frame width cfg g w info frame height cfg g h info time base numerator cfg g timebase num info time base denominator cfg g timebase den snprintf file name sizeof file name s d ivf argv 2 i outfile i vpx video writer open file name k Container IVF info if outfile i die Failed to open s for writing file name assert outfile i NULL cfg ss number layers 1 if vpx codec enc init codec encoder codec interface cfg 0 die codec codec Failed to initialize encoder if strncmp encoder name vp8 3 0 vpx codec control codec V P8 ESETCPUUSED speed vpx codec control codec V P8 ESETNOISESENSITIVITY k Denoiser On Y Only else if strncmp encoder name vp9 3 0 vpx codec control codec V P8 ESETCPUUSED speed vpx codec control codec V P9 ESETAQMODE 3 vpx codec control codec V P9 ESETFRAMEPERIODICBOOST 0 vpx codec control codec V P9 ESETNOISESENSITIVITY 0 if vpx codec control codec V P9 ESETSVC 1 die codec codec Failed to set SVC vpx codec control codec V P8 ESETSTATICTHRESHOLD 1 vpx codec control codec V P8 ESETTOKENPARTITIONS 1 const int max intra size pct 200 vpx codec control codec V P8 ESETMAXINTRABITRATEPCT max intra size pct frame avail 1 while frame avail got data struct vpx usec timer timer vpx codec iter t iter NULL const vpx codec cx pkt t pkt layer id spatial layer id 0 layer id temporal layer id cfg ts layer id frame cnt cfg ts periodicity if strncmp encoder name vp9 3 0 vpx codec control codec V P9 ESETSVCLAYERID layer id flags layer flags frame cnt flag periodicity frame avail vpx img read raw infile if frame avail rc layer input frames layer id temporal layer id vpx usec timer start timer if vpx codec encode codec frame avail raw NULL pts 1 flags VPXDLREALTIME die codec codec Failed to encode frame vpx usec timer mark timer cx time vpx usec timer elapsed timer if layering mode 7 layer flags 0 VPXEFLAGFORCEKF got data 0 while pkt vpx codec get cx data codec iter got data 1 switch pkt kind case VPXCODECCXFRAMEPKT for i cfg ts layer id frame cnt cfg ts periodicity i cfg ts number layers i vpx video writer write frame outfile i pkt data frame buf pkt data frame sz pts rc layer tot enc frames i rc layer encoding bitrate i 8 0 pkt data frame sz if i cfg ts layer id frame cnt cfg ts periodicity pkt data frame flags VPXFRAMEISKEY rc layer avg frame size i 8 0 pkt data frame sz rc layer avg rate mismatch i fabs 8 0 pkt data frame sz rc layer pfb i rc layer pfb i rc layer enc frames i break default break frame cnt pts frame duration fclose infile printout rate control summary rc cfg frame cnt printf n printf Frame cnt and encoding time FPS stats for encoding d f f n frame cnt float cx time double frame cnt 1000000 double frame cnt double cx time if vpx codec destroy codec die codec codec Failed to destroy codec for i 0 i cfg ts number layers i vpx video writer close outfile i vpx img free raw return enum Imap Auth Res imap auth cram md5 struct Imap Data idata const char method char ibuf LONGSTRING 2 obuf LONGSTRING unsigned char hmac response M D5 DIGESTLEN int len int rc if mutt bit isset idata capabilities ACRAMM D5 return IMAPAUTHUNAVAIL mutt message Authenticating CRAMM D5 if mutt account getlogin idata conn account 0 return IMAPAUTHFAILURE if mutt account getpass idata conn account 0 return IMAPAUTHFAILURE imap cmd start idata AUTHENTICATECRAMM D5 do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDRESPOND mutt debug 1 Invalid response from server s n ibuf goto bail len mutt b64 decode obuf idata buf 2 sizeof obuf if len 1 mutt debug 1 Error decoding base64 response n goto bail obuf len 0 mutt debug 2 CRAM challenge s n obuf hmac md5 idata conn account pass obuf hmac response int off snprintf obuf sizeof obuf s idata conn account user mutt md5 toascii hmac response obuf off mutt debug 2 CRAM response s n obuf mutt b64 encode ibuf obuf strlen obuf sizeof ibuf 2 mutt str strcat ibuf sizeof ibuf r n mutt socket send idata conn ibuf do rc imap cmd step idata while rc IMAPCMDCONTINUE if rc IMAPCMDOK mutt debug 1 Error receiving server response n goto bail if imap code idata buf return IMAPAUTHSUCCESS bail mutt error CRAMM D5 authentication failed return int y4m input fetch frame y4m input y4m FILE fin vpx image t img char frame 6 int pic sz int c w int c h int c sz int bytes per sample y4m bit depth 8 2 1 if file read frame 6 fin return 0 if memcmp frame FRAME 5 fprintf stderr Loss of framing in Y4 M input data n return 1 if frame 5 n char c int j for j 0 j 79 file read c 1 fin c n j if j 79 fprintf stderr Error parsing Y4 M frame header n return 1 if file read y4m dst buf y4m dst buf read sz fin fprintf stderr Error reading Y4 M frame data n return 1 if file read y4m aux buf y4m aux buf read sz fin fprintf stderr Error reading Y4 M frame data n return 1 y4m convert y4m y4m dst buf y4m aux buf memset img 0 sizeof img img fmt y4m vpx fmt img w img d w y4m pic w img h img d h y4m pic h img x chroma shift y4m dst c dec h 1 img y chroma shift y4m dst c dec v 1 img bps y4m bps pic sz y4m pic w y4m pic h bytes per sample c w y4m pic w y4m dst c dec h 1 y4m dst c dec h c w bytes per sample c h y4m pic h y4m dst c dec v 1 y4m dst c dec v c sz c w c h img stride PLANEY img stride PLANEALPHA y4m pic w bytes per sample img stride PLANEU img stride PLANEV c w img planes PLANEY y4m dst buf img planes PLANEU y4m dst buf pic sz img planes PLANEV y4m dst buf pic sz c sz img planes PLANEALPHA y4m dst buf pic sz 2 c sz return 1 void vp9 xform quant MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane const scan order const scan order vp9 default scan orders tx size tran low t const coeff BLOCKOFFSET p coeff block tran low t const qcoeff BLOCKOFFSET p qcoeff block tran low t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 16 X16 vp9 fdct16x16 src diff coeff diff stride vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 8 X8 vp9 fdct8x8 src diff coeff diff stride vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan break default assert 0 break static int read inter segment id V P9 COMMON const cm MACROBLOCKD const xd int mi row int mi col vp9 reader r struct segmentation const seg cm seg MBMODEINFO const mbmi xd mi 0 mbmi const BLOCKSIZE bsize mbmi sb type int predicted segment id segment id if seg enabled return 0 predicted segment id vp9 get segment id cm cm last frame seg map bsize mi row mi col if seg update map return predicted segment id if seg temporal update const vp9 prob pred prob vp9 get pred prob seg id seg xd mbmi seg id predicted vp9 read r pred prob segment id mbmi seg id predicted predicted segment id read segment id r seg else segment id read segment id r seg set segment id cm bsize mi row mi col segment id return segment id static int decode frame AV Codec Context avctx void data int got frame AV Packet pkt BMV Dec Context const c avctx priv data int type scr off int i ret uint8 t srcptr outptr c stream pkt data type bytestream get byte c stream if type BMVAUDIO int blobs bytestream get byte c stream if pkt size blobs 65 2 av log avctx AVLOGERROR Audio data doesn t fit in frame n return AVERRORINVALIDDATA c stream blobs 65 if type BMVCOMMAND int command size type BMVPRINT 8 10 if c stream pkt data command size pkt size av log avctx AVLOGERROR Command data doesn t fit in frame n return AVERRORINVALIDDATA c stream command size if type BMVPALETTE if c stream pkt data pkt size 768 av log avctx AVLOGERROR Palette data doesn t fit in frame n return AVERRORINVALIDDATA for i 0 i 256 i c pal i bytestream get be24 c stream if type BMVSCROLL if c stream pkt data pkt size 2 av log avctx AVLOGERROR Screen offset data doesn t fit in frame n return AVERRORINVALIDDATA scr off int16 t bytestream get le16 c stream else if type BMVINTRABMVINTRA scr off 640 else scr off 0 if c pic data 0 avctx release buffer avctx c pic c pic reference 3 if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret if decode bmv frame c stream pkt size c stream pkt data c frame scr off av log avctx AVLOGERROR Error decoding frame data n return AVERRORINVALIDDATA memcpy c pic data 1 c pal AVPALETTESIZE c pic palette has changed type BMVPALETTE outptr c pic data 0 srcptr c frame for i 0 i avctx height i memcpy outptr srcptr avctx width srcptr avctx width outptr c pic linesize 0 got frame 1 AV Frame data c pic return pkt size int unupack int upack char dest uint32 t dsize char buff uint32 t vma uint32 t ep uint32 t base uint32 t va int file int j searchval char loc esi loc edi NULL loc ebx end edi save edi alvalue char paddr pushed esi save2 uint32 t save1 save3 loc ecx count shlsize original ep ret loc ebx u struct cli exe section section int upack version UPACK 399 if upack uint32 t aljump shroff lngjmpoff if buff 5 xff buff 6 x36 upack version UPACK 0297729 loc esi dest cli readint32 buff 1 vma if CLIISCONTAINED dest dsize loc esi 12 return 1 original ep cli readint32 loc esi loc esi 4 loc esi 4 original ep vma cli dbgmsg Upack EP 08x original 08 X 08x n ep original ep cli readint32 loc esi 8 if upack version UPACK 399 loc edi dest cli readint32 loc esi vma if CLIISCONTAINED dest dsize dest ep 0xa 2 dest ep 0xa xeb return 1 loc esi dest dest ep 0xb ep 0xc alvalue loc esi 0x1a if CLIISCONTAINED dest dsize alvalue 2 alvalue xeb return 1 alvalue alvalue alvalue 0xff 1 0xa lngjmpoff 8 else if CLIISCONTAINED dest dsize dest ep 7 5 dest ep 7 xe9 return 1 loc esi dest cli readint32 dest ep 8 ep 0xc alvalue loc esi 0x25 lngjmpoff 10 if CLIISCONTAINED dest dsize alvalue 2 alvalue xb5 return 1 alvalue count alvalue 0xff if CLIISCONTAINED dest dsize alvalue lngjmpoff 5 alvalue lngjmpoff xe9 return 1 shlsize cli readint32 alvalue lngjmpoff 1 if upack version UPACK 399 shlsize shlsize loc esi dest loc esi 0x1b 0x1c 0x018 else shlsize shlsize loc esi dest 0x035 alvalue dest shlsize 43 aljump 8 shroff 24 if CLIISCONTAINED dest dsize alvalue 1 2 alvalue 1 xe3 alvalue dest shlsize 46 if CLIISCONTAINED dest dsize alvalue 1 2 alvalue 1 xe3 return 1 else if upack version UPACK 0297729 upack version UPACK 0151477 aljump 7 shroff 26 alvalue alvalue 0xff 1 if CLIISCONTAINED dest dsize alvalue aljump 5 alvalue aljump xe9 return 1 ret cli readint32 alvalue aljump 1 alvalue ret aljump 1 4 27 if upack version UPACK 0297729 alvalue 2 if CLIISCONTAINED dest dsize dest shlsize shroff 3 dest shlsize shroff xc1 dest shlsize shroff 1 xed return 1 shlsize dest shlsize shroff 2 0xff count 0x100 if shlsize 2 shlsize 8 cli dbgmsg Upack context bits out of bounds n return 1 cli dbgmsg Upack Context Bits parameter used with lzma 02x 02x n shlsize count if upack version UPACK 0297729 if CLIISCONTAINED dest dsize loc esi 6 10 loc esi 6 xbe loc esi 11 xbf return 1 if uint32 t cli readint32 loc esi 7 base uint32 t cli readint32 loc esi 7 vma return 1 loc edi dest cli readint32 loc esi 12 vma loc esi dest cli readint32 loc esi 7 base else if CLIISCONTAINED dest dsize loc esi 7 5 loc esi 7 xbe return 1 loc esi dest cli readint32 loc esi 8 vma if upack version UPACK 0297729 if CLIISCONTAINED dest dsize loc edi 0x58 24 4 count CLIISCONTAINED dest dsize loc esi 0x58 0x64 4 return 1 for j 0 j 0x16 j loc esi 4 loc edi 4 cli writeint32 loc edi cli readint32 loc esi else if CLIISCONTAINED dest dsize loc edi 0x9c 24 4 count CLIISCONTAINED dest dsize loc esi 0x9c 0x34 4 return 1 for j 0 j 0x27 j loc esi 4 loc edi 4 cli writeint32 loc edi cli readint32 loc esi save3 cli readint32 loc esi 4 paddr dest uint32 t cli readint32 loc edi 4 vma loc ebx loc edi cli writeint32 loc edi 0xffffffff loc edi 4 cli writeint32 loc edi 0 loc edi 4 for j 0 j 4 j loc edi 4 cli writeint32 loc edi 1 for j 0 unsigned int j count j loc edi 4 cli writeint32 loc edi 0x400 loc edi dest cli readint32 loc esi 0xc vma if upack version UPACK 0297729 loc edi dest vma base pushed esi loc edi end edi dest cli readint32 loc esi 0x34 vma if upack version UPACK 0297729 end edi dest cli readint32 loc esi 0x64 vma save3 cli readint32 loc esi 0x40 cli dbgmsg Upack data initialized before upack lzma call n if ret uint32 t unupack399 dest dsize 0 loc ebx 0 loc edi end edi shlsize paddr 0xffffffff return 1 else int ep jmp offs rep stosd count offs context bits offs loc esi dest vma ep if buff 0 xbe buff 5 xad buff 6 x8b buff 7 xf8 upack version UPACK 11 12 if upack version UPACK 11 12 ep jmp offs 0x1a4 rep stosd count offs 0x1b context bits offs 0x41 alvalue loc esi 0x184 else ep jmp offs 0x217 rep stosd count offs 0x3a context bits offs 0x5f alvalue loc esi 0x1c1 if CLIISCONTAINED dest dsize loc esi ep jmp offs 4 return 1 save1 cli readint32 loc esi ep jmp offs original ep loc esi dest ep jmp offs 4 original ep int32 t save1 cli dbgmsg Upack EP 08x original 08x n ep original ep count loc esi rep stosd count offs 0xff shlsize loc esi context bits offs 0xff shlsize 8 shlsize if shlsize 2 shlsize 8 cli dbgmsg Upack context bits out of bounds n return 1 count 0x100 cli dbgmsg Upack Context Bits parameter used with lzma 02x 02x n shlsize count if upack version UPACK 399 loc esi 4 loc ecx cli readint32 loc esi 2 cli writeint32 loc esi 2 0 if loc ecx cli dbgmsg Upack something s wrong report back n return 1 loc esi loc ecx 2 if CLIISCONTAINED dest dsize loc esi 12 return 1 cli dbgmsg Upack p p 08x 08x n loc esi dest cli readint32 loc esi base loc ebx u loc esi dest cli readint32 loc esi base cli dbgmsg Upack EBX 08x n loc ebx u loc esi 4 save2 loc edi dest cli readint32 loc esi base cli dbgmsg Upack DEST 08x 08x n cli readint32 loc esi cli readint32 loc esi base loc esi 4 j cli readint32 loc esi if j 0 cli dbgmsg Upack probably hand crafted data report back n return 1 loc esi 4 cli dbgmsg Upack ecx counter 08x n j if CLIISCONTAINED dest dsize loc esi j 4 CLIISCONTAINED dest dsize loc edi j count 4 return 1 for j loc edi 4 loc esi 4 cli writeint32 loc edi cli readint32 loc esi if CLIISCONTAINED dest dsize save2 8 return 1 loc ecx cli readint32 save2 save2 4 loc esi save2 do loc esi loc ebx u loc esi 4 while loc ecx if CLIISCONTAINED dest dsize loc esi 4 return 1 save1 cli readint32 loc esi loc esi 4 for j 0 uint32 t j count j loc edi 4 cli writeint32 loc edi save1 if CLIISCONTAINED dest dsize loc esi 0x10 4 return 1 cli writeint32 loc esi 0x10 uint32 t cli readint32 loc esi 0x10 loc ebx u loc ebx loc esi 0x14 loc esi save2 save edi loc edi dest uint32 t cli readint32 loc esi base loc esi 4 cli dbgmsg Upack before fixing n if CLIISCONTAINED dest dsize loc ebx 4 12 4 4 CLIISCONTAINED dest dsize loc esi 0x24 4 CLIISCONTAINED dest dsize loc esi 0x40 4 return 1 for j 2 j 6 j cli writeint32 loc ebx j 2 cli readint32 loc ebx j 2 paddr dest cli readint32 loc ebx 4 base save1 loc ecx pushed esi loc edi end edi dest cli readint32 loc esi 0x24 base vma cli readint32 loc ebx cli writeint32 loc ebx cli readint32 loc ebx 4 cli writeint32 loc ebx 4 vma else if upack version UPACK 11 12 cli dbgmsg Upack v 1 1 1 2 n loc esi dest 0x148 loc edi dest cli readint32 loc esi base loc esi 4 save edi loc edi paddr dest uint32 t cli readint32 loc esi base loc esi 4 loc edi 4 loc ebx loc edi if CLIISCONTAINED dest dsize loc edi 6 count 4 return 1 cli writeint32 loc edi 0xffffffff loc edi 4 cli writeint32 loc edi 0 loc edi 4 for j 0 j 4 j loc edi 4 cli writeint32 loc edi 1 for j 0 uint32 t j count j loc edi 4 cli writeint32 loc edi 0x400 loc edi dest cli readint32 loc esi base pushed esi loc edi loc esi 4 loc ecx 0 loc esi 4 end edi dest cli readint32 loc esi 0x28 base loc esi save edi cli dbgmsg Upack data initialized before upack lzma call n if ret uint32 t unupack399 dest dsize loc ecx loc ebx loc ecx loc edi end edi shlsize paddr 0xffffffff return 1 if upack version UPACK 399 save3 cli readint32 loc esi 0x40 else if upack version UPACK 11 12 save3 cli readint32 dest vma ep 0x174 loc ecx 0 if CLIISCONTAINED dest dsize alvalue 1 cli dbgmsg Upack alvalue out of bounds n return 1 searchval alvalue 0xff cli dbgmsg Upack loops 08x search value 02x n save3 searchval while save3 if CLIISCONTAINED dest dsize pushed esi loc ecx 1 cli dbgmsg Upack callfixerr p 08x p p n dest dsize dest dsize pushed esi loc ecx return 1 if pushed esi loc ecx xe8 pushed esi loc ecx xe9 char adr pushed esi loc ecx 1 loc ecx if CLIISCONTAINED dest dsize adr 4 cli dbgmsg Upack callfixerr n return 1 if cli readint32 adr 0xff searchval continue cli writeint32 adr E C32 C E32 uint32 t cli readint32 adr 0xffffff00 loc ecx 4 loc ecx 4 save3 else loc ecx section raw 0 section rva va section rsz end edi loc edi section vsz end edi loc edi if cli rebuildpe dest upack 0 va section 1 base original ep 0 0 file cli dbgmsg Upack Rebuilding failed n return 0 return 1 static void slurm rpc allocate resources slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESS slurm msg t response msg DEFTIMERS job desc msg t job desc msg job desc msg t msg data resource allocation response msg t alloc msg slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info int immediate job desc msg immediate bool do unlock false bool reject job false struct job record job ptr NULL uint16 t port slurm addr t resp addr char err msg NULL job submit user msg NULLSTARTTIMER if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if uid job desc msg user id validate slurm user uid error code ESLURMUSERIDMISSING error Security violation RESOURCEALLOCATE from uid d uid debug2 sched Processing RPCREQUESTRESOURCEALLOCATION from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTRESOURCEALLOCATE lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg error code ESLURMRESERVATIONBUSY error attempt to nest ALPS allocation on s d by uid d job desc msg alloc node job desc msg alloc sid uid int ff h264 decode ref pic list reordering H264 Context h int list index pic structure i print short term h print long term h for list 0 list h list count list for i 0 i h ref count list i COPYPICTURE h ref list list i h default ref list list i if get bits1 h gb int pred h curr pic num for index 0 index unsigned int reordering of pic nums idc get ue golomb 31 h gb unsigned int pic id int i Picture ref NULL if reordering of pic nums idc 3 break if index h ref count list av log h avctx AVLOGERROR reference count overflow n return 1 if reordering of pic nums idc 3 if reordering of pic nums idc 2 const unsigned int abs diff pic num get ue golomb h gb 1 int frame num if abs diff pic num h max pic num av log h avctx AVLOGERROR abs diff pic num overflow n return 1 if reordering of pic nums idc 0 pred abs diff pic num else pred abs diff pic num pred h max pic num 1 frame num pic num extract h pred pic structure for i h short ref count 1 i 0 i ref h short ref i assert ref reference assert ref long ref if ref frame num frame num ref reference pic structure break if i 0 ref pic id pred else int long idx pic id get ue golomb h gb long idx pic num extract h pic id pic structure if long idx 31 av log h avctx AVLOGERROR long term pic idx overflow n return 1 ref h long ref long idx assert ref ref reference if ref ref reference pic structure ref pic id pic id assert ref long ref i 0 else i 1 if i 0 av log h avctx AVLOGERROR reference picture missing during reorder n memset h ref list list index 0 sizeof Picture else for i index i 1 h ref count list i if ref long ref h ref list list i long ref ref pic id h ref list list i pic id break for i index i COPYPICTURE h ref list list i h ref list list i 1 COPYPICTURE h ref list list index ref if FIELDPICTURE pic as field h ref list list index pic structure else av log h avctx AVLOGERROR illegal reordering of pic nums idc n return 1 for list 0 list h list count list for index 0 index h ref count list index if h ref list list index f data 0 av log h avctx AVLOGERROR Missing reference picture n if h default ref list list 0 f data 0 COPYPICTURE h ref list list index h default ref list list 0 else return 1 return 0 void Default TTF English Names struct ttflangname dummy Spline Font sf time t now struct tm tm char buffer 200 if dummy names ttf copyright NULL dummy names ttf copyright 0 dummy names ttf copyright utf8 verify copy sf copyright if dummy names ttf family NULL dummy names ttf family 0 dummy names ttf family utf8 verify copy sf familyname if dummy names ttf subfamily NULL dummy names ttf subfamily 0 dummy names ttf subfamily utf8 verify copy SF Get Modifiers sf if dummy names ttf uniqueid NULL dummy names ttf uniqueid 0 time now tm localtime now sprintf buffer s s d d d BDF Foundry BDF Foundry TTF Foundry TTF Foundry Font Forge 2 0 sf fullname NULL sf fullname sf fontname tm tm mday tm tm mon 1 tm tm year 1900 dummy names ttf uniqueid copy buffer if dummy names ttf fullname NULL dummy names ttf fullname 0 dummy names ttf fullname utf8 verify copy sf fullname if dummy names ttf version NULL dummy names ttf version 0 if sf subfontcnt 0 sprintf buffer Version f double sf cidversion else if sf version NULL sprintf buffer Version 20s sf version else strcpy buffer Version 1 0 dummy names ttf version copy buffer if dummy names ttf postscriptname NULL dummy names ttf postscriptname 0 dummy names ttf postscriptname utf8 verify copy sf fontname static void h245 setup channels packet info pinfo channel info t upcoming channel lcl rtp dyn payload t rtp dyn payload NULL struct srtp info dummy srtp info NULL if upcoming channel lcl return if strcmp upcoming channel lcl data type str t38fax if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 t38 add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num return if upcoming channel lcl rfc2198 0 rtp dyn payload rtp dyn payload new rtp dyn payload insert rtp dyn payload upcoming channel lcl rfc2198 red 8000 if upcoming channel lcl srtp flag dummy srtp info wmem new0 wmem file scope struct srtp info if upcoming channel lcl media addr addr type ATNONE upcoming channel lcl media addr port 0 srtp add address pinfo upcoming channel lcl media addr addr upcoming channel lcl media addr port 0 H245 pinfo fd num upcoming channel lcl is video rtp dyn payload dummy srtp info if upcoming channel lcl media control addr addr type ATNONE upcoming channel lcl media control addr port 0 rtcp handle srtcp add address pinfo upcoming channel lcl media control addr addr upcoming channel lcl media control addr port 0 H245 pinfo fd num dummy srtp info extern int as mysql job complete mysql conn t mysql conn struct job record job ptr char query NULL int rc SLURMSUCCESS job state time t submit time end time uint32 t exit code 0 if job ptr db index job ptr details job ptr details submit time job ptr resize time error as mysql job complete Not inputing this job it has no submit time return SLURMERROR if check connection mysql conn SLURMSUCCESS return ESLURMDBCONNECTION debug2 as mysql slurmdb job complete called if job ptr resize time submit time job ptr resize time else submit time job ptr details submit time if ISJOBRESIZING job ptr end time job ptr resize time job state JOBRESIZING else if job ptr end time 0 if job ptr start time error s We are trying to end a job u with no end time setting it to the start time ld of the job func job ptr job id job ptr start time job ptr end time job ptr start time else error s job u never started func job ptr job id return SLURMSUCCESS end time job ptr end time if ISJOBREQUEUED job ptr job state JOBREQUEUE else if ISJOBREVOKED job ptr job state JOBREVOKED else job state job ptr job state JOBSTATEBASE slurm mutex lock rollup lock if end time global last rollup global last rollup job ptr end time slurm mutex unlock rollup lock query xstrdup printf update s s set hourly rollup ld daily rollup ld monthly rollup ld mysql conn cluster name last ran table end time end time end time if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query void mysql db query mysql conn query xfree query else slurm mutex unlock rollup lock if job ptr db index if job ptr db index get db index mysql conn submit time job ptr job id job ptr assoc id char comment job ptr comment job ptr comment NULL if as mysql job start mysql conn job ptr SLURMERROR job ptr comment comment error couldn t add job u at job completion job ptr job id return SLURMSUCCESS job ptr comment comment query xstrdup printf update s s set mod time UNIXTIMESTAMP time end ld state d mysql conn cluster name job table end time job state if job ptr derived ec NOVAL xstrfmtcat query derived ec u job ptr derived ec if job ptr comment xstrfmtcat query derived es s job ptr comment if job ptr admin comment xstrfmtcat query admin comment s job ptr admin comment exit code job ptr exit code if exit code 1 exit code 256 xstrfmtcat query exit code d kill requid d where job db inx PR Iu64 exit code job ptr requid job ptr db index if debug flags DEBUGFLAGDBJOBDBDEBUG mysql conn conn query n s query rc mysql db query mysql conn query xfree query return rc static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt LOCO Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data int decoded ret if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p key frame 1 switch l mode case LOCOCYU Y2 case LOCOYU Y2 case LOCOUYVY decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height p linesize 1 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height p linesize 2 buf buf size 1 break case LOCOCY V12 case LOCOY V12 decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 2 avctx width 2 avctx height 2 p linesize 2 buf buf size 1 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 1 avctx width 2 avctx height 2 p linesize 1 buf buf size 1 break case LOCOCRGB case LOCORGB decoded loco decode plane l p data 0 p linesize 0 avctx height 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 1 avctx width avctx height p linesize 0 buf buf size 3 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 p linesize 0 avctx height 1 2 avctx width avctx height p linesize 0 buf buf size 3 break case LOCORGBA decoded loco decode plane l p data 0 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 1 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 2 avctx width avctx height p linesize 0 buf buf size 4 if decoded buf size goto buf too small buf decoded buf size decoded decoded loco decode plane l p data 0 3 avctx width avctx height p linesize 0 buf buf size 4 break got frame 1 return buf size buf too small av log avctx AVLOGERROR Input data too small n return void bn mul comba4 BNULONG r BNULONG a BNULONG b BNULONG t1 t2 BNULONG c1 c2 c3 c1 0 c2 0 c3 0 mul add c a 0 b 0 c1 c2 c3 r 0 c1 c1 0 mul add c a 0 b 1 c2 c3 c1 mul add c a 1 b 0 c2 c3 c1 r 1 c2 c2 0 mul add c a 2 b 0 c3 c1 c2 mul add c a 1 b 1 c3 c1 c2 mul add c a 0 b 2 c3 c1 c2 r 2 c3 c3 0 mul add c a 0 b 3 c1 c2 c3 mul add c a 1 b 2 c1 c2 c3 mul add c a 2 b 1 c1 c2 c3 mul add c a 3 b 0 c1 c2 c3 r 3 c1 c1 0 mul add c a 3 b 1 c2 c3 c1 mul add c a 2 b 2 c2 c3 c1 mul add c a 1 b 3 c2 c3 c1 r 4 c2 c2 0 mul add c a 2 b 3 c3 c1 c2 mul add c a 3 b 2 c3 c1 c2 r 5 c3 c3 0 mul add c a 3 b 3 c1 c2 c3 r 6 c1 r 7 c2 static int isoent gen joliet identifier struct archive write a struct isoent isoent struct idr idr struct iso9660 iso9660 struct isoent np unsigned char p size t l int r size t ffmax parent len static const struct archive rb tree ops rb ops isoent cmp node joliet isoent cmp key joliet if isoent children cnt 0 return 0 iso9660 a format data if iso9660 opt joliet OPTJOLIETLONGNAME ffmax 206 else ffmax 128 r idr start a idr isoent children cnt int ffmax 6 2 rb ops if r 0 return r parent len 1 for np isoent np parent np np np parent parent len np mb len 1 for np isoent children first np NULL np np chnext unsigned char dot int ext off noff weight size t lt if l np file basename utf16 length ffmax l ffmax p malloc l 1 2 if p NULL archive set error a archive ENOMEM Can t allocate memory return ARCHIVEFATAL memcpy p np file basename utf16 s l p l 0 p l 1 0 np identifier char p lt l dot p l weight 0 while lt 0 if joliet allowed char p 0 p 1 archive be16enc p 0x005 F else if p 0 0 p 1 0x2 E dot p p 2 lt 2 ext off int dot unsigned char np identifier np ext off ext off np ext len int l ext off np id len int l if np file basename utf16 length ffmax if archive strncpy l iso9660 mbs const char np identifier l iso9660 sconv from utf16be 0 errno ENOMEM archive set error a archive errno No memory return ARCHIVEFATAL np mb len int iso9660 mbs length if np mb len int np file basename length weight np mb len else np mb len int np file basename length if parent len 240 np mb len 240 parent len np mb len 240 archive set error a archive ARCHIVEERRNOMISC The regulation of Joliet extensions A length of a full pathname of s is longer than 240 bytes p d b d archive entry pathname np file entry int parent len int np mb len return ARCHIVEFATAL if l ffmax noff ext off 6 else if l ffmax 2 noff ext off 4 else if l ffmax 4 noff ext off 2 else noff ext off idr register idr np weight noff idr resolve idr idr set num beutf16 return static int mv refs rt const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 int const motion 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col 1 const motion 1 for i MVREFNEIGHBOURS refmv count i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 if different ref found refmv count for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd return const motion static uint32 t nvic readl nvic state s uint32 t offset uint32 t val int irq switch offset case 4 return s num irq 32 1 case 0x10 val s systick control s systick control SYSTICKCOUNTFLAG return val case 0x14 return s systick reload case 0x18 int64 t t if s systick control SYSTICKENABLE 0 return 0 t qemu get clock ns vm clock if t s systick tick return 0 val s systick tick t 1 systick scale s 1 if val s systick reload val 0 return val case 0x1c return 10000 case 0xd00 return cpu single env cp15 c0 cpuid case 0xd04 val s gic running irq 0 if val 1023 val 0 else if val 32 val 16 if s gic running irq 0 1023 s gic last active s gic running irq 0 0 1023 val 1 11 if s gic current pending 0 1023 val s gic current pending 0 12 for irq 32 irq s num irq irq if s gic irq state irq pending val 1 22 break if s gic irq state ARM V7 MEXCPSYSTICK pending val 1 26 if s gic irq state ARM V7 MEXCPPENDSV pending val 1 28 if s gic irq state ARM V7 MEXCPNMI pending val 1 31 return val case 0xd08 return cpu single env v7m vecbase case 0xd0c return 0xfa05000 case 0xd10 return 0 case 0xd14 return 0 case 0xd24 val 0 if s gic irq state ARM V7 MEXCPMEM active val 1 0 if s gic irq state ARM V7 MEXCPBUS active val 1 1 if s gic irq state ARM V7 MEXCPUSAGE active val 1 3 if s gic irq state ARM V7 MEXCPSVC active val 1 7 if s gic irq state ARM V7 MEXCPDEBUG active val 1 8 if s gic irq state ARM V7 MEXCPPENDSV active val 1 10 if s gic irq state ARM V7 MEXCPSYSTICK active val 1 11 if s gic irq state ARM V7 MEXCPUSAGE pending val 1 12 if s gic irq state ARM V7 MEXCPMEM pending val 1 13 if s gic irq state ARM V7 MEXCPBUS pending val 1 14 if s gic irq state ARM V7 MEXCPSVC pending val 1 15 if s gic irq state ARM V7 MEXCPMEM enabled val 1 16 if s gic irq state ARM V7 MEXCPBUS enabled val 1 17 if s gic irq state ARM V7 MEXCPUSAGE enabled val 1 18 return val case 0xd28 qemu log mask LOGUNIMP Configurable Fault Status unimplemented n return 0 case 0xd2c case 0xd30 case 0xd34 case 0xd38 case 0xd3c qemu log mask LOGUNIMP Fault status registers unimplemented n return 0 case 0xd40 return 0x00000030 case 0xd44 return 0x00000200 case 0xd48 return 0x00100000 case 0xd4c return 0x00000000 case 0xd50 return 0x00000030 case 0xd54 return 0x00000000 case 0xd58 return 0x00000000 case 0xd5c return 0x00000000 case 0xd60 return 0x01141110 case 0xd64 return 0x02111000 case 0xd68 return 0x21112231 case 0xd6c return 0x01111110 case 0xd70 return 0x01310102 default qemu log mask LOGGUESTERRORNVIC Bad read offset 0x x n offset return 0 static int sdp parse fmtp config h264 AV Format Context s AV Stream stream Payload Context h264 data const char attr const char value AV Codec Parameters par stream codecpar if strcmp attr packetization mode av log s AVLOGDEBUGRTP Packetization Mode d n atoi value h264 data packetization mode atoi value if h264 data packetization mode 1 av log s AVLOGERROR Interleaved RTP mode is not supported yet n else if strcmp attr profile level id if strlen value 6 parse profile level id s h264 data value else if strcmp attr sprop parameter sets int ret if value strlen value 1 av log s AVLOGWARNING Missing PPS in sprop parameter sets ignoring n return 0 par extradata size 0 av freep par extradata ret ff h264 parse sprop parameter sets s par extradata par extradata size value av log s AVLOGDEBUG Extradata set to p size d n par extradata par extradata size return ret return 0 Jbig2 Segment jbig2 parse segment header Jbig2 Ctx ctx uint8 t buf size t buf size size t p header size Jbig2 Segment result uint8 t rtscarf uint32 t rtscarf long uint32 t referred to segments uint32 t referred to segment count uint32 t referred to segment size uint32 t pa size uint32 t offset if buf size 11 return NULL result jbig2 new ctx Jbig2 Segment 1 if result NULL jbig2 error ctx JBI G2 SEVERITYFATAL 1 failed to allocate segment in jbig2 parse segment header return result result number jbig2 get uint32 buf result flags buf 4 rtscarf buf 5 if rtscarf 0xe0 0xe0 rtscarf long jbig2 get uint32 buf 5 referred to segment count rtscarf long 0x1fffffff offset 5 4 referred to segment count 1 8 else referred to segment count rtscarf 5 offset 5 1 result referred to segment count referred to segment count referred to segment size result number 256 1 result number 65536 2 4 pa size result flags 0x40 4 1 if offset referred to segment count referred to segment size pa size 4 buf size jbig2 error ctx JBI G2 SEVERITYDEBUG result number jbig2 parse segment header called with insufficient data 1 jbig2 free ctx allocator result return NULL if referred to segment count uint32 t i referred to segments jbig2 new ctx uint32 t referred to segment count referred to segment size if referred to segments NULL jbig2 error ctx JBI G2 SEVERITYFATAL 1 could not allocate referred to segments in jbig2 parse segment header return NULL for i 0 i referred to segment count i referred to segments i referred to segment size 1 buf offset referred to segment size 2 jbig2 get uint16 buf offset jbig2 get uint32 buf offset offset referred to segment size jbig2 error ctx JBI G2 SEVERITYDEBUG result number segment d refers to segment d result number referred to segments i result referred to segments referred to segments else result referred to segments NULL if result flags 0x40 result page association jbig2 get uint32 buf offset offset 4 else result page association buf offset jbig2 error ctx JBI G2 SEVERITYDEBUG result number segment d is associated with page d result number result page association result data length jbig2 get uint32 buf offset p header size offset 4 result result NULL return result static int tgv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Tgv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int chunk type ret chunk type AVR L32 buf 0 buf EAPREAMBLESIZE if chunk type k VGTTAG int pal count i if buf 12 buf end av log avctx AVLOGWARNING truncated header n return AVERRORINVALIDDATA s width AVR L16 buf 0 s height AVR L16 buf 2 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height av freep s frame buffer av frame unref s last frame pal count AVR L16 buf 6 buf 12 for i 0 i pal count i AVPALETTECOUNT buf 2 buf end i s palette i AVR B24 buf buf 3 if ret av image check size s width s height 0 avctx 0 return ret if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 return ret memcpy frame data 1 s palette AVPALETTESIZE if chunk type k VGTTAG int y frame key frame 1 frame pict type AVPICTURETYPEI if s frame buffer s frame buffer av malloc s width s height return AVERRORENOMEM if unpack buf buf end s frame buffer s avctx width s avctx height 0 av log avctx AVLOGWARNING truncated intra frame n return AVERRORINVALIDDATA for y 0 y s height y memcpy frame data 0 y frame linesize 0 s frame buffer y s width s width else if s last frame data 0 av log avctx AVLOGWARNING inter frame without corresponding intra frame n return buf size frame key frame 0 frame pict type AVPICTURETYPEP if tgv decode inter s frame buf buf end 0 av log avctx AVLOGWARNING truncated inter frame n return AVERRORINVALIDDATA av frame unref s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size void min heap dtor min heap t s free s p static void rv34 pred mv R V34 Dec Context r int block type int subblock no int dmv no Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j int mx my int avail r avail cache avail indexes subblock no int c off part sizes w block type mv pos subblock no 1 subblock no 1 s b8 stride if subblock no 3 c off 1 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail c off 4 if avail 4 avail 1 r rv30 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride c off 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride c off 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv dmv no 0 my r dmv dmv no 1 for j 0 j part sizes h block type j for i 0 i part sizes w block type i s current picture ptr f motion val 0 mv pos i j s b8 stride 0 mx s current picture ptr f motion val 0 mv pos i j s b8 stride 1 my static int mimic decode update thread context AV Codec Context avctx const AV Codec Context avctx from Mimic Context dst avctx priv data src avctx from priv data if avctx avctx from return 0 dst cur index src next cur index dst prev index src next prev index memcpy dst buf ptrs src buf ptrs sizeof src buf ptrs memcpy dst flipped ptrs src flipped ptrs sizeof src flipped ptrs memset dst buf ptrs dst cur index 0 sizeof AV Frame return 0 static void configure static seg features V P9 COMP cpi V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc struct segmentation const seg cm seg int high q int rc avg q 48 0 int qi delta if cm frame type KEYFRAME vpx memset cpi segmentation map 0 cm mi rows cm mi cols seg update map 0 seg update data 0 cpi static mb pct 0 vp9 disable segmentation seg vp9 clearall segfeatures seg else if cpi refresh alt ref frame vpx memset cpi segmentation map 0 cm mi rows cm mi cols seg update map 0 seg update data 0 cpi static mb pct 0 vp9 disable segmentation seg vp9 clearall segfeatures seg vp9 update mbgraph stats cpi if seg enabled seg update map 1 seg update data 1 qi delta vp9 compute qdelta rc rc avg q rc avg q 0 875 vp9 set segdata seg 1 SEGLVLALTQ qi delta 2 vp9 set segdata seg 1 SEGLVLALTLF 2 vp9 enable segfeature seg 1 SEGLVLALTQ vp9 enable segfeature seg 1 SEGLVLALTLF seg abs delta SEGMENTDELTADATA else if seg enabled if rc frames since golden 0 if rc source alt ref active seg update map 0 seg update data 1 seg abs delta SEGMENTDELTADATA qi delta vp9 compute qdelta rc rc avg q rc avg q 1 125 vp9 set segdata seg 1 SEGLVLALTQ qi delta 2 vp9 enable segfeature seg 1 SEGLVLALTQ vp9 set segdata seg 1 SEGLVLALTLF 2 vp9 enable segfeature seg 1 SEGLVLALTLF if high q cpi static mb pct 100 vp9 set segdata seg 1 SEGLVLREFFRAMEALTREFFRAME vp9 enable segfeature seg 1 SEGLVLREFFRAME vp9 enable segfeature seg 1 SEGLVLSKIP else vp9 disable segmentation seg vpx memset cpi segmentation map 0 cm mi rows cm mi cols seg update map 0 seg update data 0 vp9 clearall segfeatures seg else if rc is src frame alt ref vp9 enable segfeature seg 0 SEGLVLREFFRAME vp9 enable segfeature seg 1 SEGLVLREFFRAME vp9 clear segdata seg 0 SEGLVLREFFRAME vp9 set segdata seg 0 SEGLVLREFFRAMEALTREFFRAME vp9 clear segdata seg 1 SEGLVLREFFRAME vp9 set segdata seg 1 SEGLVLREFFRAMEALTREFFRAME if high q vp9 enable segfeature seg 0 SEGLVLSKIP vp9 enable segfeature seg 1 SEGLVLSKIP seg update data 1 else seg update map 0 seg update data 0 void vp9 rd pick intra mode sb V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd struct macroblockd plane const pd xd plane int rate y 0 rate uv 0 rate y tokenonly 0 rate uv tokenonly 0 int y skip 0 uv skip 0 int64 t dist y 0 dist uv 0 tx cache TXMODES 0 TXSIZE max uv tx size x skip encode 0 ctx skip 0 xd mi 0 src mi mbmi ref frame 0 INTRAFRAME if bsize BLOCK 8 X8 if rd pick intra sby mode cpi x rate y rate y tokenonly dist y y skip bsize tx cache best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip bsize max uv tx size else y skip 0 if rd pick intra sub 8x8 y mode cpi x rate y rate y tokenonly dist y best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip BLOCK 8 X8 max uv tx size if y skip uv skip returnrate rate y rate uv rate y tokenonly rate uv tokenonly vp9 cost bit vp9 get skip prob cm xd 1 returndist dist y dist uv vp9 zero ctx tx rd diff else int i returnrate rate y rate uv vp9 cost bit vp9 get skip prob cm xd 0 returndist dist y dist uv if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i if tx cache i IN T64 MAX tx cache cm tx mode IN T64 MAX ctx tx rd diff i tx cache i tx cache cm tx mode else ctx tx rd diff i 0 ctx mic xd mi 0 src mi static int vp3 update thread context AV Codec Context dst const AV Codec Context src Vp3 Decode Context s dst priv data s1 src priv data int qps changed 0 i err if s s1 copy fields s s1 golden frame current frame return 1 void ff mpeg4 pred ac Mpeg Enc Context s int16 t block int n int dir int i int16 t ac val ac val1 int8 t const qscale table s current picture f qscale table ac val s ac val 0 0 s block index n 16 ac val1 ac val if s ac pred if dir 0 const int xy s mb x 1 s mb y s mb stride ac val 16 if s mb x 0 s qscale qscale table xy n 1 n 3 for i 1 i 8 i block s dsp idct permutation i 3 ac val i else for i 1 i 8 i block s dsp idct permutation i 3 ROUNDEDDIV ac val i qscale table xy s qscale else const int xy s mb x s mb y s mb stride s mb stride ac val 16 s block wrap n if s mb y 0 s qscale qscale table xy n 2 n 3 for i 1 i 8 i block s dsp idct permutation i ac val i 8 else for i 1 i 8 i block s dsp idct permutation i ROUNDEDDIV ac val i 8 qscale table xy s qscale for i 1 i 8 i ac val1 i block s dsp idct permutation i 3 for i 1 i 8 i ac val1 8 i block s dsp idct permutation i int set wep key char string int bit 0 char p type char tok char s strlen string 1 u char tmp wkey 512 size t tmp wkey len char tmp 128 memset GBLWIFI wkey 0 sizeof GBLWIFI wkey GBLWIFI wkey len 0 strcpy s string p ec strtok s tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key bit atoi p if bit 0 SEMIFATALERROR Unsupported WEP key length tmp wkey len bit 8 WEPIVLEN if bit 64 bit 128 SEMIFATALERROR Unsupported WEP key length p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key type p p ec strtok NULL tok if p NULLSEMIFATALERROR Invalid parsing of the WEP key if type s if strescape char tmp wkey p int tmp wkey len SEMIFATALERROR Specified WEP key length does not match the given string else if type p if bit 64 make key 64 u char p tmp wkey else if bit 128 make key 128 u char p tmp wkey else SEMIFATALERROR Invalid parsing of the WEP key USERMSG Using WEP key s n str tohex tmp wkey tmp wkey len tmp sizeof tmp memcpy GBLWIFI wkey tmp wkey sizeof GBLWIFI wkey GBLWIFI wkey len tmp wkey len return static void pred temp direct motion H264 Context const h int mb type int b8 stride 2 int b4 stride h b stride int mb xy h mb xy mb y h mb y int mb type col 2 const int16 t l1mv0 2 l1mv1 2 const int8 t l1ref0 l1ref1 const int is b8x8 IS 8 X8 mb type unsigned int sub mb type int i8 i4 assert h ref list 1 0 reference 3 await reference mb row h h ref list 1 0 h mb y ISINTERLACED mb type if ISINTERLACED h ref list 1 0 mb type mb xy if ISINTERLACED mb type mb y h mb y 1 h col parity mb xy h mb x h mb y 1 h col parity h mb stride b8 stride 0 else mb y h col fieldoff mb xy h mb stride h col fieldoff goto single col else if ISINTERLACED mb type mb y h mb y 1 mb xy h mb x h mb y 1 h mb stride mb type col 0 h ref list 1 0 mb type mb xy mb type col 1 h ref list 1 0 mb type mb xy h mb stride b8 stride 2 4 h mb stride b4 stride 6 if ISINTERLACED mb type col 0 ISINTERLACED mb type col 1 mb type col 0 MBTYPEINTERLACED mb type col 1 MBTYPEINTERLACED sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if mb type col 0 MBTYPE 16x16 ORINTRA mb type col 1 MBTYPE 16x16 ORINTRA is b8x8 mb type MBTYPE 16x8 MBTYPE L0 L1 MBTYPEDIREC T2 else mb type MBTYPE 8x8 MBTYPE L0 L1 else single col mb type col 0 mb type col 1 h ref list 1 0 mb type mb xy sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if is b8x8 mb type col 0 MBTYPE 16x16 ORINTRA mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 else if is b8x8 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 mb type MBTYPE L0 L1 MBTYPEDIREC T2 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 else if h sps direct 8x8 inference flag sub mb type MBTYPE 8x8 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 mb type MBTYPE 8x8 MBTYPE L0 L1 await reference mb row h h ref list 1 0 mb y l1mv0 h ref list 1 0 motion val 0 h mb2b xy mb xy l1mv1 h ref list 1 0 motion val 1 h mb2b xy mb xy l1ref0 h ref list 1 0 ref index 0 4 mb xy l1ref1 h ref list 1 0 ref index 1 4 mb xy if b8 stride if h mb y 1 l1ref0 2 l1ref1 2 l1mv0 2 b4 stride l1mv1 2 b4 stride const int map col to list0 2 h map col to list0 0 h map col to list0 1 const int dist scale factor h dist scale factor int ref offset if FRAMEMBAFFISINTERLACED mb type map col to list0 0 h map col to list0 field h mb y 1 0 map col to list0 1 h map col to list0 field h mb y 1 1 dist scale factor h dist scale factor field h mb y 1 ref offset h ref list 1 0 mbaff 4 mb type col 0 3 if ISINTERLACED mb type ISINTERLACED mb type col 0 int y shift 2 ISINTERLACED mb type assert h sps direct 8x8 inference flag for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col y8 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue ref0 l1ref0 x8 y8 b8 stride if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 x8 y8 b8 stride ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 const int16 t mv col l1mv x8 3 y8 b4 stride int my col mv col 1 y shift 2 int mx scale mv col 0 128 8 int my scale my col 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my my col 4 return if IS 16 X16 mb type int ref mv0 mv1 fill rectangle h ref cache 1 scan8 0 4 4 8 0 1 if ISINTRA mb type col 0 ref mv0 mv1 0 else const int ref0 l1ref0 0 0 map col to list0 0 l1ref0 0 ref offset map col to list0 1 l1ref1 0 ref offset const int scale dist scale factor ref0 const int16 t mv col l1ref0 0 0 l1mv0 0 l1mv1 0 int mv l0 2 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 ref ref0 mv0 pack16to32 mv l0 0 mv l0 1 mv1 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 fill rectangle h ref cache 0 scan8 0 4 4 8 ref 1 fill rectangle h mv cache 0 scan8 0 4 4 8 mv0 4 fill rectangle h mv cache 1 scan8 0 4 4 8 mv1 4 else for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col 0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue assert b8 stride 2 ref0 l1ref0 i8 if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 i8 ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 if ISSUB 8 X8 sub mb type const int16 t mv col l1mv x8 3 y8 3 b4 stride int mx scale mv col 0 128 8 int my scale mv col 1 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my mv col 1 4 else for i4 0 i4 4 i4 const int16 t mv col l1mv x8 2 i4 1 y8 2 i4 1 b4 stride int16 t mv l0 h mv cache 0 scan8 i8 4 i4 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 AVW N32 A h mv cache 1 scan8 i8 4 i4 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 static Asn1 Generic Decode Asn1 Der Sequence const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t d length parsed bytes numbytes el max size uint8 t c uint32 t seq index Asn1 Generic node d ptr node Asn1 Generic New if node NULL return NULL node type AS N1 SEQUENCE c d ptr 0 if c 1 7 7 0 d length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr d length numbytes errcode 1 SC Free node return NULL node length d length d ptr buffer if node length max size node length d length if errcode errcode ERRDERELEMENTSIZETOOBIGSC Free node return NULL parsed bytes 0 seq index 0 while parsed bytes d length el max size max size d ptr buffer Asn1 Generic child Decode Asn1 Der Generic d ptr el max size depth seq index errcode if child NULL if errcode errcode 0 Der Free node return NULL break int ret Asn1 Sequence Append node child if ret 1 Der Free child break parsed bytes child length d ptr child length seq index return Asn1 Generic node static int eightsvx decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Eight Svx Context esc avctx priv data AV Frame frame data int buf size int ch ret int is compr avctx codec id AVCODECIDPCM S8 PLANAR if avpkt data int hdr size is compr 2 0 int chan size avpkt size hdr size avctx channels avctx channels if avpkt size hdr size avctx channels av log avctx AVLOGERROR packet size is too small n return AVERROREINVAL if esc data 0 av log avctx AVLOGERROR unexpected data after first packet n return AVERROREINVAL if is compr esc fib acc 0 avpkt data 1 128 if avctx channels 2 esc fib acc 1 avpkt data 2 chan size 1 128 esc data idx 0 esc data size chan size if esc data 0 av malloc chan size return AVERRORENOMEM if avctx channels 2 if esc data 1 av malloc chan size av freep esc data 0 return AVERRORENOMEM memcpy esc data 0 avpkt data hdr size chan size if avctx channels 2 memcpy esc data 1 avpkt data 2 hdr size chan size chan size if esc data 0 av log avctx AVLOGERROR unexpected empty packet n return AVERROREINVAL buf size FFMINMAXFRAMESIZE esc data size esc data idx if buf size 0 got frame ptr 0 return avpkt size frame nb samples buf size is compr 1 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret for ch 0 ch avctx channels ch if is compr delta decode frame data ch esc data ch esc data idx buf size esc fib acc ch esc table else raw decode frame data ch esc data ch esc data idx buf size esc data idx buf size got frame ptr 1 return avpkt size static gboolean logcat read packet struct logcat phdr logcat FILET fh struct wtap pkthdr phdr Buffer buf int err gchar err info gint bytes read gint packet size guint16 payload length guint tmp 2 guint8 pd bytes read file read tmp 2 fh if bytes read 2 err file error fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return FALSE payload length pletoh16 tmp if logcat version 1 packet size 5 4 payload length else if logcat version 2 packet size 6 4 payload length else return FALSE buffer assure space buf packet size pd buffer start ptr buf memcpy pd tmp 2 bytes read file read pd 2 packet size 2 fh if bytes read packet size 2 err file error fh err info if err 0 err WTAPERRSHORTREAD return FALSE phdr rec type RECTYPEPACKET phdr presence flags WTAPHASTS phdr ts secs time t pletoh32 pd 12 phdr ts nsecs int pletoh32 pd 16 phdr caplen packet size phdr len packet size phdr pseudo header logcat version logcat version return static void temporal filter predictors mb c MACROBLOCKD xd uint8 t y mb ptr uint8 t u mb ptr uint8 t v mb ptr int stride int uv block width int uv block height int mv row int mv col uint8 t pred struct scale factors scale int x int y const int which mv 0 const MV mv mv row mv col const Interp Kernel const kernel vp9 get interp kernel xd mi 0 mbmi interp filter enum mv precision mv precision uv int uv stride if uv block width 8 uv stride stride 1 1 mv precision uv MVPRECISION Q4 else uv stride stride mv precision uv MVPRECISION Q3 vp9 build inter predictor y mb ptr stride pred 0 16 mv scale 16 16 which mv kernel MVPRECISION Q3 x y vp9 build inter predictor u mb ptr uv stride pred 256 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y vp9 build inter predictor v mb ptr uv stride pred 512 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y static int pefromupx const char src uint32 t ssize char dst uint32 t dsize uint32 t ep uint32 t upx0 uint32 t upx1 uint32 t magic uint32 t dend char imports sections NULL pehdr NULL newbuf unsigned int sectcnt 0 upd 1 uint32 t realstuffsz 0 valign 0 uint32 t foffset 0xd0 0xf8 if dst NULL src NULL return 0 while valign magic sectcnt if ep upx1 valign ssize 5 src ep upx1 valign 2 x8d src ep upx1 valign 1 xbe break if valign ep upx1 0x80 ssize 8 const char pt src ep upx1 0x80 cli dbgmsg UPX bad magic scanning for imports n while pt cli memstr pt ssize pt src 8 x8d xbe 2 if pt 6 x8b pt 7 x07 valign pt src 2 ep upx1 break pt if valign CLIISCONTAINED src ssize src ep upx1 valign 4 imports dst cli readint32 src ep upx1 valign realstuffsz imports dst if realstuffsz dsize cli dbgmsg UPX wrong realstuff size n else pehdr imports while CLIISCONTAINED dst dsize pehdr 8 cli readint32 pehdr pehdr 8 while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr while CLIISCONTAINED dst dsize pehdr 2 pehdr pehdr pehdr pehdr pehdr 4 if sections checkpe dst dsize pehdr valign sectcnt pehdr NULL if pehdr dend 0xf8 0x28 cli dbgmsg UPX no luck scanning for PE n pehdr dst dend 0xf8 0x28 while pehdr dst if sections checkpe dst dsize pehdr valign sectcnt break pehdr if realstuffsz pehdr dst pehdr NULL if pehdr uint32 t rebsz PESALIGN dend 0x1000 cli dbgmsg UPX no luck brutally crafing a reasonable PE n if newbuf char cli calloc rebsz 0x200 sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 FAKEPE 0x120 memcpy newbuf 0x200 dst dend memcpy dst newbuf dend 0x200 free newbuf cli writeint32 dst 0xd0 0x50 rebsz 0x1000 cli writeint32 dst 0xd0 0x100 rebsz cli writeint32 dst 0xd0 0x108 rebsz dsize rebsz 0x200 cli dbgmsg UPXPE structure added to uncompressed data n return 1 if sections sectcnt 0 foffset PESALIGN foffset 0x28 sectcnt valign for upd 0 upd sectcnt upd uint32 t vsize PESALIGN uint32 t cli readint32 sections 8 valign uint32 t urva PEALIGN uint32 t cli readint32 sections 12 valign if CLIISCONTAINED upx0 realstuffsz urva vsize cli dbgmsg UPX Sect d out of bounds giving up rebuild n upd return 0 cli writeint32 sections 8 vsize cli writeint32 sections 12 urva cli writeint32 sections 16 vsize cli writeint32 sections 20 foffset if foffset vsize foffset return 0 foffset vsize sections 0x28 cli writeint32 pehdr 8 0x4d414c43 cli writeint32 pehdr 0x3c valign if newbuf char cli calloc foffset sizeof char cli dbgmsg UPX malloc failed giving up rebuild n return 0 memcpy newbuf HEADERS 0xd0 memcpy newbuf 0xd0 pehdr 0xf8 0x28 sectcnt sections pehdr 0xf8 for upd 0 upd sectcnt upd uint32 t offset1 offset2 offset3 offset1 uint32 t cli readint32 sections 20 offset2 uint32 t cli readint32 sections 16 if offset1 foffset offset2 foffset offset1 offset2 foffset free newbuf return 1 offset3 uint32 t cli readint32 sections 12 if offset3 upx0 dsize free newbuf return 1 memcpy newbuf offset1 dst offset3 upx0 offset2 sections 0x28 if foffset dsize 8192 cli dbgmsg UPX wrong raw size giving up rebuild n free newbuf return 0 memcpy dst newbuf foffset dsize foffset free newbuf cli dbgmsg UPXPE structure rebuilt from compressed file n return 1 static void model rd for sb V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum int i int64 t rate sum 0 int64 t dist sum 0 const int ref xd mi 0 src mi mbmi ref frame 0 unsigned int sse unsigned int var 0 unsigned int sum sse 0 const int shift 8 int rate int64 t dist x pred sse ref 0 for i 0 i MAXMBPLANE i struct macroblock plane const p x plane i struct macroblockd plane const pd xd plane i const BLOCKSIZE bs get plane block size bsize pd const TXSIZE max tx size max txsize lookup bs const BLOCKSIZE unit size txsize to bsize max tx size int bw 1 b width log2 lookup bs b width log2 lookup unit size int bh 1 b height log2 lookup bs b width log2 lookup unit size int idx idy int lw b width log2 lookup unit size 2 int lh b height log2 lookup unit size 2 sum sse 0 for idy 0 idy bh idy for idx 0 idx bw idx uint8 t src p src buf idy p src stride lh idx lw uint8 t dst pd dst buf idy pd dst stride lh idx lh int block idx idy 1 idx var cpi fn ptr unit size vf src p src stride dst pd dst stride sse x bsse i 2 block idx sse sum sse sse if x select tx size if x bsse i 2 block idx p quant thred 0 shift x skip txfm i 2 block idx 1 else if var p quant thred 1 shift x skip txfm i 2 block idx 2 else x skip txfm i 2 block idx 0 if i 0 x pred sse ref sse if cpi oxcf speed 4 int64 t rate int64 t dist int64 t square error sse int quantizer pd dequant 1 3 if quantizer 120 rate square error 280 quantizer 8 else rate 0 dist square error quantizer 8 rate sum rate dist sum dist else vp9 model rd from var lapndz sum sse 1 num pels log2 lookup bs pd dequant 1 3 rate dist rate sum rate dist sum dist out rate sum int rate sum out dist sum dist sum 4 static inline picture t ffmpeg New Pict Buf decoder t p dec AV Codec Context p context decoder sys t p sys p dec p sys int width p context coded width int height p context coded height if p sys p va NULL int aligns AVNUMDATAPOINTERS avcodec align dimensions2 p context width height aligns if width 0 height 0 width 8192 height 8192 msg Err p dec Invalid frame size dx d width height return NULL p dec fmt out video i width width p dec fmt out video i height height if width p context width height p context height p dec fmt out video i visible width p context width p dec fmt out video i visible height p context height else p dec fmt out video i visible width width p dec fmt out video i visible height height if p sys p va Get Vlc Chroma p dec fmt out video p context pix fmt p dec fmt out video i chroma VLCCODEC I420 p dec fmt out i codec p dec fmt out video i chroma if p dec fmt in video i sar num 0 p dec fmt in video i sar den 0 p dec fmt out video i sar num p dec fmt in video i sar num p dec fmt out video i sar den p dec fmt in video i sar den else p dec fmt out video i sar num p context sample aspect ratio num p dec fmt out video i sar den p context sample aspect ratio den if p dec fmt out video i sar num p dec fmt out video i sar den p dec fmt out video i sar num 1 p dec fmt out video i sar den 1 if p dec fmt in video i frame rate 0 p dec fmt in video i frame rate base 0 p dec fmt out video i frame rate p dec fmt in video i frame rate p dec fmt out video i frame rate base p dec fmt in video i frame rate base p dec fmt out video i frame rate p context framerate num p dec fmt out video i frame rate base p context framerate den p dec fmt out video i frame rate p context time base den p dec fmt out video i frame rate base p context time base num MAX p context ticks per frame 1 static void fill mode info sb V P9 COMMON cm MACROBLOCK x int mi row int mi col BLOCKSIZE bsize BLOCKSIZE subsize PCTREE pc tree MACROBLOCKD xd x e mbd int bsl b width log2 bsize hbs 1 bsl 4 PARTITIONTYPE partition pc tree partitioning assert bsize BLOCK 8 X8 if mi row cm mi rows mi col cm mi cols return switch partition case PARTITIONNONE set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree none mic duplicate mode info in sb cm xd mi row mi col bsize break case PARTITIONVERT set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree vertical 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi col hbs cm mi cols set modeinfo offsets cm xd mi row mi col hbs xd mi 0 src mi pc tree vertical 1 mic duplicate mode info in sb cm xd mi row mi col hbs bsize break case PARTITIONHORZ set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree horizontal 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi row hbs cm mi rows set modeinfo offsets cm xd mi row hbs mi col xd mi 0 src mi pc tree horizontal 1 mic duplicate mode info in sb cm xd mi row hbs mi col bsize break case PARTITIONSPLITBLOCKSIZE subsubsize get subsize subsize PARTITIONSPLIT fill mode info sb cm x mi row mi col subsize subsubsize pc tree split 0 fill mode info sb cm x mi row mi col hbs subsize subsubsize pc tree split 1 fill mode info sb cm x mi row hbs mi col subsize subsubsize pc tree split 2 fill mode info sb cm x mi row hbs mi col hbs subsize subsubsize pc tree split 3 break default break void ff h264 filter mb H264 Context h int mb x int mb y uint8 t img y uint8 t img cb uint8 t img cr unsigned int linesize unsigned int uvlinesize const int mb xy mb x mb y h mb stride const int mb type h cur pic f mb type mb xy const int mvy limit ISINTERLACED mb type 2 4 int first vertical edge done 0 av unused int dir int chroma CONFIGGRAY h flags CODECFLAGGRAY int qp bd offset 6 h sps bit depth luma 8 int a h slice alpha c0 offset qp bd offset int b h slice beta offset qp bd offset if FRAMEMBAFFISINTERLACED mb type h left type LTOP h left type LTOPDECLAREALIGNED 8 int16 t b S 8 int qp 2 int bqp 2 int rqp 2 int mb qp mbn0 qp mbn1 qp int i first vertical edge done 1 if ISINTRA mb type AVW N64 A b S 0 0x0004000400040004 ULLAVW N64 A b S 4 0x0004000400040004 ULL else static const uint8 t offset 2 2 8 3 4 0 3 4 0 3 4 0 3 4 0 3 4 1 3 4 1 3 4 1 3 4 1 3 4 2 3 4 2 3 4 2 3 4 2 3 4 3 3 4 3 3 4 3 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 3 4 0 3 4 1 3 4 2 3 4 3 const uint8 t off offset MBFIELD mb y 1 for i 0 i 8 i int j MBFIELD i 2 i 1 int mbn xy h left mb xy LEFT j int mbn type h left type LEFT j if ISINTRA mbn type b S i 4 else b S i 1 h non zero count cache 12 8 i 1 h pps cabac IS 8x8 DCT mbn type h cbp table mbn xy MBFIELD i 2 mb y 1 8 2 12 h non zero count mbn xy off i mb qp h cur pic f qscale table mb xy mbn0 qp h cur pic f qscale table h left mb xy 0 mbn1 qp h cur pic f qscale table h left mb xy 1 qp 0 mb qp mbn0 qp 1 1 bqp 0 get chroma qp h 0 mb qp get chroma qp h 0 mbn0 qp 1 1 rqp 0 get chroma qp h 1 mb qp get chroma qp h 1 mbn0 qp 1 1 qp 1 mb qp mbn1 qp 1 1 bqp 1 get chroma qp h 0 mb qp get chroma qp h 0 mbn1 qp 1 1 rqp 1 get chroma qp h 1 mb qp get chroma qp h 1 mbn1 qp 1 1 tprintf h avctx filter mb d d MBAFFQ Py d d Q Pb d d Q Pr d d ls d uvls d mb x mb y qp 0 qp 1 bqp 0 bqp 1 rqp 0 rqp 1 linesize uvlinesize int i for i 0 i 8 i tprintf h avctx b S d d i b S i tprintf h avctx n if MBFIELD filter mb mbaff edgev h img y linesize b S 1 qp 0 a b 1 filter mb mbaff edgev h img y 8 linesize linesize b S 4 1 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgev h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgev h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgev h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else if CHROM A422 filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 8 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 8 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgecv h img cb uvlinesize b S 1 bqp 0 a b 1 filter mb mbaff edgecv h img cb 4 uvlinesize uvlinesize b S 4 1 bqp 1 a b 1 filter mb mbaff edgecv h img cr uvlinesize b S 1 rqp 0 a b 1 filter mb mbaff edgecv h img cr 4 uvlinesize uvlinesize b S 4 1 rqp 1 a b 1 else filter mb mbaff edgev h img y 2 linesize b S 2 qp 0 a b 1 filter mb mbaff edgev h img y linesize 2 linesize b S 1 2 qp 1 a b 1 if chroma if CHROM A444 filter mb mbaff edgev h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgev h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgev h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgev h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 else filter mb mbaff edgecv h img cb 2 uvlinesize b S 2 bqp 0 a b 1 filter mb mbaff edgecv h img cb uvlinesize 2 uvlinesize b S 1 2 bqp 1 a b 1 filter mb mbaff edgecv h img cr 2 uvlinesize b S 2 rqp 0 a b 1 filter mb mbaff edgecv h img cr uvlinesize 2 uvlinesize b S 1 2 rqp 1 a b 1 dir 2 dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit dir 0 first vertical edge done a b chroma dir filter mb dir h mb x mb y img y img cb img cr linesize uvlinesize mb xy mb type mvy limit 0 a b chroma 1 static void choose tx size from rd V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t psse int64 t tx cache TXMODES int64 t ref best rd BLOCKSIZE bs const TXSIZE max tx size max txsize lookup bs V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi vp9 prob skip prob vp9 get skip prob cm xd int r TXSIZES 2 s TXSIZES int64 t d TXSIZES sse TXSIZES int64 t rd TXSIZES 2 IN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAXIN T64 MAX int n m int s0 s1 const TXSIZE max mode tx size tx mode to biggest tx size cm tx mode int64 t best rd IN T64 MAXTXSIZE best tx max tx size const vp9 prob tx probs get tx probs2 max tx size xd cm fc tx probs assert skip prob 0 s0 vp9 cost bit skip prob 0 s1 vp9 cost bit skip prob 1 for n max tx size n 0 n txfm rd in plane x r n 0 d n s n sse n ref best rd 0 bs n cpi sf use fast coef costing r n 1 r n 0 if r n 0 INTMAX for m 0 m n n int max tx size m if m n r n 1 vp9 cost zero tx probs m else r n 1 vp9 cost one tx probs m if d n IN T64 MAX rd n 0 rd n 1 IN T64 MAX else if s n rd n 0 rd n 1 RDCOST x rdmult x rddiv s1 d n else rd n 0 RDCOST x rdmult x rddiv r n 0 s0 d n rd n 1 RDCOST x rdmult x rddiv r n 1 s0 d n if cpi sf tx size search breakout rd n 1 IN T64 MAX n int max tx size rd n 1 rd n 1 1 s n 1 break if rd n 1 best rd best tx n best rd rd n 1 mbmi tx size cm tx mode TXMODESELECT best tx MIN max tx size max mode tx size distortion d mbmi tx size rate r mbmi tx size cm tx mode TXMODESELECT skip s mbmi tx size psse sse mbmi tx size tx cache ONLY 4 X4 rd TX 4 X4 0 tx cache ALLOW 8 X8 rd TX 8 X8 0 tx cache ALLOW 16 X16 rd MIN max tx size TX 16 X16 0 tx cache ALLOW 32 X32 rd MIN max tx size TX 32 X32 0 if max tx size TX 32 X32 best tx TX 32 X32 tx cache TXMODESELECT rd TX 32 X32 1 else if max tx size TX 16 X16 best tx TX 16 X16 tx cache TXMODESELECT rd TX 16 X16 1 else if rd TX 8 X8 1 rd TX 4 X4 1 tx cache TXMODESELECT rd TX 8 X8 1 else tx cache TXMODESELECT rd TX 4 X4 1 static void build inter predictors for planes MACROBLOCKD xd BLOCKSIZE bsize int mi row int mi col int plane from int plane to int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane plane from plane plane to plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 src mi mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static int decode cabac field decoding flag H264 Context h const long mbb xy h mb xy 2 L h mb stride unsigned long ctx 0 ctx h mb field decoding flag h mb x ctx h cur pic mb type mbb xy 7 h slice table mbb xy h slice num return get cabac noinline h cabac h cabac state 70 ctx static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Dxa Dec Context const c avctx priv data uint8 t outptr srcptr tmpptr unsigned long dsize int i j compr ret int stride int orig buf size buf size int pc 0 if buf 0 C buf 1 M buf 2 A buf 3 P int r g b buf 4 for i 0 i 256 i r buf g buf b buf c pal i r 16 g 8 b pc 1 buf size 768 4 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed pc outptr frame data 0 srcptr c decomp buf tmpptr c prev data 0 stride frame linesize 0 if buf 0 N buf 1 U buf 2 L buf 3 L compr 1 else compr buf 4 dsize c dsize if compr 4 compr 1 uncompress c decomp buf dsize buf 9 buf size 9 ZOK av log avctx AVLOGERROR Uncompress failed n return AVERRORUNKNOWN switch compr case 1 frame key frame 0 frame pict type AVPICTURETYPEP if c prev data 0 memcpy frame data 0 c prev data 0 frame linesize 0 avctx height else memset frame data 0 0 frame linesize 0 avctx height frame key frame 1 frame pict type AVPICTURETYPEI break case 2 case 3 case 4 case 5 frame key frame compr 1 frame pict type compr 1 AVPICTURETYPEPAVPICTURETYPEI for j 0 j avctx height j if compr 1 for i 0 i avctx width i outptr i srcptr i tmpptr i tmpptr stride else memcpy outptr srcptr avctx width outptr stride srcptr avctx width break case 12 case 13 frame key frame 0 frame pict type AVPICTURETYPEP decode 13 avctx c frame data 0 frame linesize 0 srcptr c prev data 0 break default av log avctx AVLOGERROR Unknown unsupported compression type d n buf 4 return AVERRORINVALIDDATA av frame unref c prev if ret av frame ref c prev frame 0 return ret got frame 1 return orig buf size static void single motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv MACROBLOCKD xd x e mbd const V P9 COMMON cm cpi common MBMODEINFO mbmi xd mi 0 mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 int bestsme INTMAX int step param int sadpb x sadperbit16 MV mvp full int ref mbmi ref frame 0 MV ref mv mbmi ref mvs ref 0 as mv int tmp col min x mv col min int tmp col max x mv col max int tmp row min x mv row min int tmp row max x mv row max int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref MV pred mv 3 pred mv 0 mbmi ref mvs ref 0 as mv pred mv 1 mbmi ref mvs ref 1 as mv pred mv 2 x pred mv ref if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv if cpi sf mv auto mv step size cm show frame step param vp9 init search range x max mv context ref cpi mv step param 2 else step param cpi mv step param if cpi sf adaptive motion search bsize BLOCK 64 X64 int boffset 2 b width log2 BLOCK 64 X64 MIN b height log2 bsize b width log2 bsize step param MAX step param boffset if cpi sf adaptive motion search int bwl b width log2 bsize int bhl b height log2 bsize int i int tlevel x pred mv sad ref bwl bhl 4 if tlevel 5 step param 2 for i LASTFRAME i ALTREFFRAME cm show frame i if x pred mv sad ref 3 x pred mv sad i x pred mv ref row 0 x pred mv ref col 0 tmp mv as int INVALIDMV if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return mvp full pred mv x mv best ref index ref mvp full col 3 mvp full row 3 bestsme vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 1 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max if bestsme INTMAX int dis cpi find fractional mv step x tmp mv as mv ref mv cm allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 rate mv vp9 mv bit cost tmp mv as mv ref mv x nmvjointcost x mvcost MVCOSTWEIGHT if cpi sf adaptive motion search x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Anm Context s avctx priv data const int buf size avpkt size uint8 t dst dst end int count ret if ret avctx reget buffer avctx s frame 0 av log avctx AVLOGERROR get buffer failed n return ret dst s frame data 0 dst end s frame data 0 s frame linesize 0 avctx height bytestream2 init s gb avpkt data buf size if bytestream2 get byte s gb 0x42 av log ask for sample avctx unknown record type n return buf size if bytestream2 get byte s gb av log ask for sample avctx padding bytes not supported n return buf size bytestream2 skip s gb 2 s x 0 do count type 0x7 F type 7 if count if OP type NULL s gb 1 count break else if type int pixel count bytestream2 get byte s gb pixel bytestream2 get byte s gb if OPNULL pixel count break else int pixel type bytestream2 get le16 s gb count type 0x3 FFF type 14 if count if type 0 break if type 2 av log ask for sample avctx unknown opcode return AVERRORPATCHWELCOME continue pixel type 3 bytestream2 get byte s gb 1 if type 1 count 0x4000 if OP type 2 s gb NULL pixel count break while bytestream2 get bytes left s gb 0 memcpy s frame data 1 s palette AVPALETTESIZE got frame 1 AV Frame data s frame return buf size int ff mpeg update thread context AV Codec Context dst const AV Codec Context src int i ret Mpeg Enc Context s dst priv data s1 src priv data if dst src s1 context initialized return 0 if s context initialized memcpy s s1 sizeof Mpeg Enc Context s avctx dst s bitstream buffer NULL s bitstream buffer size s allocated bitstream buffer size 0 ff MPV common init s if s height s1 height s width s1 width s context reinit int err s context reinit 0 s height s1 height s width s1 width if err ff MPV common frame size change s 0 return err s avctx coded height s1 avctx coded height s avctx coded width s1 avctx coded width s avctx width s1 avctx width s avctx height s1 avctx height s coded picture number s1 coded picture number s picture number s1 picture number s input picture number s1 input picture number for i 0 i MAXPICTURECOUNT i ff mpeg unref picture s s picture i if s1 picture i f data 0 ret ff mpeg ref picture s s picture i s1 picture i 0 return ret ff mpeg unref picture s s pic if s1 pic f data 0 ret ff mpeg ref picture s s pic s1 pic else ret update picture tables s pic s1 pic if ret 0 return ret void do exec struct st command command int error char buf 512 FILE res file char cmd command first argument DYNAMICSTRING ds cmd DYNAMICSTRING ds sorted ds result DBUGENTER do exec DBUGPRINT enter cmd s cmd while cmd my isspace charset info cmd cmd if cmd report or die Missing argument in exec return command last argument command end init dynamic string ds cmd 0 command query len 256 256 do eval ds cmd cmd command end is windows if builtin echo 0 strncmp cmd echo 4 0 replace ds cmd echo 4 builtin echo strlen builtin echo while replace ds cmd 3 4 3 0 DBUGPRINT info Executing s as s command first argument ds cmd str if res file my popen ds cmd r dynstr free ds cmd if command abort on error report or die popen s r failed command first argument return ds result ds res if display result sorted init dynamic string ds sorted 1024 1024 ds result ds sorted while fgets buf sizeof buf res file if disable result log buf strlen buf 1 0 DBUGPRINT exec result s buf else replace dynstr append ds result buf error pclose res file if display result sorted dynstr append sorted ds res ds sorted 0 dynstr free ds sorted if error 0 uint status WEXITSTATUS error int i if command abort on error report or die exec of s failed error d status d errno d n Output from before failure n s n ds cmd str error status errno ds res str dynstr free ds cmd return DBUGPRINT info error d status d error status i match expected error command status NULL if i 0 DBUGPRINT info command s failed with expected error d command first argument status else dynstr free ds cmd if command expected errors count 0 report or die command s failed with wrong error d command first argument status else if command expected errors err 0 type ERRERRNO command expected errors err 0 code errnum 0 log msg exec of s failed error d errno d ds cmd str error errno dynstr free ds cmd report or die command s succeeded should have failed with errno d command first argument command expected errors err 0 code errnum dynstr free ds cmd static gpg error t parse keyblock image iobuf t iobuf int pk no int uid no const u32 sigstatus kbnode t r keyblock gpg error t err PACKET pkt kbnode t keyblock NULL kbnode t node tail int in cert save mode u32 n sigs int pk count uid count r keyblock NULL pkt xtrymalloc sizeof pkt if pkt return gpg error from syserror init packet pkt save mode set packet list mode 0 in cert 0 n sigs 0 tail NULL pk count uid count 0 while err parse packet iobuf pkt 1 if gpg err code err GPGERRUNKNOWNPACKET free packet pkt init packet pkt continue if err log error parse keyblock image read error s n gpg strerror err err gpg error GPGERRINVKEYRING break switch pkt pkttype case PKTPUBLICKEY case PKTPUBLICSUBKEY case PKTSECRETKEY case PKTSECRETSUBKEY case PKTUSERID case PKTATTRIBUTE case PKTSIGNATURE break default log error skipped packet of type d in keybox n int pkt pkttype free packet pkt init packet pkt continue if in cert pkt pkttype PKTPUBLICKEY log error parse keyblock image first packet in a keybox blob is not a public key packet n err gpg error GPGERRINVKEYRING break if in cert pkt pkttype PKTPUBLICKEY pkt pkttype PKTSECRETKEY log error parse keyblock image multiple keyblocks in a keybox blob n err gpg error GPGERRINVKEYRING break in cert 1 if pkt pkttype PKTSIGNATURE sigstatus PKT signature sig pkt pkt signature n sigs if n sigs sigstatus 0 log error parse keyblock image more signatures than found in the meta data n err gpg error GPGERRINVKEYRING break if sigstatus n sigs sig flags checked 1 if sigstatus n sigs 1 else if sigstatus n sigs 2 else if sigstatus n sigs 0x10000000 else sig flags valid 1 node new kbnode pkt switch pkt pkttype case PKTPUBLICKEY case PKTPUBLICSUBKEY case PKTSECRETKEY case PKTSECRETSUBKEY if pk count pk no node flag 1 break case PKTUSERID if uid count uid no node flag 2 break default break if keyblock keyblock node else tail node tail node next pkt xtrymalloc sizeof pkt if pkt err gpg error from syserror break init packet pkt set packet list mode save mode if err 1 keyblock err 0 if err sigstatus n sigs sigstatus 0 log error parse keyblock image signature count does not match n err gpg error GPGERRINVKEYRING if err release kbnode keyblock else r keyblock keyblock free packet pkt xfree pkt return err void ff estimate p frame motion Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me uint8 t pix ppix int sum mx my dmin int varc int vard int P 10 2 const int shift 1 s quarter sample int mb type 0 Picture const pic s current picture init ref c s new picture f data s last picture f data NULL 16 mb x 16 mb y 0 assert s quarter sample 0 s quarter sample 1 assert s linesize c stride assert s uvlinesize c uvstride c penalty factor get penalty factor s lambda s lambda2 c avctx me cmp c sub penalty factor get penalty factor s lambda s lambda2 c avctx me sub cmp c mb penalty factor get penalty factor s lambda s lambda2 c avctx mb cmp c current mv penalty c mv penalty s f code MAXMV get limits s 16 mb x 16 mb y c skip 0 pix c src 0 0 sum s dsp pix sum pix s linesize varc s dsp pix norm1 pix s linesize unsigned sum sum 8 500 pic mb mean s mb stride mb y mb x sum 128 8 pic mb var s mb stride mb y mb x varc 128 8 c mb var sum temp varc 128 8 switch s me method case MEZERO default mx 0 my 0 dmin 0 break case ME X1 case MEEPZS const int mot stride s b8 stride const int mot xy s block index 0 PLEFT 0 s current picture motion val 0 mot xy 1 0 PLEFT 1 s current picture motion val 0 mot xy 1 1 if PLEFT 0 c xmax shift PLEFT 0 c xmax shift if s first slice line PTOP 0 s current picture motion val 0 mot xy mot stride 0 PTOP 1 s current picture motion val 0 mot xy mot stride 1 PTOPRIGHT 0 s current picture motion val 0 mot xy mot stride 2 0 PTOPRIGHT 1 s current picture motion val 0 mot xy mot stride 2 1 if PTOP 1 c ymax shift PTOP 1 c ymax shift if PTOPRIGHT 0 c xmin shift PTOPRIGHT 0 c xmin shift if PTOPRIGHT 1 c ymax shift PTOPRIGHT 1 c ymax shift PMEDIAN 0 mid pred PLEFT 0 PTOP 0 PTOPRIGHT 0 PMEDIAN 1 mid pred PLEFT 1 PTOP 1 PTOPRIGHT 1 if s out format FMT H263 c pred x PMEDIAN 0 c pred y PMEDIAN 1 else c pred x PLEFT 0 c pred y PLEFT 1 else c pred x PLEFT 0 c pred y PLEFT 1 dmin ff epzs motion search s mx my P 0 0 s p mv table 1 16 shift 0 16 break ppix c ref 0 0 my s linesize mx vard s dsp sse 0 NULL pix ppix s linesize 16 pic mc mb var s mb stride mb y mb x vard 128 8 c mc mb var sum temp vard 128 8 if mb type int p score FFMIN vard varc 500 s lambda2 FFLAMBDASHIFT 100 int i score varc 500 s lambda2 FFLAMBDASHIFT 20 c scene change score ff sqrt p score ff sqrt i score if mb type CANDIDATEMBTYPEINTER c sub motion search s mx my dmin 0 0 0 16 set p mv tables s mx my 1 else mx shift my shift if mb type CANDIDATEMBTYPEINTE R4 V h263 mv4 search s mx my shift set p mv tables s mx my 0 if mb type CANDIDATEMBTYPEINTERI interlaced search s 0 s p field mv table s p field select table mx my 1 else if c avctx mb decision FFMBDECISIONSIMPLE int p score FFMIN vard varc 500 s lambda2 FFLAMBDASHIFT 100 int i score varc 500 s lambda2 FFLAMBDASHIFT 20 c scene change score ff sqrt p score ff sqrt i score if vard 2 200 256 varc mb type CANDIDATEMBTYPEINTRA if varc 2 200 256 vard s qscale 24 mb type CANDIDATEMBTYPEINTER c sub motion search s mx my dmin 0 0 0 16 if s flags CODECFLAGM V0 if mx my mb type CANDIDATEMBTYPESKIPPED else mx shift my shift if s flags CODECFLAG 4 MV c skip varc 50 8 vard 10 8 if h263 mv4 search s mx my shift INTMAX mb type CANDIDATEMBTYPEINTE R4 V set p mv tables s mx my 0 else set p mv tables s mx my 1 if s flags CODECFLAGINTERLACEDME c skip if interlaced search s 0 s p field mv table s p field select table mx my 0 INTMAX mb type CANDIDATEMBTYPEINTERI else int intra score i mb type CANDIDATEMBTYPEINTER dmin c sub motion search s mx my dmin 0 0 0 16 if c avctx me sub cmp c avctx mb cmp c skip dmin get mb score s mx my 0 0 0 16 1 if s flags CODECFLAG 4 MV c skip varc 50 8 vard 10 8 int dmin4 h263 mv4 search s mx my shift if dmin4 dmin mb type CANDIDATEMBTYPEINTE R4 V dmin dmin4 if s flags CODECFLAGINTERLACEDME c skip int dmin i interlaced search s 0 s p field mv table s p field select table mx my 0 if dmin i dmin mb type CANDIDATEMBTYPEINTERI dmin dmin i set p mv tables s mx my mb type CANDIDATEMBTYPEINTE R4 V if c avctx mb cmp 0x FFFFCMPSSE intra score varc 500 else unsigned mean sum 128 8 mean 0x01010101 for i 0 i 16 i uint32 t c scratchpad i s linesize 0 mean uint32 t c scratchpad i s linesize 4 mean uint32 t c scratchpad i s linesize 8 mean uint32 t c scratchpad i s linesize 12 mean intra score s dsp mb cmp 0 s c scratchpad pix s linesize 16 intra score c mb penalty factor 16 if intra score dmin mb type CANDIDATEMBTYPEINTRA s current picture mb type mb y s mb stride mb x CANDIDATEMBTYPEINTRA else s current picture mb type mb y s mb stride mb x 0 int p score FFMIN vard varc 500 s lambda2 FFLAMBDASHIFT 100 int i score varc 500 s lambda2 FFLAMBDASHIFT 20 c scene change score ff sqrt p score ff sqrt i score s mb type mb y s mb stride mb x mb type static void choose largest tx size V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skip int64 t sse int64 t ref best rd BLOCKSIZE bs const TXSIZE max tx size max txsize lookup bs V P9 COMMON const cm cpi common const TXSIZE largest tx size tx mode to biggest tx size cm tx mode MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi mbmi tx size MIN max tx size largest tx size txfm rd in plane x rate distortion skip sse ref best rd 0 bs mbmi tx size cpi sf use fast coef costing static int mss1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S1 Context ctx avctx priv data MS S12 Context c ctx ctx Get Bit Context gb Arith Coder acoder int pal changed 0 int ret init get bits gb buf buf size 8 arith init acoder gb ctx pic reference 3 ctx pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSREADABLEFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx ctx pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pal pic ctx pic data 0 ctx pic linesize 0 avctx height 1 c pal stride ctx pic linesize 0 c keyframe arith get bit acoder if c keyframe c corrupted 0 ff mss12 slicecontext reset ctx sc pal changed decode pal c acoder ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else if c corrupted return AVERRORINVALIDDATA ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP c corrupted ff mss12 decode rect ctx sc acoder 0 0 avctx width avctx height if c corrupted return AVERRORINVALIDDATA memcpy ctx pic data 1 c pal AVPALETTESIZE ctx pic palette has changed pal changed got frame 1 AV Frame data ctx pic return buf size void vp9 rc update rate correction factors V P9 COMP cpi int damp var const V P9 COMMON const cm cpi common int correction factor 100 double rate correction factor get rate correction factor cpi double adjustment limit int projected size based on q 0 if cpi rc is src frame alt ref return vp9 clear system state projected size based on q estimate bits at q cm frame type cm base qindex cm M Bs rate correction factor cm bit depth if projected size based on q 0 correction factor 100 cpi rc projected frame size projected size based on q switch damp var case 0 adjustment limit 0 75 break case 1 adjustment limit 0 375 break case 2 default adjustment limit 0 25 break if correction factor 102 correction factor int 100 correction factor 100 adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MAXBPBFACTOR rate correction factor MAXBPBFACTOR else if correction factor 99 correction factor int 100 100 correction factor adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MINBPBFACTOR rate correction factor MINBPBFACTOR set rate correction factor cpi rate correction factor static int64 t rd pick intra sbuv mode V P9 COMP cpi MACROBLOCK x PICKMODECONTEXT ctx int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize TXSIZE max tx size MACROBLOCKD xd x e mbd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPRED int64 t best rd IN T64 MAX this rd int this rate tokenonly this rate s int64 t this distortion this sse for mode DCPRED mode TMPRED mode if cpi sf intra uv mode mask max tx size 1 mode continue xd mi 0 mbmi uv mode mode super block uvrd cpi x this rate tokenonly this distortion s this sse bsize best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly cpi intra uv mode cost cpi common frame type mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if x select tx size swap block ptr x ctx 2 0 1 MAXMBPLANE xd mi 0 mbmi uv mode mode selected return best rd void vp9 rc get second pass params V P9 COMP cpi V P9 COMMON const cm cpi common RATECONTROL const rc cpi rc TWOPASS const twopass cpi twopass GFGROUP const gf group twopass gf group int frames left FIRSTPASSSTATS this frame FIRSTPASSSTATS this frame copy int target rate LAYERCONTEXT const lc is two pass svc cpi cpi svc layer context cpi svc spatial layer id 0 if lc NULL frames left int twopass total stats count lc current video frame in layer else frames left int twopass total stats count cm current video frame if twopass stats in return if gf group update type gf group index ARFUPDATE int target rate configure buffer updates cpi target rate gf group bit allocation gf group index target rate vp9 rc clamp pframe target size cpi target rate rc base frame target target rate if cpi oxcf rc mode VPXVBR vbr rate correction target rate rc vbr bits off target vp9 rc set frame target cpi target rate cm frame type INTERFRAME if lc NULL if cpi svc spatial layer id 0 lc is key frame 0 else lc is key frame cpi svc layer context 0 is key frame if lc is key frame cpi ref frame flags V P9 LASTFLAG return vp9 clear system state if cpi oxcf rc mode VPXQ twopass active worst quality cpi oxcf cq level else if cm current video frame 0 lc NULL lc current video frame in layer 0 const int section target bandwidth int twopass bits left frames left const int tmp q get twopass worst quality cpi twopass total left stats section target bandwidth twopass active worst quality tmp q rc ni av qi tmp q rc avg q vp9 convert qindex to q tmp q cm bit depth vp9 zero this frame if EOF input stats twopass this frame return this frame copy this frame if rc frames to key 0 cpi frame flags FRAMEFLAGSKEY find next key frame cpi this frame copy else cm frame type INTERFRAME if lc NULL if cpi svc spatial layer id 0 lc is key frame cm frame type KEYFRAME if lc is key frame cpi ref frame flags V P9 LASTFLAGV P9 GOLDFLAGV P9 ALTFLAG lc frames from key frame 0 else cm frame type INTERFRAME lc is key frame cpi svc layer context 0 is key frame if lc is key frame cpi ref frame flags V P9 LASTFLAG lc frames from key frame 0 if rc frames till gf update due 0 define gf group cpi this frame copy if twopass gf zeromotion pct 995 if cm show frame cpi allow encode breakout ENCODEBREAKOUTDISABLED else cpi allow encode breakout ENCODEBREAKOUTLIMITED rc frames till gf update due rc baseline gf interval if lc NULL cpi refresh golden frame 1 FILE fpfile fpfile fopen arf stt a arf count fprintf fpfile 10d 10d 10d 10ld n cm current video frame rc kf boost arf count rc gfu boost fclose fpfile configure buffer updates cpi target rate gf group bit allocation gf group index if cpi common frame type KEYFRAME target rate vp9 rc clamp iframe target size cpi target rate else target rate vp9 rc clamp pframe target size cpi target rate rc base frame target target rate if cpi oxcf rc mode VPXVBR vbr rate correction target rate rc vbr bits off target vp9 rc set frame target cpi target rate subtract stats twopass total left stats this frame static gint detect version wtap wth int err gchar err info gint bytes read guint16 payload length guint16 try header size guint8 buffer gint64 file offset guint32 log length guint32 tag length guint16 tmp file offset file tell wth fh bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 payload length pletoh16 tmp bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 try header size pletoh16 tmp buffer guint8 g malloc 5 4 payload length bytes read file read buffer 5 4 payload length wth fh if bytes read 5 4 payload length if bytes read 4 4 payload length err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD g free buffer return 1 if try header size 24 tag length guint32 strlen buffer 5 4 1 1 log length guint32 strlen buffer 5 4 1 tag length 1 if payload length 1 tag length log length g free buffer return 2 tag length guint32 strlen buffer 4 4 1 1 log length guint32 strlen buffer 4 4 1 tag length 1 if payload length 1 tag length log length if file seek wth fh file offset 4 4 1 tag length log length SEEKSET err 1 g free buffer return 1 g free buffer return 1 g free buffer return 0 static double eqjoinsel inner Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL Form pg statistic stats2 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid get opcode operator if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple stats2 Form pg statistic GETSTRUCT vardata2 stats Tuple if statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double nullfrac2 stats2 stanullfrac double matchprodfreq matchfreq1 matchfreq2 unmatchfreq1 unmatchfreq2 otherfreq1 otherfreq2 totalsel1 totalsel2 int i nmatches fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 nvalues2 sizeof bool matchprodfreq 0 0 nmatches 0 for i 0 i nvalues1 i int j for j 0 j nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true matchprodfreq numbers1 i numbers2 j nmatches break CLAMPPROBABILITY matchprodfreq matchfreq1 unmatchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i else unmatchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 CLAMPPROBABILITY unmatchfreq1 matchfreq2 unmatchfreq2 0 0 for i 0 i nvalues2 i if hasmatch2 i matchfreq2 numbers2 i else unmatchfreq2 numbers2 i CLAMPPROBABILITY matchfreq2 CLAMPPROBABILITY unmatchfreq2 pfree hasmatch1 pfree hasmatch2 otherfreq1 1 0 nullfrac1 matchfreq1 unmatchfreq1 otherfreq2 1 0 nullfrac2 matchfreq2 unmatchfreq2 CLAMPPROBABILITY otherfreq1 CLAMPPROBABILITY otherfreq2 totalsel1 matchprodfreq if nd2 nvalues2 totalsel1 unmatchfreq1 otherfreq2 nd2 nvalues2 if nd2 nmatches totalsel1 otherfreq1 otherfreq2 unmatchfreq2 nd2 nmatches totalsel2 matchprodfreq if nd1 nvalues1 totalsel2 unmatchfreq2 otherfreq1 nd1 nvalues1 if nd1 nmatches totalsel2 otherfreq2 otherfreq1 unmatchfreq1 nd1 nmatches selec totalsel1 totalsel2 totalsel1 totalsel2 else double nullfrac1 stats1 stats1 stanullfrac 0 0 double nullfrac2 stats2 stats2 stanullfrac 0 0 selec 1 0 nullfrac1 1 0 nullfrac2 if nd1 nd2 selec nd1 else selec nd2 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static void xhci kick epctx XHCIEP Context epctx unsigned int streamid XHCI State xhci epctx xhci XHCI Stream Context stctx XHCI Transfer xfer XHCI Ring ring USB Endpoint ep NULL uint64 t mfindex int length int i trace usb xhci ep kick epctx slotid epctx epid streamid assert epctx kick active if xhci slots epctx slotid 1 uport xhci slots epctx slotid 1 uport dev xhci slots epctx slotid 1 uport dev attached return if epctx retry XHCI Transfer xfer epctx retry trace usb xhci xfer retry xfer assert xfer running retry if xfer timed xfer mfindex xhci mfindex get xhci xhci check intr iso kick xhci xfer epctx mfindex if xfer running retry return xfer timed xfer 0 xfer running retry 1 if xfer iso xfer if xhci setup packet xfer 0 return usb handle packet xfer packet ep dev xfer packet assert xfer packet status USBRETNAK xhci try complete packet xfer else if xhci setup packet xfer 0 return usb handle packet xfer packet ep dev xfer packet if xfer packet status USBRETNAK return xhci try complete packet xfer assert xfer running retry if xfer complete xhci ep free xfer epctx retry epctx retry NULL if epctx state EPHALTEDDPRINTF xhci ep halted not running schedule n return if epctx nr pstreams uint32 t err stctx xhci find stream epctx streamid err if stctx NULL return ring stctx ring xhci set ep state xhci epctx stctx EPRUNNING else ring epctx ring streamid 0 xhci set ep state xhci epctx NULLEPRUNNING assert ring dequeue 0 epctx kick active while 1 length xhci ring chain length xhci ring if length 0 break xfer xhci ep alloc xfer epctx length if xfer NULL break for i 0 i length i TRB Type type type xhci ring fetch xhci ring xfer trbs i NULL assert type xfer streamid streamid if epctx epid 1 xhci fire ctl transfer xhci xfer else xhci fire transfer xhci xfer epctx if xfer complete xhci ep free xfer xfer xfer NULL if epctx state EPHALTED break if xfer NULL xfer running retry DPRINTF xhci xfer nacked stopping schedule n epctx retry xfer break epctx kick active ep xhci epid to usbep epctx if ep usb device flush ep queue ep dev ep void append Conn Str Val PQ Exp Buffer buf const char str const char s bool needquotes needquotes true for s str s s if s a s z s A s Z s 0 s 9 s s needquotes true break needquotes false if needquotes append PQ Exp Buffer Char buf while str if str str append PQ Exp Buffer Char buf append PQ Exp Buffer Char buf str str append PQ Exp Buffer Char buf else append PQ Exp Buffer Str buf str int ff h263 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg Enc Context s avctx priv data int ret AV Frame pict data s flags2 avctx flags2 if buf size 0 if s low delay 0 s next picture ptr pict s next picture ptr f s next picture ptr NULL got frame 1 return 0 if s flags CODECFLAGTRUNCATED int next if CONFIGMPE G4 DECODER s codec id AVCODECIDMPE G4 next ff mpeg4 find frame end s parse context buf buf size else if CONFIG H263 DECODER s codec id AVCODECID H263 next ff h263 find frame end s parse context buf buf size else av log s avctx AVLOGERROR this codec does not support truncated bitstreams n return 1 if ff combine frame s parse context next const uint8 t buf buf size 0 return buf size retry if s bitstream buffer size s divx packed buf size 20 init get bits s gb s bitstream buffer s bitstream buffer size 8 else init get bits s gb buf buf size 8 s bitstream buffer size 0 if s context initialized if ff MPV common init s 0 return 1 if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 return i s current picture ptr s picture i if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode picture header s else if CONFIGMSMPE G4 DECODER s msmpeg4 version ret ff msmpeg4 decode picture header s else if CONFIGMPE G4 DECODER s h263 pred if s avctx extradata size s picture number 0 Get Bit Context gb init get bits gb s avctx extradata s avctx extradata size 8 ret ff mpeg4 decode picture header s gb ret ff mpeg4 decode picture header s s gb else if CONFIG H263 IDECODER s codec id AVCODECID H263 I ret ff intel h263 decode picture header s else if CONFIGFLVDECODER s h263 flv ret ff flv decode picture header s else ret ff h263 decode picture header s if ret FRAMESKIPPED return get consumed bytes s buf size if ret 0 av log s avctx AVLOGERROR header damaged n return 1 avctx has b frames s low delay if s xvid build 1 s divx version 1 s lavc build 1 if s stream codec tag AVR L32 XVID s codec tag AVR L32 XVID s codec tag AVR L32 XVIX s codec tag AVR L32 RM P4 s codec tag AVR L32 ZM P4 s codec tag AVR L32 SIPP s xvid build 0 if s xvid build 1 s divx version 1 s lavc build 1 if s codec tag AVR L32 DIVX s vo type 0 s vol control parameters 0 s divx version 400 if s xvid build 0 s divx version 0 s divx version s divx build 1 if s workaround bugs FFBUGAUTODETECT if s codec tag AVR L32 XVIX s workaround bugs FFBUGXVIDILACE if s codec tag AVR L32 UM P4 s workaround bugs FFBUGUM P4 if s divx version 500 s divx build 1814 s workaround bugs FFBUGQPELCHROMA if s divx version 502 s divx build 1814 s workaround bugs FFBUGQPELCHROM A2 if s xvid build 3 U s padding bug score 256 256 256 64 if s xvid build 1 U s workaround bugs FFBUGQPELCHROMA if s xvid build 12 U s workaround bugs FFBUGEDGE if s xvid build 32 U s workaround bugs FFBUGDCCLIP s dsp put no rnd postfix1 ff put no rnd postfix2 s dsp avg postfix1 ff avg postfix2 if s lavc build 4653 U s workaround bugs FFBUGSTDQPEL if s lavc build 4655 U s workaround bugs FFBUGDIRECTBLOCKSIZE if s lavc build 4670 U s workaround bugs FFBUGEDGE if s lavc build 4712 U s workaround bugs FFBUGDCCLIP if s divx version 0 s workaround bugs FFBUGDIRECTBLOCKSIZE if s divx version 501 s divx build 20020416 s padding bug score 256 256 256 64 if s divx version 500 U s workaround bugs FFBUGEDGE if s divx version 0 s workaround bugs FFBUGHPELCHROMA if s resync marker 0 s data partitioning 0 s divx version 1 s codec id AVCODECIDMPE G4 s vo type 0 s workaround bugs FFBUGNOPADDING if s lavc build 4609 U s workaround bugs FFBUGNOPADDING if s workaround bugs FFBUGSTDQPELSETQPELFUNC qpel pixels tab 0 5 qpel16 mc11 old c SETQPELFUNC qpel pixels tab 0 7 qpel16 mc31 old c SETQPELFUNC qpel pixels tab 0 9 qpel16 mc12 old c SETQPELFUNC qpel pixels tab 0 11 qpel16 mc32 old c SETQPELFUNC qpel pixels tab 0 13 qpel16 mc13 old c SETQPELFUNC qpel pixels tab 0 15 qpel16 mc33 old c SETQPELFUNC qpel pixels tab 1 5 qpel8 mc11 old c SETQPELFUNC qpel pixels tab 1 7 qpel8 mc31 old c SETQPELFUNC qpel pixels tab 1 9 qpel8 mc12 old c SETQPELFUNC qpel pixels tab 1 11 qpel8 mc32 old c SETQPELFUNC qpel pixels tab 1 13 qpel8 mc13 old c SETQPELFUNC qpel pixels tab 1 15 qpel8 mc33 old c if avctx debug FFDEBUGBUGS av log s avctx AVLOGDEBUG bugs X lavc build d xvid build d divx version d divx build d s n s workaround bugs s lavc build s xvid build s divx version s divx build s divx packed p avctx idct algo FFIDCTXVIDMMX ff dct common init s s picture number 0 Parse Context pc s parse context s parse context buffer 0 ff MPV common end s s parse context pc avcodec set dimensions avctx s width s height goto retry if s width avctx coded width s height avctx coded height s context reinit s context reinit 0 avcodec set dimensions avctx s width s height if ret ff MPV common frame size change s return ret if s codec id AVCODECID H263 s codec id AVCODECID H263 P s codec id AVCODECID H263 I s gob index ff h263 get gob height s s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable return get consumed bytes s buf size if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return get consumed bytes s buf size if s next p frame damaged if s pict type AVPICTURETYPEB return get consumed bytes s buf size else s next p frame damaged 0 if s no rounding s pict type AVPICTURETYPEB s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab else s me qpel put s dsp put no rnd qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if ff MPV frame start s avctx 0 return 1 if s divx packed ff thread finish setup avctx if CONFIGMPE G4 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau mpeg4 decode picture s s gb buffer s gb buffer end s gb buffer goto frame end if avctx hwaccel if avctx hwaccel start frame avctx s gb buffer s gb buffer end s gb buffer 0 return 1 ff mpeg er frame start s if CONFIGWM V2 DECODER s msmpeg4 version 5 ret ff wmv2 decode secondary picture header s if ret 0 return ret if ret 1 goto intrax8 decoded s mb x 0 s mb y 0 ret decode slice s while s mb y s mb height if s msmpeg4 version if s slice height 0 s mb x 0 s mb y s slice height 0 get bits left s gb 0 break else int prev x s mb x prev y s mb y if ff h263 resync s 0 break if prev y s mb width prev x s mb y s mb width s mb x s er error occurred 1 if s msmpeg4 version 4 s h263 pred ff mpeg4 clean buffers s if decode slice s 0 ret AVERRORINVALIDDATA if s msmpeg4 version s msmpeg4 version 4 s pict type AVPICTURETYPEI if CONFIGMSMPE G4 DECODER ff msmpeg4 decode ext header s buf size 0 s er error status table s mb num 1 ERMBERROR assert s bitstream buffer size 0 frame end if s codec id AVCODECIDMPE G4 s divx packed int current pos get bits count s gb 3 int startcode found 0 if buf size current pos 5 int i for i current pos i buf size 3 i if buf i 0 buf i 1 0 buf i 2 1 buf i 3 0x B6 startcode found 1 break if s gb buffer s bitstream buffer buf size 7 s xvid build 0 startcode found 1 current pos 0 if startcode found av fast malloc s bitstream buffer s allocated bitstream buffer size buf size current pos FFINPUTBUFFERPADDINGSIZE if s bitstream buffer return AVERRORENOMEM memcpy s bitstream buffer buf current pos buf size current pos s bitstream buffer size buf size current pos intrax8 decoded ff er frame end s er if avctx hwaccel if avctx hwaccel end frame avctx 0 return 1 ff MPV frame end s assert s current picture f pict type s current picture ptr f pict type assert s current picture f pict type s pict type if s pict type AVPICTURETYPEB s low delay pict s current picture ptr f else if s last picture ptr NULL pict s last picture ptr f if s last picture ptr s low delay got frame 1 ff print debug info s pict static double ineq histogram selectivity Planner Info root Variable Stat Data vardata Fmgr Info opproc bool isgt Datum constval Oid consttype double hist selec Oid hist op Datum values int nvalues hist selec 1 0 if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opproc fn oid get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDHISTOGRAM Invalid Oid hist op values nvalues NULLNULL if nvalues 1 double histfrac int lobound 0 int hibound nvalues bool have end false if nvalues 2 have end get actual variable range root vardata hist op values 0 values 1 while lobound hibound int probe lobound hibound 2 bool ltcmp if probe 0 nvalues 2 have end get actual variable range root vardata hist op values 0 NULL else if probe nvalues 1 nvalues 2 have end get actual variable range root vardata hist op NULL values probe ltcmp Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values probe constval if isgt ltcmp ltcmp if ltcmp lobound probe 1 else hibound probe if lobound 0 histfrac 0 0 else if lobound nvalues histfrac 1 0 else int i lobound double val high low double binfrac if convert to scalar constval consttype val values i 1 values i vardata vartype low high if high low binfrac 0 5 else if val low binfrac 0 0 else if val high binfrac 1 0 else binfrac val low high low if isnan binfrac binfrac 0 0 binfrac 1 0 binfrac 0 5 else binfrac 0 5 histfrac double i 1 binfrac histfrac double nvalues 1 hist selec isgt 1 0 histfrac histfrac if have end CLAMPPROBABILITY hist selec else if hist selec 0 0001 hist selec 0 0001 else if hist selec 0 9999 hist selec 0 9999 free attstatsslot vardata atttype values nvalues NULL 0 return hist selec static vpx codec err t parse options Svc Context svc ctx const char options char input string char option name char option value char input ptr Svc Internal const si get svc internal svc ctx vpx codec err t res VPXCODECOK if options NULL return VPXCODECOK input string strdup options option name strtok r input string input ptr while option name NULL option value strtok r NULL input ptr if option value NULL svc log svc ctx SVCLOGERROR option missing value s n option name res VPXCODECINVALIDPARAM break if strcmp spatial layers option name 0 svc ctx spatial layers atoi option value else if strcmp temporal layers option name 0 svc ctx temporal layers atoi option value else if strcmp scale factors option name 0 res parse scale factors svc ctx option value if res VPXCODECOK break else if strcmp quantizers option name 0 res parse quantizer values svc ctx option value if res VPXCODECOK break else if strcmp auto alt refs option name 0 res parse auto alt ref svc ctx option value if res VPXCODECOK break else if strcmp multi frame contexts option name 0 si use multiple frame contexts atoi option value else svc log svc ctx SVCLOGERROR invalid option s n option name res VPXCODECINVALIDPARAM break option name strtok r NULL input ptr free input string if si use multiple frame contexts svc ctx spatial layers 3 svc ctx spatial layers svc ctx temporal layers 4 res VPXCODECINVALIDPARAM return res P Gconn Get Connection void P Gconn tmpconn int argcount 7 int i const char keywords const char values const char tmpparam bool need password P Qconninfo Option conn opts NULLP Qconninfo Option conn opt char err msg NULL i 0 if connection string conn opts P Qconninfo Parse connection string err msg if conn opts NULL fprintf stderr s s progname err msg exit 1 for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 argcount keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 keywords i conn opt keyword values i conn opt val i else keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values keywords i dbname values i dbname NULL replication dbname i keywords i replication values i dbname NULL true database i keywords i fallback application name values i progname i if dbhost keywords i host values i dbhost i if dbuser keywords i user values i dbuser i if dbport keywords i port values i dbport i need password dbgetpassword 1 dbpassword NULL do if need password if dbpassword free dbpassword dbpassword simple prompt Password 100 false need password false if dbpassword keywords i password values i dbpassword else keywords i NULL values i NULL tmpconn P Qconnectdb Params keywords values true if tmpconn fprintf stderr s could not connect to server n progname exit 1 if P Qstatus tmpconn CONNECTIONBADP Qconnection Needs Password tmpconn dbgetpassword 1 P Qfinish tmpconn need password true while need password if P Qstatus tmpconn CONNECTIONOK fprintf stderr s could not connect to server s progname P Qerror Message tmpconn P Qfinish tmpconn free values free keywords if conn opts P Qconninfo Free conn opts return NULL free values free keywords if conn opts P Qconninfo Free conn opts tmpparam P Qparameter Status tmpconn integer datetimes if tmpparam fprintf stderr s could not determine server setting for integer datetimes n progname P Qfinish tmpconn exit 1 fprintf stderr s integer datetimes compile flag does not match server n progname P Qfinish tmpconn exit 1 void Default TTF English Names struct ttflangname dummy Spline Font sf time t now struct tm tm char buffer 200 if dummy names ttf copyright NULL dummy names ttf copyright 0 dummy names ttf copyright utf8 verify copy sf copyright if dummy names ttf family NULL dummy names ttf family 0 dummy names ttf family utf8 verify copy sf familyname if dummy names ttf subfamily NULL dummy names ttf subfamily 0 dummy names ttf subfamily utf8 verify copy SF Get Modifiers sf if dummy names ttf uniqueid NULL dummy names ttf uniqueid 0 time now tm localtime now sprintf buffer s s d d d BDF Foundry BDF Foundry TTF Foundry TTF Foundry Font Forge 2 0 sf fullname NULL sf fullname sf fontname tm tm mday tm tm mon 1 tm tm year 1900 dummy names ttf uniqueid copy buffer if dummy names ttf fullname NULL dummy names ttf fullname 0 dummy names ttf fullname utf8 verify copy sf fullname if dummy names ttf version NULL dummy names ttf version 0 if sf subfontcnt 0 sprintf buffer Version f double sf cidversion else if sf version NULL sprintf buffer Version 20s sf version else strcpy buffer Version 1 0 dummy names ttf version copy buffer if dummy names ttf postscriptname NULL dummy names ttf postscriptname 0 dummy names ttf postscriptname utf8 verify copy sf fontname static void temporal filter predictors mb c MACROBLOCKD xd uint8 t y mb ptr uint8 t u mb ptr uint8 t v mb ptr int stride int uv block width int uv block height int mv row int mv col uint8 t pred struct scale factors scale int x int y const int which mv 0 const MV mv mv row mv col const Interp Kernel const kernel vp9 get interp kernel xd mi 0 mbmi interp filter enum mv precision mv precision uv int uv stride if uv block width 8 uv stride stride 1 1 mv precision uv MVPRECISION Q4 else uv stride stride mv precision uv MVPRECISION Q3 vp9 build inter predictor y mb ptr stride pred 0 16 mv scale 16 16 which mv kernel MVPRECISION Q3 x y vp9 build inter predictor u mb ptr uv stride pred 256 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y vp9 build inter predictor v mb ptr uv stride pred 512 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y static void pred temp direct motion H264 Context const h int mb type int b8 stride 2 int b4 stride h b stride int mb xy h mb xy mb y h mb y int mb type col 2 const int16 t l1mv0 2 l1mv1 2 const int8 t l1ref0 l1ref1 const int is b8x8 IS 8 X8 mb type unsigned int sub mb type int i8 i4 assert h ref list 1 0 reference 3 await reference mb row h h ref list 1 0 h mb y ISINTERLACED mb type if ISINTERLACED h ref list 1 0 mb type mb xy if ISINTERLACED mb type mb y h mb y 1 h col parity mb xy h mb x h mb y 1 h col parity h mb stride b8 stride 0 else mb y h col fieldoff mb xy h mb stride h col fieldoff goto single col else if ISINTERLACED mb type mb y h mb y 1 mb xy h mb x h mb y 1 h mb stride mb type col 0 h ref list 1 0 mb type mb xy mb type col 1 h ref list 1 0 mb type mb xy h mb stride b8 stride 2 4 h mb stride b4 stride 6 if ISINTERLACED mb type col 0 ISINTERLACED mb type col 1 mb type col 0 MBTYPEINTERLACED mb type col 1 MBTYPEINTERLACED sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if mb type col 0 MBTYPE 16x16 ORINTRA mb type col 1 MBTYPE 16x16 ORINTRA is b8x8 mb type MBTYPE 16x8 MBTYPE L0 L1 MBTYPEDIREC T2 else mb type MBTYPE 8x8 MBTYPE L0 L1 else single col mb type col 0 mb type col 1 h ref list 1 0 mb type mb xy sub mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 if is b8x8 mb type col 0 MBTYPE 16x16 ORINTRA mb type MBTYPE 16x16 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 else if is b8x8 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 mb type MBTYPE L0 L1 MBTYPEDIREC T2 mb type col 0 MBTYPE 16x8 MBTYPE 8x16 else if h sps direct 8x8 inference flag sub mb type MBTYPE 8x8 MBTYPE P0 L0 MBTYPE P0 L1 MBTYPEDIREC T2 mb type MBTYPE 8x8 MBTYPE L0 L1 await reference mb row h h ref list 1 0 mb y l1mv0 h ref list 1 0 motion val 0 h mb2b xy mb xy l1mv1 h ref list 1 0 motion val 1 h mb2b xy mb xy l1ref0 h ref list 1 0 ref index 0 4 mb xy l1ref1 h ref list 1 0 ref index 1 4 mb xy if b8 stride if h mb y 1 l1ref0 2 l1ref1 2 l1mv0 2 b4 stride l1mv1 2 b4 stride const int map col to list0 2 h map col to list0 0 h map col to list0 1 const int dist scale factor h dist scale factor int ref offset if FRAMEMBAFFISINTERLACED mb type map col to list0 0 h map col to list0 field h mb y 1 0 map col to list0 1 h map col to list0 field h mb y 1 1 dist scale factor h dist scale factor field h mb y 1 ref offset h ref list 1 0 mbaff 4 mb type col 0 3 if ISINTERLACED mb type ISINTERLACED mb type col 0 int y shift 2 ISINTERLACED mb type assert h sps direct 8x8 inference flag for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col y8 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue ref0 l1ref0 x8 y8 b8 stride if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 x8 y8 b8 stride ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 const int16 t mv col l1mv x8 3 y8 b4 stride int my col mv col 1 y shift 2 int mx scale mv col 0 128 8 int my scale my col 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my my col 4 return if IS 16 X16 mb type int ref mv0 mv1 fill rectangle h ref cache 1 scan8 0 4 4 8 0 1 if ISINTRA mb type col 0 ref mv0 mv1 0 else const int ref0 l1ref0 0 0 map col to list0 0 l1ref0 0 ref offset map col to list0 1 l1ref1 0 ref offset const int scale dist scale factor ref0 const int16 t mv col l1ref0 0 0 l1mv0 0 l1mv1 0 int mv l0 2 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 ref ref0 mv0 pack16to32 mv l0 0 mv l0 1 mv1 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 fill rectangle h ref cache 0 scan8 0 4 4 8 ref 1 fill rectangle h mv cache 0 scan8 0 4 4 8 mv0 4 fill rectangle h mv cache 1 scan8 0 4 4 8 mv1 4 else for i8 0 i8 4 i8 const int x8 i8 1 const int y8 i8 1 int ref0 scale const int16 t l1mv 2 l1mv0 if is b8x8 ISDIRECT h sub mb type i8 continue h sub mb type i8 sub mb type fill rectangle h ref cache 1 scan8 i8 4 2 2 8 0 1 if ISINTRA mb type col 0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 0 1 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 0 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 0 4 continue assert b8 stride 2 ref0 l1ref0 i8 if ref0 0 ref0 map col to list0 0 ref0 ref offset else ref0 map col to list0 1 l1ref1 i8 ref offset l1mv l1mv1 scale dist scale factor ref0 fill rectangle h ref cache 0 scan8 i8 4 2 2 8 ref0 1 if ISSUB 8 X8 sub mb type const int16 t mv col l1mv x8 3 y8 3 b4 stride int mx scale mv col 0 128 8 int my scale mv col 1 128 8 fill rectangle h mv cache 0 scan8 i8 4 2 2 8 pack16to32 mx my 4 fill rectangle h mv cache 1 scan8 i8 4 2 2 8 pack16to32 mx mv col 0 my mv col 1 4 else for i4 0 i4 4 i4 const int16 t mv col l1mv x8 2 i4 1 y8 2 i4 1 b4 stride int16 t mv l0 h mv cache 0 scan8 i8 4 i4 mv l0 0 scale mv col 0 128 8 mv l0 1 scale mv col 1 128 8 AVW N32 A h mv cache 1 scan8 i8 4 i4 pack16to32 mv l0 0 mv col 0 mv l0 1 mv col 1 static VALUE ossl cipher update int argc VALUE argv VALUE self EVPCIPHERCTX ctx unsigned char in long in len out len VALUE data str rb scan args argc argv 11 data str if RTEST rb attr get self id key set ossl raise e Cipher Error key not set String Value data in unsigned char RSTRINGPTR data if in len RSTRINGLEN data 0 ossl raise rb e Arg Error data must not be empty Get Cipher self ctx out len in len EVPCIPHERCTX block size ctx if out len 0 ossl raise rb e Range Error data too big to make output buffer ld bytes in len if NILP str str rb str new 0 out len else String Value str rb str resize str out len if ossl cipher update long ctx unsigned char RSTRINGPTR str out len in in len ossl raise e Cipher Error NULL assert out len RSTRINGLEN str rb str set len str out len return str void proto register adb void module t module expert module t expert module static hf register info hf hf command Command adb command FTUIN T32 BASEHEXVALS command vals 0x00 NULLHFILL hf argument 0 Argument 0 adb argument 0 FTUIN T32 BASEHEXNULL 0x00 NULLHFILL hf argument 1 Argument 0 adb argument 1 FTUIN T32 BASEHEXNULL 0x00 NULLHFILL hf data length Data Length adb data length FTUIN T32 BASEDECNULL 0x00 NULLHFILL hf data crc32 Data CR C32 adb data crc32 FTUIN T32 BASEHEXNULL 0x00 NULLHFILL hf magic Magic adb magic FTUIN T32 BASEHEXVALS magic vals 0x00 NULLHFILL hf version Version adb version FTUIN T32 BASEHEXNULL 0x00 NULLHFILL hf max data Max Data adb max data FTUIN T32 BASEDECNULL 0x00 NULLHFILL hf auth type Type adb auth type FTUIN T32 BASEHEXVALS auth type vals 0x00 NULLHFILL hf online Online adb online FTBOOLEAN 32 TFS tfs no yes 0x00 NULLHFILL hf sequence Sequence adb sequence FTUIN T32 BASEDECNULL 0x00 NULLHFILL hf zero Zero adb zero FTUIN T32 BASEHEXNULL 0x00 NULLHFILL hf local id Local ID adb local id FTUIN T32 BASEDECNULL 0x00 NULLHFILL hf remote id Remote ID adb remote id FTUIN T32 BASEDECNULL 0x00 NULLHFILL hf data Data adb data FTNONEBASENONENULL 0x00 NULLHFILL hf service Service adb service FTSTRINGBASENONENULL 0x00 NULLHFILL hf data fragment Data Fragment adb data fragment FTNONEBASENONENULL 0x00 NULLHFILL hf service start in frame Service Start in Frame adb service start in frame FTFRAMENUMBASENONENULL 0x00 NULLHFILL hf close local in frame Local Service Close in Frame adb close local in frame FTFRAMENUMBASENONENULL 0x00 NULLHFILL hf close remote in frame Remote Service Close in Frame adb close remote in frame FTFRAMENUMBASENONENULL 0x00 NULLHFILL hf command in frame Command in Frame adb command in frame FTFRAMENUMBASENONENULL 0x00 NULLHFILL hf completed in frame Completed in Frame adb completed in frame FTFRAMENUMBASENONENULL 0x00 NULLHFILL hf connection info Info adb connection info FTSTRINGZSTRASCIINULL 0x00 NULLHFILL static gint ett ett adb ett adb arg0 ett adb arg1 ett adb crc ett adb magic static ei register info ei ei invalid magic adb expert invalid magic PIPROTOCOLPIWARN Invalid Magic EXPFILL ei invalid crc adb expert crc error PIPROTOCOLPIERRORCR C32 Error EXPFILL ei invalid data adb expert data error PIPROTOCOLPIERROR Mismatch between message payload size and data length EXPFILL command info wmem tree new autoreset wmem epan scope wmem file scope service info wmem tree new autoreset wmem epan scope wmem file scope proto adb proto register protocol Android Debug Bridge ADB adb adb handle register dissector adb dissect adb proto adb proto register field array proto adb hf array length hf proto register subtree array ett array length ett expert module expert register protocol proto adb expert register field array expert module ei array length ei module prefs register protocol proto adb NULL prefs register static text preference module version ADB protocol version is compatible prior to adb 1 0 31 Version of protocol supported by this dissector static int ec G F2m montgomery point multiply const ECGROUP group ECPOINT r const BIGNUM scalar const ECPOINT point BNCTX ctx BIGNUM x1 x2 z1 z2 int ret 0 i BNULONG mask word if r point E Cerr ECFECG F2 MMONTGOMERYPOINTMULTIPLYECRINVALIDARGUMENT return 0 if scalar NULLBN is zero scalar point NULLECPOINT is at infinity group point return ECPOINT set to infinity group r if point Z is one return 0 BNCTX start ctx x1 BNCTX get ctx z1 BNCTX get ctx if z1 NULL goto err x2 r X z2 r Y bn wexpand x1 group field top bn wexpand z1 group field top bn wexpand x2 group field top bn wexpand z2 group field top if BNG F2m mod arr x1 point X group poly goto err if BN one z1 goto err if group meth field sqr group z2 x1 ctx goto err if group meth field sqr group x2 z2 ctx goto err if BNG F2m add x2 x2 group b goto err i scalar top 1 mask BNTBIT word scalar d i while word mask mask 1 mask 1 if mask i mask BNTBIT for i 0 i word scalar d i while mask BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top if gf2m Madd group point X x2 z2 x1 z1 ctx goto err if gf2m Mdouble group x1 z1 ctx goto err BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top mask 1 mask BNTBIT i gf2m Mxy group point X point Y x1 z1 x2 z2 ctx if i 0 goto err else if i 1 if ECPOINT set to infinity group r goto err else if BN one r Z goto err r Z is one 1 BN set negative r X 0 BN set negative r Y 0 ret 1 err BNCTX end ctx return ret int ff mpeg4 decode video packet header Mpeg Enc Context s int mb num bits av log2 s mb num 1 1 int header extension 0 mb num len if get bits count s gb s gb size in bits 20 return 1 for len 0 len 32 len if get bits1 s gb break if len ff mpeg4 get video packet prefix length s av log s avctx AVLOGERROR marker does not match f code n return 1 if s shape RECTSHAPE header extension get bits1 s gb mb num get bits s gb mb num bits if mb num s mb num av log s avctx AVLOGERROR illegal mb num in video packet d d n mb num s mb num return 1 if s pict type AVPICTURETYPEB int mb x 0 mb y 0 while s next picture f mbskip table s mb index2xy mb num if mb x ff thread await progress s next picture ptr f mb y 0 mb num if mb x s mb width mb x 0 if mb num s mb num return 1 s mb x mb num s mb width s mb y mb num s mb width if s shape BINONLYSHAPE int qscale get bits s gb s quant precision if qscale s chroma qscale s qscale qscale if s shape RECTSHAPE header extension get bits1 s gb if header extension int time incr 0 while get bits1 s gb 0 time incr check marker s gb before time increment in video packed header skip bits s gb s time increment bits check marker s gb before vop coding type in video packed header skip bits s gb 2 if s shape BINONLYSHAPE skip bits s gb 3 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE mpeg4 decode sprite trajectory s s gb av log s avctx AVLOGERROR untested n if s pict type AVPICTURETYPEI int f code get bits s gb 3 if f code 0 av log s avctx AVLOGERROR Error video packet header damaged f code 0 n if s pict type AVPICTURETYPEB int b code get bits s gb 3 if b code 0 av log s avctx AVLOGERROR Error video packet header damaged b code 0 n return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t ctable 128 Qpeg Context const a avctx priv data AV Frame const p a pic uint8 t outdata int delta ret const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if avpkt size 0x86 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA bytestream2 init a buffer avpkt data avpkt size if ret ff reget buffer avctx p 0 av log avctx AVLOGERROR reget buffer failed n return ret outdata a pic data 0 bytestream2 skip a buffer 4 bytestream2 get buffer a buffer ctable 128 bytestream2 skip a buffer 1 delta bytestream2 get byte a buffer if delta 0x10 qpeg decode intra a outdata a pic linesize 0 avctx width avctx height else qpeg decode inter a outdata a pic linesize 0 avctx width avctx height delta ctable a refdata if pal a pic palette has changed 1 memcpy a pal pal AVPALETTESIZE memcpy a pic data 1 a pal AVPALETTESIZE if ret av frame ref data a pic 0 return ret got frame 1 return avpkt size static void write modes sb V P9 COMP cpi const Tile Info const tile vp9 writer w TOKENEXTRA tok const TOKENEXTRA const tok end int mi row int mi col BLOCKSIZE bsize const V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd const int bsl b width log2 bsize const int bs 1 bsl 4 PARTITIONTYPE partition BLOCKSIZE subsize const MODEINFO m NULL if mi row cm mi rows mi col cm mi cols return m cm mi mi row cm mi stride mi col src mi partition partition lookup bsl m mbmi sb type write partition cm xd bs mi row mi col partition bsize w subsize get subsize bsize partition if subsize BLOCK 8 X8 write modes b cpi tile w tok tok end mi row mi col else switch partition case PARTITIONNONE write modes b cpi tile w tok tok end mi row mi col break case PARTITIONHORZ write modes b cpi tile w tok tok end mi row mi col if mi row bs cm mi rows write modes b cpi tile w tok tok end mi row bs mi col break case PARTITIONVERT write modes b cpi tile w tok tok end mi row mi col if mi col bs cm mi cols write modes b cpi tile w tok tok end mi row mi col bs break case PARTITIONSPLIT write modes sb cpi tile w tok tok end mi row mi col subsize write modes sb cpi tile w tok tok end mi row mi col bs subsize write modes sb cpi tile w tok tok end mi row bs mi col subsize write modes sb cpi tile w tok tok end mi row bs mi col bs subsize break default assert 0 if bsize BLOCK 8 X8 bsize BLOCK 8 X8 partition PARTITIONSPLIT update partition context xd mi row mi col subsize bsize static void txfm rd in plane MACROBLOCK x int rate int64 t distortion int skippable int64 t sse int64 t ref best rd int plane BLOCKSIZE bsize TXSIZE tx size int use fast coef casting MACROBLOCKD const xd x e mbd const struct macroblockd plane const pd xd plane plane struct rdcost block args args vp9 zero args args x x args best rd ref best rd args use fast coef costing use fast coef casting if plane 0 xd mi 0 mbmi tx size tx size vp9 get entropy contexts bsize tx size pd args t above args t left args so get scan xd tx size pd plane type 0 vp9 foreach transformed block in plane xd bsize plane block rd txfm args if args skip rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 else distortion args this dist rate args this rate sse args this sse skippable vp9 is skippable in plane x bsize plane static int aasc decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Aasc Context s avctx priv data int compr i stride ret if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret compr AVR L32 buf buf 4 buf size 4 switch compr case 0 stride avctx width 3 3 3 for i avctx height 1 i 0 i memcpy s frame data 0 i s frame linesize 0 buf avctx width 3 buf stride break case 1 bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame 8 s gb break default av log avctx AVLOGERROR Unknown compression type d n compr return AVERRORINVALIDDATA got frame 1 if ret av frame ref data s frame 0 return ret return buf size static void qemu dummy cpu thread fn void arg exit 1 sigset t waitset int r qemu mutex lock iothread qemu thread get self cpu thread cpu thread id qemu get thread id sigemptyset waitset sigaddset waitset SIGIPI cpu created true qemu cond signal qemu cpu cond cpu single env cpu env ptr while 1 cpu single env NULL qemu mutex unlock iothread do int sig r sigwait waitset sig while r 1 errno EAGAIN errno EINTR if r 1 perror sigwait exit 1 qemu mutex lock iothread cpu single env cpu env ptr qemu wait io event common cpu return static int get buffer AV Codec Context avctx Picture pic SV Q3 Context s avctx priv data H264 Context h s h const int big mb num h mb stride h mb height 1 1 const int mb array size h mb stride h mb height const int b4 stride h mb width 4 1 const int b4 array size b4 stride h mb height 4 int ret if pic motion val buf 0 int i pic mb type buf av buffer allocz big mb num h mb stride sizeof uint32 t if pic mb type buf return AVERRORENOMEM pic mb type uint32 t pic mb type buf data 2 h mb stride 1 for i 0 i 2 i pic motion val buf i av buffer allocz 2 b4 array size 4 sizeof int16 t pic ref index buf i av buffer allocz 4 mb array size if pic motion val buf i pic ref index buf i ret AVERRORENOMEM goto fail pic motion val i int16 t 2 pic motion val buf i data 4 pic ref index i pic ref index buf i data pic f motion subsample log2 2 pic reference h pict type AVPICTURETYPEB ret ff get buffer avctx pic f pic reference AVGETBUFFERFLAGREF 0 if ret 0 goto fail if h edge emu buffer h edge emu buffer av mallocz pic f linesize 0 17 if h edge emu buffer return AVERRORENOMEM h linesize pic f linesize 0 h uvlinesize pic f linesize 1 return 0 fail free picture avctx pic return ret int udpv6 queue rcv skb struct sock sk struct sk buff skb struct udp sock up udp sk sk int rc int is udplite ISUDPLITE sk if xfrm6 policy check sk XFRMPOLICYIN skb goto drop if is udplite UDPLITERECVCCUDPSKBCB skb partial cov if up pcrlen 0 LIMITNETDEBUGKERNWARNINGUDPLIT E6 partial coverage d while full coverage d requested n UDPSKBCB skb cscov skb len goto drop if UDPSKBCB skb cscov up pcrlen LIMITNETDEBUGKERNWARNINGUDPLIT E6 coverage d too small need min d n UDPSKBCB skb cscov up pcrlen goto drop if sk sk filter if udp lib checksum complete skb goto drop if rc ip queue rcv skb sk skb 0 if rc ENOMEMUD P6 INCSTATSBH sock net sk UDPMIBRCVBUFERRORS is udplite goto drop no sk drops inc return 0 drop atomic inc sk sk drops drop no sk drops inc UD P6 INCSTATSBH sock net sk UDPMIBINERRORS is udplite kfree skb skb return 1 static int vc1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size n slices 0 i ret V C1 Context v avctx priv data Mpeg Enc Context s v s AV Frame pict data uint8 t buf2 NULL const uint8 t buf start buf int mb height n slices1 struct uint8 t buf Get Bit Context gb int mby start slices NULL tmp if buf size 0 buf size 4 AVR B32 buf V C1 CODEENDOFSEQ if s low delay 0 s next picture ptr if ret av frame ref pict s next picture ptr f 0 return ret s next picture ptr NULL got frame 1 return 0 if s avctx codec capabilities CODECCAPHWACCELVDPAU if v profile PROFILEADVANCED avctx pix fmt AVPIXFMTVDPAUWM V3 else avctx pix fmt AVPIXFMTVDPAUV C1 if avctx codec id AVCODECIDV C1 avctx codec id AVCODECIDV C1 IMAGE int buf size2 0 buf2 av mallocz buf size FFINPUTBUFFERPADDINGSIZE if ISMARKERAVR B32 buf const uint8 t start end next int size next buf for start buf end buf buf size next end start next next find next marker start 4 end size next start 4 if size 0 continue switch AVR B32 start case V C1 CODEFRAME if avctx hwaccel s avctx codec capabilities CODECCAPHWACCELVDPAU buf start start buf size2 vc1 unescape buffer start 4 size buf2 break case V C1 CODEFIELD int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices break case V C1 CODEENTRYPOINT buf size2 vc1 unescape buffer start 4 size buf2 init get bits s gb buf2 buf size2 8 ff vc1 decode entry point avctx v s gb break case V C1 CODESLICE int buf size3 tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer start 4 size slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start get bits slices n slices gb 9 n slices break else if v interlace buf 0 0x C0 0x C0 const uint8 t divider int buf size3 divider find next marker buf buf buf size if divider buf buf size AVR B32 divider V C1 CODEFIELD av log avctx AVLOGERROR Error in WV C1 interlaced frame n goto err else tmp av realloc slices sizeof slices n slices 1 if tmp goto err slices tmp slices n slices buf av mallocz buf size FFINPUTBUFFERPADDINGSIZE if slices n slices buf goto err buf size3 vc1 unescape buffer divider 4 buf buf size divider 4 slices n slices buf init get bits slices n slices gb slices n slices buf buf size3 3 slices n slices mby start s mb height 1 n slices1 n slices 1 n slices buf size2 vc1 unescape buffer buf divider buf buf2 else buf size2 vc1 unescape buffer buf buf size buf2 init get bits s gb buf2 buf size2 8 else init get bits s gb buf buf size 8 if v res sprite v new sprite get bits1 s gb v two sprites get bits1 s gb if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE if v new sprite avctx width avctx coded width v sprite width avctx height avctx coded height v sprite height else goto image if s context initialized s width avctx coded width s height avctx coded height ff vc1 decode end avctx if s context initialized if ff msmpeg4 decode init avctx 0 ff vc1 decode init alloc tables v 0 goto err s low delay avctx has b frames v res sprite if v profile PROFILEADVANCED s h edge pos avctx coded width s v edge pos avctx coded height if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 goto err s current picture ptr s picture i v pic header flag 0 if v profile PROFILEADVANCED if ff vc1 parse frame header v s gb 1 goto err else if ff vc1 parse frame header adv v s gb 1 goto err if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE s pict type AVPICTURETYPEI av log v s avctx AVLOGERROR Sprite decoder expected I frame n goto err s current picture ptr f repeat pict 0 if v rff s current picture ptr f repeat pict 1 else if v rptfrm s current picture ptr f repeat pict v rptfrm 2 s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if s last picture ptr NULL s pict type AVPICTURETYPEB s droppable goto err if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL goto end if s next p frame damaged if s pict type AVPICTURETYPEB goto end else s next p frame damaged 0 if ff MPV frame start s avctx 0 goto err s me qpel put s dsp put qpel pixels tab s me qpel avg s dsp avg qpel pixels tab if CONFIGV C1 VDPAUDECODER s avctx codec capabilities CODECCAPHWACCELVDPAU ff vdpau vc1 decode picture s buf start buf buf size buf start else if avctx hwaccel if avctx hwaccel start frame avctx buf buf size 0 goto err if avctx hwaccel decode slice avctx buf start buf buf size buf start 0 goto err if avctx hwaccel end frame avctx 0 goto err else ff mpeg er frame start s v bits buf size 8 v end mb x s mb width if v field mode uint8 t tmp 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 tmp 0 v mv f last 0 tmp 1 v mv f last 1 v mv f last 0 v mv f next 0 v mv f last 1 v mv f next 1 v mv f next 0 v mv f 0 v mv f next 1 v mv f 1 v mv f 0 tmp 0 v mv f 1 tmp 1 mb height s mb height v field mode for i 0 i n slices i if i 0 slices i 1 mby start mb height if v field mode 0 av log v s avctx AVLOGERROR Slice d starts beyond picture boundary d d n i slices i 1 mby start mb height continue v second field 1 v blocks off s mb width s mb height 1 v mb off s mb stride s mb height 1 else v second field 0 v blocks off 0 v mb off 0 if i v pic header flag 0 if v field mode i n slices1 2 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Field header damaged n continue else if get bits1 s gb v pic header flag 1 if ff vc1 parse frame header adv v s gb 0 av log v s avctx AVLOGERROR Slice header damaged n continue s start mb y i 0 0 FFMAX 0 slices i 1 mby start mb height if v field mode v second field s end mb y i n slices mb height FFMIN mb height slices i mby start mb height else s end mb y i n slices1 1 mb height FFMIN mb height slices i mby start mb height ff vc1 decode blocks v if i n slices s gb slices i gb if v field mode v second field 0 if s pict type AVPICTURETYPEB memcpy v mv f base v mv f next base 2 s b8 stride s mb height 2 1 s mb stride s mb height 1 2 s current picture f linesize 0 1 s current picture f linesize 1 1 s current picture f linesize 2 1 s linesize 1 s uvlinesize 1 av dlog s avctx Consumed i i bits n get bits count s gb s gb size in bits ff er frame end s er ff MPV frame end s if avctx codec id AVCODECIDWM V3 IMAGE avctx codec id AVCODECIDV C1 IMAGE image avctx width avctx coded width v output width avctx height avctx coded height v output height if avctx skip frame AVDISCARDNONREF goto end got frame 1 else if s pict type AVPICTURETYPEB s low delay if ret av frame ref pict s current picture ptr f 0 goto err ff print debug info s s current picture ptr else if s last picture ptr NULL if ret av frame ref pict s last picture ptr f 0 goto err ff print debug info s s last picture ptr if s last picture ptr s low delay got frame 1 end av free buf2 for i 0 i n slices i av free slices i buf av free slices return buf size err av free buf2 for i 0 i n slices i av free slices i buf av free slices return 1 static int vc1 decode i block adv V C1 Context v int16 t block 64 int n int coded int codingset int mquant Get Bit Context gb v s gb Mpeg Enc Context s v s int dc pred dir 0 int i int16 t dc val int16 t ac val ac val2 int dcdiff int a avail v a avail c avail v c avail int use pred s ac pred int scale int q1 q2 0 int mb pos s mb x s mb y s mb stride if n 4 dcdiff get vlc2 s gb ff msmp4 dc luma vlc s dc table index table DCVLCBITS 3 else dcdiff get vlc2 s gb ff msmp4 dc chroma vlc s dc table index table DCVLCBITS 3 if dcdiff 0 av log s avctx AVLOGERROR Illegal DCVLC n return 1 if dcdiff if dcdiff 119 if mquant 1 dcdiff get bits gb 10 else if mquant 2 dcdiff get bits gb 9 else dcdiff get bits gb 8 else if mquant 1 dcdiff dcdiff 2 get bits gb 2 3 else if mquant 2 dcdiff dcdiff 1 get bits1 gb 1 if get bits1 gb dcdiff dcdiff dcdiff vc1 pred dc v s v overlap mquant n v a avail v c avail dc val dc pred dir dc val dcdiff if n 4 block 0 dcdiff s y dc scale else block 0 dcdiff s c dc scale i 1 if a avail c avail use pred 0 ac val s ac val 0 0 s block index n 16 ac val2 ac val scale mquant 2 mquant v pq v halfpq 0 if dc pred dir ac val 16 else ac val 16 s block wrap n q1 s current picture f qscale table mb pos if dc pred dir c avail mb pos q2 s current picture f qscale table mb pos 1 if dc pred dir a avail mb pos s mb stride q2 s current picture f qscale table mb pos s mb stride if dc pred dir n 1 q2 q1 if dc pred dir n 2 q2 q1 if n 3 q2 q1 if coded int last 0 skip value const uint8 t zz table int k if v s ac pred if use pred v fcm ILACEFRAME zz table v zzi 8x8 else if dc pred dir zz table v zz 8x8 2 else zz table v zz 8x8 3 else if v fcm ILACEFRAME zz table v zz 8x8 1 else zz table v zzi 8x8 while last vc1 decode ac coeff v last skip value codingset i skip if i 63 break block zz table i value if use pred if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA if dc pred dir for k 1 k 8 k block k v left blk sh ac val k q2 ff vc1 dqscale q1 1 0x20000 18 else for k 1 k 8 k block k v top blk sh ac val k 8 q2 ff vc1 dqscale q1 1 0x20000 18 else if dc pred dir for k 1 k 8 k block k v left blk sh ac val k else for k 1 k 8 k block k v top blk sh ac val k 8 for k 1 k 8 k ac val2 k block k v left blk sh ac val2 k 8 block k v top blk sh for k 1 k 64 k if block k block k scale if v pquantizer block k block k 0 mquant mquant if use pred i 63 else int k memset ac val2 0 16 2 if dc pred dir if use pred memcpy ac val2 ac val 8 2 if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA for k 1 k 8 k ac val2 k ac val2 k q2 ff vc1 dqscale q1 1 0x20000 18 else if use pred memcpy ac val2 8 ac val 8 8 2 if q2 q1 q2 q1 q1 2 q1 v pq v halfpq 0 1 q2 q2 2 q2 v pq v halfpq 0 1 if q1 1 return AVERRORINVALIDDATA for k 1 k 8 k ac val2 k 8 ac val2 k 8 q2 ff vc1 dqscale q1 1 0x20000 18 if use pred if dc pred dir for k 1 k 8 k block k v left blk sh ac val2 k scale if v pquantizer block k v left blk sh block k v left blk sh block k v left blk sh 0 mquant mquant else for k 1 k 8 k block k v top blk sh ac val2 k 8 scale if v pquantizer block k v top blk sh block k v top blk sh block k v top blk sh 0 mquant mquant i 63 s block last index n i return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w ret AV Frame pic data const uint8 t psrc avpkt data uint16 t y u v int aligned width avctx width 47 48 48 int stride aligned width 8 3 if avpkt size stride avctx height av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA if ret ff get buffer avctx pic 0 0 return ret y uint16 t pic data 0 u uint16 t pic data 1 v uint16 t pic data 2 pic pict type AVPICTURETYPEI pic key frame 1 val av le2ne32 src a val 0x3 FF b val 10 0x3 FF c val 20 0x3 static int mace decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int16 t samples MACE Context ctx avctx priv data int i j k l ret int is mace3 avctx codec id AVCODECIDMAC E3 frame nb samples 3 buf size 1 is mace3 avctx channels if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame extended data for i 0 i avctx channels i int16 t output samples i for j 0 j buf size avctx channels is mace3 j for k 0 k 1 is mace3 k uint8 t pkt buf i is mace3 j avctx channels is mace3 k uint8 t val 2 3 pkt 5 pkt 3 3 pkt 7 pkt 7 pkt 3 3 pkt 5 for l 0 l 3 l if is mace3 chomp3 ctx chd i output val 1 l l else chomp6 ctx chd i output val 0 l l output 1 1 is mace3 got frame ptr 1 return buf size static void apply loop filter Vp3 Decode Context s int plane int ystart int yend int x y int bounding values s bounding values array 127 int width s fragment width plane int height s fragment height plane int fragment s fragment start plane ystart width int stride s current frame linesize plane uint8 t plane data s current frame data plane if s flipped image stride stride plane data s data offset plane 8 ystart stride for y ystart y yend y for x 0 x width x if s all fragments fragment coding method MODECOPY if x 0 s vp3dsp h loop filter plane data 8 x stride bounding values if y 0 s vp3dsp v loop filter plane data 8 x stride bounding values if x width 1 s all fragments fragment 1 coding method MODECOPY s vp3dsp h loop filter plane data 8 x 8 stride bounding values if y height 1 s all fragments fragment width coding method MODECOPY s vp3dsp v loop filter plane data 8 x 8 stride stride bounding values fragment plane data 8 stride static int amrwb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMRWB Context ctx avctx priv data AV Frame frame data AMRWB Frame cf ctx frame const uint8 t buf avpkt data int buf size avpkt size int expected fr size header size float buf out float spare vector AMRWBSFRSIZE float fixed gain factor float synth fixed vector float synth fixed gain float voice fac stab fac float synth exc AMRWBSFRSIZE float hb exc AMRWBSFRSIZE 16k float hb samples AMRWBSFRSIZE 16k float hb gain int sub i ret frame nb samples 4 AMRWBSFRSIZE 16k if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 header size decode mime header ctx buf if ctx fr cur mode MODESID av log avctx AVLOGERROR Invalid mode d n ctx fr cur mode return AVERRORINVALIDDATA expected fr size cf sizes wb ctx fr cur mode 7 3 1 if buf size expected fr size av log avctx AVLOGERROR Frame too small d bytes Truncated file n buf size got frame ptr 0 return AVERRORINVALIDDATA if ctx fr quality ctx fr cur mode MODESID av log avctx AVLOGERROR Encountered a bad or corrupted frame n if ctx fr cur mode MODESID av log missing feature avctx SID mode 1 return AVERRORPATCHWELCOME ff amr bit reorder uint16 t ctx frame sizeof AMRWB Frame buf header size amr bit orderings by mode ctx fr cur mode if ctx fr cur mode MODE 6k60 decode isf indices 36b cf isp id ctx isf cur else decode isf indices 46b cf isp id ctx isf cur isf add mean and past ctx isf cur ctx isf q past ff set min dist lsf ctx isf cur MINISFSPACINGLPORDER 1 stab fac stability factor ctx isf cur ctx isf past final ctx isf cur LPORDER 1 2 0 ff acelp lsf2lspd ctx isp 3 ctx isf cur LPORDER if ctx first frame ctx first frame 0 memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof double interpolate isp ctx isp ctx isp sub4 past for sub 0 sub 4 sub ff amrwb lsp2lpc ctx isp sub ctx lp coef sub LPORDER for sub 0 sub 4 sub const AMRWB Sub Frame cur subframe cf subframe sub float sub buf buf out sub AMRWBSFRSIZE 16k decode pitch vector ctx cur subframe sub decode fixed vector ctx fixed vector cur subframe pul ih cur subframe pul il ctx fr cur mode pitch sharpening ctx ctx fixed vector decode gains cur subframe vq gain ctx fr cur mode fixed gain factor ctx pitch gain 0 ctx fixed gain 0 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c ctx fixed vector ctx fixed vector AMRWBSFRSIZEAMRWBSFRSIZE ctx prediction error ENERGYMEAN energy pred fac voice fac voice factor ctx pitch vector ctx pitch gain 0 ctx fixed vector ctx fixed gain 0 ctx tilt coef voice fac 0 25 0 25 for i 0 i AMRWBSFRSIZE i ctx excitation i ctx pitch gain 0 ctx excitation i ctx fixed gain 0 ctx fixed vector i ctx excitation i truncf ctx excitation i synth fixed gain noise enhancer ctx fixed gain 0 ctx prev tr gain voice fac stab fac synth fixed vector anti sparseness ctx ctx fixed vector spare vector pitch enhancer synth fixed vector voice fac synthesis ctx ctx lp coef sub synth exc synth fixed gain synth fixed vector ctx samples az LPORDER de emphasis ctx samples up UPSMEMSIZE ctx samples az LPORDERPREEMPHFAC ctx demph mem ff acelp apply order 2 transfer function ctx samples up UPSMEMSIZE ctx samples up UPSMEMSIZE hpf zeros hpf 31 poles hpf 31 gain ctx hpf 31 mem AMRWBSFRSIZE upsample 5 4 sub buf ctx samples up UPSFIRSIZEAMRWBSFRSIZE 16k ff acelp apply order 2 transfer function hb samples ctx samples up UPSMEMSIZE hpf zeros hpf 400 poles hpf 400 gain ctx hpf 400 mem AMRWBSFRSIZE hb gain find hb gain ctx hb samples cur subframe hb gain cf vad scaled hb excitation ctx hb exc synth exc hb gain hb synthesis ctx sub ctx samples hb LPORDER 16k hb exc ctx isf cur ctx isf past final hb fir filter hb samples bpf 6 7 coef ctx bpf 6 7 mem ctx samples hb LPORDER 16k if ctx fr cur mode MODE 23k85 hb fir filter hb samples lpf 7 coef ctx lpf 7 mem hb samples for i 0 i AMRWBSFRSIZE 16k i sub buf i sub buf i hb samples i 1 0f 1 15 update sub state ctx memcpy ctx isp sub4 past ctx isp 3 LPORDER sizeof ctx isp 3 0 memcpy ctx isf past final ctx isf cur LPORDER sizeof float got frame ptr 1 return expected fr size static int tak decode frame AV Codec Context avctx void data int got frame ptr AV Packet pkt TAK Dec Context s avctx priv data AV Frame frame data Get Bit Context gb s gb int chan i ret hsize if pkt size TAKMINFRAMEHEADERBYTES return AVERRORINVALIDDATA init get bits gb pkt data pkt size 8 if ret ff tak decode frame header avctx gb s ti 0 0 return ret if s ti flags TAKFRAMEFLAGHASMETADATA av log missing feature avctx frame metadata 1 return AVERRORPATCHWELCOME hsize get bits count gb 8 if avctx err recognition AVEFCRCCHECK if ff tak check crc pkt data hsize av log avctx AVLOGERRORCRC error n return AVERRORINVALIDDATA if s ti codec TAKCODECMONOSTEREO s ti codec TAKCODECMULTICHANNEL av log avctx AVLOGERROR unsupported codec d n s ti codec return AVERRORPATCHWELCOME if s ti data type av log avctx AVLOGERROR unsupported data type d n s ti data type return AVERRORINVALIDDATA if s ti codec TAKCODECMONOSTEREO s ti channels 2 av log avctx AVLOGERROR invalid number of channels d n s ti channels return AVERRORINVALIDDATA if s ti channels 6 av log avctx AVLOGERROR unsupported number of channels d n s ti channels return AVERRORINVALIDDATA if s ti frame samples 0 av log avctx AVLOGERROR unsupported invalid number of samples n return AVERRORINVALIDDATA if s ti bps avctx bits per coded sample avctx bits per coded sample s ti bps if ret set bps params avctx 0 return ret if s ti sample rate avctx sample rate avctx sample rate s ti sample rate set sample rate params avctx if s ti ch layout avctx channel layout s ti ch layout avctx channels s ti channels s nb samples s ti last frame samples s ti last frame samples s ti frame samples frame nb samples s nb samples if ret ff get buffer avctx frame 0 return ret if avctx bits per coded sample 16 int buf size av samples get buffer size NULL avctx channels s nb samples AVSAMPLEFMT S32 P 0 av fast malloc s decode buffer s decode buffer size buf size if s decode buffer return AVERRORENOMEM ret av samples fill arrays uint8 t s decoded NULL s decode buffer avctx channels s nb samples AVSAMPLEFMT S32 P 0 if ret 0 return ret else for chan 0 chan avctx channels chan s decoded chan int32 t frame extended data chan if s nb samples 16 for chan 0 chan avctx channels chan int32 t decoded s decoded chan for i 0 i s nb samples i decoded i get sbits gb avctx bits per coded sample else if s ti codec TAKCODECMONOSTEREO for chan 0 chan avctx channels chan if ret decode channel s chan return ret if avctx channels 2 if get bits1 gb skip bits gb 6 s dmode get bits gb 3 if ret decorrelate s 0 1 s nb samples 1 return ret else if s ti codec TAKCODECMULTICHANNEL if get bits1 gb int ch mask 0 chan get bits gb 4 1 if chan avctx channels return AVERRORINVALIDDATA for i 0 i chan i int nbit get bits gb 4 if nbit avctx channels return AVERRORINVALIDDATA if ch mask 1 nbit return AVERRORINVALIDDATA s mcdparams i present get bits1 gb if s mcdparams i present s mcdparams i index get bits gb 2 s mcdparams i chan2 get bits gb 4 if s mcdparams i index 1 if nbit s mcdparams i chan2 ch mask 1 s mcdparams i chan2 return AVERRORINVALIDDATA ch mask 1 s mcdparams i chan2 else if ch mask 1 s mcdparams i chan2 return AVERRORINVALIDDATA s mcdparams i chan1 nbit ch mask 1 nbit else chan avctx channels for i 0 i chan i s mcdparams i present 0 s mcdparams i chan1 i for i 0 i chan i if s mcdparams i present s mcdparams i index 1 if ret decode channel s s mcdparams i chan2 return ret if ret decode channel s s mcdparams i chan1 return ret if s mcdparams i present s dmode mc dmodes s mcdparams i index if ret decorrelate s s mcdparams i chan2 s mcdparams i chan1 s nb samples 1 return ret for chan 0 chan avctx channels chan int32 t decoded s decoded chan if s lpc mode chan decode lpc decoded s lpc mode chan s nb samples if s sample shift chan 0 for i 0 i s nb samples i decoded i s sample shift chan align get bits gb skip bits gb 24 if get bits left gb 0 av log avctx AVLOGDEBUG overread n else if get bits left gb 0 av log avctx AVLOGDEBUG underread n if avctx err recognition AVEFCRCCHECK if ff tak check crc pkt data hsize get bits count gb 8 hsize av log avctx AVLOGERRORCRC error n return AVERRORINVALIDDATA switch avctx sample fmt case AVSAMPLEFMT U8 P for chan 0 chan avctx channels chan uint8 t samples uint8 t frame extended data chan int32 t decoded s decoded chan for i 0 i s nb samples i samples i decoded i 0x80 break case AVSAMPLEFMT S16 P for chan 0 chan avctx channels chan int16 t samples int16 t frame extended data chan int32 t decoded s decoded chan for i 0 i s nb samples i samples i decoded i break case AVSAMPLEFMT S32 P for chan 0 chan avctx channels chan int32 t samples int32 t frame extended data chan for i 0 i s nb samples i samples i 8 break got frame ptr 1 return pkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt VB Dec Context const c avctx priv data AV Frame frame data uint8 t outptr srcptr int i j ret int flags uint32 t size int offset 0 bytestream2 init c stream avpkt data avpkt size if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret flags bytestream2 get le16 c stream if flags VBHASGMC i int16 t bytestream2 get le16 c stream j int16 t bytestream2 get le16 c stream offset i j avctx width if flags VBHASVIDEO size bytestream2 get le32 c stream vb decode framedata c offset bytestream2 skip c stream size 4 if flags VBHASPALETTE size bytestream2 get le32 c stream vb decode palette c size memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed flags VBHASPALETTE outptr frame data 0 srcptr c frame for i 0 i avctx height i memcpy outptr srcptr avctx width srcptr avctx width outptr frame linesize 0 FFSWAP uint8 t c frame c prev frame got frame 1 return avpkt size static void mark commit struct commit c void data mark object c object NULL data void ff h264 fill mbaff ref list H264 Context h int list i j for list 0 list 2 list for i 0 i h ref count list i Picture frame h ref list list i Picture field h ref list list 16 2 i field 0 frame for j 0 j 3 j field 0 f linesize j 1 field 0 f reference PICTTOPFIELD field 0 poc field 0 field poc 0 field 1 field 0 for j 0 j 3 j field 1 f data j frame f linesize j field 1 f reference PICTBOTTOMFIELD field 1 poc field 1 field poc 1 h luma weight 16 2 i list 0 h luma weight 16 2 i 1 list 0 h luma weight i list 0 h luma weight 16 2 i list 1 h luma weight 16 2 i 1 list 1 h luma weight i list 1 for j 0 j 2 j h chroma weight 16 2 i list j 0 h chroma weight 16 2 i 1 list j 0 h chroma weight i list j 0 h chroma weight 16 2 i list j 1 h chroma weight 16 2 i 1 list j 1 h chroma weight i list j 1 ENDTESTSTARTTEST test find user by ip in addr t ip unsigned int testip ip inet addr 127 0 0 1 init users ip 27 users 0 conn CONNDNSNULL testip unsigned int inet addr 10 0 0 1 fail unless find user by ip testip 1 testip unsigned int inet addr 127 0 0 2 fail unless find user by ip testip 1 users 0 active 1 testip unsigned int inet addr 127 0 0 2 fail unless find user by ip testip 1 users 0 last pkt time NULL testip unsigned int inet addr 127 0 0 2 fail unless find user by ip testip 1 users 0 authenticated 1 testip unsigned int inet addr 127 0 0 2 fail unless find user by ip testip 0 void checked xcalloc size t num size t size alloc limit assert checked xcalloc num size return xcalloc num size static int decode udvm address operand guint8 buff guint operand address guint16 value guint current address guint32 result guint16 value1 guint next opreand address next opreand address decode udvm multitype operand buff operand address value1 result value1 0xffff result result current address value result 0xffff return next opreand address static int amrnb decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AMR Context p avctx priv data AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float buf out int i subframe ret float fixed gain factor AMR Fixed fixed sparse 0 float spare vector AMRSUBFRAMESIZE float synth fixed gain const float synth fixed vector frame nb samples AMRBLOCKSIZE if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf out float frame data 0 p cur frame mode unpack bitstream p buf buf size if p cur frame mode NODATA av log avctx AVLOGERROR Corrupt bitstream n return AVERRORINVALIDDATA if p cur frame mode MODEDTX av log missing feature avctx dtx mode 1 return AVERRORPATCHWELCOME if p cur frame mode MODE 12k2 lsf2lsp 5 p else lsf2lsp 3 p for i 0 i 4 i ff acelp lspd2lpc p lsp i p lpc i 5 for subframe 0 subframe 4 subframe const AMRNB Subframe amr subframe p frame subframe subframe decode pitch vector p amr subframe subframe decode fixed sparse fixed sparse amr subframe pulses p cur frame mode subframe decode gains p amr subframe p cur frame mode subframe fixed gain factor pitch sharpening p subframe p cur frame mode fixed sparse if fixed sparse pitch lag 0 av log avctx AVLOGERROR The file is corrupted pitch lag 0 is not allowed n return AVERRORINVALIDDATA ff set fixed vector p fixed vector fixed sparse 1 0 AMRSUBFRAMESIZE p fixed gain 4 ff amr set fixed gain fixed gain factor avpriv scalarproduct float c p fixed vector p fixed vector AMRSUBFRAMESIZEAMRSUBFRAMESIZE p prediction error energy mean p cur frame mode energy pred fac for i 0 i AMRSUBFRAMESIZE i p excitation i p pitch gain 4 ff set fixed vector p excitation fixed sparse p fixed gain 4 AMRSUBFRAMESIZE for i 0 i AMRSUBFRAMESIZE i p excitation i truncf p excitation i synth fixed gain fixed gain smooth p p lsf q subframe p lsf avg p cur frame mode synth fixed vector anti sparseness p fixed sparse p fixed vector synth fixed gain spare vector if synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 0 synthesis p p lpc subframe synth fixed gain synth fixed vector p samples in LPFILTERORDER 1 postfilter p p lpc subframe buf out subframe AMRSUBFRAMESIZE ff clear fixed vector p fixed vector fixed sparse AMRSUBFRAMESIZE update state p ff acelp apply order 2 transfer function buf out buf out highpass zeros highpass poles highpass gain AMRSAMPLESCALE p high pass mem AMRBLOCKSIZE ff weighted vector sumf p lsf avg p lsf avg p lsf q 3 0 84 0 16 LPFILTERORDER got frame ptr 1 return frame sizes nb p cur frame mode 1 static vpx codec err t encoder init vpx codec ctx t ctx vpx codec priv enc mr cfg t data vpx codec err t res VPXCODECOK void data if ctx priv NULL vpx codec alg priv t const priv vpx calloc 1 sizeof priv if priv NULL return VPXCODECMEMERROR ctx priv vpx codec priv t priv ctx priv init flags ctx init flags ctx priv enc total encoders 1 if ctx config enc priv cfg ctx config enc ctx config enc priv cfg priv extra cfg default extra cfg vp9 initialize enc res validate config priv priv cfg priv extra cfg if res VPXCODECOK set encoder config priv oxcf priv cfg priv extra cfg priv cpi vp9 create compressor priv oxcf if priv cpi NULL res VPXCODECMEMERROR else priv cpi output pkt list priv pkt list head return res uint8 t jbig2 decode gray scale image Jbig2 Ctx ctx Jbig2 Segment segment const byte data const size t size bool GSMMR uint32 t GSW uint32 t GSH uint32 t GSBPP bool GSUSESKIP Jbig2 Image GSKIP int GSTEMPLATE Jbig2 Arith Cx GB stats uint8 t GSVALSNULL size t consumed bytes 0 int i j code stride int x y Jbig2 Image GSPLANES Jbig2 Generic Region Params rparams Jbig2 Word Stream ws NULL Jbig2 Arith State as NULLGSPLANES jbig2 new ctx Jbig2 Image GSBPP if GSPLANESNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate d bytes for GSPLANESGSBPP return NULL for i 0 i GSBPP i GSPLANES i jbig2 image new ctx GSWGSH if GSPLANES i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate dx d image for GSPLANESGSWGSH for j i 1 j 0 j jbig2 image release ctx GSPLANES j jbig2 free ctx allocator GSPLANES return NULL rparams MMRGSMMR rparams GBTEMPLATEGSTEMPLATE rparams TPGDON 0 rparams USESKIPGSUSESKIP rparams gbat 0 GSTEMPLATE 1 3 2 rparams gbat 1 1 rparams gbat 2 3 rparams gbat 3 1 rparams gbat 4 2 rparams gbat 5 2 rparams gbat 6 2 rparams gbat 7 2 if GSMMR code jbig2 decode halftone mmr ctx rparams data size GSPLANESGSBPP 1 consumed bytes else ws jbig2 word stream buf new ctx data size if ws NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate ws in jbig2 decode gray scale image goto cleanup as jbig2 arith new ctx ws if as NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate as in jbig2 decode gray scale image goto cleanup code jbig2 decode generic region ctx segment rparams as GSPLANESGSBPP 1 GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup j GSBPP 2 while j 0 if GSMMR code jbig2 decode halftone mmr ctx rparams data consumed bytes size consumed bytes GSPLANES j consumed bytes else code jbig2 decode generic region ctx segment rparams as GSPLANES j GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup stride GSPLANES 0 stride for i 0 i stride GSH i GSPLANES j data i GSPLANES j 1 data i j GSVALS jbig2 new ctx uint8 t GSW if GSVALSNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSW goto cleanup for i 0 i GSW i GSVALS i jbig2 new ctx uint8 t GSH if GSVALS i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSHGSW for j i 1 j 0 j jbig2 free ctx allocator GSVALS j jbig2 free ctx allocator GSVALSGSVALSNULL goto cleanup for x 0 x GSW x for y 0 y GSH y GSVALS x y 0 for j 0 j GSBPP j GSVALS x y jbig2 image get pixel GSPLANES j x y j cleanup if GSMMR jbig2 free ctx allocator as jbig2 word stream buf free ctx ws for i 0 i GSBPP i jbig2 image release ctx GSPLANES i jbig2 free ctx allocator GSPLANES return int ff h264 fill default ref list H264 Context h int i len if h slice type nos AVPICTURETYPEB Picture sorted 32 int cur poc list int lens 2 if FIELDPICTURE cur poc h cur pic ptr field poc h picture structure PICTBOTTOMFIELD else cur poc h cur pic ptr poc for list 0 list 2 list len add sorted sorted h short ref h short ref count cur poc 1 list len add sorted sorted len h short ref h short ref count cur poc 0 list assert len 32 len build def list h default ref list list sorted len 0 h picture structure len build def list h default ref list list len h long ref 16 1 h picture structure assert len 32 if len h ref count list memset h default ref list list len 0 sizeof Picture h ref count list len lens list len if lens 0 lens 1 lens 1 1 for i 0 h default ref list 0 i f data 0 h default ref list 1 i f data 0 i lens 0 i if i lens 0 Picture tmp COPYPICTURE tmp h default ref list 1 0 COPYPICTURE h default ref list 1 0 h default ref list 1 1 COPYPICTURE h default ref list 1 1 tmp else len build def list h default ref list 0 h short ref h short ref count 0 h picture structure len build def list h default ref list 0 len h long ref 16 1 h picture structure assert len 32 if len h ref count 0 memset h default ref list 0 len 0 sizeof Picture h ref count 0 len i h ref count 0 i tprintf h avctx List0 s fn d 0x p n h default ref list 0 i long ref LTST h default ref list 0 i pic id h default ref list 0 i f data 0 if h slice type nos AVPICTURETYPEB for i 0 i h ref count 1 i tprintf h avctx List1 s fn d 0x p n h default ref list 1 i long ref LTST h default ref list 1 i pic id h default ref list 1 i f data 0 static void encode breakout test V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col MVREFERENCEFRAME ref frame PREDICTIONMODE this mode unsigned int var y unsigned int sse y struct buf 2d yv12 mb MAXMBPLANE int rate int64 t dist MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi const BLOCKSIZE uv size get plane block size bsize xd plane 1 unsigned int var var y sse sse y unsigned int thresh ac unsigned int thresh dc if x encode breakout 0 const unsigned int max thresh 36000 const unsigned int min thresh MIN unsigned int x encode breakout 4 max thresh thresh ac xd plane 0 dequant 1 xd plane 0 dequant 1 9 thresh ac clamp thresh ac min thresh max thresh thresh ac b width log2 bsize b height log2 bsize thresh dc xd plane 0 dequant 0 xd plane 0 dequant 0 6 else thresh ac 0 thresh dc 0 if var thresh ac sse var thresh dc unsigned int sse u sse v unsigned int var u var v if x encode breakout 0 xd plane 1 pre 0 yv12 mb ref frame 1 xd plane 2 pre 0 yv12 mb ref frame 2 vp9 build inter predictors sbuv xd mi row mi col bsize var u cpi fn ptr uv size vf x plane 1 src buf x plane 1 src stride xd plane 1 dst buf xd plane 1 dst stride sse u if var u 4 thresh ac sse u var u thresh dc var v cpi fn ptr uv size vf x plane 2 src buf x plane 2 src stride xd plane 2 dst buf xd plane 2 dst stride sse v if var v 4 thresh ac sse v var v thresh dc x skip 1 rate cpi inter mode cost mbmi mode context ref frame INTEROFFSET this mode dist sse 4 int ff ivi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt IV I45 Dec Context ctx avctx priv data const uint8 t buf avpkt data AV Frame frame data int buf size avpkt size int result p b init get bits ctx gb buf buf size 8 ctx frame data buf ctx frame size buf size result ctx decode pic hdr ctx avctx if result av log avctx AVLOGERROR Error while decoding picture header d n result return 1 if ctx gop invalid return AVERRORINVALIDDATA if ctx gop flags IV I5 ISPROTECTED av log avctx AVLOGERROR Password protected clip n return 1 ctx switch buffers ctx if ctx is nonnull frame ctx for p 0 p 3 p for b 0 b ctx planes p num bands b result decode band ctx ctx planes p bands b avctx if result av log avctx AVLOGERROR Error while decoding band d plane d n b p return 1 if avctx codec id AVCODECIDINDE O4 ctx frame type 0 while get bits ctx gb 8 skip bits long ctx gb 64 if get bits left ctx gb 18 show bits ctx gb 18 0x3 FF F8 av log avctx AVLOGERROR Buffer contains IP frames n avcodec set dimensions avctx ctx planes 0 width ctx planes 0 height if result ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return result if ctx is scalable if avctx codec id AVCODECIDINDE O4 ff ivi recompose haar ctx planes 0 frame data 0 frame linesize 0 else ff ivi recompose53 ctx planes 0 frame data 0 frame linesize 0 else ivi output plane ctx planes 0 frame data 0 frame linesize 0 ivi output plane ctx planes 2 frame data 1 frame linesize 1 ivi output plane ctx planes 1 frame data 2 frame linesize 2 got frame 1 return buf size void bluetooth add address packet info pinfo address addr const gchar setup method guint32 setup frame number gboolean is video void data address null addr conversation t p conv struct rtp conversation info p conv data NULL if pinfo fd flags visited rtp handle NULL return SETADDRESS null addr ATNONE 0 NULL p conv find conversation setup frame number addr null addr PTBLUETOOTH 0 0 NOADDRBNOPORTB if p conv p conv setup frame setup frame number p conv conversation new setup frame number addr null addr PTBLUETOOTH 0 0 NOADD R2 NOPOR T2 conversation set dissector p conv rtp handle p conv data struct rtp conversation info conversation get proto data p conv proto rtp if p conv data p conv data wmem new wmem file scope struct rtp conversation info p conv data rtp dyn payload NULL p conv data extended seqno 0x10000 p conv data rtp conv info wmem new wmem file scope rtp private conv info p conv data rtp conv info multisegment pdus wmem tree new wmem file scope conversation add proto data p conv proto rtp p conv data if is video p conv data bta2dp info NULL p conv data btvdp info btvdp codec info t wmem memdup wmem file scope data sizeof btvdp codec info t else p conv data bta2dp info bta2dp codec info t wmem memdup wmem file scope data sizeof bta2dp codec info t p conv data btvdp info NULL rtp dyn payload free p conv data rtp dyn payload g strlcpy p conv data method setup method MAXRTPSETUPMETHODSIZE 1 p conv data frame number setup frame number p conv data is video is video p conv data rtp dyn payload NULL p conv data srtp info void vp9 foreach transformed block in plane const MACROBLOCKD const xd BLOCKSIZE bsize int plane foreach transformed block visitor visit void arg const struct macroblockd plane const pd xd plane plane const MBMODEINFO mbmi xd mi 0 src mi mbmi const TXSIZE tx size plane get uv tx size mbmi pd mbmi tx size const BLOCKSIZE plane bsize get plane block size bsize pd const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int step 1 tx size 1 int i if xd mb to right edge 0 xd mb to bottom edge 0 int r c int max blocks wide num 4x4 w int max blocks high num 4x4 h if xd mb to right edge 0 max blocks wide xd mb to right edge 5 pd subsampling x if xd mb to bottom edge 0 max blocks high xd mb to bottom edge 5 pd subsampling y i 0 for r 0 r num 4x4 h r 1 tx size for c 0 c num 4x4 w c 1 tx size if r max blocks high c max blocks wide visit plane i plane bsize tx size arg i step else for i 0 i num 4x4 w num 4x4 h i step visit plane i plane bsize tx size arg void ff h263 encode mb Mpeg Enc Context s int16 t block 6 64 int motion x int motion y int cbpc cbpy i cbp pred x pred y int16 t pred dc int16 t rec intradc 6 int16 t dc ptr 6 const int interleaved stats s flags CODECFLAGPAS S1 if s mb intra cbp get p cbp s block motion x motion y if cbp motion x motion y s dquant s mv type MVTYPE 16 X16 0 put bits s pb 1 1 if interleaved stats s misc bits s last bits s skip count return put bits s pb 1 0 cbpc cbp 3 cbpy cbp 2 if s alt inter vlc 0 cbpc 3 cbpy 0x F if s dquant cbpc 8 if s mv type MVTYPE 16 X16 put bits s pb ff h263 inter MCBPC bits cbpc ff h263 inter MCBPC code cbpc put bits s pb ff h263 cbpy tab cbpy 1 ff h263 cbpy tab cbpy 0 if s dquant put bits s pb 2 dquant code s dquant 2 if interleaved stats s misc bits get bits diff s ff h263 pred motion s 0 0 pred x pred y if s umvplus ff h263 encode motion vector s motion x pred x motion y pred y 1 else h263p encode umotion s motion x pred x h263p encode umotion s motion y pred y if motion x pred x 1 motion y pred y 1 put bits s pb 1 1 else put bits s pb ff h263 inter MCBPC bits cbpc 16 ff h263 inter MCBPC code cbpc 16 put bits s pb ff h263 cbpy tab cbpy 1 ff h263 cbpy tab cbpy 0 if s dquant put bits s pb 2 dquant code s dquant 2 if interleaved stats s misc bits get bits diff s for i 0 i 4 i ff h263 pred motion s i 0 pred x pred y motion x s current picture motion val 0 s block index i 0 motion y s current picture motion val 0 s block index i 1 if s umvplus ff h263 encode motion vector s motion x pred x motion y pred y 1 else h263p encode umotion s motion x pred x h263p encode umotion s motion y pred y if motion x pred x 1 motion y pred y 1 put bits s pb 1 1 if interleaved stats s mv bits get bits diff s else assert s mb intra cbp 0 if s h263 aic for i 0 i 6 i int16 t level block i 0 int scale if i 4 scale s y dc scale else scale s c dc scale pred dc ff h263 pred dc s i dc ptr i level pred dc if level 0 level level scale 1 scale else level level scale 1 scale if level 0 s block last index i 0 s block last index i 1 if s modified quant if level 127 level 127 else if level 127 level 127 block i 0 level rec intradc i scale level pred dc rec intradc i 1 if rec intradc i 0 rec intradc i 0 else if rec intradc i 2047 rec intradc i 2047 dc ptr i rec intradc i if s block last index i 0 cbp 1 5 i else for i 0 i 6 i if s block last index i 1 cbp 1 5 i cbpc cbp 3 if s pict type AVPICTURETYPEI if s dquant cbpc 4 put bits s pb ff h263 intra MCBPC bits cbpc ff h263 intra MCBPC code cbpc else if s dquant cbpc 8 put bits s pb 1 0 put bits s pb ff h263 inter MCBPC bits cbpc 4 ff h263 inter MCBPC code cbpc 4 if s h263 aic put bits s pb 1 0 cbpy cbp 2 put bits s pb ff h263 cbpy tab cbpy 1 ff h263 cbpy tab cbpy 0 if s dquant put bits s pb 2 dquant code s dquant 2 if interleaved stats s misc bits get bits diff s for i 0 i 6 i h263 encode block s block i i if s h263 aic s mb intra block i 0 rec intradc i if interleaved stats if s mb intra s p tex bits get bits diff s s f count else s i tex bits get bits diff s s i count int ff mpeg4 set direct mv Mpeg Enc Context s int mx int my const int mb index s mb x s mb y s mb stride const int colocated mb type s next picture mb type mb index uint16 t time pp uint16 t time pb int i if IS 8 X8 colocated mb type s mv type MVTYPE 8 X8 for i 0 i 4 i ff mpeg4 set one direct mv s mx my i return MBTYPEDIREC T2 MBTYPE 8x8 MBTYPE L0 L1 else if ISINTERLACED colocated mb type s mv type MVTYPEFIELD for i 0 i 2 i int field select s next picture ref index 0 4 mb index 2 i s field select 0 i field select s field select 1 i i if s top field first time pp s pp field time field select i time pb s pb field time field select i else time pp s pp field time field select i time pb s pb field time field select i s mv 0 i 0 s p field mv table i 0 mb index 0 time pb time pp mx s mv 0 i 1 s p field mv table i 0 mb index 1 time pb time pp my s mv 1 i 0 mx s mv 0 i 0 s p field mv table i 0 mb index 0 s p field mv table i 0 mb index 0 time pb time pp time pp s mv 1 i 1 my s mv 0 i 1 s p field mv table i 0 mb index 1 s p field mv table i 0 mb index 1 time pb time pp time pp return MBTYPEDIREC T2 MBTYPE 16x8 MBTYPE L0 L1 MBTYPEINTERLACED else ff mpeg4 set one direct mv s mx my 0 s mv 0 1 0 s mv 0 2 0 s mv 0 3 0 s mv 0 0 0 s mv 0 1 1 s mv 0 2 1 s mv 0 3 1 s mv 0 0 1 s mv 1 1 0 s mv 1 2 0 s mv 1 3 0 s mv 1 0 0 s mv 1 1 1 s mv 1 2 1 s mv 1 3 1 s mv 1 0 1 if s avctx workaround bugs FFBUGDIRECTBLOCKSIZE s quarter sample s mv type MVTYPE 16 X16 else s mv type MVTYPE 8 X8 return MBTYPEDIREC T2 MBTYPE 16x16 MBTYPE L0 L1 static int mp decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Motion Pixels Context mp avctx priv data Get Bit Context gb int i count1 count2 sz mp frame reference 1 mp frame buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if avctx reget buffer avctx mp frame av log avctx AVLOGERROR reget buffer failed n return 1 av fast malloc mp bswapbuf mp bswapbuf size buf size FFINPUTBUFFERPADDINGSIZE if mp bswapbuf return AVERRORENOMEM mp dsp bswap buf uint32 t mp bswapbuf const uint32 t buf buf size 4 if buf size 3 memcpy mp bswapbuf buf size 3 buf buf size 3 buf size 3 memset mp bswapbuf buf size 0 FFINPUTBUFFERPADDINGSIZE init get bits gb mp bswapbuf buf size 8 memset mp changes map 0 avctx width avctx height for i avctx extradata 1 2 i 2 i count1 get bits gb 12 count2 get bits gb 12 mp read changes map mp gb count1 8 i mp read changes map mp gb count2 4 i mp codes count get bits gb 4 if mp codes count 0 goto end if mp changes map 0 0 uint16 t mp frame data 0 get bits gb 15 mp changes map 0 1 mp read codes table mp gb sz get bits gb 18 if avctx extradata 0 5 sz get bits gb 18 if sz 0 goto end if mp max codes bits 0 goto end if init vlc mp vlc mp max codes bits mp codes count mp codes 0 size sizeof Huff Code 1 mp codes 0 code sizeof Huff Code 4 0 goto end mp decode frame helper mp gb ff free vlc mp vlc end got frame 1 AV Frame data mp frame return buf size int vp9 get tx size context const MACROBLOCKD xd const int max tx size max txsize lookup xd mi 0 mbmi sb type const MBMODEINFO const above mbmi get mbmi get above mi xd const MBMODEINFO const left mbmi get mbmi get left mi xd const int has above above mbmi NULL const int has left left mbmi NULL int above ctx has above above mbmi skip int above mbmi tx size max tx size int left ctx has left left mbmi skip int left mbmi tx size max tx size if has left left ctx above ctx if has above above ctx left ctx return above ctx left ctx max tx size void vp9 regular quantize b 4x4 MACROBLOCK x int plane int block const int16 t scan const int16 t iscan MACROBLOCKD const xd x e mbd struct macroblock plane p x plane plane struct macroblockd plane pd xd plane plane vp9 high quantize b BLOCKOFFSET p coeff block 16 x skip block p zbin p round p quant p quant shift BLOCKOFFSET p qcoeff block BLOCKOFFSET pd dqcoeff block pd dequant p zbin extra p eobs block scan iscan return static inline void rv34 mc R V34 Dec Context r const int block type const int xoff const int yoff int mv off const int width const int height int dir const int thirdpel int weighted qpel mc func qpel mc 16 h264 chroma mc func chroma mc Mpeg Enc Context s r s uint8 t YUV src Y src U src V int dxy mx my umx umy lx ly uvmx uvmy src x src y uvsrc x uvsrc y int mv pos s mb x 2 s mb y 2 s b8 stride mv off int is16x16 1 if thirdpel int chroma mx chroma my mx s current picture ptr motion val dir mv pos 0 3 24 3 1 24 my s current picture ptr motion val dir mv pos 1 3 24 3 1 24 lx s current picture ptr motion val dir mv pos 0 3 24 3 ly s current picture ptr motion val dir mv pos 1 3 24 3 chroma mx s current picture ptr motion val dir mv pos 0 2 chroma my s current picture ptr motion val dir mv pos 1 2 umx chroma mx 3 24 3 1 24 umy chroma my 3 24 3 1 24 uvmx chroma coeffs chroma mx 3 24 3 uvmy chroma coeffs chroma my 3 24 3 else int cx cy mx s current picture ptr motion val dir mv pos 0 2 my s current picture ptr motion val dir mv pos 1 2 lx s current picture ptr motion val dir mv pos 0 3 ly s current picture ptr motion val dir mv pos 1 3 cx s current picture ptr motion val dir mv pos 0 2 cy s current picture ptr motion val dir mv pos 1 2 umx cx 2 umy cy 2 uvmx cx 3 1 uvmy cy 3 1 if uvmx 6 uvmy 6 uvmx uvmy 4 if HAVETHREADS s avctx active thread type FFTHREADFRAME int mb row s mb y yoff my 5 8 height 4 Thread Frame f dir s next picture ptr tf s last picture ptr tf ff thread await progress f mb row 0 dxy ly 4 lx src Y dir s next picture ptr f data 0 s last picture ptr f data 0 src U dir s next picture ptr f data 1 s last picture ptr f data 1 src V dir s next picture ptr f data 2 s last picture ptr f data 2 src x s mb x 16 xoff mx src y s mb y 16 yoff my uvsrc x s mb x 8 xoff 1 umx uvsrc y s mb y 8 yoff 1 umy src Y src y s linesize src x src U uvsrc y s uvlinesize uvsrc x src V uvsrc y s uvlinesize uvsrc x if s h edge pos width 3 6 s v edge pos height 3 6 unsigned src x lx 2 s h edge pos lx 2 width 3 4 unsigned src y ly 2 s v edge pos ly 2 height 3 4 uint8 t uvbuf s edge emu buffer 22 s linesize src Y 2 2 s linesize s vdsp emulated edge mc s edge emu buffer src Y s linesize width 3 6 height 3 6 src x 2 src y 2 s h edge pos s v edge pos src Y s edge emu buffer 2 2 s linesize s vdsp emulated edge mc uvbuf src U s uvlinesize width 2 1 height 2 1 uvsrc x uvsrc y s h edge pos 1 s v edge pos 1 s vdsp emulated edge mc uvbuf 16 src V s uvlinesize width 2 1 height 2 1 uvsrc x uvsrc y s h edge pos 1 s v edge pos 1 src U uvbuf src V uvbuf 16 if weighted Y s dest 0 xoff yoff s linesize U s dest 1 xoff 1 yoff 1 s uvlinesize V s dest 2 xoff 1 yoff 1 s uvlinesize else Y r tmp b block y dir xoff yoff s linesize U r tmp b block uv dir 2 xoff 1 yoff 1 s uvlinesize V r tmp b block uv dir 2 1 xoff 1 yoff 1 s uvlinesize if block type R V34 MBP 16x8 qpel mc 1 dxy Y src Y s linesize Y 8 src Y 8 else if block type R V34 MBP 8x16 qpel mc 1 dxy Y src Y s linesize Y 8 s linesize src Y 8 s linesize is16x16 block type R V34 MBP 8x8 block type R V34 MBP 16x8 block type R V34 MBP 8x16 qpel mc is16x16 dxy Y src Y s linesize chroma mc 2 width U src U s uvlinesize height 4 uvmx uvmy chroma mc 2 width V src V s uvlinesize height 4 uvmx uvmy static void ppp hdlc netdissect options ndo const u char p int length u char b s t c int i proto const void se if length 0 return b uint8 t malloc length if b NULL return for s u char p t b i length i 0 i c s if c 0x7d if i 1 i c s 0x20 else continue t c se ndo ndo snapend ndo ndo snapend t length t b if length 1 goto trunc proto b switch proto case PPPIP ip print ndo b 1 length 1 goto cleanup case PPPIP V6 ip6 print ndo b 1 length 1 goto cleanup default break if length 2 goto trunc proto EXTRACT 16 BITS b switch proto case PPPADDRESS 8 PPPCONTROL if length 4 goto trunc proto EXTRACT 16 BITS b 2 handle ppp ndo proto b 4 length 4 break default handle ppp ndo proto b 2 length 2 break cleanup ndo ndo snapend se free b return trunc ndo ndo snapend se free b NDPRINT ndo ppp static void parse content type struct attachment istream astream const struct message header line hdr struct rfc822 parser context parser string t content type if astream part content type NULL return rfc822 parser init parser hdr full value hdr full value len NULL rfc822 skip lwsp parser TBEGIN content type t str new 64 void rfc822 parse content type parser content type astream part content type i strdup str c content type TEND rfc822 parser deinit parser static char create argv command struct rule rule struct process process struct iovec argv size t count i j stdin arg char req argv NULL const char program for count 0 argv count NULL count if rule sudo user NULL req argv xcalloc count 1 sizeof char else req argv xcalloc count 5 sizeof char if rule sudo user NULL req argv 0 xstrdup PATHSUDO req argv 1 xstrdup u req argv 2 xstrdup rule sudo user req argv 3 xstrdup req argv 4 xstrdup rule program j 5 else program strrchr rule program if program NULL program rule program else program req argv 0 xstrdup program j 1 if rule stdin arg 1 stdin arg count 1 else stdin arg size t rule stdin arg for i 1 i count i const char data argv i iov base size t length argv i iov len if i stdin arg process input evbuffer new if process input NULL die internal error cannot create input buffer if evbuffer add process input data length 0 die internal error cannot add data to input buffer continue if length 0 req argv j xstrdup else req argv j xstrndup data length j req argv j NULL return req argv static int read intra segment id V P9 COMMON const cm MACROBLOCKD const xd int mi row int mi col vp9 reader r struct segmentation const seg cm seg const BLOCKSIZE bsize xd mi 0 src mi mbmi sb type int segment id if seg enabled return 0 if seg update map return 0 segment id read segment id r seg set segment id cm bsize mi row mi col segment id return segment id static int64 t rd sbuv dcpred const V P9 COMP cpi MACROBLOCK x int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize const V P9 COMMON cm cpi common int64 t unused x e mbd mi 0 mbmi uv mode DCPRED super block uvrd cpi x rate tokenonly distortion skippable unused bsize IN T64 MAX rate rate tokenonly cpi intra uv mode cost cm frame type DCPRED return RDCOST x rdmult x rddiv rate distortion static void cirrus mem writeb mode4and5 8bpp Cirrus VGA State s unsigned mode unsigned offset uint32 t mem value int x unsigned val mem value uint8 t dst for x 0 x 8 x dst s vga vram ptr offset x s cirrus addr mask if val 0x80 dst s cirrus shadow gr1 else if mode 5 dst s cirrus shadow gr0 val 1 memory region set dirty s vga vram offset 8 static void model rd for sb y V P9 COMP cpi BLOCKSIZE bsize MACROBLOCK x MACROBLOCKD xd int out rate sum int64 t out dist sum unsigned int var y unsigned int sse y unsigned int sse int rate int64 t dist struct macroblock plane const p x plane 0 struct macroblockd plane const pd xd plane 0 const uint32 t dc quant pd dequant 0 const uint32 t ac quant pd dequant 1 unsigned int var cpi fn ptr bsize vf p src buf p src stride pd dst buf pd dst stride sse var y var sse y sse if sse dc quant dc quant 6 x skip txfm 0 1 else if var ac quant ac quant 6 x skip txfm 0 2 else x skip txfm 0 0 if cpi common tx mode TXMODESELECT if sse var 2 xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode else xd mi 0 src mi mbmi tx size TX 8 X8 else xd mi 0 src mi mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size cpi common tx mode vp9 model rd from var lapndz sse var 1 num pels log2 lookup bsize dc quant 3 rate dist out rate sum rate 1 out dist sum dist 3 vp9 model rd from var lapndz var 1 num pels log2 lookup bsize ac quant 3 rate dist out rate sum rate out dist sum dist 4 static int temporal filter find matching mb c V P9 COMP cpi uint8 t arf frame buf uint8 t frame ptr buf int stride MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd const MVSPEEDFEATURES const mv sf cpi sf mv int step param int sadpb x sadperbit16 int bestsme INTMAX int distortion unsigned int sse int sad list 5 MV best ref mv1 0 0 MV best ref mv1 full MV ref mv x e mbd mi 0 src mi bmi 0 as mv 0 as mv struct buf 2d src x plane 0 src struct buf 2d pre xd plane 0 pre 0 best ref mv1 full col best ref mv1 col 3 best ref mv1 full row best ref mv1 row 3 x plane 0 src buf arf frame buf x plane 0 src stride stride xd plane 0 pre 0 buf frame ptr buf xd plane 0 pre 0 stride stride step param mv sf reduce first step size step param MIN step param MAXMVSEARCHSTEPS 2 vp9 hex search x best ref mv1 full step param sadpb 1 cond sad list cpi sad list cpi fn ptr BLOCK 16 X16 0 best ref mv1 ref mv bestsme cpi find fractional mv step x ref mv best ref mv1 cpi common allow high precision mv x errorperbit cpi fn ptr BLOCK 16 X16 0 mv sf subpel iters per step cond sad list cpi sad list NULLNULL distortion sse NULL 0 0 x plane 0 src src xd plane 0 pre 0 pre return bestsme static int truespeech decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size TS Context c avctx priv data int i j int16 t samples int iterations ret iterations buf size 32 if iterations av log avctx AVLOGERROR Too small input buffer d bytes need at least 32 bytes n buf size return 1 frame nb samples iterations 240 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 memset samples 0 iterations 240 sizeof samples for j 0 j iterations j truespeech read frame c buf buf 32 truespeech correlate filter c truespeech filters merge c for i 0 i 4 i truespeech apply twopoint filter c i truespeech place pulses c samples i truespeech update filters c samples i truespeech synth c samples i samples 60 truespeech save prevvec c got frame ptr 1 return buf size void traverse commit list struct rev info revs show commit fn show commit show object fn show object void data int i struct commit commit struct strbuf base strbuf init base PATHMAX while commit get revision revs NULL if commit tree add pending tree revs commit tree show commit commit data for i 0 i revs pending nr i struct object array entry pending revs pending objects i struct object obj pending item const char name pending name const char path pending path if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN show object obj NULL name data continue if path path if obj type OBJTREE process tree revs struct tree obj show object NULL base path data continue if obj type OBJBLOB process blob revs struct blob obj show object NULL path data continue die unknown pending object s s oid to hex obj oid name object array clear revs pending strbuf release base static void alloc mode context V P9 COMMON cm int num 4x4 blk PICKMODECONTEXT ctx const int num blk num 4x4 blk 4 4 num 4x4 blk const int num pix num blk 4 int i k ctx num 4x4 blk num blk CHECKMEMERROR cm ctx zcoeff blk vpx calloc num 4x4 blk sizeof uint8 t for i 0 i MAXMBPLANE i for k 0 k 3 k CHECKMEMERROR cm ctx coeff i k vpx memalign 16 num pix sizeof ctx coeff i k CHECKMEMERROR cm ctx qcoeff i k vpx memalign 16 num pix sizeof ctx qcoeff i k CHECKMEMERROR cm ctx dqcoeff i k vpx memalign 16 num pix sizeof ctx dqcoeff i k CHECKMEMERROR cm ctx eobs i k vpx memalign 16 num pix sizeof ctx eobs i k ctx coeff pbuf i k ctx coeff i k ctx qcoeff pbuf i k ctx qcoeff i k ctx dqcoeff pbuf i k ctx dqcoeff i k ctx eobs pbuf i k ctx eobs i k static int dtls1 retrieve buffered fragment SSL s int ok pitem item hm fragment frag int al ok 0 do item pqueue peek s d1 buffered messages if item NULL return 0 frag hm fragment item data if frag msg header seq s d1 handshake read seq pqueue pop s d1 buffered messages dtls1 hm fragment free frag pitem free item item NULL frag NULL while item NULL if frag reassembly NULL return 0 if s d1 handshake read seq frag msg header seq unsigned long frag len frag msg header frag len pqueue pop s d1 buffered messages al dtls1 preprocess fragment s frag msg header if al 0 unsigned char p unsigned char s init buf data DTL S1 HMHEADERLENGTH memcpy p frag msg header frag off frag fragment frag msg header frag len dtls1 hm fragment free frag pitem free item if al 0 ok 1 return frag len ssl3 send alert s SS L3 ALFATAL al s init num 0 ok 0 return 1 else return 0 static int64 t encode inter mb segment V P9 COMP cpi MACROBLOCK x int64 t best yrd int i int labelyrate int64 t distortion int64 t sse ENTROPYCONTEXT ta ENTROPYCONTEXT tl int mi row int mi col int k MACROBLOCKD xd x e mbd struct macroblockd plane const pd xd plane 0 struct macroblock plane const p x plane 0 MODEINFO const mi xd mi 0 src mi const BLOCKSIZE plane bsize get plane block size mi mbmi sb type pd const int width 4 num 4x4 blocks wide lookup plane bsize const int height 4 num 4x4 blocks high lookup plane bsize int idx idy const uint8 t const src p src buf raster block offset BLOCK 8 X8 i p src stride uint8 t const dst pd dst buf raster block offset BLOCK 8 X8 i pd dst stride int64 t thisdistortion 0 thissse 0 int thisrate 0 ref const scan order so vp9 default scan orders TX 4 X4 const int is compound has second ref mi mbmi const Interp Kernel kernel vp9 get interp kernel mi mbmi interp filter for ref 0 ref 1 is compound ref const uint8 t pre pd pre ref buf raster block offset BLOCK 8 X8 i pd pre ref stride vp9 build inter predictor pre pd pre ref stride dst pd dst stride mi bmi i as mv ref as mv xd block refs ref sf width height ref kernel MVPRECISION Q3 mi col MISIZE 4 i 2 mi row MISIZE 4 i 2 vp9 subtract block height width raster block offset int16 BLOCK 8 X8 i p src diff 8 src p src stride dst pd dst stride k i for idy 0 idy height 4 idy for idx 0 idx width 4 idx int64 t ssz rd rd1 rd2 tran low t coeff k idy 2 idx coeff BLOCKOFFSET p coeff k x fwd txm4x4 raster block offset int16 BLOCK 8 X8 k p src diff coeff 8 vp9 regular quantize b 4x4 x 0 k so scan so iscan thisdistortion vp9 block error coeff BLOCKOFFSET pd dqcoeff k 16 ssz thissse ssz thisrate cost coeffs x 0 k ta k 1 tl k 1 TX 4 X4 so scan so neighbors cpi sf use fast coef costing rd1 RDCOST x rdmult x rddiv thisrate thisdistortion 2 rd2 RDCOST x rdmult x rddiv 0 thissse 2 rd MIN rd1 rd2 if rd best yrd return IN T64 MAX distortion thisdistortion 2 labelyrate thisrate sse thissse 2 return RDCOST x rdmult x rddiv labelyrate distortion static void encode block intra int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane int16 t coeff BLOCKOFFSET p coeff block int16 t qcoeff BLOCKOFFSET p qcoeff block int16 t dqcoeff BLOCKOFFSET pd dqcoeff block const scan order scan order TXTYPE tx type PREDICTIONMODE mode const int bwl b width log2 plane bsize const int diff stride 4 1 bwl uint8 t src dst int16 t src diff uint16 t eob p eobs block const int src stride p src stride const int dst stride pd dst stride int i j txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j dst stride i src p src buf 4 j src stride i src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 scan order vp9 default scan orders TX 32 X32 mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 6 bwl TX 32 X32 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 32 32 src diff diff stride src src stride dst dst stride fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 idct32x32 add dqcoeff dst dst stride eob break case TX 16 X16 tx type get tx type pd plane type xd scan order vp9 scan orders TX 16 X16 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 4 bwl TX 16 X16 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 16 16 src diff diff stride src src stride dst dst stride vp9 fht16x16 src diff coeff diff stride tx type vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht16x16 add tx type dqcoeff dst dst stride eob break case TX 8 X8 tx type get tx type pd plane type xd scan order vp9 scan orders TX 8 X8 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 2 bwl TX 8 X8 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 8 8 src diff diff stride src src stride dst dst stride vp9 fht8x8 src diff coeff diff stride tx type vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht8x8 add tx type dqcoeff dst dst stride eob break case TX 4 X4 tx type get tx type 4x4 pd plane type xd block scan order vp9 scan orders TX 4 X4 tx type mode plane 0 get y mode xd mi 0 block mbmi uv mode vp9 predict intra block xd block bwl TX 4 X4 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 4 4 src diff diff stride src src stride dst dst stride if tx type DCTDCT vp9 fht4x4 src diff coeff diff stride tx type else x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob if tx type DCTDCT x itxm add dqcoeff dst dst stride eob else vp9 iht4x4 16 add dqcoeff dst dst stride tx type break default assert 0 break if eob args skip 0 static void i alloc struct array immovable gs memory t mem uint num elements gs memory type ptr t pstype client name t cname gs ref memory t const imem gs ref memory t mem obj header t obj ulong lsize if alloc array check size num elements pstype ssize lsize false return NULL obj alloc obj imem lsize pstype ALLOCIMMOVABLEALLOCDIRECT cname if debug7m A mem a d s s lu u u 0x lx n alloc trace space imem client name string cname struct type name string pstype ulong num elements pstype ssize num elements pstype ssize ulong obj return char obj static int decode cabac mb skip H264 Context h int mb x int mb y int mba xy mbb xy int ctx 0 if FRAMEMBAFF int mb xy mb x mb y 1 h mb stride mba xy mb xy 1 if mb y 1 h slice table mba xy h slice num MBFIELDISINTERLACED h cur pic mb type mba xy mba xy h mb stride if MBFIELD mbb xy mb xy h mb stride if mb y 1 h slice table mbb xy h slice num ISINTERLACED h cur pic mb type mbb xy mbb xy h mb stride else mbb xy mb x mb y 1 h mb stride else int mb xy h mb xy mba xy mb xy 1 mbb xy mb xy h mb stride FIELDPICTURE if h slice table mba xy h slice num ISSKIP h cur pic mb type mba xy ctx if h slice table mbb xy h slice num ISSKIP h cur pic mb type mbb xy ctx if h slice type nos AVPICTURETYPEB ctx 13 return get cabac noinline h cabac h cabac state 11 ctx static int64 t rd pick intra sby mode V P9 COMP cpi MACROBLOCK x int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize int64 t tx cache TXMODES int64 t best rd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPREDMACROBLOCKD const xd x e mbd MODEINFO const mic xd mi 0 int this rate this rate tokenonly s int64 t this distortion this rd TXSIZE best tx TX 4 X4 int i int bmode costs cpi mbmode cost if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i tx cache i IN T64 MAX for mode DCPRED mode TMPRED mode int64 t local tx cache TXMODESMODEINFO above mi xd mi xd mi stride MODEINFO left mi xd left available xd mi 1 NULL if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi 0 const PREDICTIONMODEL vp9 left block mode mic left mi 0 bmode costs cpi y mode costs AL mic mbmi mode mode super block yrd cpi x this rate tokenonly this distortion s NULL bsize local tx cache best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly bmode costs mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd best tx mic mbmi tx size rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if cpi sf tx size search method USEFULLRD this rd IN T64 MAX for i 0 i TXMODES local tx cache i IN T64 MAX i const int64 t adj rd this rd local tx cache i local tx cache cpi common tx mode if adj rd tx cache i tx cache i adj rd mic mbmi mode mode selected mic mbmi tx size best tx return best rd static int calc arf boost V P9 COMP cpi int offset int f frames int b frames int f boost int b boost TWOPASS const twopass cpi twopass int i double boost score 0 0 double mv ratio accumulator 0 0 double decay accumulator 1 0 double this frame mv in out 0 0 double mv in out accumulator 0 0 double abs mv in out accumulator 0 0 int arf boost int flash detected 0 for i 0 i f frames i const FIRSTPASSSTATS this frame read frame stats twopass i offset if this frame NULL break accumulate frame motion stats this frame this frame mv in out mv in out accumulator abs mv in out accumulator mv ratio accumulator flash detected detect flash twopass i offset detect flash twopass i offset 1 if flash detected decay accumulator get prediction decay rate cpi common this frame decay accumulator decay accumulator MINDECAYFACTORMINDECAYFACTOR decay accumulator boost score decay accumulator calc frame boost twopass this frame this frame mv in out f boost int boost score boost score 0 0 mv ratio accumulator 0 0 decay accumulator 1 0 this frame mv in out 0 0 mv in out accumulator 0 0 abs mv in out accumulator 0 0 for i 1 i b frames i const FIRSTPASSSTATS this frame read frame stats twopass i offset if this frame NULL break accumulate frame motion stats this frame this frame mv in out mv in out accumulator abs mv in out accumulator mv ratio accumulator flash detected detect flash twopass i offset detect flash twopass i offset 1 if flash detected decay accumulator get prediction decay rate cpi common this frame decay accumulator decay accumulator MINDECAYFACTORMINDECAYFACTOR decay accumulator boost score decay accumulator calc frame boost twopass this frame this frame mv in out b boost int boost score arf boost f boost b boost if arf boost b frames f frames 20 arf boost b frames f frames 20 return arf boost static int tgv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Tgv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int chunk type ret chunk type AVR L32 buf 0 buf EAPREAMBLESIZE if chunk type k VGTTAG int pal count i if buf 12 buf end av log avctx AVLOGWARNING truncated header n return AVERRORINVALIDDATA s width AVR L16 buf 0 s height AVR L16 buf 2 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height av freep s frame buffer av frame unref s last frame pal count AVR L16 buf 6 buf 12 for i 0 i pal count i AVPALETTECOUNT buf 2 buf end i s palette i AVR B24 buf buf 3 if ret av image check size s width s height 0 avctx 0 return ret if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 return ret memcpy frame data 1 s palette AVPALETTESIZE if chunk type k VGTTAG int y frame key frame 1 frame pict type AVPICTURETYPEI if s frame buffer s frame buffer av malloc s width s height return AVERRORENOMEM if unpack buf buf end s frame buffer s avctx width s avctx height 0 av log avctx AVLOGWARNING truncated intra frame n return AVERRORINVALIDDATA for y 0 y s height y memcpy frame data 0 y frame linesize 0 s frame buffer y s width s width else if s last frame data 0 av log avctx AVLOGWARNING inter frame without corresponding intra frame n return buf size frame key frame 0 frame pict type AVPICTURETYPEP if tgv decode inter s frame buf buf end 0 av log avctx AVLOGWARNING truncated inter frame n return AVERRORINVALIDDATA av frame unref s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size int ff h263 decode mb Mpeg Enc Context s int16 t block 6 64 int cbpc cbpy i cbp pred x pred y mx my dquant int16 t mot val const int xy s mb x s mb y s mb stride int cbpb 0 pb mv count 0 assert s h263 pred if s pict type AVPICTURETYPEP do if get bits1 s gb s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s current picture mb type xy MBTYPESKIPMBTYPE 16x16 MBTYPE L0 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped s obmc s loop filter goto end cbpc get vlc2 s gb ff h263 inter MCBPC vlc table INTERMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERROR cbpc damaged at d d n s mb x s mb y return 1 while cbpc 20 s dsp clear blocks s block 0 dquant cbpc 8 s mb intra cbpc 4 0 if s mb intra goto intra if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s s mv dir MVDIRFORWARD if cbpc 16 0 s current picture mb type xy MBTYPE 16x16 MBTYPE L0 s mv type MVTYPE 16 X16 ff h263 pred motion s 0 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 0 0 mx s mv 0 0 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb else s current picture mb type xy MBTYPE 8x8 MBTYPE L0 s mv type MVTYPE 8 X8 for i 0 i 4 i mot val ff h263 pred motion s i 0 pred x pred y if s umvplus mx h263p decode umotion s pred x else mx ff h263 decode motion s pred x 1 if mx 0xffff return 1 if s umvplus my h263p decode umotion s pred y else my ff h263 decode motion s pred y 1 if my 0xffff return 1 s mv 0 i 0 mx s mv 0 i 1 my if s umvplus mx pred x 1 my pred y 1 skip bits1 s gb mot val 0 mx mot val 1 my else if s pict type AVPICTURETYPEB int mb type const int stride s b8 stride int16 t mot val0 s current picture motion val 0 2 s mb x s mb y stride int16 t mot val1 s current picture motion val 1 2 s mb x s mb y stride mot val0 0 mot val0 2 mot val0 0 2 stride mot val0 2 2 stride mot val0 1 mot val0 3 mot val0 1 2 stride mot val0 3 2 stride mot val1 0 mot val1 2 mot val1 0 2 stride mot val1 2 2 stride mot val1 1 mot val1 3 mot val1 1 2 stride mot val1 3 2 stride 0 do mb type get vlc2 s gb h263 mbtype b vlc table H263 MBTYPEBVLCBITS 2 if mb type 0 av log s avctx AVLOGERROR b mb type damaged at d d n s mb x s mb y return 1 mb type h263 mb type b map mb type while mb type s mb intra ISINTRA mb type if HASCBP mb type s dsp clear blocks s block 0 cbpc get vlc2 s gb cbpc b vlc table CBPCBVLCBITS 1 if s mb intra dquant ISQUANT mb type goto intra cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERROR b cbpy damaged at d d n s mb x s mb y return 1 if s alt inter vlc 0 cbpc 3 3 cbpy 0x F cbp cbpc 3 cbpy 2 else cbp 0 assert s mb intra if ISQUANT mb type h263 decode dquant s if ISDIRECT mb type s mv dir MVDIRFORWARDMVDIRBACKWARDMVDIRECT mb type ff mpeg4 set direct mv s 0 0 else s mv dir 0 s mv type MVTYPE 16 X16 if USESLIST mb type 0 int16 t mot val ff h263 pred motion s 0 0 mx my s mv dir MVDIRFORWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 0 0 0 mx s mv 0 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my if USESLIST mb type 1 int16 t mot val ff h263 pred motion s 0 1 mx my s mv dir MVDIRBACKWARD mx ff h263 decode motion s mx 1 my ff h263 decode motion s my 1 s mv 1 0 0 mx s mv 1 0 1 my mot val 0 mot val 2 mot val 0 2 stride mot val 2 2 stride mx mot val 1 mot val 3 mot val 1 2 stride mot val 3 2 stride my s current picture mb type xy mb type else do cbpc get vlc2 s gb ff h263 intra MCBPC vlc table INTRAMCBPCVLCBITS 2 if cbpc 0 av log s avctx AVLOGERRORI cbpc damaged at d d n s mb x s mb y return 1 while cbpc 8 s dsp clear blocks s block 0 dquant cbpc 4 s mb intra 1 intra s current picture mb type xy MBTYPEINTRA if s h263 aic s ac pred get bits1 s gb if s ac pred s current picture mb type xy MBTYPEINTRAMBTYPEACPRED s h263 aic dir get bits1 s gb else s ac pred 0 if s pb frame get bits1 s gb pb mv count h263 get modb s gb s pb frame cbpb cbpy get vlc2 s gb ff h263 cbpy vlc table CBPYVLCBITS 1 if cbpy 0 av log s avctx AVLOGERRORI cbpy damaged at d d n s mb x s mb y return 1 cbp cbpc 3 cbpy 2 if dquant h263 decode dquant s pb mv count s pb frame while pb mv count ff h263 decode motion s 0 1 ff h263 decode motion s 0 1 for i 0 i 6 i if h263 decode block s block i i cbp 32 0 return 1 cbp cbp if s pb frame h263 skip b part s cbpb 0 return 1 if s obmc s mb intra if s pict type AVPICTURETYPEP s mb x 1 s mb width s mb num left 1 preview obmc s end int v show bits s gb 16 if get bits left s gb 16 v 16 get bits left s gb if v 0 return SLICEEND return static inline void vc1 pred mv V C1 Context v int n int dmv x int dmv y int mv1 int r x int r y uint8 t is intra int pred flag int dir Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int mixedmv pic num samefield 0 num oppfield 0 int opposite a f b f c f int16 t field pred A 2 int16 t field pred B 2 int16 t field pred C 2 int a valid b valid c valid int hybridmv thresh y bias 0 if v mv mode MVPMODEMIXEDMV v mv mode MVPMODEINTENSITYCOMP v mv mode2 MVPMODEMIXEDMV mixedmv pic 1 else mixedmv pic 0 dmv x 1 s quarter sample dmv y 1 s quarter sample wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture f motion val 0 xy v blocks off 0 0 s mv 0 n 1 s current picture f motion val 0 xy v blocks off 1 0 s current picture f motion val 1 xy v blocks off 0 0 s current picture f motion val 1 xy v blocks off 1 0 if mv1 s current picture f motion val 0 xy 1 v blocks off 0 0 s current picture f motion val 0 xy 1 v blocks off 1 0 s current picture f motion val 0 xy wrap v blocks off 0 0 s current picture f motion val 0 xy wrap v blocks off 1 0 s current picture f motion val 0 xy wrap 1 v blocks off 0 0 s current picture f motion val 0 xy wrap 1 v blocks off 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture f motion val 1 xy 1 v blocks off 0 0 s current picture f motion val 1 xy 1 v blocks off 1 0 s current picture f motion val 1 xy wrap 0 0 s current picture f motion val 1 xy wrap v blocks off 1 0 s current picture f motion val 1 xy wrap 1 v blocks off 0 0 s current picture f motion val 1 xy wrap 1 v blocks off 1 0 return C s current picture f motion val dir xy 1 v blocks off A s current picture f motion val dir xy wrap v blocks off if mv1 if v field mode mixedmv pic off s mb x s mb width 1 2 2 else off s mb x s mb width 1 1 2 else switch n case 0 off s mb x 0 1 1 break case 1 off s mb x s mb width 1 1 1 break case 2 off 1 break case 3 off 1 B s current picture f motion val dir xy wrap off v blocks off a valid s first slice line n 2 n 3 b valid a valid s mb width 1 c valid s mb x n 1 n 3 if v field mode a valid a valid is intra xy wrap b valid b valid is intra xy wrap off c valid c valid is intra xy 1 if a valid a f v mv f dir xy wrap v blocks off num oppfield a f num samefield 1 a f field pred A 0 A 0 field pred A 1 A 1 else field pred A 0 field pred A 1 0 a f 0 if b valid b f v mv f dir xy wrap off v blocks off num oppfield b f num samefield 1 b f field pred B 0 B 0 field pred B 1 B 1 else field pred B 0 field pred B 1 0 b f 0 if c valid c f v mv f dir xy 1 v blocks off num oppfield c f num samefield 1 c f field pred C 0 C 0 field pred C 1 C 1 else field pred C 0 field pred C 1 0 c f 0 if v field mode if v numref opposite 1 v reffield else if num samefield num oppfield opposite 1 pred flag else opposite pred flag else opposite 0 if opposite if a valid a f field pred A 0 scaleforopp v field pred A 0 0 dir field pred A 1 scaleforopp v field pred A 1 1 dir if b valid b f field pred B 0 scaleforopp v field pred B 0 0 dir field pred B 1 scaleforopp v field pred B 1 1 dir if c valid c f field pred C 0 scaleforopp v field pred C 0 0 dir field pred C 1 scaleforopp v field pred C 1 1 dir v mv f dir xy v blocks off 1 v ref field type dir v cur field type else if a valid a f field pred A 0 scaleforsame v n field pred A 0 0 dir field pred A 1 scaleforsame v n field pred A 1 1 dir if b valid b f field pred B 0 scaleforsame v n field pred B 0 0 dir field pred B 1 scaleforsame v n field pred B 1 1 dir if c valid c f field pred C 0 scaleforsame v n field pred C 0 0 dir field pred C 1 scaleforsame v n field pred C 1 1 dir v mv f dir xy v blocks off 0 v ref field type dir v cur field type if a valid px field pred A 0 py field pred A 1 else if c valid px field pred C 0 py field pred C 1 else if b valid px field pred B 0 py field pred B 1 else px 0 py 0 if num samefield num oppfield 1 px mid pred field pred A 0 field pred B 0 field pred C 0 py mid pred field pred A 1 field pred B 1 field pred C 1 if v field mode int qx qy XY qx s mb x 6 n 1 n 3 32 0 qy s mb y 6 n 2 n 3 32 0 X s mb width 6 4 Y s mb height 6 4 if mv1 if qx px 60 px 60 qx if qy py 60 py 60 qy else if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy if v field mode s pict type AVPICTURETYPEB hybridmv thresh 32 if a valid c valid if is intra xy wrap sum FFABS px FFABS py else sum FFABS px field pred A 0 FFABS py field pred A 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 else if is intra xy 1 sum FFABS px FFABS py else sum FFABS px field pred C 0 FFABS py field pred C 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 if v field mode v numref r y 1 if v field mode v cur field type v ref field type dir 0 y bias 1 s mv dir n 0 s current picture f motion val dir xy v blocks off 0 px dmv x r x r x 1 1 r x s mv dir n 1 s current picture f motion val dir xy v blocks off 1 py dmv y r y y bias r y 1 1 r y y bias if mv1 s current picture f motion val dir xy 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 v mv f dir xy 1 v blocks off v mv f dir xy v blocks off v mv f dir xy wrap v blocks off v mv f dir xy wrap 1 v blocks off v mv f dir xy v blocks off static uint dump routines for db char db char query buff QUERYLENGTH const char routine type FUNCTIONPROCEDURE char db name buff NAMELEN 2 3 name buff NAMELEN 2 3 char routine name int i FILE sql file md result file MYSQLRES routine res routine list res MYSQLROW row routine list row char db cl name MYCSNAMESIZE int db cl altered FALSEDBUGENTER dump routines for db DBUGPRINT enter db s db mysql real escape string mysql db name buff db ulong strlen db print comment sql file 0 n n Dumping routines for database s n n db if lock tables mysql query mysql LOCKTABLES mysql proc READ if fetch db collation db db cl name sizeof db cl name DBUGRETURN 1 if switch character set results mysql binary DBUGRETURN 1 if opt xml fputs t routines n sql file for i 0 i 1 i my snprintf query buff sizeof query buff SHOW s STATUSWHERE Db s routine type i db name buff if mysql query with error report mysql routine list res query buff DBUGRETURN 1 if mysql num rows routine list res while routine list row mysql fetch row routine list res routine name quote name routine list row 1 name buff 0 DBUGPRINT info retrieving CREATE s for s routine type i name buff my snprintf query buff sizeof query buff SHOWCREATE s s routine type i routine name if mysql query with error report mysql routine res query buff DBUGRETURN 1 while row mysql fetch row routine res DBUGPRINT info length of body for s row 2 s is zu routine name row 2 row 2 null row 2 strlen row 2 0 if row 2 NULL print comment sql file 1 n insufficient privileges to s n query buff print comment sql file 1 does s have permissions on mysql proc n n current user maybe die EXMYSQLERR s has insufficent privileges to s current user query buff else if strlen row 2 if opt xml if i print xml row sql file routine routine res row Create Procedure else print xml row sql file routine routine res row Create Function continue if opt drop fprintf sql file n routine type i routine name if mysql num fields routine res 6 if switch db collation sql file db db cl name row 5 db cl altered DBUGRETURN 1 switch cs variables sql file row 3 row 3 row 4 else fprintf sql file n WARNING old server version The following dump may be incomplete n n switch sql mode sql file row 1 fprintf sql file DELIMITER n s n DELIMITER n const char row 2 restore sql mode sql file if mysql num fields routine res 6 restore cs variables sql file if db cl altered if restore db collation sql file db db cl name DBUGRETURN 1 mysql free result routine res mysql free result routine list res if opt xml fputs t routines n sql file check io sql file if switch character set results mysql default charset DBUGRETURN 1 if lock tables void mysql query with error report mysql 0 UNLOCKTABLESDBUGRETURN 0 static int m authenticate struct Client client p struct Client source p int parc const char parv struct Client agent p NULL struct Client saslserv p NULL if Is Capable source p CLICAPSASL return 0 if strlen client p id 3 exit client client p client p client p Mixing client and server protocol return 0 if parv 1 strchr parv 1 exit client client p client p client p Malformed AUTHENTICATE return 0 saslserv p find named client Config File Entry sasl service if saslserv p NULL Is Service saslserv p sendto one source p form str ERRSASLABORTED me name Empty String source p name source p name return 0 if source p local Client sasl complete source p local Client sasl agent 0 source p local Client sasl complete 0 if strlen parv 1 400 sendto one source p form str ERRSASLTOOLONG me name Empty String source p name source p name return 0 if source p id strcpy source p id generate uid add to id hash source p id source p if source p local Client sasl agent agent p find id source p local Client sasl agent if agent p NULL sendto one saslserv p s ENCAP s SASL s s H s s me id saslserv p servptr name source p id saslserv p id source p host source p sockhost if strcmp parv 1 EXTERNAL source p certfp NULL sendto one saslserv p s ENCAP s SASL s s S s s me id saslserv p servptr name source p id saslserv p id parv 1 source p certfp else sendto one saslserv p s ENCAP s SASL s s S s me id saslserv p servptr name source p id saslserv p id parv 1 rb strlcpy source p local Client sasl agent saslserv p id IDLEN else sendto one agent p s ENCAP s SASL s s C s me id agent p servptr name source p id agent p id parv 1 source p local Client sasl out return 0 static int sipr decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Sipr Context ctx avctx priv data AV Frame frame data const uint8 t buf avpkt data Sipr Parameters parm const Sipr Mode Param mode par modes ctx mode Get Bit Context gb float samples int subframe size ctx mode MODE 16k LSUBFR 16k SUBFRSIZE int i ret ctx avctx avctx if avpkt size mode par bits per frame 3 av log avctx AVLOGERROR Error processing packet packet size d too small n avpkt size return 1 frame nb samples mode par frames per packet subframe size mode par subframe count if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples float frame data 0 init get bits gb buf mode par bits per frame for i 0 i mode par frames per packet i decode parameters parm gb mode par ctx decode frame ctx parm samples samples subframe size mode par subframe count got frame ptr 1 return mode par bits per frame 3 static int output data MLP Decode Context m unsigned int substr AV Frame frame int got frame ptr AV Codec Context avctx m avctx Sub Stream s m substream substr unsigned int i out ch 0 int32 t data 32 int16 t data 16 int ret int is32 m avctx sample fmt AVSAMPLEFMT S32 if m avctx channels s max matrix channel 1 av log m avctx AVLOGERROR channel count mismatch n return AVERRORINVALIDDATA if s blockpos av log avctx AVLOGERROR No samples to output n return AVERRORINVALIDDATA frame nb samples s blockpos if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret data 32 int32 t frame data 0 data 16 int16 t frame data 0 for i 0 i s blockpos i for out ch 0 out ch s max matrix channel out ch int mat ch s ch assign out ch int32 t sample m sample buffer i mat ch s output shift mat ch s lossless check data sample 0xffffff mat ch if is32 data 32 sample 8 else data 16 sample 8 got frame ptr 1 return 0 int main int argc char argv int ret value 0 libettercap init ef globals alloc select text interface libettercap ui init fprintf stdout n ECCOLORBOLD s s ECCOLOREND copyright s s n n PROGRAMECVERSIONECCOPYRIGHTECAUTHORSEFGBL lineno 1 parse options argc argv if EFGBLOPTIONS source file yyin fopen EFGBLOPTIONS source file r if yyin NULLFATALERROR Input file not found else FATALERROR No source file setbuf yyin NULL setbuf stdout NULL setbuf stderr NULL load tables load constants fprintf stdout n Parsing source file s EFGBLOPTIONS source file fflush stdout ef debug 1 n if yyparse 0 fprintf stdout done n n else fprintf stdout n n The script contains errors n n ret value write output if ret value ENOTHANDLEDFATALERROR Cannot write output file s the filter is not correctly handled EFGBLOPTIONS output file else if ret value EINVALIDFATALERROR Cannot write output file s the filter format is not correct EFGBLOPTIONS output file ef globals free return 0 void vp9 rc init minq luts int i for i 0 i QINDEXRANGE i const double maxq vp9 convert qindex to q i kf low motion minq i get minq index maxq 0 000001 0 0004 0 125 kf high motion minq i get minq index maxq 0 000002 0 0012 0 50 arfgf low motion minq i get minq index maxq 0 0000015 0 0009 0 30 arfgf high motion minq i get minq index maxq 0 0000021 0 00125 0 50 inter minq i get minq index maxq 0 00000271 0 00113 0 90 rtc minq i get minq index maxq 0 00000271 0 00113 0 70 static int zsethalftone5 i ctx t i ctx p os ptr op osp uint count gs halftone component phtc 0 gs halftone component pc int code 0 int j bool have default gs halftone pht 0 gx device halftone pdht 0 ref sprocs GSCLIENTCOLORMAXCOMPONENTS 1 ref tprocs GSCLIENTCOLORMAXCOMPONENTS 1 gs memory t mem uint edepth ref stack count e stack int npop 2 int dict enum dict first op ref rvalue 2 int cname colorant number byte pname uint name size int halftonetype type 0 gs gstate pgs igs int space index r space index op 1 mem gs memory t idmemory spaces indexed space index check type op t dictionary check dict read op check type op 1 t dictionary check dict read op 1 code dict int param op 1 Halftone Type 1 100 0 type if code 0 return code halftonetype type 2 type 4 ht type multiple colorscreen ht type multiple have default false for count 0 if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue else if colorant number GXDEVICECOLORMAXCOMPONENTS if have default return error gs error rangecheck have default true count if count GSCLIENTCOLORMAXCOMPONENTS 1 code gs note error gs error rangecheck break if count 0 halftonetype ht type multiple have default code gs note error gs error rangecheck if code 0 check estack 5 refset null sprocs count refset null tprocs count rc alloc struct 0 pht gs halftone st halftone imemory pht 0 sethalftone5 phtc gs alloc struct array mem count gs halftone component st ht component element sethalftone5 rc alloc struct 0 pdht gx device halftone st device halftone imemory pdht 0 sethalftone5 if pht 0 phtc 0 pdht 0 j 0 code gs note error gs error V Merror if code 0 dict enum dict first op for j 0 pc phtc int type if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue pc cname cname pc comp number colorant number check dict read rvalue 1 if dict int param rvalue 1 Halftone Type 1 7 0 type 0 code gs note error gs error typecheck break switch type default code gs note error gs error rangecheck break case 1 code dict spot params rvalue 1 pc params spot sprocs j tprocs j mem pc params spot screen spot function spot1 dummy pc type ht type spot break case 3 code dict threshold params rvalue 1 pc params threshold tprocs j pc type ht type threshold break case 7 code dict threshold2 params rvalue 1 pc params threshold2 tprocs j imemory pc type ht type threshold2 break if code 0 break pc j if code 0 pht type halftonetype pht params multiple components phtc pht params multiple num comp j pht params multiple get colorname string gs get colorname string code gs sethalftone prepare igs pht pdht if code 0 dict enum dict first op for pc phtc if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue if pc type ht type spot code dict spot results i ctx p rvalue 1 pc params spot if code 0 break pc if code 0 uint odepth ref stack count o stack ref odict odict5 odict op 1 odict5 op pop 2 op osp esp 5 make mark estack esp 4 es other sethalftone cleanup esp 3 odict make istruct esp 2 0 pht make istruct esp 1 0 pdht make op estack esp sethalftone finish for j 0 j count j gx ht order porder NULL if pdht components 0 porder pdht order else int k int comp number phtc j comp number for k 0 k count k if pdht components k comp number comp number porder pdht components k corder break switch phtc j type case ht type spot code zscreen enum init i ctx p porder phtc j params spot screen sprocs j 0 0 space index if code 0 break case ht type threshold if r has type tprocs j t invalid check ostack zcolor remap one ostack check estack zcolor remap one estack code zcolor remap one i ctx p tprocs j porder transfer igs zcolor remap one finish op osp break default if code 0 ref stack pop to o stack odepth ref stack pop to e stack edepth op osp op 1 odict op odict5 break npop 0 if code 0 gs free object mem pdht sethalftone5 gs free object mem phtc sethalftone5 gs free object mem pht sethalftone5 return code pop npop return ref stack count e stack edepth o push estack 0 static int cmv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cmv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int ret if buf end buf EAPREAMBLESIZE return AVERRORINVALIDDATA if AVR L32 buf MV Ih TAGAVR B32 buf MV Ih TAG cmv process header s buf EAPREAMBLESIZE buf end return buf size if av image check size s width s height 0 s avctx return 1 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 s palette AVPALETTESIZE buf EAPREAMBLESIZE if buf 0 1 cmv decode inter s frame buf 2 buf end frame key frame 0 frame pict type AVPICTURETYPEP else frame key frame 1 frame pict type AVPICTURETYPEI cmv decode intra s frame buf 2 buf end av frame unref s last2 frame av frame move ref s last2 frame s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size static void vdpau h264 set rf Vdp Reference Frame H264 rf Picture pic int pic structure Vdp Video Surface surface ff vdpau get surface id pic if pic structure 0 pic structure pic f reference rf surface surface rf is long term pic f reference pic long ref rf top is reference pic structure PICTTOPFIELD 0 rf bottom is reference pic structure PICTBOTTOMFIELD 0 rf field order cnt 0 h264 foc pic field poc 0 rf field order cnt 1 h264 foc pic field poc 1 rf frame idx pic long ref pic pic id pic frame num static int output data MLP Decode Context m unsigned int substr AV Frame frame int got frame ptr AV Codec Context avctx m avctx Sub Stream s m substream substr unsigned int i out ch 0 int32 t data 32 int16 t data 16 int ret int is32 m avctx sample fmt AVSAMPLEFMT S32 if m avctx channels s max matrix channel 1 av log m avctx AVLOGERROR channel count mismatch n return AVERRORINVALIDDATA if s blockpos av log avctx AVLOGERROR No samples to output n return AVERRORINVALIDDATA frame nb samples s blockpos if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret data 32 int32 t frame data 0 data 16 int16 t frame data 0 for i 0 i s blockpos i for out ch 0 out ch s max matrix channel out ch int mat ch s ch assign out ch int32 t sample m sample buffer i mat ch s output shift mat ch s lossless check data sample 0xffffff mat ch if is32 data 32 sample 8 else data 16 sample 8 got frame ptr 1 return 0 static void temporal filter predictors mb c MACROBLOCKD xd uint8 t y mb ptr uint8 t u mb ptr uint8 t v mb ptr int stride int uv block width int uv block height int mv row int mv col uint8 t pred struct scale factors scale int x int y const int which mv 0 const MV mv mv row mv col const Interp Kernel const kernel vp9 get interp kernel xd mi 0 mbmi interp filter enum mv precision mv precision uv int uv stride if uv block width 8 uv stride stride 1 1 mv precision uv MVPRECISION Q4 else uv stride stride mv precision uv MVPRECISION Q3 vp9 build inter predictor y mb ptr stride pred 0 16 mv scale 16 16 which mv kernel MVPRECISION Q3 x y vp9 build inter predictor u mb ptr uv stride pred 256 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y vp9 build inter predictor v mb ptr uv stride pred 512 uv block width mv scale uv block width uv block height which mv kernel mv precision uv x y static V P9 DENOISERDECISION perform motion compensation V P9 DENOISER denoiser MACROBLOCK mb BLOCKSIZE bs int increase denoising int mi row int mi col PICKMODECONTEXT ctx int motion magnitude int mv col mv row int sse diff ctx zeromv sse ctx newmv sse MVREFERENCEFRAME frame MACROBLOCKD filter mbd mb e mbd MBMODEINFO mbmi filter mbd mi 0 mbmi MBMODEINFO saved mbmi int i j struct buf 2d saved dst MAXMBPLANE struct buf 2d saved pre MAXMBPLANE 2 saved mbmi mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j saved pre i j filter mbd plane i pre j saved dst i filter mbd plane i dst mv col ctx best sse mv as mv col mv row ctx best sse mv as mv row motion magnitude mv row mv row mv col mv col frame ctx best reference frame if frame INTRAFRAME sse diff sse diff thresh bs increase denoising mv row mv col mbmi ref frame 0 ctx best reference frame mbmi mode ctx best sse inter mode mbmi mv 0 ctx best sse mv else frame ctx best zeromv reference frame mbmi ref frame 0 ctx best zeromv reference frame mbmi mode ZEROMV mbmi mv 0 as int 0 ctx best sse inter mode ZEROMV ctx best sse mv as int 0 ctx newmv sse ctx zeromv sse for j 0 j 2 j filter mbd plane 0 pre j buf block start denoiser running avg y frame y buffer denoiser running avg y frame y stride mi row mi col filter mbd plane 0 pre j stride denoiser running avg y frame y stride filter mbd plane 1 pre j buf block start denoiser running avg y frame u buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 1 pre j stride denoiser running avg y frame uv stride filter mbd plane 2 pre j buf block start denoiser running avg y frame v buffer denoiser running avg y frame uv stride mi row mi col filter mbd plane 2 pre j stride denoiser running avg y frame uv stride filter mbd plane 0 dst buf block start denoiser mc running avg y y buffer denoiser mc running avg y y stride mi row mi col filter mbd plane 0 dst stride denoiser mc running avg y y stride filter mbd plane 1 dst buf block start denoiser mc running avg y u buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 1 dst stride denoiser mc running avg y uv stride filter mbd plane 2 dst buf block start denoiser mc running avg y v buffer denoiser mc running avg y uv stride mi row mi col filter mbd plane 2 dst stride denoiser mc running avg y uv stride vp9 build inter predictors sby filter mbd mv row mv col bs mbmi saved mbmi for i 0 i MAXMBPLANE i for j 0 j 2 j filter mbd plane i pre j saved pre i j filter mbd plane i dst saved dst i mv row ctx best sse mv as mv row mv col ctx best sse mv as mv col if ctx newmv sse sse thresh bs increase denoising return COPYBLOCK if mv row mv row mv col mv col noise motion thresh bs increase denoising return COPYBLOCK return static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Cam Studio Context c avctx priv data AV Frame picture data int ret if buf size 2 av log avctx AVLOGERROR coded frame too small n return AVERRORINVALIDDATA if ret ff get buffer avctx picture 0 0 av log avctx AVLOGERROR get buffer failed n return ret switch buf 0 1 7 case 0 int outlen c decomp size inlen buf size 2 if av lzo1x decode c decomp buf outlen buf 2 inlen av log avctx AVLOGERROR error during lzo decompression n break case 1 if uncompress c decomp buf dlen buf 2 buf size 2 ZOK av log avctx AVLOGERROR error during zlib decompression n break return AVERRORENOSYS default av log avctx AVLOGERROR unknown compression n return AVERRORINVALIDDATA if buf 0 1 picture pict type AVPICTURETYPEI picture key frame 1 switch c bpp case 16 copy frame 16 picture c decomp buf c linelen c height break case 32 copy frame 32 picture c decomp buf c linelen c height break default copy frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height else picture pict type AVPICTURETYPEP picture key frame 0 switch c bpp case 16 add frame 16 picture c decomp buf c linelen c height break case 32 add frame 32 picture c decomp buf c linelen c height break default add frame default picture c decomp buf FFALIGN c linelen 4 c linelen c height got frame 1 return buf size static int ra288 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size float out int i ret R A288 Context ractx avctx priv data Get Bit Context gb if buf size avctx block align av log avctx AVLOGERROR Error Input buffer is too small d d n buf size avctx block align return AVERRORINVALIDDATA frame nb samples R A288 BLOCKSIZER A288 BLOCKSPERFRAME if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out float frame data 0 init get bits gb buf avctx block align 8 for i 0 i R A288 BLOCKSPERFRAME i float gain amptable get bits gb 3 int cb coef get bits gb 6 i 1 decode ractx gain cb coef memcpy out ractx sp hist 70 36 R A288 BLOCKSIZE sizeof out out R A288 BLOCKSIZE if i 7 3 backward filter ractx ractx sp hist ractx sp rec syn window ractx sp lpc syn bw tab 36 40 35 70 backward filter ractx ractx gain hist ractx gain rec gain window ractx gain lpc gain bw tab 10 8 20 28 got frame ptr 1 return avctx block align static int msrle decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Msrle Context s avctx priv data int istride FFALIGN avctx width avctx bits per coded sample 32 8 int ret s buf buf s size buf size if ret ff reget buffer avctx s frame 0 av log avctx AVLOGERROR reget buffer failed n return ret if avctx bits per coded sample 8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal s frame palette has changed 1 memcpy s pal pal AVPALETTESIZE memcpy s frame data 1 s pal AVPALETTESIZE if avctx height istride avpkt size int linesize avctx width avctx bits per coded sample 8 uint8 t ptr s frame data 0 uint8 t buf avpkt data avctx height 1 istride int i j for i 0 i avctx height i if avctx bits per coded sample 4 for j 0 j avctx width 1 j 2 ptr j 0 buf j 1 4 ptr j 1 buf j 1 0x F if avctx width 1 ptr j 0 buf j 1 4 else memcpy ptr buf linesize buf istride ptr s frame linesize 0 else bytestream2 init s gb buf buf size ff msrle decode avctx AV Picture s frame avctx bits per coded sample s gb if ret av frame ref data s frame 0 return ret got frame 1 return buf size void ff clean h263 qscales Mpeg Enc Context s int i int8 t const qscale table s current picture f qscale table ff init qscale tab s for i 1 i s mb num i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 for i s mb num 2 i 0 i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 if s codec id AVCODECID H263 P for i 1 i s mb num i int mb xy s mb index2xy i if qscale table mb xy qscale table s mb index2xy i 1 s mb type mb xy CANDIDATEMBTYPEINTE R4 V s mb type mb xy static int mss1 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size MS S1 Context ctx avctx priv data MS S12 Context c ctx ctx Get Bit Context gb Arith Coder acoder int pal changed 0 int ret init get bits gb buf buf size 8 arith init acoder gb ctx pic reference 3 ctx pic buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSREADABLEFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx ctx pic 0 av log avctx AVLOGERROR reget buffer failed n return ret c pal pic ctx pic data 0 ctx pic linesize 0 avctx height 1 c pal stride ctx pic linesize 0 c keyframe arith get bit acoder if c keyframe c corrupted 0 ff mss12 slicecontext reset ctx sc pal changed decode pal c acoder ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else if c corrupted return AVERRORINVALIDDATA ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP c corrupted ff mss12 decode rect ctx sc acoder 0 0 avctx width avctx height if c corrupted return AVERRORINVALIDDATA memcpy ctx pic data 1 c pal AVPALETTESIZE ctx pic palette has changed pal changed got frame 1 AV Frame data ctx pic return buf size int encode function char string struct filter op fop char str strdup string int ret ENOTFOUND char name args int nargs 0 i char dec args NULL char tok memset fop 0 sizeof struct filter op name ec strtok string tok args name strlen name 1 dec args decode args args nargs fop opcode FOPFUNC if strcmp name search if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCSEARCH fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name regex if nargs 2 int err regex t regex char errbuf 100 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCREGEX fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 err regcomp regex const char fop op func string REGEXTENDEDREGNOSUBREGICASE if err regerror err regex errbuf sizeof errbuf SCRIPTERROR s errbuf regfree regex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name pcre regex const char errbuf NULL int erroff if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func string strdup dec args 1 fop op func slen strlen fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else if nargs 3 fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func level 5 fop op func string strdup dec args 1 fop op func slen strlen fop op func string fop op func replace strdup dec args 2 fop op func rlen strlen fop op func replace ret ESUCCESS pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name replace if nargs 2 fop op func op FFUNCREPLACE fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string fop op func replace u char strdup dec args 1 fop op func rlen strescape char fop op func replace char fop op func replace ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name inject if nargs 1 fop op func op FFUNCINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name execinject if nargs 1 fop op func op FFUNCEXECINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name log if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCLOG fop op func string u char strdup dec args 1 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name drop if nargs 0 fop op func op FFUNCDROP ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name kill if nargs 0 fop op func op FFUNCKILL ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name msg if nargs 1 fop op func op FFUNCMSG fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exec if nargs 1 fop op func op FFUNCEXEC fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exit if nargs 0 fop opcode FOPEXIT ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name for i 0 i nargs i SAFEFREE dec args i SAFEFREE dec args SAFEFREE str return ret static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size Dxa Dec Context const c avctx priv data uint8 t outptr srcptr tmpptr unsigned long dsize int i j compr ret int stride int orig buf size buf size int pc 0 if buf 0 C buf 1 M buf 2 A buf 3 P int r g b buf 4 for i 0 i 256 i r buf g buf b buf c pal i r 16 g 8 b pc 1 buf size 768 4 if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret memcpy frame data 1 c pal AVPALETTESIZE frame palette has changed pc outptr frame data 0 srcptr c decomp buf tmpptr c prev data 0 stride frame linesize 0 if buf 0 N buf 1 U buf 2 L buf 3 L compr 1 else compr buf 4 dsize c dsize if compr 4 compr 1 uncompress c decomp buf dsize buf 9 buf size 9 ZOK av log avctx AVLOGERROR Uncompress failed n return AVERRORUNKNOWN switch compr case 1 frame key frame 0 frame pict type AVPICTURETYPEP if c prev data 0 memcpy frame data 0 c prev data 0 frame linesize 0 avctx height else memset frame data 0 0 frame linesize 0 avctx height frame key frame 1 frame pict type AVPICTURETYPEI break case 2 case 3 case 4 case 5 frame key frame compr 1 frame pict type compr 1 AVPICTURETYPEPAVPICTURETYPEI for j 0 j avctx height j if compr 1 for i 0 i avctx width i outptr i srcptr i tmpptr i tmpptr stride else memcpy outptr srcptr avctx width outptr stride srcptr avctx width break case 12 case 13 frame key frame 0 frame pict type AVPICTURETYPEP decode 13 avctx c frame data 0 frame linesize 0 srcptr c prev data 0 break default av log avctx AVLOGERROR Unknown unsupported compression type d n buf 4 return AVERRORINVALIDDATA av frame unref c prev if ret av frame ref c prev frame 0 return ret got frame 1 return orig buf size void vp9 init layer context V P9 COMP const cpi SVC const svc cpi svc const V P9 Encoder Config const oxcf cpi oxcf int layer int layer end int alt ref idx svc number spatial layers svc number temporal layers svc spatial layer id 0 svc temporal layer id 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR layer end svc number temporal layers else layer end svc number spatial layers for layer 0 layer layer end layer LAYERCONTEXT const lc svc layer context layer RATECONTROL const lrc lc rc int i lc current video frame in layer 0 lc layer size 0 lc frames from key frame 0 lc last frame type FRAMETYPES lrc ni av qi oxcf worst allowed q lrc total actual bits 0 lrc total target vs actual 0 lrc ni tot qi 0 lrc tot q 0 0 lrc avg q 0 0 lrc ni frames 0 lrc decimation count 0 lrc decimation factor 0 for i 0 i RATEFACTORLEVELS i lrc rate correction factors i 1 0 if svc number temporal layers 1 cpi oxcf rc mode VPXCBR lc target bandwidth oxcf ts target bitrate layer lrc last q INTERFRAME oxcf worst allowed q lrc avg frame qindex INTERFRAME oxcf worst allowed q else lc target bandwidth oxcf ss target bitrate layer lrc last q KEYFRAME oxcf best allowed q lrc last q INTERFRAME oxcf best allowed q lrc avg frame qindex KEYFRAME oxcf worst allowed q oxcf best allowed q 2 lrc avg frame qindex INTERFRAME oxcf worst allowed q oxcf best allowed q 2 if oxcf ss play alternate layer lc alt ref idx alt ref idx else lc alt ref idx 1 lc gold ref idx 1 lrc buffer level oxcf starting buffer level ms lc target bandwidth 1000 lrc bits off target lrc buffer level if svc number temporal layers 1 cpi oxcf rc mode VPXCBR alt ref idx REFFRAMES svc layer context 0 gold ref idx alt ref idx static int yop decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Yop Dec Context s avctx priv data AV Frame frame data int tag firstcolor is odd frame int ret i x y uint32 t palette if avpkt size 4 3 s num pal colors av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA ret ff get buffer avctx frame 0 if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset frame data 1 0 AVPALETTESIZE s dstbuf frame data 0 s dstptr frame data 0 s srcptr avpkt data 4 s src end avpkt data avpkt size s low nibble NULL is odd frame avpkt data 0 firstcolor s first color is odd frame palette uint32 t frame data 1 for i 0 i s num pal colors i s srcptr 3 palette i firstcolor s srcptr 0 18 s srcptr 1 10 s srcptr 2 2 frame palette has changed 1 for y 0 y avctx height y 2 for x 0 x avctx width x 2 if s srcptr avpkt data avpkt size av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA tag yop get next nibble s if tag 0xf ret yop paint block s frame linesize 0 tag if ret 0 return ret else tag yop get next nibble s ret yop copy previous block s frame linesize 0 tag if ret 0 return ret s dstptr 2 s dstptr 2 frame linesize 0 x got frame 1 return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Video XL Context const a avctx priv data AV Frame const p a pic uint8 t YUV int i j ret int stride uint32 t val int y0 y1 y2 y3 0 c0 0 c1 0 if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 Y a pic data 0 U a pic data 1 V a pic data 2 stride avctx width 4 if buf size avctx width avctx height av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA for i 0 i avctx height i buf stride for j 0 j avctx width j 4 val AVR L32 buf buf 4 val val 16 0x FFFF val 0x FFFF 16 if j y0 val 0x1 F 2 else y0 y3 xl table val 0x1 F val 5 y1 y0 xl table val 0x1 F val 5 y2 y1 xl table val 0x1 F val 6 y3 y2 xl table val 0x1 F val 5 if j c0 val 0x1 F 2 else c0 xl table val 0x1 F val 5 if j c1 val 0x1 F 2 else c1 xl table val 0x1 FY j 0 y0 1 Y j 1 y1 1 Y j 2 y2 1 Y j 3 y3 1 U j 2 c0 1 V j 2 c1 1 buf avctx width 4 Y a pic linesize 0 U a pic linesize 1 V a pic linesize 2 got frame 1 AV Frame data a pic return buf size static gboolean logcat dump text wtap dumper wdh const struct wtap pkthdr phdr const guint8 pd int err gchar buf gint length gchar priority const struct logger entry log entry struct logger entry pd const struct logger entry v2 log entry v2 struct logger entry v2 pd gint payload length const gchar tag gint32 pid gint32 tid gint32 seconds gint32 milliseconds const gchar msg begin gint msg pre skip gchar log gchar log part gchar log next const union wtap pseudo header pseudo header phdr pseudo header const struct dumper t dumper const struct dumper t wdh priv if phdr rec type RECTYPEPACKET err WTAPERRRECTYPEUNSUPPORTED return FALSE payload length GIN T32 FROMLE log entry len pid GIN T32 FROMLE log entry pid tid GIN T32 FROMLE log entry tid seconds GIN T32 FROMLE log entry sec milliseconds GIN T32 FROMLE log entry nsec 1000000 if pseudo header logcat version 1 priority get priority log entry msg 0 tag log entry msg 1 msg pre skip 1 strlen tag 1 msg begin log entry msg msg pre skip else if pseudo header logcat version 2 priority get priority log entry v2 msg 0 tag log entry v2 msg 1 msg pre skip 1 strlen tag 1 msg begin log entry v2 msg msg pre skip else err WTAPERRUNSUPPORTED return FALSE log g strndup msg begin payload length msg pre skip log next log do log part log next if dumper type DUMPLONG log next NULL else log next strchr log part n if log next NULL log next 0 log next if log next 0 log next NULL buf logcat log dumper seconds milliseconds pid tid priority tag log part if buf g free log return FALSE length guint32 strlen buf if wtap dump file write wdh buf length err g free log return FALSE wdh bytes dumped length while log next NULL g free log return void run on cpu CPU State cpu void func void data void data struct qemu work item wi if qemu cpu is self cpu func data return wi func func wi data data if cpu queued work first NULL cpu queued work first wi else cpu queued work last next wi cpu queued work last wi wi next NULL wi done false qemu cpu kick cpu while wi done CPU Arch State self env cpu single env qemu cond wait qemu work cond qemu global mutex cpu single env self env gpg err code t gcry ecc fill in curve unsigned int nbits const char name elliptic curve t curve unsigned int r nbits int idx aliasno const char resname NULL if name for idx 0 domain parms idx desc idx if strcmp name domain parms idx desc resname domain parms idx desc break if domain parms idx desc for aliasno 0 curve aliases aliasno name aliasno if strcmp name curve aliases aliasno other break if curve aliases aliasno name for idx 0 domain parms idx desc idx if strcmp curve aliases aliasno name domain parms idx desc resname domain parms idx desc break else for idx 0 domain parms idx desc idx if nbits domain parms idx nbits domain parms idx model MPIECWEIERSTRASS break if domain parms idx desc return GPGERRUNKNOWNCURVE if fips mode domain parms idx fips return GPGERRNOTSUPPORTED switch domain parms idx model case MPIECWEIERSTRASS case MPIECTWISTEDEDWARDS break case MPIECMONTGOMERY return GPGERRNOTSUPPORTED default return GPGERRBUG if r nbits r nbits domain parms idx nbits curve model domain parms idx model curve p scanval domain parms idx p curve a scanval domain parms idx a curve b scanval domain parms idx b curve n scanval domain parms idx n curve G x scanval domain parms idx g x curve G y scanval domain parms idx g y curve G z mpi alloc set ui 1 curve name resname return 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt MDEC Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size Thread Frame frame f data int i ret if ret ff thread get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret frame f pict type AVPICTURETYPEI frame f key frame 1 av fast malloc a bitstream buffer a bitstream buffer size buf size FFINPUTBUFFERPADDINGSIZE if a bitstream buffer return AVERRORENOMEM for i 0 i buf size i 2 a bitstream buffer i buf i 1 a bitstream buffer i 1 buf i init get bits a gb a bitstream buffer buf size 8 skip bits a gb 32 a qscale get bits a gb 16 a version get bits a gb 16 a last dc 0 a last dc 1 a last dc 2 128 for a mb x 0 a mb x a mb width a mb x for a mb y 0 a mb y a mb height a mb y if ret decode mb a a block 0 return ret idct put a frame f a mb x a mb y got frame 1 return get bits count a gb 31 32 4 void stp print netdissect options ndo const u char p u int length const struct stp bpdu stp bpdu u int mstp len u int spb len stp bpdu const struct stp bpdu p if length 4 goto trunc NDTCHECK stp bpdu protocol id if EXTRACT 16 BITS stp bpdu protocol id NDPRINT ndo unknown STP version length u length return NDTCHECK stp bpdu protocol version NDPRINT ndo STP s tok2str stp proto values Unknown STP protocol 0x 02x stp bpdu protocol version switch stp bpdu protocol version case STPPROTOREGULAR case STPPROTORAPID case STPPROTOMSTP case STPPROTOSPB break default return NDTCHECK stp bpdu bpdu type NDPRINT ndo s tok2str stp bpdu type values Unknown BPDU Type 0x 02x stp bpdu bpdu type switch stp bpdu bpdu type case STPBPDUTYPECONFIG if length sizeof struct stp bpdu 1 goto trunc if stp print config bpdu ndo stp bpdu length goto trunc break case STPBPDUTYPERSTP if stp bpdu protocol version STPPROTORAPID if length sizeof struct stp bpdu goto trunc if stp print config bpdu ndo stp bpdu length goto trunc else if stp bpdu protocol version STPPROTOMSTP stp bpdu protocol version STPPROTOSPB if length STPBPDUMSTPMINLEN goto trunc NDTCHECK stp bpdu v1 length if stp bpdu v1 length 0 goto trunc NDTCHECK 16 BITS p MSTBPDUVE R3 LENOFFSET mstp len EXTRACT 16 BITS p MSTBPDUVE R3 LENOFFSET mstp len 2 if length sizeof struct stp bpdu mstp len goto trunc if stp print mstp bpdu ndo stp bpdu length goto trunc if stp bpdu protocol version STPPROTOSPBNDTCHECK 16 BITS p MSTBPDUVE R3 LENOFFSET mstp len spb len EXTRACT 16 BITS p MSTBPDUVE R3 LENOFFSET mstp len spb len 2 if length sizeof struct stp bpdu mstp len spb len spb len SPBBPDUMINLEN goto trunc if stp print spb bpdu ndo stp bpdu sizeof struct stp bpdu mstp len goto trunc break case STPBPDUTYPETOPOCHANGE break default break return trunc NDPRINT ndo stp d length static vpx image t img alloc helper vpx image t img vpx img fmt t fmt unsigned int d w unsigned int d h unsigned int buf align unsigned int stride align unsigned char img data unsigned int h w s xcs ycs bps int align if buf align buf align 1 if buf align buf align 1 goto fail if stride align stride align 1 if stride align stride align 1 goto fail switch fmt case VPXIMGFMTRG B32 case VPXIMGFMTRG B32 LE case VPXIMGFMTARGB case VPXIMGFMTARGBLE bps 32 break case VPXIMGFMTRG B24 case VPXIMGFMTBG R24 bps 24 break case VPXIMGFMTRG B565 case VPXIMGFMTRG B565 LE case VPXIMGFMTRG B555 case VPXIMGFMTRG B555 LE case VPXIMGFMTUYVY case VPXIMGFMTYU Y2 case VPXIMGFMTYVYU bps 16 break case VPXIMGFMT I420 case VPXIMGFMTY V12 case VPXIMGFMTVPX I420 case VPXIMGFMTVPXY V12 bps 12 break case VPXIMGFMT I422 bps 16 break case VPXIMGFMT I444 bps 24 break case VPXIMGFMT I42016 bps 24 break case VPXIMGFMT I42216 bps 32 break case VPXIMGFMT I44416 bps 48 break default bps 16 break switch fmt case VPXIMGFMT I420 case VPXIMGFMTY V12 case VPXIMGFMTVPX I420 case VPXIMGFMTVPXY V12 case VPXIMGFMT I422 case VPXIMGFMT I42016 case VPXIMGFMT I42216 xcs 1 break default xcs 0 break switch fmt case VPXIMGFMT I420 case VPXIMGFMTY V12 case VPXIMGFMTVPX I420 case VPXIMGFMTVPXY V12 ycs 1 break default ycs 0 break align 1 xcs 1 w d w align align align 1 ycs 1 h d h align align s fmt VPXIMGFMTPLANAR w bps w 8 s s stride align 1 stride align 1 if img img vpx image t calloc 1 sizeof vpx image t if img goto fail img self allocd 1 else memset img 0 sizeof vpx image t img img data img data if img data img img data img buf memalign buf align fmt VPXIMGFMTPLANAR h s bps 8 h s img img data owner 1 if img img data goto fail img fmt fmt img bit depth fmt VPXIMGFMTHIGH 16 8 img w w img h h img x chroma shift xcs img y chroma shift ycs img bps bps img stride VPXPLANEY img stride VPXPLANEALPHA s img stride VPXPLANEU img stride VPXPLANEV s xcs if vpx img set rect img 0 0 d w d h return img fail vpx img free img return void jas realloc void ptr size t size void result JASDBGLOG 101 jas realloc x zu n ptr size result realloc ptr size JASDBGLOG 100 jas realloc p zu p n ptr size result return result static int set and cost bmi mvs V P9 COMP cpi MACROBLOCKD xd int i PREDICTIONMODE mode int mv this mv 2 int mv frame mv MBMODECOUNTMAXREFFRAMES int mv seg mvs MAXREFFRAMES int mv best ref mv 2 const int mvjcost int mvcost 2 MODEINFO const mic xd mi 0 const MBMODEINFO const mbmi mic mbmi int thismvcost 0 int idx idy const int num 4x4 blocks wide num 4x4 blocks wide lookup mbmi sb type const int num 4x4 blocks high num 4x4 blocks high lookup mbmi sb type const int is compound has second ref mbmi switch mode case NEWMV this mv 0 as int seg mvs mbmi ref frame 0 as int thismvcost vp9 mv bit cost this mv 0 as mv best ref mv 0 as mv mvjcost mvcost MVCOSTWEIGHTSUB if is compound this mv 1 as int seg mvs mbmi ref frame 1 as int thismvcost vp9 mv bit cost this mv 1 as mv best ref mv 1 as mv mvjcost mvcost MVCOSTWEIGHTSUB break case NEARMV case NEARESTMV this mv 0 as int frame mv mode mbmi ref frame 0 as int if is compound this mv 1 as int frame mv mode mbmi ref frame 1 as int break case ZEROMV this mv 0 as int 0 if is compound this mv 1 as int 0 break default break mic bmi i as mv 0 as int this mv 0 as int if is compound mic bmi i as mv 1 as int this mv 1 as int mic bmi i as mode mode for idy 0 idy num 4x4 blocks high idy for idx 0 idx num 4x4 blocks wide idx vpx memcpy mic bmi i idy 2 idx mic bmi i sizeof mic bmi i return cost mv ref cpi mode mbmi mode context mbmi ref frame 0 thismvcost static int decode frame AV Codec Context avctx void data int got frame AV Packet pkt Bink Context const c avctx priv data AV Frame frame data Get Bit Context gb int plane plane idx ret int bits count pkt size 3 if c version b if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret else if ret ff reget buffer avctx c last 0 av log avctx AVLOGERROR reget buffer failed n return ret if ret av frame ref frame c last 0 return ret init get bits gb pkt data bits count if c has alpha if c version i skip bits long gb 32 if ret bink decode plane c frame gb 3 0 0 return ret if c version i skip bits long gb 32 for plane 0 plane 3 plane plane idx plane c swap planes plane plane 3 if c version b if ret bink decode plane c frame gb plane idx plane 0 return ret else if ret binkb decode plane c frame gb plane idx avctx frame number plane 0 return ret if get bits count gb bits count break emms c if c version b av frame unref c last if ret av frame ref c last frame 0 return ret got frame 1 return pkt size void configure buffer updates V P9 COMP cpi TWOPASS const twopass cpi twopass cpi rc is src frame alt ref 0 switch twopass gf group update type twopass gf group index case KFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 1 break case LFUPDATE cpi refresh last frame 1 cpi refresh golden frame 0 cpi refresh alt ref frame 0 break case GFUPDATE cpi refresh last frame 1 cpi refresh golden frame 1 cpi refresh alt ref frame 0 break case OVERLAYUPDATE cpi refresh last frame 0 cpi refresh golden frame 1 cpi refresh alt ref frame 0 cpi rc is src frame alt ref 1 break case ARFUPDATE cpi refresh last frame 0 cpi refresh golden frame 0 cpi refresh alt ref frame 1 break default assert 0 break if is two pass svc cpi if cpi svc temporal layer id 0 cpi refresh last frame 0 cpi refresh golden frame 0 if cpi svc layer context cpi svc spatial layer id gold ref idx 0 cpi refresh golden frame 0 if cpi alt ref source NULL cpi refresh alt ref frame 0 static int rv34 decode mv R V34 Dec Context r int block type Mpeg Enc Context s r s Get Bit Context gb s gb int i j k l int mv pos s mb x 2 s mb y 2 s b8 stride int next bt memset r dmv 0 sizeof r dmv for i 0 i num mvs block type i r dmv i 0 svq3 get se golomb gb r dmv i 1 svq3 get se golomb gb switch block type case R V34 MBTYPEINTRA case R V34 MBTYPEINTR A16x16 ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride return 0 case R V34 MBSKIP if s pict type AVPICTURETYPEPZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBDIRECT if HAVETHREADS s avctx active thread type FFTHREADFRAME ff thread await progress s next picture ptr f FFMAX 0 s mb y 1 0 next bt s next picture ptr f mb type s mb x s mb y s mb stride if ISINTRA next bt ISSKIP next bt ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride ZER O8x2 s current picture ptr f motion val 1 s mb x 2 s mb y 2 s b8 stride s b8 stride else for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k for l 0 l 2 l s current picture ptr f motion val l mv pos i j s b8 stride k calc add mv r l s next picture ptr f motion val 0 mv pos i j s b8 stride k if IS 16 X8 next bt IS 8 X16 next bt IS 8 X8 next bt rv34 mc 2mv r block type else rv34 mc 2mv skip r ZER O8x2 s current picture ptr f motion val 0 s mb x 2 s mb y 2 s b8 stride s b8 stride break case R V34 MBP 16x16 case R V34 MBPMI X16x16 rv34 pred mv r block type 0 0 rv34 mc 1mv r block type 0 0 0 2 2 0 break case R V34 MBBFORWARD case R V34 MBBBACKWARD r dmv 1 0 r dmv 0 0 r dmv 1 1 r dmv 0 1 if r rv30 rv34 pred mv rv3 r block type block type R V34 MBBBACKWARD else rv34 pred mv b r block type block type R V34 MBBBACKWARD rv34 mc 1mv r block type 0 0 0 2 2 block type R V34 MBBBACKWARD break case R V34 MBP 16x8 case R V34 MBP 8x16 rv34 pred mv r block type 0 0 rv34 pred mv r block type 1 block type R V34 MBP 16x8 1 if block type R V34 MBP 16x8 rv34 mc 1mv r block type 0 0 0 2 1 0 rv34 mc 1mv r block type 0 8 s b8 stride 2 1 0 if block type R V34 MBP 8x16 rv34 mc 1mv r block type 0 0 0 1 2 0 rv34 mc 1mv r block type 8 0 1 1 2 0 break case R V34 MBBBIDIR rv34 pred mv b r block type 0 rv34 pred mv b r block type 1 rv34 mc 2mv r block type break case R V34 MBP 8x8 for i 0 i 4 i rv34 pred mv r block type i i rv34 mc 1mv r block type i 1 3 i 2 2 i 1 i 1 s b8 stride 1 1 0 break return 0 void xps parse color xps document doc char base uri char string fz colorspace csp float samples fz context ctx doc ctx char p int i n char buf 1024 char profile csp fz device rgb ctx samples 0 1 samples 1 0 samples 2 0 samples 3 0 if string 0 if strlen string 9 samples 0 unhex string 1 16 unhex string 2 samples 1 unhex string 3 16 unhex string 4 samples 2 unhex string 5 16 unhex string 6 samples 3 unhex string 7 16 unhex string 8 else samples 0 255 samples 1 unhex string 1 16 unhex string 2 samples 2 unhex string 3 16 unhex string 4 samples 3 unhex string 5 16 unhex string 6 samples 0 255 samples 1 255 samples 2 255 samples 3 255 else if string 0 s string 1 c string 2 if count commas string 2 sscanf string sc g g g samples 1 samples 2 samples 3 if count commas string 3 sscanf string sc g g g g samples samples 1 samples 2 samples 3 else if strstr string Context Color string fz strlcpy buf string sizeof buf profile strchr buf if profile fz warn ctx cannot find icc profile uri in s string return profile 0 p strchr profile if p fz warn ctx cannot find component values in s profile return p 0 n count commas p 1 if n FZMAXCOLORS fz warn ctx ignoring d color components max d allowed n FZMAXCOLORSFZMAXCOLORS n FZMAXCOLORS i 0 while i n samples i fz atof p p strchr p if p break p if p p while i n samples i 0 switch n case 2 csp fz device gray ctx break case 4 csp fz device rgb ctx break case 5 csp fz device cmyk ctx break default csp fz device gray ctx break static Asn1 Generic Decode Asn1 Der Printable String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 PRINTSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL strlcpy a str const char d ptr length 1 a str length 0 d ptr length a length d ptr buffer return a static double eqjoinsel semi Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 Rel Opt Info inner rel double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid Oid Is Valid operator get opcode operator Invalid Oid if vardata2 rel nd2 Min nd2 vardata2 rel rows nd2 Min nd2 inner rel rows if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Oid Is Valid operator Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double matchfreq1 uncertainfrac uncertain int i nmatches clamped nvalues2 clamped nvalues2 Min nvalues2 nd2 fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 clamped nvalues2 sizeof bool nmatches 0 for i 0 i nvalues1 i int j for j 0 j clamped nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true nmatches break matchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 pfree hasmatch1 pfree hasmatch2 if isdefault1 isdefault2 nd1 nmatches nd2 nmatches if nd1 nd2 nd2 0 uncertainfrac 1 0 else uncertainfrac nd2 nd1 else uncertainfrac 0 5 uncertain 1 0 matchfreq1 nullfrac1 CLAMPPROBABILITY uncertain selec matchfreq1 uncertainfrac uncertain else double nullfrac1 stats1 stats1 stanullfrac 0 0 if isdefault1 isdefault2 if nd1 nd2 nd2 0 selec 1 0 nullfrac1 else selec nd2 nd1 1 0 nullfrac1 else selec 0 5 1 0 nullfrac1 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static void slurm rpc submit batch pack job slurm msg t msg static int select serial 1 static int active rpc cnt 0 List Iterator iter int error code SLURMSUCCESS alloc only 0 DEFTIMERS uint32 t pack job id 0 pack job offset 0 struct job record job ptr NULL first job ptr NULL slurm msg t response msg submit response msg t submit msg job desc msg t job desc msg char script NULL slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKNOLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKNOLOCK List job req list List msg data uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint32 t job uid NOVAL char err msg NULL job submit user msg NULL bool reject job false bool is super user List submit job list NULL hostset t jobid hostset NULL char tmp str 32 STARTTIMER debug2 Processing RPCREQUESTSUBMITBATCHPACKJOB from uid d uid if job req list list count job req list 0 info REQUESTSUBMITBATCHPACKJOB from uid d with empty job list uid error code SLURMERROR reject job true goto send msg if sched backfill error code ESLURMNOTSUPPORTED reject job true goto send msg if select serial 1 if xstrcmp slurmctld conf select type select serial select serial 0 else select serial 1 if slurmctld config submissions disabled select serial 1 info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if job req list list count job req list 0 info REQUESTSUBMITBATCHPACKJOB from uid d with empty job list uid error code SLURMERROR reject job true goto send msg is super user validate super user uid lock slurmctld job read lock iter list iterator create job req list while job desc msg job desc msg t list next iter if job uid NOVAL job uid job desc msg user id if uid job desc msg user id is super user error Security violation REQUESTSUBMITBATCHPACKJOB from uid d uid error code ESLURMUSERIDMISSING break if job desc msg alloc node NULL job desc msg alloc node 0 0 error REQUESTSUBMITBATCHPACKJOB lacks alloc node from uid d uid error code ESLURMINVALIDNODENAME break dump job desc job desc msg job desc msg pack job offset pack job offset error code validate job create req job desc msg uid err msg if error code SLURMSUCCESS reject job true break if err msg char save ptr NULL tok tok strtok r err msg n save ptr while tok char sep if job submit user msg sep n xstrfmtcat job submit user msg s d s sep pack job offset tok tok strtok r NULL n save ptr xfree err msg pack job offset list iterator destroy iter unlock slurmctld job read lock if error code SLURMSUCCESS goto send msg if err msg job submit user msg xstrdup err msg submit job list list create NULL pack job offset 0 throttle start active rpc cnt lock slurmctld job write lock STARTTIMER iter list iterator create job req list while job desc msg job desc msg t list next iter if script script xstrdup job desc msg script if pack job offset job desc msg script info s Pack job u offset u has script being ignored func pack job id pack job offset xfree job desc msg script if pack job offset job desc msg mail type 0 xfree job desc msg mail user if job desc msg burst buffer xfree job desc msg script job desc msg script bb g build pack script script pack job offset job desc msg pack job offset pack job offset error code job allocate job desc msg job desc msg immediate false NULL alloc only uid job ptr err msg msg protocol version if job ptr error code job ptr job state JOBFAILED reject job true else if pack job id 0 pack job id job ptr job id first job ptr job ptr alloc only 1 snprintf tmp str sizeof tmp str u job ptr job id if jobid hostset hostset insert jobid hostset tmp str else jobid hostset hostset create tmp str job ptr pack job id pack job id job ptr pack job offset pack job offset job ptr batch flag 1 list append submit job list job ptr if job desc msg immediate error code SLURMSUCCESS error code ESLURMCANNOTSTARTIMMEDIATELY reject job true if reject job break list iterator destroy iter xfree script if pack job id 0 reject job info s No error but no pack job id func error code SLURMERROR reject job true if reject job accounting enforce ACCOUNTINGENFORCELIMITS acct policy validate pack submit job list info Pack job u exceeded association QOS limit for user u pack job id job uid error code ESLURMACCOUNTINGPOLICY reject job true if reject job int buf size pack job offset 16 char tmp str xmalloc buf size char tmp offset tmp str first job ptr pack job list submit job list hostset ranged string jobid hostset buf size tmp str if tmp str 0 tmp offset strchr tmp str if tmp offset tmp offset 0 0 tmp offset tmp str 1 iter list iterator create submit job list while job ptr struct job record list next iter job ptr pack job id set xstrdup tmp offset if slurmctld conf debug flags DEBUGFLAGHETEROJOBS char buf JBUFSIZ info Submit s jobid2fmt job ptr buf sizeof buf list iterator destroy iter xfree tmp str unlock slurmctld job write lock throttle fini active rpc cnt send msg ENDTIME R2 slurm rpc submit batch pack job if reject job info s s func slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code if submit job list void list for each submit job list pack job cancel NULL if first job ptr first job ptr pack job list submit job list else FREENULLLIST submit job list else info s Job Id u s func pack job id TIMESTR submit msg job id pack job id submit msg step id SLURMBATCHSCRIPT submit msg error code error code submit msg job submit user msg job submit user msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg conn msg conn response msg msg type RESPONSESUBMITBATCHJOB response msg data submit msg slurm send node msg msg conn fd response msg schedule job save if jobid hostset hostset destroy jobid hostset xfree err msg xfree job submit user msg static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end buf avpkt size Kgv Context const c avctx priv data int offsets 8 uint16 t out prev int outcnt 0 maxcnt int w h i res if avpkt size 2 return AVERRORINVALIDDATA w buf 0 1 8 h buf 1 1 8 buf 2 if res av image check size w h 0 avctx 0 return res if w avctx width h avctx height if c prev data 0 avctx release buffer avctx c prev avcodec set dimensions avctx w h maxcnt w h c cur reference 3 if res ff get buffer avctx c cur 0 return res out uint16 t c cur data 0 if c prev data 0 prev uint16 t c prev data 0 else prev NULL for i 0 i 8 i offsets i 1 while outcnt maxcnt buf end 2 buf int code AVR L16 buf buf 2 if code 0x8000 out outcnt code else int count int inp off uint16 t inp if code 0x6000 0x6000 int oidx code 10 7 int start count code 0x3 FF 3 if offsets oidx 0 if buf end 3 buf break offsets oidx AVR L24 buf buf 3 start outcnt offsets oidx maxcnt if maxcnt start count break if prev av log avctx AVLOGERROR Frame reference does not exist n break inp prev inp off start else int offset code 0x1 FFF 1 if code 0x6000 count 2 else if code 0x6000 0x2000 count 3 else if buf end 1 buf break count 4 buf if outcnt offset break inp out inp off outcnt offset if maxcnt outcnt count break for i inp off i count inp off i out outcnt inp i if outcnt maxcnt av log avctx AVLOGDEBUG frame finished with d diff n outcnt maxcnt got frame 1 AV Frame data c cur if c prev data 0 avctx release buffer avctx c prev FFSWAPAV Frame c cur c prev return avpkt size int Get Certificate Failure JNI Env env const Java Param Ref jclass obj const Java Param Ref jobject java web contents enum Certificate Failure NONE 0 CERTIFICATEFAILUNSPECIFIED 1 CERTIFICATEFAILUNTRUSTED 2 CERTIFICATEFAILREVOKED 3 CERTIFICATEFAILNOTYETVALID 4 CERTIFICATEFAILEXPIRED 5 CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS 6 content Web Contents web contents content Web Contents From Java Web Contents java web contents content Navigation Entry entry web contents Get Controller Get Visible Entry if entry return NONE const content SSL Status ssl entry Get SSL switch ssl security style case content SECURITYSTYLEWARNING case content SECURITYSTYLEUNKNOWN case content SECURITYSTYLEUNAUTHENTICATED return NONE case content SECURITYSTYLEAUTHENTICATIONBROKEN case content SECURITYSTYLEAUTHENTICATED if net Is Cert Status Error ssl cert status if ssl cert status net CERTSTATUSAUTHORITYINVALID return CERTIFICATEFAILUNTRUSTED if ssl cert status net CERTSTATUSREVOKED return CERTIFICATEFAILREVOKED if ssl cert status net CERTSTATUSDATEINVALID return CERTIFICATEFAILEXPIRED if ssl cert status net CERTSTATUSUNABLETOCHECKREVOCATION return CERTIFICATEFAILUNABLETOCHECKREVOCATIONSTATUS return CERTIFICATEFAILUNSPECIFIED if ssl content status content SSL Status DISPLAYEDINSECURECONTENT return CERTIFICATEFAILUNSPECIFIED return P Gconn Get Connection void P Gconn tmpconn int argcount 7 int i const char keywords const char values const char tmpparam bool need password P Qconninfo Option conn opts NULLP Qconninfo Option conn opt char err msg NULL i 0 if connection string conn opts P Qconninfo Parse connection string err msg if conn opts NULL fprintf stderr s s progname err msg exit 1 for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 argcount keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 keywords i conn opt keyword values i conn opt val i else keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values keywords i dbname values i dbname NULL replication dbname i keywords i replication values i dbname NULL true database i keywords i fallback application name values i progname i if dbhost keywords i host values i dbhost i if dbuser keywords i user values i dbuser i if dbport keywords i port values i dbport i need password dbgetpassword 1 dbpassword NULL do if need password if dbpassword free dbpassword dbpassword simple prompt Password 100 false need password false if dbpassword keywords i password values i dbpassword else keywords i NULL values i NULL tmpconn P Qconnectdb Params keywords values true if tmpconn fprintf stderr s could not connect to server n progname exit 1 if P Qstatus tmpconn CONNECTIONBADP Qconnection Needs Password tmpconn dbgetpassword 1 P Qfinish tmpconn need password true while need password if P Qstatus tmpconn CONNECTIONOK fprintf stderr s could not connect to server s progname P Qerror Message tmpconn P Qfinish tmpconn free values free keywords if conn opts P Qconninfo Free conn opts return NULL free values free keywords if conn opts P Qconninfo Free conn opts tmpparam P Qparameter Status tmpconn integer datetimes if tmpparam fprintf stderr s could not determine server setting for integer datetimes n progname P Qfinish tmpconn exit 1 fprintf stderr s integer datetimes compile flag does not match server n progname P Qfinish tmpconn exit 1 int read ndx and attrs int f in int f out int iflag ptr uchar type ptr char buf int len ptr int len iflags 0 struct file list flist uchar fnamecmp type FNAMECMPFNAME int ndx read loop while 1 ndx read ndx f in if ndx 0 break if ndx NDXDONE return ndx if ndx NDXDELSTATS read del stats f in if am sender am server write del stats f out continue if inc recurse am sender int last if first flist last first flist prev ndx start first flist prev used 1 else last 1 rprintf FERROR Invalid file index d d d s n ndx NDXDONE last who am i exit cleanup RERRPROTOCOL if ndx NDXFLISTEOF flist eof 1 if DEBUGGTEFLIST 3 rprintf FINFO s flist eof 1 n who am i write int f out NDXFLISTEOF continue ndx NDXFLISTOFFSET ndx if ndx 0 ndx dir flist used ndx NDXFLISTOFFSET ndx rprintf FERROR Invalid dir index d d d s n ndx NDXFLISTOFFSETNDXFLISTOFFSET dir flist used 1 who am i exit cleanup RERRPROTOCOL if DEBUGGTEFLIST 2 rprintf FINFO s receiving flist for dir d n who am i ndx start flist forward ndx flist recv file list f in ndx flist parent ndx ndx stop flist forward iflags protocol version 29 read shortint f in ITEMTRANSFERITEMMISSINGDATA if protocol version 30 ndx cur flist used iflags ITEMISNEW if am sender maybe send keepalive time NULLMSKALLOWFLUSH goto read loop flist flist for ndx ndx read ndx and attrs if flist cur flist cur flist flist if am sender file old total cur flist used for flist first flist flist cur flist flist flist next file old total flist used if iflags ITEMBASISTYPEFOLLOWS fnamecmp type read byte f in type ptr fnamecmp type if iflags ITEMXNAMEFOLLOWS if len read vstring f in buf MAXPATHLEN 0 exit cleanup RERRPROTOCOL if sanitize paths sanitize path buf buf 0 SPDEFAULT len strlen buf else buf 0 len 1 len ptr len if iflags ITEMTRANSFER int i ndx cur flist ndx start if i 0 SISREG cur flist files i mode rprintf FERROR received request to transfer non regular file d s n ndx who am i exit cleanup RERRPROTOCOL iflag ptr iflags return ndx static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Fraps Context const s avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame frame data AV Frame const f s frame uint32 t header unsigned int version header size unsigned int x y const uint32 t buf32 uint32 t luma1 luma2 cb cr uint32 t offs 4 int i j ret is chroma planes enum AV Pixel Format pix fmt header AVR L32 buf version header 0xff header size header 1 30 8 4 if version 5 av log avctx AVLOGERROR This file is encoded with Fraps version d This codec can only decode versions 5 n version return AVERRORPATCHWELCOME buf 4 if header size 8 buf 4 pix fmt version 1 AVPIXFMTBG R24 AVPIXFMTYUV J420 P if avctx pix fmt pix fmt f data 0 avctx release buffer avctx f avctx pix fmt pix fmt switch version case 0 default if buf size avctx width avctx height 3 2 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 2 header size return AVERRORINVALIDDATA if avctx width 8 0 avctx height 2 0 av log avctx AVLOGERROR Invalid frame size dx d n avctx width avctx height return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI buf32 const uint32 t buf for y 0 y avctx height 2 y luma1 uint32 t f data 0 y 2 f linesize 0 luma2 uint32 t f data 0 y 2 1 f linesize 0 cr uint32 t f data 1 y f linesize 1 cb uint32 t f data 2 y f linesize 2 for x 0 x avctx width x 8 luma1 buf32 luma1 buf32 luma2 buf32 luma2 buf32 cr buf32 cb buf32 break case 1 if buf size avctx width avctx height 3 header size buf size header size av log avctx AVLOGERROR Invalid frame length d should be d n buf size avctx width avctx height 3 header size return AVERRORINVALIDDATA f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret f pict type header 1 U 31 AVPICTURETYPEPAVPICTURETYPEI f key frame f pict type AVPICTURETYPEI if f pict type AVPICTURETYPEI for y 0 y avctx height y memcpy f data 0 avctx height y 1 f linesize 0 buf y avctx width 3 3 avctx width break case 2 case 4 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i is chroma i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data i f linesize i avctx width is chroma avctx height is chroma buf offs i offs i 1 offs i is chroma 1 0 av log avctx AVLOGERROR Error decoding plane i n i return ret break case 3 case 5 planes 3 f reference 1 f buffer hints FFBUFFERHINTSVALIDFFBUFFERHINTSPRESERVEFFBUFFERHINTSREUSABLE if ret avctx reget buffer avctx f 0 av log avctx AVLOGERROR reget buffer failed n return ret if buf size 8 f pict type AVPICTURETYPEP f key frame 0 break f pict type AVPICTURETYPEI f key frame 1 if AVR L32 buf FPSTAG buf size planes 1024 24 av log avctx AVLOGERROR Fraps error in data stream n return AVERRORINVALIDDATA for i 0 i planes i offs i AVR L32 buf 4 i 4 if offs i buf size i offs i offs i 1 1024 av log avctx AVLOGERROR Fraps plane i offset is out of bounds n i return AVERRORINVALIDDATA offs planes buf size for i 0 i planes i av fast padded malloc s tmpbuf s tmpbuf size offs i 1 offs i 1024 if s tmpbuf return AVERRORENOMEM if ret fraps2 decode plane s f data 0 i f linesize 0 avctx height 1 f linesize 0 avctx width avctx height buf offs i offs i 1 offs i 0 3 0 av log avctx AVLOGERROR Error decoding plane i n i return ret for j 0 j avctx height j for i 0 i avctx width i f data 0 0 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 f data 0 2 i 3 j f linesize 0 f data 0 1 i 3 j f linesize 0 break frame f got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int field ret AV Frame pic avctx coded frame const uint8 t buf avpkt data const uint8 t buf end buf avpkt size if pic data 0 avctx release buffer avctx pic if avpkt size avctx width 2 avctx height 4 2 8 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA if bytestream get le32 buf MKTAGFRW 1 av log avctx AVLOGERROR incorrect marker n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret pic pict type AVPICTURETYPEI pic key frame 1 pic interlaced frame 1 pic top field first 1 for field 0 field 2 field int i int field h avctx height field 1 int field size min field size avctx width 2 field h uint8 t dst pic data 0 if buf end buf 8 return AVERRORINVALIDDATA buf 4 field size bytestream get le32 buf if field size min field size av log avctx AVLOGERROR Field size i is too small required i n field size min field size return AVERRORINVALIDDATA if buf end buf field size av log avctx AVLOGERROR Packet is too small need i have i n field size int buf end buf return AVERRORINVALIDDATA if field dst pic linesize 0 for i 0 i field h i memcpy dst buf avctx width 2 buf avctx width 2 dst pic linesize 0 1 buf field size min field size got frame 1 AV Frame data pic return avpkt size static Asn1 Generic Decode Asn1 Der I A5 String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length max size return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 I A5 STRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL strlcpy a str const char d ptr length 1 d ptr length a length d ptr buffer return a static void jbig2 decode mmr init Jbig2 Mmr Ctx mmr int width int height const byte data size t size size t i uint32 t word 0 mmr width width mmr height height mmr data data mmr size size mmr data index 0 mmr bit index 0 for i 0 i size i 4 i word data i 3 i 3 mmr word word int decodenetnum const char num sockaddr u netnum struct addrinfo hints ai NULL int err u short port const char cp const char port str char pp char np char name 80 REQUIRE num NULLREQUIRE strlen num sizeof name port str NULL if num 0 pp strchr num if NULL pp cp num else if NULL strchr pp 1 cp num else strlcpy name num sizeof name cp name pp strchr cp pp 0 port str pp 1 else cp num 1 np name while cp cp np cp np 0 if cp 0 cp 1 0 cp 2 port str cp 2 cp name ZERO hints hints ai flags ZAINUMERICHOST err getaddrinfo cp ntp hints ai if err 0 return 0 INSIST ai ai addrlen sizeof netnum ZERO netnum memcpy netnum ai ai addr ai ai addrlen freeaddrinfo ai if NULL port str 1 sscanf port str hu port port NTPPORTSETPORT netnum port return 1 void jpc qmfb split colres jpc fix t a int numrows int numcols int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr numcols srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr numcols if buf splitbuf jas free buf static void first pass motion search V P9 COMP cpi MACROBLOCK x const MV ref mv MV best mv int best motion err MACROBLOCKD const xd x e mbd MV tmp mv 0 0 MV ref mv full ref mv row 3 ref mv col 3 int num00 tmp err n const BLOCKSIZE bsize xd mi 0 src mi mbmi sb type vp9 variance fn ptr t v fn ptr cpi fn ptr bsize const int new mv mode penalty NEWMVMODEPENALTY int step param 3 int further steps MAXMVSEARCHSTEPS 1 step param const int sr get search range cpi common step param sr further steps sr v fn ptr vf get block variance fn bsize tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv n num00 num00 0 while n further steps n if num00 num00 else tmp err cpi diamond search sad x cpi ss cfg ref mv full tmp mv step param n x sadperbit16 num00 v fn ptr ref mv if tmp err INTMAX tmp err vp9 get mvpred var x tmp mv ref mv v fn ptr 1 if tmp err INTMAX new mv mode penalty tmp err new mv mode penalty if tmp err best motion err best motion err tmp err best mv tmp mv static P Gconn get db conn Cluster Info cluster const char db name char conn opts 2 NAMEDATALENMAXPGPATH 100 if cluster sockdir snprintf conn opts sizeof conn opts dbname s user s host s port d db name os info user cluster sockdir cluster port else snprintf conn opts sizeof conn opts dbname s user s port d db name os info user cluster port return P Qconnectdb conn opts static ulong get sort uint count va list args va start args count ulong sort 0 DBUGASSERT count 4 while count char start str va arg args char uint chars 0 uint wild pos 0 if start str for str str if str wild prefix str 1 str else if str wild many str wild one wild pos uint str start 1 if wild pos 1 str wild many str 0 wild pos break chars 128 sort sort 8 wild pos min wild pos 127 chars va end args return sort static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt int h w AV Frame pic avctx coded frame const uint8 t src avpkt data uint8 t Y1 Y2 UV int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 3 2 16 av log avctx AVLOGERROR packet too small n return AVERRORINVALIDDATA pic reference 0 if ret ff get buffer avctx pic 0 return ret pic pict type AVPICTURETYPEI pic key frame 1 if AVR L32 src 0x01000002 av log ask for sample avctx Unknown frame header X n AVR L32 src return AVERRORPATCHWELCOME src 16 Y1 pic data 0 Y2 pic data 0 pic linesize 0 U pic data 1 V pic data 2 for h 0 h avctx height h 2 for w 0 w avctx width w 2 AVCOP Y16 Y1 w src AVCOP Y16 Y2 w src 2 U w 1 src 4 0x80 V w 1 src 5 0x80 src 6 Y1 pic linesize 0 1 Y2 pic linesize 0 1 U pic linesize 1 V pic linesize 2 got frame 1 AV Frame data pic return avpkt size static int tgv decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Tgv Context s avctx priv data const uint8 t buf end buf buf size AV Frame frame data int chunk type ret chunk type AVR L32 buf 0 buf EAPREAMBLESIZE if chunk type k VGTTAG int pal count i if buf 12 buf end av log avctx AVLOGWARNING truncated header n return AVERRORINVALIDDATA s width AVR L16 buf 0 s height AVR L16 buf 2 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height av freep s frame buffer av frame unref s last frame pal count AVR L16 buf 6 buf 12 for i 0 i pal count i AVPALETTECOUNT buf 2 buf end i s palette i AVR B24 buf buf 3 if ret av image check size s width s height 0 avctx 0 return ret if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 return ret memcpy frame data 1 s palette AVPALETTESIZE if chunk type k VGTTAG int y frame key frame 1 frame pict type AVPICTURETYPEI if s frame buffer s frame buffer av malloc s width s height return AVERRORENOMEM if unpack buf buf end s frame buffer s avctx width s avctx height 0 av log avctx AVLOGWARNING truncated intra frame n return AVERRORINVALIDDATA for y 0 y s height y memcpy frame data 0 y frame linesize 0 s frame buffer y s width s width else if s last frame data 0 av log avctx AVLOGWARNING inter frame without corresponding intra frame n return buf size frame key frame 0 frame pict type AVPICTURETYPEP if tgv decode inter s frame buf buf end 0 av log avctx AVLOGWARNING truncated inter frame n return AVERRORINVALIDDATA av frame unref s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt WN V1 Context const l avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame const p data unsigned char YUV int i j ret int prev y 0 prev u 0 prev v 0 uint8 t rbuf rbuf av malloc buf size FFINPUTBUFFERPADDINGSIZE if rbuf av log avctx AVLOGERROR Cannot allocate temporary buffer n return AVERRORENOMEM if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n av free rbuf return ret p key frame 1 for i 8 i buf size i rbuf i ff reverse buf i init get bits l gb rbuf 8 buf size 8 8 if buf 2 4 6 l shift 2 else l shift 8 buf 2 4 if l shift 4 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 4 if l shift 1 av log ask for sample avctx Unknown WN V1 frame header value i n buf 2 4 l shift 1 Y p data 0 U p data 1 V p data 2 for j 0 j avctx height j for i 0 i avctx width 2 i Y i 2 wnv1 get code l prev y prev u U i wnv1 get code l prev u prev y Y i 2 1 wnv1 get code l Y i 2 prev v V i wnv1 get code l prev v Y p linesize 0 U p linesize 1 V p linesize 2 got frame 1 av free rbuf return buf size static int truespeech decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size TS Context c avctx priv data int i j int16 t samples int iterations ret iterations buf size 32 if iterations av log avctx AVLOGERROR Too small input buffer d bytes need at least 32 bytes n buf size return 1 frame nb samples iterations 240 if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret samples int16 t frame data 0 memset samples 0 iterations 240 sizeof samples for j 0 j iterations j truespeech read frame c buf buf 32 truespeech correlate filter c truespeech filters merge c for i 0 i 4 i truespeech apply twopoint filter c i truespeech place pulses c samples i truespeech update filters c samples i truespeech synth c samples i samples 60 truespeech save prevvec c got frame ptr 1 return buf size static uint32 t nvic readl nvic state s uint32 t offset uint32 t val int irq switch offset case 4 return s num irq 32 1 case 0x10 val s systick control s systick control SYSTICKCOUNTFLAG return val case 0x14 return s systick reload case 0x18 int64 t t if s systick control SYSTICKENABLE 0 return 0 t qemu get clock ns vm clock if t s systick tick return 0 val s systick tick t 1 systick scale s 1 if val s systick reload val 0 return val case 0x1c return 10000 case 0xd00 return cpu single env cp15 c0 cpuid case 0xd04 val s gic running irq 0 if val 1023 val 0 else if val 32 val 16 if s gic running irq 0 1023 s gic last active s gic running irq 0 0 1023 val 1 11 if s gic current pending 0 1023 val s gic current pending 0 12 for irq 32 irq s num irq irq if s gic irq state irq pending val 1 22 break if s gic irq state ARM V7 MEXCPSYSTICK pending val 1 26 if s gic irq state ARM V7 MEXCPPENDSV pending val 1 28 if s gic irq state ARM V7 MEXCPNMI pending val 1 31 return val case 0xd08 return cpu single env v7m vecbase case 0xd0c return 0xfa05000 case 0xd10 return 0 case 0xd14 return 0 case 0xd24 val 0 if s gic irq state ARM V7 MEXCPMEM active val 1 0 if s gic irq state ARM V7 MEXCPBUS active val 1 1 if s gic irq state ARM V7 MEXCPUSAGE active val 1 3 if s gic irq state ARM V7 MEXCPSVC active val 1 7 if s gic irq state ARM V7 MEXCPDEBUG active val 1 8 if s gic irq state ARM V7 MEXCPPENDSV active val 1 10 if s gic irq state ARM V7 MEXCPSYSTICK active val 1 11 if s gic irq state ARM V7 MEXCPUSAGE pending val 1 12 if s gic irq state ARM V7 MEXCPMEM pending val 1 13 if s gic irq state ARM V7 MEXCPBUS pending val 1 14 if s gic irq state ARM V7 MEXCPSVC pending val 1 15 if s gic irq state ARM V7 MEXCPMEM enabled val 1 16 if s gic irq state ARM V7 MEXCPBUS enabled val 1 17 if s gic irq state ARM V7 MEXCPUSAGE enabled val 1 18 return val case 0xd28 qemu log mask LOGUNIMP Configurable Fault Status unimplemented n return 0 case 0xd2c case 0xd30 case 0xd34 case 0xd38 case 0xd3c qemu log mask LOGUNIMP Fault status registers unimplemented n return 0 case 0xd40 return 0x00000030 case 0xd44 return 0x00000200 case 0xd48 return 0x00100000 case 0xd4c return 0x00000000 case 0xd50 return 0x00000030 case 0xd54 return 0x00000000 case 0xd58 return 0x00000000 case 0xd5c return 0x00000000 case 0xd60 return 0x01141110 case 0xd64 return 0x02111000 case 0xd68 return 0x21112231 case 0xd6c return 0x01111110 case 0xd70 return 0x01310102 default qemu log mask LOGGUESTERRORNVIC Bad read offset 0x x n offset return 0 const char vpx svc dump statistics Svc Context svc ctx int number of frames encode frame count int i j uint32 t bytes total 0 double scale COMPONENTS double psnr COMPONENTS double mse COMPONENTS double y scale Svc Internal const si get svc internal svc ctx if svc ctx NULL si NULL return NULL svc log reset svc ctx encode frame count si encode frame count if si encode frame count 0 return vpx svc get message svc ctx svc log svc ctx SVCLOGINFO n for i 0 i si layers i number of frames encode frame count svc log svc ctx SVCLOGINFO Layer d Average PSNR 2 3f 2 3f 2 3f 2 3f Bytes u n i double si psnr sum i 0 number of frames double si psnr sum i 1 number of frames double si psnr sum i 2 number of frames double si psnr sum i 3 number of frames si bytes sum i y scale si width si height 255 0 255 0 number of frames scale 1 y scale scale 2 scale 3 y scale 4 scale 0 y scale 1 5 for j 0 j COMPONENTS j psnr j calc psnr si sse sum i j scale j mse j si sse sum i j 255 0 255 0 scale j svc log svc ctx SVCLOGINFO Layer d Overall PSNR 2 3f 2 3f 2 3f 2 3f n i psnr 0 psnr 1 psnr 2 psnr 3 svc log svc ctx SVCLOGINFO Layer d Overall MSE 2 3f 2 3f 2 3f 2 3f n i mse 0 mse 1 mse 2 mse 3 bytes total si bytes sum i si bytes sum i 0 for j 0 j COMPONENTS j si psnr sum i j 0 si sse sum i j 0 si encode frame count 0 svc log svc ctx SVCLOGINFO Total Bytes u n bytes total return vpx svc get message svc ctx static gboolean logcat dump text wtap dumper wdh const struct wtap pkthdr phdr const guint8 pd int err gchar buf gint length gchar priority const struct logger entry log entry struct logger entry pd const struct logger entry v2 log entry v2 struct logger entry v2 pd gint payload length const gchar tag gint32 pid gint32 tid gint32 seconds gint32 milliseconds const gchar msg begin gint msg pre skip gchar log gchar log part gchar log next const union wtap pseudo header pseudo header phdr pseudo header const struct dumper t dumper const struct dumper t wdh priv if phdr rec type RECTYPEPACKET err WTAPERRRECTYPEUNSUPPORTED return FALSE payload length GIN T32 FROMLE log entry len pid GIN T32 FROMLE log entry pid tid GIN T32 FROMLE log entry tid seconds GIN T32 FROMLE log entry sec milliseconds GIN T32 FROMLE log entry nsec 1000000 if pseudo header logcat version 1 priority get priority log entry msg 0 tag log entry msg 1 msg pre skip 1 strlen tag 1 msg begin log entry msg msg pre skip else if pseudo header logcat version 2 priority get priority log entry v2 msg 0 tag log entry v2 msg 1 msg pre skip 1 strlen tag 1 msg begin log entry v2 msg msg pre skip else err WTAPERRUNSUPPORTED return FALSE log g strndup msg begin payload length msg pre skip log next log do log part log next if dumper type DUMPLONG log next NULL else log next strchr log part n if log next NULL log next 0 log next if log next 0 log next NULL buf logcat log dumper seconds milliseconds pid tid priority tag log part if buf g free log return FALSE length guint32 strlen buf if wtap dump file write wdh buf length err g free log return FALSE wdh bytes dumped length while log next NULL g free log return int ff alloc picture Mpeg Enc Context s Picture pic int shared const int big mb num s mb stride s mb height 1 1 const int mb array size s mb stride s mb height const int b8 array size s b8 stride s mb height 2 const int b4 array size s b4 stride s mb height 4 int i int r 1 if shared assert pic f data 0 assert pic f type 0 pic f type FFBUFFERTYPESHARED pic f type FFBUFFERTYPESHARED else assert pic f data 0 if alloc frame buffer s pic 0 return 1 s linesize pic f linesize 0 s uvlinesize pic f linesize 1 if pic f qscale table NULL if s encoding FFALLOCZORGOTO s avctx pic mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mc mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mb mean mb array size sizeof int8 t fail FFALLOCZORGOTO s avctx pic f mbskip table mb array size sizeof uint8 t 2 fail FFALLOCZORGOTO s avctx pic qscale table base big mb num s mb stride sizeof uint8 t fail FFALLOCZORGOTO s avctx pic mb type base big mb num s mb stride sizeof uint32 t fail pic f mb type pic mb type base 2 s mb stride 1 pic f qscale table pic qscale table base 2 s mb stride 1 if s out format FMT H264 for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b4 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 2 else if s out format FMT H263 s encoding s avctx debug FFDEBUGMV s avctx debug mv for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b8 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 3 if s avctx debug FFDEBUGDCTCOEFFFFALLOCZORGOTO s avctx pic f dct coeff 64 mb array size sizeof int16 t 6 fail pic f qstride s mb stride FFALLOCZORGOTO s avctx pic f pan scan 1 sizeof AV Pan Scan fail pic owner2 s return 0 fail if r 0 free frame buffer s pic return 1 static int zsethalftone5 i ctx t i ctx p os ptr op osp uint count gs halftone component phtc 0 gs halftone component pc int code 0 int j bool have default gs halftone pht 0 gx device halftone pdht 0 ref sprocs GSCLIENTCOLORMAXCOMPONENTS 1 ref tprocs GSCLIENTCOLORMAXCOMPONENTS 1 gs memory t mem uint edepth ref stack count e stack int npop 2 int dict enum dict first op ref rvalue 2 int cname colorant number byte pname uint name size int halftonetype type 0 gs gstate pgs igs int space index r space index op 1 mem gs memory t idmemory spaces indexed space index check type op t dictionary check dict read op check type op 1 t dictionary check dict read op 1 code dict int param op 1 Halftone Type 1 100 0 type if code 0 return code halftonetype type 2 type 4 ht type multiple colorscreen ht type multiple have default false for count 0 if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue else if colorant number GXDEVICECOLORMAXCOMPONENTS if have default return error gs error rangecheck have default true count if count GSCLIENTCOLORMAXCOMPONENTS 1 code gs note error gs error rangecheck break if count 0 halftonetype ht type multiple have default code gs note error gs error rangecheck if code 0 check estack 5 refset null sprocs count refset null tprocs count rc alloc struct 0 pht gs halftone st halftone imemory pht 0 sethalftone5 phtc gs alloc struct array mem count gs halftone component st ht component element sethalftone5 rc alloc struct 0 pdht gx device halftone st device halftone imemory pdht 0 sethalftone5 if pht 0 phtc 0 pdht 0 j 0 code gs note error gs error V Merror if code 0 dict enum dict first op for j 0 pc phtc int type if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue pc cname cname pc comp number colorant number check dict read rvalue 1 if dict int param rvalue 1 Halftone Type 1 7 0 type 0 code gs note error gs error typecheck break switch type default code gs note error gs error rangecheck break case 1 code dict spot params rvalue 1 pc params spot sprocs j tprocs j mem pc params spot screen spot function spot1 dummy pc type ht type spot break case 3 code dict threshold params rvalue 1 pc params threshold tprocs j pc type ht type threshold break case 7 code dict threshold2 params rvalue 1 pc params threshold2 tprocs j imemory pc type ht type threshold2 break if code 0 break pc j if code 0 pht type halftonetype pht params multiple components phtc pht params multiple num comp j pht params multiple get colorname string gs get colorname string code gs sethalftone prepare igs pht pdht if code 0 dict enum dict first op for pc phtc if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue if pc type ht type spot code dict spot results i ctx p rvalue 1 pc params spot if code 0 break pc if code 0 uint odepth ref stack count o stack ref odict odict5 odict op 1 odict5 op pop 2 op osp esp 5 make mark estack esp 4 es other sethalftone cleanup esp 3 odict make istruct esp 2 0 pht make istruct esp 1 0 pdht make op estack esp sethalftone finish for j 0 j count j gx ht order porder NULL if pdht components 0 porder pdht order else int k int comp number phtc j comp number for k 0 k count k if pdht components k comp number comp number porder pdht components k corder break switch phtc j type case ht type spot code zscreen enum init i ctx p porder phtc j params spot screen sprocs j 0 0 space index if code 0 break case ht type threshold if r has type tprocs j t invalid check ostack zcolor remap one ostack check estack zcolor remap one estack code zcolor remap one i ctx p tprocs j porder transfer igs zcolor remap one finish op osp break default if code 0 ref stack pop to o stack odepth ref stack pop to e stack edepth op osp op 1 odict op odict5 break npop 0 if code 0 gs free object mem pdht sethalftone5 gs free object mem phtc sethalftone5 gs free object mem pht sethalftone5 return code pop npop return ref stack count e stack edepth o push estack 0 void vp9 init quantizer V P9 COMP cpi V P9 COMMON const cm cpi common QUANTS const quants cpi quants int i q quant for q 0 q QINDEXRANGE q const int qzbin factor q 0 64 vp9 dc quant q 0 148 84 80 const int qrounding factor q 0 64 48 for i 0 i 2 i int qrounding factor fp i 0 48 42 if q 0 qrounding factor fp 64 quant i 0 vp9 dc quant q cm y dc delta q vp9 ac quant q 0 invert quant quants y quant q i quants y quant shift q i quant quants y quant fp q i 1 16 quant quants y round fp q i qrounding factor fp quant 7 quants y zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants y round q i qrounding factor quant 7 cm y dequant q i quant quant i 0 vp9 dc quant q cm uv dc delta q vp9 ac quant q cm uv ac delta q invert quant quants uv quant q i quants uv quant shift q i quant quants uv quant fp q i 1 16 quant quants uv round fp q i qrounding factor fp quant 7 quants uv zbin q i ROUNDPOWEROFTWO qzbin factor quant 7 quants uv round q i qrounding factor quant 7 cm uv dequant q i quant for i 2 i 8 i quants y quant q i quants y quant q 1 quants y quant fp q i quants y quant fp q 1 quants y round fp q i quants y round fp q 1 quants y quant shift q i quants y quant shift q 1 quants y zbin q i quants y zbin q 1 quants y round q i quants y round q 1 cm y dequant q i cm y dequant q 1 quants uv quant q i quants uv quant q 1 quants uv quant fp q i quants uv quant fp q 1 quants uv round fp q i quants uv round fp q 1 quants uv quant shift q i quants uv quant shift q 1 quants uv zbin q i quants uv zbin q 1 quants uv round q i quants uv round q 1 cm uv dequant q i cm uv dequant q 1 static int32 t append Keywords To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status char buf ULOCKEYWORDANDVALUESCAPACITY char attr Buf ULOCKEYWORDANDVALUESCAPACITY 0 int32 t attr Buf Length 0 U Enumeration keyword Enum NULL int32 t reslen 0 keyword Enum uloc open Keywords locale ID status if UFAILURE status had Posix uenum close keyword Enum return 0 if keyword Enum NULL had Posix int32 t len const char key Extension List Entry first Ext NULL Extension List Entry ext Attribute List Entry first Attr NULL Attribute List Entry attr char attr Value char ext Buf ULOCKEYWORDANDVALUESCAPACITY char p Ext Buf ext Buf int32 t ext Buf Capacity sizeof ext Buf const char bcp Key nullptr bcp Value nullptr U Error Code tmp Status UZEROERROR int32 t keylen U Bool is Bcp U Ext while TRUE key uenum next keyword Enum NULL status if key NULL break len uloc get Keyword Value locale ID key buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR break tmp Status UZEROERROR continue keylen int32 t uprv strlen key is Bcp U Ext keylen 1 if uprv strcmp key LOCALEATTRIBUTEKEY 0 if len 0 int32 t i 0 while TRUE attr Buf Length 0 for i len i if buf i attr Buf attr Buf Length buf i else i break if attr Buf Length 0 attr Buf attr Buf Length 0 else if i len break attr Attribute List Entry uprv malloc sizeof Attribute List Entry if attr NULL status UMEMORYALLOCATIONERROR break attr Value char uprv malloc attr Buf Length 1 if attr Value NULL status UMEMORYALLOCATIONERROR break uprv strcpy attr Value attr Buf attr attribute attr Value if add Attribute To List first Attr attr uprv free attr uprv free attr Value if strict status UILLEGALARGUMENTERROR break bcp Key LOCALEATTRIBUTEKEY bcp Value NULL else if is Bcp U Ext bcp Key uloc to Unicode Locale Key key if bcp Key NULL if strict status UILLEGALARGUMENTERROR break continue bcp Value uloc to Unicode Locale Type key buf if bcp Value NULL if strict status UILLEGALARGUMENTERROR break continue if bcp Value buf int32 t bcp Value Len uprv strlen bcp Value if bcp Value Len ext Buf Capacity uprv strcpy p Ext Buf bcp Value TC String to Lower Case p Ext Buf bcp Value p Ext Buf p Ext Buf bcp Value Len 1 ext Buf Capacity bcp Value Len 1 else if strict status UILLEGALARGUMENTERROR break continue else if key PRIVATEUSE if is Privateuse Value Subtags buf len if strict status UILLEGALARGUMENTERROR break continue else if is Extension Singleton key keylen is Extension Subtags buf len if strict status UILLEGALARGUMENTERROR break continue bcp Key key if len 1 ext Buf Capacity uprv memcpy p Ext Buf buf len bcp Value p Ext Buf p Ext Buf len p Ext Buf 0 p Ext Buf ext Buf Capacity len 1 else status UILLEGALARGUMENTERROR break ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR break ext key bcp Key ext value bcp Value if add Extension To List first Ext ext TRUE uprv free ext if strict status UILLEGALARGUMENTERROR break if had Posix ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR goto cleanup ext key POSIXKEY ext value POSIXVALUE if add Extension To List first Ext ext TRUE uprv free ext if USUCCESS status first Ext NULL first Attr NULLU Bool start LDML Extension FALSE for ext first Ext ext ext ext next if start LDML Extension uprv strlen ext key 1 if reslen capacity append At reslen SEP reslen if reslen capacity append At reslen LDMLEXT reslen start LDML Extension TRUE if uprv strcmp ext key LOCALEATTRIBUTEKEY 0 for attr first Attr attr attr attr next if reslen capacity append At reslen SEP reslen len int32 t uprv strlen attr attribute if reslen capacity uprv memcpy append At reslen attr attribute uprv min len capacity reslen reslen len else if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext key if reslen capacity uprv memcpy append At reslen ext key uprv min len capacity reslen reslen len if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext value if reslen capacity uprv memcpy append At reslen ext value uprv min len capacity reslen reslen len cleanup ext first Ext while ext NULL Extension List Entry tmp Ext ext next uprv free ext ext tmp Ext attr first Attr while attr NULL Attribute List Entry tmp Attr attr next char p Value char attr attribute uprv free p Value uprv free attr attr tmp Attr uenum close keyword Enum if UFAILURE status return 0 return u terminate Chars append At capacity reslen status static void vmport ioport write void opaque hwaddr addr uint64 t val unsigned size CPU X86 State env cpu single env env regs REAX vmport ioport read opaque addr 4 static int cavs decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AVS Context h avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data uint32 t stc 1 int input size const uint8 t buf end const uint8 t buf ptr if buf size 0 if h low delay h DPB 0 f data 0 got frame 1 picture h DPB 0 f if h cur f data 0 avctx release buffer avctx h cur f FFSWAPAVS Frame h cur h DPB 0 return 0 buf ptr buf buf end buf buf size for buf ptr avpriv mpv find start code buf ptr buf end stc if stc 0x FFFFF E00 buf ptr buf end return FFMAX 0 buf ptr buf input size buf end buf ptr 8 switch stc case CAVSSTARTCODE init get bits h gb buf ptr input size decode seq header h break case PICISTARTCODE if h got keyframe if h DPB 0 f data 0 avctx release buffer avctx h DPB 0 f if h DPB 1 f data 0 avctx release buffer avctx h DPB 1 f h got keyframe 1 case PICPBSTARTCODE got frame 0 if h got keyframe break init get bits h gb buf ptr input size h stc stc if decode pic h break got frame 1 if h cur f pict type AVPICTURETYPEB if h DPB 1 f data 0 picture h DPB 1 f else got frame 0 else picture h cur f break case EXTSTARTCODE break case USERSTARTCODE break default if stc SLICEMAXSTARTCODE init get bits h gb buf ptr input size decode slice header h h gb break void parse Extension Object proto tree tree tvbuff t tvb packet info pinfo gint p Offset const char sz Field Name static const int extobj mask hf opcua extobj mask binbodyflag hf opcua extobj mask xmlbodyflag NULL gint i Offset p Offset guint8 Encoding Mask guint32 Type Id proto tree extobj tree proto item ti guint opcua nested count extobj tree proto tree add subtree format tree tvb p Offset 1 ett opcua extensionobject ti s Extension Object sz Field Name opcua nested count GPOINTERTOUINT p get proto data pinfo pool pinfo proto opcua 0 if opcua nested count MAXNESTINGDEPTH expert add info pinfo ti ei nesting depth return p add proto data pinfo pool pinfo proto opcua 0 GUINTTOPOINTER opcua nested count Type Id get Extension Object Type tvb i Offset parse Expanded Node Id extobj tree tvb pinfo i Offset Type Id Encoding Mask tvb get guint8 tvb i Offset proto tree add bitmask extobj tree tvb i Offset hf opcua extobj mask ett opcua extensionobject encodingmask extobj mask ENCLITTLEENDIAN i Offset if Encoding Mask EXTOBJENCODINGMASKBINBODYFLAG dispatch Extension Object Type extobj tree tvb pinfo i Offset Type Id proto item set end ti tvb i Offset p Offset i Offset int petite inflate2x 1to9 char buf uint32 t minrva uint32 t bufsz struct cli exe section sections unsigned int sectcount uint32 t Imagebase uint32 t pep int desc int version uint32 t Res Rva uint32 t Res Size char adjbuf buf minrva char packed NULL uint32 t thisrva 0 bottom 0 enc ep 0 irva 0 workdone 0 grown 0x355 skew 0x35 int j 0 oob mangled 0 check4resources 0 struct cli exe section usects NULL void tmpsct NULL if version 2 packed adjbuf sections sectcount 1 rva 0x1b8 if version 1 packed adjbuf sections sectcount 1 rva 0x178 grown 0x323 skew 0x34 while 1 char ssrc ddst uint32 t size srva int backbytes oldback backsize addsize if CLIISCONTAINED buf bufsz packed 4 if usects free usects return 1 srva cli readint32 packed if srva int t upd 1 if j 0 return 1 while upd upd 0 for t 0 t j 1 t uint32 t trva trsz tvsz if usects t rva usects t 1 rva continue trva usects t rva trsz usects t rsz tvsz usects t vsz usects t rva usects t 1 rva usects t rsz usects t 1 rsz usects t vsz usects t 1 vsz usects t 1 rva trva usects t 1 rsz trsz usects t 1 vsz tvsz upd 1 for t 0 t j 1 t if usects t vsz usects t 1 rva usects t rva usects t vsz usects t 1 rva usects t rva if enc ep uint32 t virtaddr pep 5 Imagebase tmpep int rndm 0 dummy 1 char thunk adjbuf irva char imports if version 2 while dummy CLIISCONTAINED buf bufsz thunk 4 uint32 t api if cli readint32 thunk workdone 1 break imports adjbuf cli readint32 thunk thunk 4 dummy 0 while CLIISCONTAINED buf bufsz imports 4 dummy 0 imports 4 if api cli readint32 imports 4 dummy 1 break if api api 0x80000000 mangled rndm 0 api virtaddr virtaddr 5 rndm virtaddr 7 else api 0xbff01337 if sections sectcount 1 rva Imagebase api enc ep if api virtaddr enc ep tmpep enc ep 0xfffffff8 3 0x1fffffff enc ep enc ep 7 29 tmpep else workdone 1 enc ep pep 5 enc ep if workdone 1 cli dbgmsg Petite Old EP x n enc ep else enc ep usects 0 rva cli dbgmsg Petite In troubles while attempting to decrypt old EP using bogus x n enc ep for t 0 t j t usects t raw t 0 usects t 1 raw usects t 1 rsz 0 if usects t rsz 0 if CLIISCONTAINED buf bufsz buf usects t raw usects t rsz memmove buf usects t raw adjbuf usects t rva usects t rsz else cli dbgmsg Petite Skipping section d Raw x R Size x n t usects t raw usects t rsz usects t raw t 0 usects t 1 raw 0 usects t rsz 0 cli dbgmsg Petite Sections dump n for t 0 t j t cli dbgmsg Petite SECT d RVA x V Size x R Offset x R Size x n t usects t rva usects t vsz usects t raw usects t rsz if cli rebuildpe buf usects j Imagebase enc ep Res Rva Res Size desc cli dbgmsg Petite Rebuilding failed n free usects return 1 free usects return 0 size srva 0x7fffffff if srva size check4resources 0 if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 bottom cli readint32 packed 8 4 ssrc adjbuf cli readint32 packed 4 size 1 4 ddst adjbuf cli readint32 packed 8 size 1 4 if CLIISCONTAINED buf bufsz ssrc size 4 CLIISCONTAINED buf bufsz ddst size 4 if usects free usects return 1 memmove ddst ssrc size 4 packed 0x0c else uint32 t check1 check2 uint8 t mydl 0 uint8 t goback unsigned int q if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 size cli readint32 packed 4 thisrva cli readint32 packed 8 packed 0x10 if j 96 cli dbgmsg Petite maximum number of sections exceeded giving up n free usects return 1 if tmpsct cli realloc usects sizeof struct cli exe section j 1 if usects free usects return 1 usects struct cli exe section tmpsct usects j rva thisrva usects j rsz size if int bottom thisrva 0 usects j vsz bottom thisrva else usects j vsz size usects j raw 0 if size j continue ssrc adjbuf srva ddst adjbuf thisrva for q 0 q sectcount q if CLIISCONTAINED sections q rva sections q vsz usects j rva usects j vsz continue if check4resources usects j rva sections q rva usects j rsz thisrva sections q rva size break if q sectcount free usects return 1 j if size 0x10000 check1 0x0 FFFF C060 check2 0x0 FFFFF C60 goback 5 else if size 0x40000 check1 0x0 FFF F8180 check2 0x0 FFFF F980 goback 7 else check1 0x0 FFF F8300 check2 0x0 FFFFF B00 goback 8 if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 size ddst ssrc backbytes 0 oldback 0 while size 0 oob doubledl ssrc mydl buf bufsz if oob 1 free usects return 1 if oob if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 ddst char ssrc size 0xff size else addsize 0 backbytes while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backbytes 3 if backbytes 0 backsize goback do if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob backsize while backsize backbytes 0xffffffff addsize 1 backbytes int check2 backbytes int check1 oldback backbytes else backsize backbytes 1 backbytes oldback if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if backsize backsize while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backsize 2 backsize addsize size backsize if CLIISCONTAINED buf bufsz ddst backsize CLIISCONTAINED buf bufsz ddst backbytes backsize free usects return 1 while backsize ddst ddst backbytes ddst backbytes 0 backsize 0 if j int strippetite 0 uint32 t reloc if usects j 1 rsz grown CLIISCONTAINED buf bufsz ddst grown 5 0x4f 8 cli readint32 ddst grown 5 0x4f 0x645ec033 cli readint32 ddst grown 5 0x4f 4 0x1b8b188b reloc 0 strippetite 1 if strippetite usects j 1 rsz grown skew CLIISCONTAINED buf bufsz ddst grown 5 0x4f skew 8 cli readint32 ddst grown 5 0x4f skew 0x645ec033 cli readint32 ddst grown 5 0x4f 4 skew 0x1b8b188b reloc skew strippetite 1 if strippetite CLIISCONTAINED buf bufsz ddst grown 0x0f 8 reloc 8 uint32 t test1 test2 test1 cli readint32 ddst grown 0x0f 8 reloc 0x9d6661aa test2 cli readint32 ddst grown 0x0f 4 reloc 0xe908c483 cli dbgmsg Petite Found petite code in sect d x Let s strip it n j 1 usects j 1 rva if test1 test2 CLIISCONTAINED buf bufsz ddst grown 0x0f reloc 0x1c0 0x0f 4 irva cli readint32 ddst grown 0x121 reloc enc ep cli readint32 ddst grown 0x0f reloc test1 mangled uint32 t cli readint32 ddst grown 0x1c0 reloc 0x90909090 cli dbgmsg Petite Encrypted EP x Array of imports x n enc ep irva usects j 1 rsz grown reloc check4resources static void main get appheader xd3 stream stream main file ifile main file output main file sfile uint8 t apphead usize t appheadsz int ret if option use appheader return ret xd3 get appheader stream apphead appheadsz if ret 0 return if appheadsz 0 char start char apphead char slash int place 0 char parsed 4 memset parsed 0 sizeof parsed while slash strchr start NULL slash 0 parsed place start start slash 1 parsed place start if place 2 place 4 main get appheader params output parsed 1 output ifile if place 4 main get appheader params sfile parsed 2 0 source ifile option use appheader 0 return static void apply loop filter Vp3 Decode Context s int plane int ystart int yend int x y int bounding values s bounding values array 127 int width s fragment width plane int height s fragment height plane int fragment s fragment start plane ystart width int stride s current frame linesize plane uint8 t plane data s current frame data plane if s flipped image stride stride plane data s data offset plane 8 ystart stride for y ystart y yend y for x 0 x width x if s all fragments fragment coding method MODECOPY if x 0 s vp3dsp h loop filter plane data 8 x stride bounding values if y 0 s vp3dsp v loop filter plane data 8 x stride bounding values if x width 1 s all fragments fragment 1 coding method MODECOPY s vp3dsp h loop filter plane data 8 x 8 stride bounding values if y height 1 s all fragments fragment width coding method MODECOPY s vp3dsp v loop filter plane data 8 x 8 stride stride bounding values fragment plane data 8 stride static gboolean logcat read packet struct logcat phdr logcat FILET fh struct wtap pkthdr phdr Buffer buf int err gchar err info gint bytes read gint packet size guint16 payload length guint tmp 2 guint8 pd bytes read file read tmp 2 fh if bytes read 2 err file error fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return FALSE payload length pletoh16 tmp if logcat version 1 packet size 5 4 payload length else if logcat version 2 packet size 6 4 payload length else return FALSE buffer assure space buf packet size pd buffer start ptr buf memcpy pd tmp 2 bytes read file read pd 2 packet size 2 fh if bytes read packet size 2 err file error fh err info if err 0 err WTAPERRSHORTREAD return FALSE phdr rec type RECTYPEPACKET phdr presence flags WTAPHASTS phdr ts secs time t pletoh32 pd 12 phdr ts nsecs int pletoh32 pd 16 phdr caplen packet size phdr len packet size phdr pseudo header logcat version logcat version return static vpx codec err t encoder init vpx codec ctx t ctx vpx codec priv enc mr cfg t data vpx codec err t res VPXCODECOK void data if ctx priv NULL vpx codec alg priv t const priv vpx calloc 1 sizeof priv if priv NULL return VPXCODECMEMERROR ctx priv vpx codec priv t priv ctx priv init flags ctx init flags ctx priv enc total encoders 1 if ctx config enc priv cfg ctx config enc ctx config enc priv cfg priv extra cfg default extra cfg vp9 initialize enc res validate config priv priv cfg priv extra cfg if res VPXCODECOK set encoder config priv oxcf priv cfg priv extra cfg priv cpi vp9 create compressor priv oxcf if priv cpi NULL res VPXCODECMEMERROR else priv cpi output pkt list priv pkt list head return res static int atrac1 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size A T1 Ctx q avctx priv data int ch ret Get Bit Context gb if buf size 212 avctx channels av log avctx AVLOGERROR Not enough data to decode n return AVERRORINVALIDDATA frame nb samples A T1 SUSAMPLES if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret for ch 0 ch avctx channels ch A T1 SU Ctx su q S Us ch init get bits gb buf 212 ch 212 8 ret at1 parse bsm gb su log2 block count if ret 0 return ret ret at1 unpack dequant gb su q spec if ret 0 return ret ret at1 imdct block su q if ret 0 return ret at1 subband synthesis q su float frame extended data ch got frame ptr 1 return avctx block align static void rv30 loop filter R V34 Dec Context r int row Mpeg Enc Context s r s int mb pos mb x int i j k uint8 t YC int loc lim cur lim left lim 0 top lim 0 mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos int mbtype s current picture ptr f mb type mb pos if ISINTRA mbtype ISSEPARATEDC mbtype r deblock coefs mb pos 0x FFFF if ISINTRA mbtype r cbp chroma mb pos 0x FF mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if mb x left lim rv30 loop filt lim s current picture ptr f qscale table mb pos 1 for j 0 j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize 4 mb x for i mb x i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if i r deblock coefs mb pos 1 1 ij 3 loc lim left lim else if i r deblock coefs mb pos 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter Y 1 s linesize loc lim for k 0 k 2 k int cur cbp left cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if mb x left cbp r cbp chroma mb pos 1 k 4 0x F for j 0 j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize 4 mb x for i mb x i 2 i C 4 int ij i j 1 loc lim 0 if cur cbp 1 ij loc lim cur lim else if i left cbp 1 ij 1 loc lim left lim else if i cur cbp 1 ij 1 loc lim cur lim if loc lim rv30 weak loop filter C 1 s uvlinesize loc lim mb pos row s mb stride for mb x 0 mb x s mb width mb x mb pos cur lim rv30 loop filt lim s current picture ptr f qscale table mb pos if row top lim rv30 loop filt lim s current picture ptr f qscale table mb pos s mb stride for j 4 row j 16 j 4 Y s current picture ptr f data 0 mb x 16 row 16 j s linesize for i 0 i 4 i Y 4 int ij i j loc lim 0 if r deblock coefs mb pos 1 ij loc lim cur lim else if j r deblock coefs mb pos s mb stride 1 ij 12 loc lim top lim else if j r deblock coefs mb pos 1 ij 4 loc lim cur lim if loc lim rv30 weak loop filter Y s linesize 1 loc lim for k 0 k 2 k int cur cbp top cbp 0 cur cbp r cbp chroma mb pos k 4 0x F if row top cbp r cbp chroma mb pos s mb stride k 4 0x F for j 4 row j 8 j 4 C s current picture ptr f data k 1 mb x 8 row 8 j s uvlinesize for i 0 i 2 i C 4 int ij i j 1 loc lim 0 if r cbp chroma mb pos 1 ij loc lim cur lim else if j top cbp 1 ij 2 loc lim top lim else if j cur cbp 1 ij 2 loc lim cur lim if loc lim rv30 weak loop filter C s uvlinesize 1 loc lim void vp9 first pass V P9 COMP cpi const struct lookahead entry source int mb row mb col MACROBLOCK const x cpi mb V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd Tile Info tile struct macroblock plane const p x plane struct macroblockd plane const pd xd plane const PICKMODECONTEXT ctx cpi pc root none int i int recon yoffset recon uvoffset Y V12 BUFFERCONFIG const lst yv12 get ref frame buffer cpi LASTFRAMEY V12 BUFFERCONFIG gld yv12 get ref frame buffer cpi GOLDENFRAMEY V12 BUFFERCONFIG const new yv12 get frame new buffer cm int recon y stride lst yv12 y stride int recon uv stride lst yv12 uv stride int uv mb height 16 lst yv12 y height lst yv12 uv height int64 t intra error 0 int64 t coded error 0 int64 t sr coded error 0 int sum mvr 0 sum mvc 0 int sum mvr abs 0 sum mvc abs 0 int64 t sum mvrs 0 sum mvcs 0 int mvcount 0 int intercount 0 int second ref count 0 int intrapenalty 256 int neutral count 0 int new mv count 0 int sum in vectors 0 MV lastmv 0 0 TWOPASS twopass cpi twopass const MV zero mv 0 0 const Y V12 BUFFERCONFIG first ref buf lst yv12 LAYERCONTEXT const lc is two pass svc cpi cpi svc layer context cpi svc spatial layer id NULL vp9 zero array cpi twopass frame mb stats buf cm M Bs static void setup frame size with refs V P9 COMMON cm struct vp9 read bit buffer rb int width height int found 0 i int has valid ref frame 0 for i 0 i REFSPERFRAME i if vp9 rb read bit rb Y V12 BUFFERCONFIG const buf cm frame refs i buf width buf y crop width height buf y crop height if buf corrupted vpx internal error cm error VPXCODECCORRUPTFRAME Frame reference is corrupt found 1 break if found vp9 read frame size rb width height if width 0 height 0 vpx internal error cm error VPXCODECCORRUPTFRAME Invalid frame size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i has valid ref frame valid ref frame size ref frame buf y crop width ref frame buf y crop height width height if has valid ref frame vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has invalid size for i 0 i REFSPERFRAME i Ref Buffer const ref frame cm frame refs i if valid ref frame img fmt ref frame buf bit depth ref frame buf uv crop width ref frame buf y crop width ref frame buf uv crop height ref frame buf y crop height cm bit depth cm subsampling x cm subsampling y vpx internal error cm error VPXCODECCORRUPTFRAME Referenced frame has incompatible color space resize context buffers cm width height setup display size cm rb if vp9 realloc frame buffer get frame new buffer cm cm width cm height cm subsampling x cm subsampling y if CONFIGV P9 HIGHBITDEPTH cm use highbitdepth endif V P9 DECBORDERINPIXELS cm frame bufs cm new fb idx raw frame buffer cm get fb cb cm cb priv vpx internal error cm error VPXCODECMEMERROR Failed to allocate frame buffer cm frame bufs cm new fb idx buf bit depth unsigned int cm bit depth static int decode element AV Codec Context avctx AV Frame frame int ch index int channels ALAC Context alac avctx priv data int has size bps is compressed decorr shift decorr left weight ret uint32 t output samples int i ch skip bits alac gb 4 skip bits alac gb 12 has size get bits1 alac gb alac extra bits get bits alac gb 2 3 bps alac sample size alac extra bits channels 1 if bps 32 av log avctx AVLOGERROR bps is unsupported d n bps return AVERRORPATCHWELCOME is compressed get bits1 alac gb if has size output samples get bits long alac gb 32 else output samples alac max samples per frame if output samples output samples alac max samples per frame av log avctx AVLOGERROR invalid samples per frame d n output samples return AVERRORINVALIDDATA if alac nb samples frame nb samples output samples if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret else if output samples alac nb samples av log avctx AVLOGERROR sample count mismatch u d n output samples alac nb samples return AVERRORINVALIDDATA alac nb samples output samples if alac sample size 16 for ch 0 ch channels ch alac output samples buffer ch int32 t frame extended data ch index ch if is compressed int16 t lpc coefs 2 32 int lpc order 2 int prediction type 2 int lpc quant 2 int rice history mult 2 decorr shift get bits alac gb 8 decorr left weight get bits alac gb 8 for ch 0 ch channels ch prediction type ch get bits alac gb 4 lpc quant ch get bits alac gb 4 rice history mult ch get bits alac gb 3 lpc order ch get bits alac gb 5 for i lpc order ch 1 i 0 i lpc coefs ch i get sbits alac gb 16 if alac extra bits for i 0 i alac nb samples i for ch 0 ch channels ch alac extra bits buffer ch i get bits alac gb alac extra bits for ch 0 ch channels ch rice decompress alac alac predict error buffer ch alac nb samples bps rice history mult ch alac rice history mult 4 if prediction type ch 15 lpc prediction alac predict error buffer ch alac predict error buffer ch alac nb samples bps NULL 31 0 else if prediction type ch 0 av log avctx AVLOGWARNING unknown prediction type i n prediction type ch lpc prediction alac predict error buffer ch alac output samples buffer ch alac nb samples bps lpc coefs ch lpc order ch lpc quant ch else for i 0 i alac nb samples i for ch 0 ch channels ch alac output samples buffer ch i get sbits long alac gb alac sample size alac extra bits 0 decorr shift 0 decorr left weight 0 if channels 2 decorr left weight decorrelate stereo alac output samples buffer alac nb samples decorr shift decorr left weight if alac extra bits append extra bits alac output samples buffer alac extra bits buffer alac extra bits channels alac nb samples switch alac sample size case 16 for ch 0 ch channels ch int16 t outbuffer int16 t frame extended data ch index ch for i 0 i alac nb samples i outbuffer alac output samples buffer ch i break case 24 for ch 0 ch channels ch for i 0 i alac nb samples i alac output samples buffer ch i 8 break return 0 static int32 t append Keywords To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status char buf ULOCKEYWORDANDVALUESCAPACITY char attr Buf ULOCKEYWORDANDVALUESCAPACITY 0 int32 t attr Buf Length 0 U Enumeration keyword Enum NULL int32 t reslen 0 keyword Enum uloc open Keywords locale ID status if UFAILURE status had Posix uenum close keyword Enum return 0 if keyword Enum NULL had Posix int32 t len const char key Extension List Entry first Ext NULL Extension List Entry ext Attribute List Entry first Attr NULL Attribute List Entry attr char attr Value char ext Buf ULOCKEYWORDANDVALUESCAPACITY char p Ext Buf ext Buf int32 t ext Buf Capacity sizeof ext Buf const char bcp Key nullptr bcp Value nullptr U Error Code tmp Status UZEROERROR int32 t keylen U Bool is Bcp U Ext while TRUE key uenum next keyword Enum NULL status if key NULL break len uloc get Keyword Value locale ID key buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR break tmp Status UZEROERROR continue keylen int32 t uprv strlen key is Bcp U Ext keylen 1 if uprv strcmp key LOCALEATTRIBUTEKEY 0 if len 0 int32 t i 0 while TRUE attr Buf Length 0 for i len i if buf i attr Buf attr Buf Length buf i else i break if attr Buf Length 0 attr Buf attr Buf Length 0 else if i len break attr Attribute List Entry uprv malloc sizeof Attribute List Entry if attr NULL status UMEMORYALLOCATIONERROR break attr Value char uprv malloc attr Buf Length 1 if attr Value NULL status UMEMORYALLOCATIONERROR break uprv strcpy attr Value attr Buf attr attribute attr Value if add Attribute To List first Attr attr uprv free attr uprv free attr Value if strict status UILLEGALARGUMENTERROR break bcp Key LOCALEATTRIBUTEKEY bcp Value NULL else if is Bcp U Ext bcp Key uloc to Unicode Locale Key key if bcp Key NULL if strict status UILLEGALARGUMENTERROR break continue bcp Value uloc to Unicode Locale Type key buf if bcp Value NULL if strict status UILLEGALARGUMENTERROR break continue if bcp Value buf int32 t bcp Value Len uprv strlen bcp Value if bcp Value Len ext Buf Capacity uprv strcpy p Ext Buf bcp Value TC String to Lower Case p Ext Buf bcp Value p Ext Buf p Ext Buf bcp Value Len 1 ext Buf Capacity bcp Value Len 1 else if strict status UILLEGALARGUMENTERROR break continue else if key PRIVATEUSE if is Privateuse Value Subtags buf len if strict status UILLEGALARGUMENTERROR break continue else if is Extension Singleton key keylen is Extension Subtags buf len if strict status UILLEGALARGUMENTERROR break continue bcp Key key if len 1 ext Buf Capacity uprv memcpy p Ext Buf buf len bcp Value p Ext Buf p Ext Buf len p Ext Buf 0 p Ext Buf ext Buf Capacity len 1 else status UILLEGALARGUMENTERROR break ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR break ext key bcp Key ext value bcp Value if add Extension To List first Ext ext TRUE uprv free ext if strict status UILLEGALARGUMENTERROR break if had Posix ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR goto cleanup ext key POSIXKEY ext value POSIXVALUE if add Extension To List first Ext ext TRUE uprv free ext if USUCCESS status first Ext NULL first Attr NULLU Bool start LDML Extension FALSE for ext first Ext ext ext ext next if start LDML Extension uprv strlen ext key 1 if reslen capacity append At reslen SEP reslen if reslen capacity append At reslen LDMLEXT reslen start LDML Extension TRUE if uprv strcmp ext key LOCALEATTRIBUTEKEY 0 for attr first Attr attr attr attr next if reslen capacity append At reslen SEP reslen len int32 t uprv strlen attr attribute if reslen capacity uprv memcpy append At reslen attr attribute uprv min len capacity reslen reslen len else if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext key if reslen capacity uprv memcpy append At reslen ext key uprv min len capacity reslen reslen len if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext value if reslen capacity uprv memcpy append At reslen ext value uprv min len capacity reslen reslen len cleanup ext first Ext while ext NULL Extension List Entry tmp Ext ext next uprv free ext ext tmp Ext attr first Attr while attr NULL Attribute List Entry tmp Attr attr next char p Value char attr attribute uprv free p Value uprv free attr attr tmp Attr uenum close keyword Enum if UFAILURE status return 0 return u terminate Chars append At capacity reslen status void jpc qmfb split colres jpc fix t a int numrows int numcols int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZEJPCQMFBCOLGRPSIZE jpc fix t buf splitbuf jpc fix t srcptr jpc fix t dstptr register jpc fix t srcptr2 register jpc fix t dstptr2 register int n register int i int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr numcols srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr2 dstptr srcptr2 srcptr for i 0 i numcols i dstptr2 srcptr2 dstptr2 srcptr2 dstptr stride srcptr numcols if buf splitbuf jas free buf void vp9 xform quant dc MACROBLOCK x int plane int block BLOCKSIZE plane bsize TXSIZE tx size MACROBLOCKD const xd x e mbd const struct macroblock plane const p x plane plane const struct macroblockd plane const pd xd plane plane int16 t const coeff BLOCKOFFSET p coeff block int16 t const qcoeff BLOCKOFFSET p qcoeff block int16 t const dqcoeff BLOCKOFFSET pd dqcoeff block uint16 t const eob p eobs block const int diff stride 4 num 4x4 blocks wide lookup plane bsize int i j const int16 t src diff txfrm block to raster xy plane bsize tx size block i j src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 vp9 fdct32x32 1 src diff coeff diff stride vp9 quantize dc 32x32 coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 16 X16 vp9 fdct16x16 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 8 X8 vp9 fdct8x8 1 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break case TX 4 X4 x fwd txm4x4 src diff coeff diff stride vp9 quantize dc coeff x skip block p round p quant fp 0 qcoeff dqcoeff pd dequant 0 eob break default assert 0 break static int mpeg4 decode partitioned mb Mpeg Enc Context s int16 t block 6 64 int cbp mb type const int xy s mb x s mb y s mb stride mb type s current picture f mb type xy cbp s cbp table xy s use intra dc vlc s qscale s intra dc threshold if s current picture f qscale table xy s qscale ff set qscale s s current picture f qscale table xy if s pict type AVPICTURETYPEP s pict type AVPICTURETYPES int i for i 0 i 4 i s mv 0 i 0 s current picture f motion val 0 s block index i 0 s mv 0 i 1 s current picture f motion val 0 s block index i 1 s mb intra ISINTRA mb type if ISSKIP mb type for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 if s pict type AVPICTURETYPES s vol sprite usage GMCSPRITE s mcsel 1 s mb skipped 0 else s mcsel 0 s mb skipped 1 else if s mb intra s ac pred ISACPRED s current picture f mb type xy else if s mb intra s mv dir MVDIRFORWARD if IS 8 X8 mb type s mv type MVTYPE 8 X8 else s mv type MVTYPE 16 X16 else s mb intra 1 s ac pred ISACPRED s current picture f mb type xy if ISSKIP mb type int i s dsp clear blocks s block 0 for i 0 i 6 i if mpeg4 decode block s block i i cbp 32 s mb intra s rvlc 0 av log s avctx AVLOGERROR texture corrupted at d d d n s mb x s mb y s mb intra return 1 cbp cbp if s mb num left 0 if mpeg4 is resync s return SLICEEND else return SLICENOEND else if mpeg4 is resync s const int delta s mb x 1 s mb width 2 1 if s cbp table xy delta return SLICEEND return static void pic as field Picture pic const int parity int i for i 0 i 4 i if parity PICTBOTTOMFIELD pic f data i pic f linesize i pic reference parity pic f linesize i 2 pic poc pic field poc parity static vpx codec err t encoder init vpx codec ctx t ctx vpx codec priv enc mr cfg t data vpx codec err t res VPXCODECOK void data if ctx priv NULL vpx codec alg priv t const priv vpx calloc 1 sizeof priv if priv NULL return VPXCODECMEMERROR ctx priv vpx codec priv t priv ctx priv init flags ctx init flags ctx priv enc total encoders 1 if ctx config enc priv cfg ctx config enc ctx config enc priv cfg priv extra cfg default extra cfg vp9 initialize enc res validate config priv priv cfg priv extra cfg if res VPXCODECOK set encoder config priv oxcf priv cfg priv extra cfg priv cpi vp9 create compressor priv oxcf if priv cpi NULL res VPXCODECMEMERROR else priv cpi output pkt list priv pkt list head return res static int tqi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size Tqi Context t avctx priv data Mpeg Enc Context s t s AV Frame frame data int ret s width AVR L16 buf 0 s height AVR L16 buf 2 tqi calculate qtable s buf 4 buf 8 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret av fast padded malloc t bitstream buf t bitstream buf size buf end buf if t bitstream buf return AVERRORENOMEM s dsp bswap buf t bitstream buf const uint32 t buf buf end buf 4 init get bits s gb t bitstream buf 8 buf end buf s last dc 0 s last dc 1 s last dc 2 0 for s mb y 0 s mb y avctx height 15 16 s mb y for s mb x 0 s mb x avctx width 15 16 s mb x if tqi decode mb s t block 0 break tqi idct put t frame t block got frame 1 return buf size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size int buf size avpkt size DPX Context const s avctx priv data AV Frame picture data AV Frame const p s picture uint8 t ptr unsigned int offset int magic num endian int x y ret int w h stride bits per color descriptor elements target packet size source packet size unsigned int rgb Buffer if avpkt size 1634 av log avctx AVLOGERROR Packet too small for DPX header n return AVERRORINVALIDDATA magic num AVR B32 buf buf 4 if magic num AVR L32 SDPX endian 0 else if magic num AVR B32 SDPX endian 1 else av log avctx AVLOGERRORDPX marker not found n return AVERRORINVALIDDATA offset read32 buf endian if avpkt size offset av log avctx AVLOGERROR Invalid data start offset n return AVERRORINVALIDDATA buf avpkt data 0x304 w read32 buf endian h read32 buf endian buf 20 descriptor buf 0 buf 3 avctx bits per raw sample bits per color buf 0 buf 825 avctx sample aspect ratio num read32 buf endian avctx sample aspect ratio den read32 buf endian switch descriptor case 51 elements 4 break case 50 elements 3 break default av log avctx AVLOGERROR Unsupported descriptor d n descriptor return AVERRORINVALIDDATA switch bits per color case 8 if elements 4 avctx pix fmt AVPIXFMTRGBA else avctx pix fmt AVPIXFMTRG B24 source packet size elements target packet size elements break case 10 avctx pix fmt AVPIXFMTRG B48 target packet size 6 source packet size 4 break case 12 case 16 if endian avctx pix fmt AVPIXFMTRG B48 BE else avctx pix fmt AVPIXFMTRG B48 LE target packet size 6 source packet size elements 2 break default av log avctx AVLOGERROR Unsupported color depth d n bits per color return AVERRORINVALIDDATA if s picture data 0 avctx release buffer avctx s picture if ret av image check size w h 0 avctx 0 return ret if w avctx width h avctx height avcodec set dimensions avctx w h if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret buf avpkt data offset ptr p data 0 stride p linesize 0 if source packet size avctx width avctx height buf end buf av log avctx AVLOGERROR Overread buffer Invalid header n return AVERRORINVALIDDATA switch bits per color case 10 for x 0 x avctx height x uint16 t dst uint16 t ptr for y 0 y avctx width y rgb Buffer read32 buf endian dst make 16bit rgb Buffer 16 dst make 16bit rgb Buffer 6 dst make 16bit rgb Buffer 4 ptr stride break case 8 case 12 case 16 if source packet size target packet size for x 0 x avctx height x memcpy ptr buf target packet size avctx width ptr stride buf source packet size avctx width else for x 0 x avctx height x uint8 t dst ptr for y 0 y avctx width y memcpy dst buf target packet size dst target packet size buf source packet size ptr stride break picture s picture got frame 1 return buf size static void dump Create DBP Gconn conn PQ Exp Buffer buf create PQ Exp Buffer char default encoding NULL char default collate NULL char default ctype NULLP Gresult res int i fprintf OPF n Database creation n n n if server version 80400 res execute Query conn SELECT pg encoding to char encoding datcollate datctype FROM pg database WHERE datname template0 else if server version 70100 res execute Query conn SELECT pg encoding to char encoding null text AS datcollate null text AS datctype FROM pg database WHERE datname template0 else res execute Query conn SELECT pg encoding to char encoding null text AS datcollate null text AS datctype FROM pg database WHERE datname template1 if P Qntuples res 0 if P Qgetisnull res 0 0 default encoding pg strdup P Qgetvalue res 0 0 if P Qgetisnull res 0 1 default collate pg strdup P Qgetvalue res 0 1 if P Qgetisnull res 0 2 default ctype pg strdup P Qgetvalue res 0 2 P Qclear res if server version 90600 res execute Query conn SELECT datname coalesce rolname select rolname from pg authid where oid select datdba from pg database where datname template0 pg encoding to char d encoding datcollate datctype datfrozenxid datminmxid datistemplate SELECT pg catalog array agg acl FROMSELECT pg catalog unnest coalesce datacl pg catalog acldefault d datdba AS acl EXCEPTSELECT pg catalog unnest pg catalog acldefault d datdba as foo AS datacl SELECT pg catalog array agg acl FROMSELECT pg catalog unnest pg catalog acldefault d datdba AS acl EXCEPTSELECT pg catalog unnest coalesce datacl pg catalog acldefault d datdba as foo AS rdatacl datconnlimit SELECT spcname FROM pg tablespace t WHERE t oid d dattablespace AS dattablespace FROM pg database d LEFTJOIN pg authid u ON datdba u oid WHERE datallowconn ORDERBY 1 else if server version 90300 res execute Query conn SELECT datname coalesce rolname select rolname from pg authid where oid select datdba from pg database where datname template0 pg encoding to char d encoding datcollate datctype datfrozenxid datminmxid datistemplate datacl as rdatacl datconnlimit SELECT spcname FROM pg tablespace t WHERE t oid d dattablespace AS dattablespace FROM pg database d LEFTJOIN pg authid u ON datdba u oid WHERE datallowconn ORDERBY 1 else if server version 80400 res execute Query conn SELECT datname coalesce rolname select rolname from pg authid where oid select datdba from pg database where datname template0 pg encoding to char d encoding datcollate datctype datfrozenxid 0 AS datminmxid datistemplate datacl as rdatacl datconnlimit SELECT spcname FROM pg tablespace t WHERE t oid d dattablespace AS dattablespace FROM pg database d LEFTJOIN pg authid u ON datdba u oid WHERE datallowconn ORDERBY 1 else if server version 80100 res execute Query conn SELECT datname coalesce rolname select rolname from pg authid where oid select datdba from pg database where datname template0 pg encoding to char d encoding null text AS datcollate null text AS datctype datfrozenxid 0 AS datminmxid datistemplate datacl as rdatacl datconnlimit SELECT spcname FROM pg tablespace t WHERE t oid d dattablespace AS dattablespace FROM pg database d LEFTJOIN pg authid u ON datdba u oid WHERE datallowconn ORDERBY 1 else if server version 80000 res execute Query conn SELECT datname coalesce usename select usename from pg shadow where usesysid select datdba from pg database where datname template0 pg encoding to char d encoding null text AS datcollate null text AS datctype datfrozenxid 0 AS datminmxid datistemplate datacl as rdatacl 1 as datconnlimit SELECT spcname FROM pg tablespace t WHERE t oid d dattablespace AS dattablespace FROM pg database d LEFTJOIN pg shadow u ON datdba usesysid WHERE datallowconn ORDERBY 1 else if server version 70300 res execute Query conn SELECT datname coalesce usename select usename from pg shadow where usesysid select datdba from pg database where datname template0 pg encoding to char d encoding null text AS datcollate null text AS datctype datfrozenxid 0 AS datminmxid datistemplate datacl as rdatacl 1 as datconnlimit pg default AS dattablespace FROM pg database d LEFTJOIN pg shadow u ON datdba usesysid WHERE datallowconn ORDERBY 1 else if server version 70100 res execute Query conn SELECT datname coalesce select usename from pg shadow where usesysid datdba select usename from pg shadow where usesysid select datdba from pg database where datname template0 pg encoding to char d encoding null text AS datcollate null text AS datctype 0 AS datfrozenxid 0 AS datminmxid datistemplate as datacl as rdatacl 1 as datconnlimit pg default AS dattablespace FROM pg database d WHERE datallowconn ORDERBY 1 else res execute Query conn SELECT datname select usename from pg shadow where usesysid datdba pg encoding to char d encoding null text AS datcollate null text AS datctype 0 AS datfrozenxid 0 AS datminmxid f as datistemplate as datacl as rdatacl 1 as datconnlimit pg default AS dattablespace FROM pg database d ORDERBY 1 for i 0 i P Qntuples res i char dbname P Qgetvalue res i 0 char dbowner P Qgetvalue res i 1 char dbencoding P Qgetvalue res i 2 char dbcollate P Qgetvalue res i 3 char dbctype P Qgetvalue res i 4 uint32 dbfrozenxid atooid P Qgetvalue res i 5 uint32 dbminmxid atooid P Qgetvalue res i 6 char dbistemplate P Qgetvalue res i 7 char dbacl P Qgetvalue res i 8 char rdbacl P Qgetvalue res i 9 char dbconnlimit P Qgetvalue res i 10 char dbtablespace P Qgetvalue res i 11 char fdbname fdbname pg strdup fmt Id dbname reset PQ Exp Buffer buf if strcmp dbname template1 0 strcmp dbname postgres 0 append PQ Exp Buffer buf CREATEDATABASE s fdbname append PQ Exp Buffer Str buf WITHTEMPLATE template0 if strlen dbowner 0 append PQ Exp Buffer buf OWNER s fmt Id dbowner if default encoding strcmp dbencoding default encoding 0 append PQ Exp Buffer Str buf ENCODING append String Literal Conn buf dbencoding conn if default collate strcmp dbcollate default collate 0 append PQ Exp Buffer Str buf LCCOLLATE append String Literal Conn buf dbcollate conn if default ctype strcmp dbctype default ctype 0 append PQ Exp Buffer Str buf LCCTYPE append String Literal Conn buf dbctype conn if strcmp dbtablespace pg default 0 no tablespaces append PQ Exp Buffer buf TABLESPACE s fmt Id dbtablespace if strcmp dbistemplate t 0 append PQ Exp Buffer buf ISTEMPLATE true if strcmp dbconnlimit 1 0 append PQ Exp Buffer buf CONNECTIONLIMIT s dbconnlimit append PQ Exp Buffer Str buf n else if strcmp dbtablespace pg default 0 no tablespaces if strcmp dbname postgres 0 append PQ Exp Buffer buf connect template1 n else append PQ Exp Buffer buf connect postgres n append PQ Exp Buffer buf ALTERDATABASE s SETTABLESPACE s n fdbname fmt Id dbtablespace append Psql Meta Connect buf dbname if binary upgrade append PQ Exp Buffer Str buf For binary upgrade set datfrozenxid and datminmxid n append PQ Exp Buffer buf UPDATE pg catalog pg database SET datfrozenxid u datminmxid u WHERE datname dbfrozenxid dbminmxid append String Literal Conn buf dbname conn append PQ Exp Buffer Str buf n if skip acls build ACL Commands fdbname NULLDATABASE dbacl rdbacl dbowner server version buf fprintf stderr s could not parse ACL list s for database s n progname dbacl fdbname P Qfinish conn exit nicely 1 fprintf OPF s buf data if server version 70300 dump Database Config conn dbname free fdbname if default encoding free default encoding if default collate free default collate if default ctype free default ctype P Qclear res destroy PQ Exp Buffer buf fprintf OPF n n void ff clean h263 qscales Mpeg Enc Context s int i int8 t const qscale table s current picture f qscale table ff init qscale tab s for i 1 i s mb num i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 for i s mb num 2 i 0 i if qscale table s mb index2xy i qscale table s mb index2xy i 1 2 qscale table s mb index2xy i qscale table s mb index2xy i 1 2 if s codec id AVCODECID H263 P for i 1 i s mb num i int mb xy s mb index2xy i if qscale table mb xy qscale table s mb index2xy i 1 s mb type mb xy CANDIDATEMBTYPEINTE R4 V s mb type mb xy static void set mode info seg skip MACROBLOCK x TXMODE tx mode int rate int64 t dist BLOCKSIZE bsize MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 mbmi INTERPFILTER filter ref if xd up available filter ref xd mi xd mi stride mbmi interp filter else if xd left available filter ref xd mi 1 mbmi interp filter else filter ref EIGHTTAP mbmi sb type bsize mbmi mode ZEROMV mbmi tx size MIN max txsize lookup bsize tx mode to biggest tx size tx mode mbmi skip 1 mbmi uv mode DCPRED mbmi ref frame 0 LASTFRAME mbmi ref frame 1 NONE mbmi mv 0 as int 0 mbmi interp filter filter ref xd mi 0 bmi 0 as mv 0 as int 0 x skip 1 rate 0 dist 0 static void build inter predictors for planes MACROBLOCKD xd BLOCKSIZE bsize int mi row int mi col int plane from int plane to int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane plane from plane plane to plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 src mi mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static VALUE ossl cipher update int argc VALUE argv VALUE self EVPCIPHERCTX ctx unsigned char in long in len out len VALUE data str rb scan args argc argv 11 data str if RTEST rb attr get self id key set ossl raise e Cipher Error key not set String Value data in unsigned char RSTRINGPTR data if in len RSTRINGLEN data 0 ossl raise rb e Arg Error data must not be empty Get Cipher self ctx out len in len EVPCIPHERCTX block size ctx if out len 0 ossl raise rb e Range Error data too big to make output buffer ld bytes in len if NILP str str rb str new 0 out len else String Value str rb str resize str out len if ossl cipher update long ctx unsigned char RSTRINGPTR str out len in in len ossl raise e Cipher Error NULL assert out len RSTRINGLEN str rb str set len str out len return str static bool cgroupfs mount cgroup void hdata const char root int type size t bufsz strlen root sizeof sys fs cgroup char path NULL char parts NULL char dirname NULL char abs path NULL char abs path2 NULL struct cgfs data cgfs d struct cgroup process info info base info int r saved errno 0 cgfs d hdata if cgfs d return false base info cgfs d info if type LXCAUTOCGROUPFULLNOSPEC type LXCAUTOCGROUPFULLMIXED else if type LXCAUTOCGROUPNOSPEC type LXCAUTOCGROUPMIXED if type LXCAUTOCGROUPRO type LXCAUTOCGROUPFULLMIXEDERROR could not mount cgroups into container invalid type specified internally errno EINVAL return false path calloc 1 bufsz if path return false snprintf path bufsz s sys fs cgroup root r mount cgroup root path tmpfs MSNOSUIDMSNODEVMSNOEXECMSRELATIME size 10240k mode 755 if r 0 SYSERROR could not mount tmpfs to sys fs cgroup in the container return false for info base info info info info next size t subsystem count i struct cgroup mount point mp info designated mount point if mp mp lxc cgroup find mount point info hierarchy info cgroup path true if mp SYSERROR could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem goto out error subsystem count lxc array len void info hierarchy subsystems parts calloc subsystem count 1 sizeof char if parts goto out error for i 0 i subsystem count i if strncmp info hierarchy subsystems i name 5 parts i info hierarchy subsystems i 5 else parts i info hierarchy subsystems i dirname lxc string join const char parts false if dirname goto out error abs path lxc append paths path dirname if abs path goto out error r mkdir p abs path 0755 if r 0 errno EEXISTSYSERROR could not create cgroup subsystem directory sys fs cgroup s dirname goto out error abs path2 lxc append paths abs path info cgroup path if abs path2 goto out error if type LXCAUTOCGROUPFULLRO type LXCAUTOCGROUPFULLRW type LXCAUTOCGROUPFULLMIXED if strcmp mp mount prefix 0 ERROR could not automatically mount cgroup full to sys fs cgroup s host has no mount point for this cgroup filesystem that has access to the root cgroup dirname goto out error r mount mp mount point abs path none MSBIND 0 if r 0 SYSERROR error bind mounting s to s mp mount point abs path goto out error if type LXCAUTOCGROUPFULLRO type LXCAUTOCGROUPFULLMIXED r mount NULL abs path NULLMSREMOUNTMSBINDMSRDONLYNULL if r 0 SYSERROR error re mounting s readonly abs path goto out error if type LXCAUTOCGROUPFULLMIXED r mount abs path2 abs path2 NULLMSBINDNULL if r 0 SYSERROR error bind mounting s onto itself abs path2 goto out error r mount NULL abs path2 NULLMSREMOUNTMSBINDNULL if r 0 SYSERROR error re mounting s readwrite abs path2 goto out error else r mkdir p abs path2 0755 if r 0 errno EEXISTSYSERROR could not create cgroup directory sys fs cgroup s s dirname info cgroup path goto out error if type LXCAUTOCGROUPMIXED type LXCAUTOCGROUPRO r mount abs path abs path NULLMSBINDNULL if r 0 SYSERROR error bind mounting s onto itself abs path goto out error r mount NULL abs path NULLMSREMOUNTMSBINDMSRDONLYNULL if r 0 SYSERROR error re mounting s readonly abs path goto out error free abs path abs path NULL abs path cgroup to absolute path mp info cgroup path NULL if abs path goto out error r mount abs path abs path2 none MSBIND 0 if r 0 SYSERROR error bind mounting s to s abs path abs path2 goto out error if type LXCAUTOCGROUPRO r mount NULL abs path2 NULLMSREMOUNTMSBINDMSRDONLYNULL if r 0 SYSERROR error re mounting s readonly abs path2 goto out error free abs path free abs path2 abs path NULL abs path2 NULL if subsystem count 1 for i 0 i subsystem count i abs path lxc append paths path parts i if abs path goto out error r symlink dirname abs path if r 0 WARN could not create symlink s s in sys fs cgroup of container parts i dirname free abs path abs path NULL free dirname free parts dirname NULL parts NULL free path return true out error saved errno errno free path free dirname free parts free abs path free abs path2 errno saved errno return false static int dtls1 retrieve buffered fragment SSL s int ok pitem item hm fragment frag int al ok 0 do item pqueue peek s d1 buffered messages if item NULL return 0 frag hm fragment item data if frag msg header seq s d1 handshake read seq pqueue pop s d1 buffered messages dtls1 hm fragment free frag pitem free item item NULL frag NULL while item NULL if frag reassembly NULL return 0 if s d1 handshake read seq frag msg header seq unsigned long frag len frag msg header frag len pqueue pop s d1 buffered messages al dtls1 preprocess fragment s frag msg header if al 0 unsigned char p unsigned char s init buf data DTL S1 HMHEADERLENGTH memcpy p frag msg header frag off frag fragment frag msg header frag len dtls1 hm fragment free frag pitem free item if al 0 ok 1 return frag len ssl3 send alert s SS L3 ALFATAL al s init num 0 ok 0 return 1 else return 0 void proto register rtp void static hf register info hf hf rtp version Version rtp version FTUIN T8 BASEDECVALS rtp version vals 0x C0 NULLHFILL hf rtp padding Padding rtp padding FTBOOLEAN 8 NULL 0x20 NULLHFILL hf rtp extension Extension rtp ext FTBOOLEAN 8 NULL 0x10 NULLHFILL hf rtp csrc count Contributing source identifiers count rtp cc FTUIN T8 BASEDECNULL 0x0 FNULLHFILL hf rtp marker Marker rtp marker FTBOOLEAN 8 NULL 0x80 NULLHFILL hf rtp payload type Payload type rtp p type FTUIN T8 BASEDECNULL 0x7 FNULLHFILL hf rtp seq nr Sequence number rtp seq FTUIN T16 BASEDECNULL 0x0 NULLHFILL hf rtp ext seq nr Extended sequence number rtp extseq FTUIN T32 BASEDECNULL 0x0 NULLHFILL hf rtp timestamp Timestamp rtp timestamp FTUIN T32 BASEDECNULL 0x0 NULLHFILL hf rtp ssrc Synchronization Source identifier rtp ssrc FTUIN T32 BASEHEXDECNULL 0x0 NULLHFILL hf rtp prof define Defined by profile rtp ext profile FTUIN T16 BASEHEXDECVALS rtp ext profile vals 0x0 NULLHFILL hf rtp length Extension length rtp ext len FTUIN T16 BASEDECNULL 0x0 NULLHFILL hf rtp csrc items Contributing Source identifiers rtp csrc items FTNONEBASENONENULL 0x0 NULLHFILL hf rtp csrc item CSRC item rtp csrc item FTUIN T32 BASEHEXDECNULL 0x0 NULLHFILL hf rtp hdr exts Header extensions rtp hdr exts FTNONEBASENONENULL 0x0 NULLHFILL hf rtp hdr ed137s E D137 extensions rtp ext ed137s FTNONEBASENONENULL 0x0 NULLHFILL hf rtp hdr ed137 E D137 extension rtp ext ed137 FTNONEBASENONENULL 0x0 NULLHFILL hf rtp hdr ed137 ptt type PTT Type rtp ext ed137 ptt type FTUIN T32 BASEDECVALS rtp ext ed137 ptt type 0x E0000000 NULLHFILL hf rtp hdr ed137 squ SQU rtp ext ed137 squ FTUIN T32 BASEDECVALS rtp ext ed137 squ 0x10000000 NULLHFILL hf rtp hdr ed137 ptt id PTT id rtp ext ed137 ptt id FTUIN T32 BASEDECNULL 0x0 F000000 NULLHFILL hf rtp hdr ed137 sct Simultaneous Call Transmissions rtp ext ed137 sct FTUIN T32 BASEDECNULL 0x00800000 NULLHFILL hf rtp hdr ed137 x X rtp ext ed137 x FTUIN T32 BASEDECNULL 0x00400000 NULLHFILL hf rtp hdr ed137 x nu Not used rtp ext ed137 x nu FTUIN T32 BASEDECNULL 0x003 FFFFENULLHFILL hf rtp hdr ed137 ft type Feature type rtp ext ed137 ft type FTUIN T32 BASEHEXDECVALS rtp ext ed137 ft type 0x003 C0000 NULLHFILL hf rtp hdr ed137 ft len Feature length rtp ext ed137 ft len FTUIN T32 BASEDECNULL 0x0003 C000 NULLHFILL hf rtp hdr ed137 ft value Feature value rtp ext ed137 ft value FTUIN T32 BASEHEXDECNULL 0x00003 FFENULLHFILL hf rtp hdr ed137 vf VF rtp ext ed137 vf FTUIN T32 BASEDECVALS rtp ext ed137 vf 0x00000001 NULLHFILL hf rtp hdr ed137 ft bss qidx BSS Quality Index rtp ext ed137 ft bss qidx FTUIN T32 BASEDECNULL 0x00003 F C0 NULLHFILL hf rtp hdr ed137 ft bss rssi qidx BSS Quality Index rtp ext ed137 ft bss qidx FTUIN T32 BASEDECVALS rtp ext ed137 ft bss rssi qidx 0x00003 F C0 NULLHFILL hf rtp hdr ed137 ft bss qidx ml BSS Quality Index Method rtp ext ed137 ft bss qidx ml FTUIN T32 BASEDECVALS rtp ext ed137 ft bss qidx ml 0x00000038 NULLHFILL hf rtp hdr ed137 ft bss nu Not used rtp ext ed137 ft bss nu FTUIN T32 BASEDECNULL 0x00000006 NULLHFILL hf rtp hdr ed137a E D137 A extension rtp ext ed137 AFTNONEBASENONENULL 0x0 NULLHFILL hf rtp hdr ed137a ptt type PTT Type rtp ext ed137 A ptt type FTUIN T32 BASEDECVALS rtp ext ed137a ptt type 0x E0000000 NULLHFILL hf rtp hdr ed137a squ SQU rtp ext ed137 A squ FTUIN T32 BASEDECVALS rtp ext ed137a squ 0x10000000 NULLHFILL hf rtp hdr ed137a ptt id PTT id rtp ext ed137 A ptt id FTUIN T32 BASEDECNULL 0x0 F C00000 NULLHFILL hf rtp hdr ed137a pm PTT Mute rtp ext ed137 A pm FTUIN T32 BASEDECNULL 0x00200000 NULLHFILL hf rtp hdr ed137a ptts PTT Summation rtp ext ed137 A ptts FTUIN T32 BASEDECNULL 0x00100000 NULLHFILL hf rtp hdr ed137a sct Simultaneous Call Transmissions rtp ext ed137a sct FTUIN T32 BASEDECNULL 0x00080000 NULLHFILL hf rtp hdr ed137a reserved Reserved rtp ext ed137 A reserved FTUIN T32 BASEHEXDECNULL 0x00060000 NULLHFILL hf rtp hdr ed137a x X rtp ext ed137 A x FTUIN T32 BASEDECNULL 0x00010000 NULLHFILL hf rtp hdr ed137a x nu Not used rtp ext ed137 A x nu FTUIN T32 BASEDECNULL 0x0000 FFFFNULLHFILL hf rtp hdr ed137a ft type Feature type rtp ext ed137 A ft type FTUIN T32 BASEHEXDECVALS rtp ext ed137a ft type 0x0000 F000 NULLHFILL hf rtp hdr ed137a ft len Feature length rtp ext ed137 A ft len FTUIN T32 BASEDECNULL 0x00000 F00 NULLHFILL hf rtp hdr ed137a ft value Feature value rtp ext ed137 A ft value FTUIN T32 BASEHEXDECNULL 0x000000 FFNULLHFILL hf rtp hdr ext Header extension rtp hdr ext FTUIN T32 BASEHEXDECNULL 0x0 NULLHFILL hf rtp data Payload rtp payload FTBYTESBASENONENULL 0x0 NULLHFILL hf rtp padding data Padding data rtp padding data FTBYTESBASENONENULL 0x0 NULLHFILL hf rtp padding count Padding count rtp padding count FTUIN T8 BASEDECNULL 0x0 NULLHFILL hf rtp setup Stream setup rtp setup FTSTRINGBASENONENULL 0x0 Stream setup method and frame number HFILL hf rtp setup frame Setup frame rtp setup frame FTFRAMENUMBASENONENULL 0x0 Frame that set up this stream HFILL hf rtp setup method Setup Method rtp setup method FTSTRINGBASENONENULL 0x0 Method used to set up this stream HFILL hf rtp rfc2198 follow Follow rtp follow FTBOOLEAN 8 TFS tfs set notset 0x80 Next header follows HFILL hf rtp rfc2198 tm off Timestamp offset rtp timestamp offset FTUIN T16 BASEDECNULL 0x FFFCNULLHFILL hf rtp rfc2198 bl len Block length rtp block length FTUIN T16 BASEDECNULL 0x03 FFNULLHFILL hf rtp ext rfc5285 id Identifier rtp ext rfc5285 id FTUIN T8 BASEDECNULL 0x0 RFC 5285 Header Extension Identifier HFILL hf rtp ext rfc5285 length Length rtp ext rfc5285 len FTUIN T8 BASEDECNULL 0x0 RFC 5285 Header Extension length HFILL hf rtp ext rfc5285 appbits Application Bits rtp ext rfc5285 appbits FTUIN T8 BASEDECNULL 0x0 RFC 5285 2 bytes header application bits HFILL hf rtp ext rfc5285 data Extension Data rtp ext rfc5285 data FTBYTESBASENONENULL 0x0 RFC 5285 Extension Data HFILL hf rtp fragments RTP Fragments rtp fragments FTNONEBASENONENULL 0x0 NULLHFILL hf rtp fragment RTP Fragment data rtp fragment FTFRAMENUMBASENONENULL 0x0 NULLHFILL hf rtp fragment overlap Fragment overlap rtp fragment overlap FTBOOLEANBASENONENULL 0x0 Fragment overlaps with other fragments HFILL hf rtp fragment overlap conflict Conflicting data in fragment overlap rtp fragment overlap conflict FTBOOLEANBASENONENULL 0x0 Overlapping fragments contained conflicting data HFILL hf rtp fragment multiple tails Multiple tail fragments found rtp fragment multipletails FTBOOLEANBASENONENULL 0x0 Several tails were found when defragmenting the packet HFILL hf rtp fragment too long fragment Fragment too long rtp fragment toolongfragment FTBOOLEANBASENONENULL 0x0 Fragment contained data past end of packet HFILL hf rtp fragment error Defragmentation error rtp fragment error FTFRAMENUMBASENONENULL 0x0 Defragmentation error due to illegal fragments HFILL hf rtp fragment count Fragment count rtp fragment count FTUIN T32 BASEDECNULL 0x0 NULLHFILL hf rtp reassembled in RTP fragment reassembled in frame rtp reassembled in FTFRAMENUMBASENONENULL 0x0 This RTP packet is reassembled in this frame HFILL hf rtp reassembled length Reassembled RTP length rtp reassembled length FTUIN T32 BASEDECNULL 0x0 The total length of the reassembled payload HFILL hf srtp encrypted payload SRTP Encrypted Payload srtp enc payload FTBYTESBASENONENULL 0x0 NULLHFILL hf srtp mki SRTPMKI srtp mki FTBYTESBASENONENULL 0x0 SRTP Master Key Index HFILL hf srtp auth tag SRTP Auth Tag srtp auth tag FTBYTESBASENONENULL 0x0 SRTP Authentication Tag HFILL static gint ett ett rtp ett csrc list ett hdr ext ett hdr ext rfc5285 ett hdr ext ed137s ett hdr ext ed137 ett hdr ext ed137a ett rtp setup ett rtp rfc2198 ett rtp rfc2198 hdr ett rtp fragment ett rtp fragments module t rtp module proto rtp proto register protocol Real Time Transport Protocol RTP rtp proto register field array proto rtp hf array length hf proto register subtree array ett array length ett new register dissector rtp dissect rtp proto rtp register dissector rtp rfc2198 dissect rtp rfc2198 proto rtp rtp tap register tap rtp rtp pt dissector table register dissector table rtp pt RTP payload type FTUIN T8 BASEDEC rtp dyn pt dissector table register dissector table rtp dyn payload type Dynamic RTP payload type FTSTRINGBASENONE rtp hdr ext dissector table register dissector table rtp hdr ext RTP header extension FTUIN T32 BASEHEX rtp hdr ext rfc5285 dissector table register dissector table rtp ext rfc5285 id RTP Generic header extension RFC 5285 FTUIN T8 BASEDEC register dissector rtp ext ed137 dissect rtp hdr ext ed137 proto rtp register dissector rtp ext ed137a dissect rtp hdr ext ed137a proto rtp rtp module prefs register protocol proto rtp proto reg handoff rtp prefs register bool preference rtp module show setup info Show stream setup information Where available show which protocol and frame caused this RTP stream to be created global rtp show setup info prefs register bool preference rtp module heuristic rtp Try to decode RTP outside of conversations If call control SIP H323 RTSP messages are missing in the trace RTP isn t decoded without this global rtp heur prefs register bool preference rtp module desegment rtp streams Allow subdissector to reassemble RTP streams Whether subdissector can request RTP streams to be reassembled desegment rtp prefs register enum preference rtp module version0 type Treat RTP version 0 packets as If an RTP version 0 packet is encountered it can be treated as an invalid or ZRTP packet a CLASSICSTUN packet or a T 38 packet global rtp version0 type rtp version0 types FALSE prefs register uint preference rtp module rfc2198 payload type Payload Type for RF C2198 Payload Type for RF C2198 Redundant Audio Data 10 rtp rfc2198 pt register init routine rtp fragment init register init routine rtp dyn payloads init int test sqr BIO bp BNCTX ctx BIGNUM a c d e int i BN init a BN init c BN init d BN init e for i 0 i num0 i BN bntest rand a 40 i 10 0 0 a neg rand neg BN sqr c a ctx if bp NULL if results BN print bp a BIO puts bp BN print bp a BIO puts bp BN print bp c BIO puts bp n BN div d e c a ctx BN sub d d a if BN is zero d BN is zero e fprintf stderr Square test failed n return 0 BN free a BN free c BN free d BN free e return 1 static void mspack fmap free void mem free mem static int rv34 decode intra macroblock R V34 Dec Context r int8 t intra types Mpeg Enc Context s r s int cbp dist int mb pos s mb x s mb y s mb stride memset r avail cache 0 sizeof r avail cache fill rectangle r avail cache 6 2 2 4 1 4 dist s mb x s resync mb x s mb y s resync mb y s mb width if s mb x dist r avail cache 5 r avail cache 9 s current picture ptr mb type mb pos 1 if dist s mb width r avail cache 2 r avail cache 3 s current picture ptr mb type mb pos s mb stride if s mb x 1 s mb width dist s mb width 1 r avail cache 4 s current picture ptr mb type mb pos s mb stride 1 if s mb x dist s mb width r avail cache 1 s current picture ptr mb type mb pos s mb stride 1 s qscale r si quant cbp rv34 decode intra mb header r intra types r cbp luma mb pos cbp r cbp chroma mb pos cbp 16 r deblock coefs mb pos 0x FFFF s current picture ptr qscale table mb pos s qscale if cbp 1 return 1 if r is16 rv34 output i16x16 r intra types cbp return 0 rv34 output intra r intra types cbp return 0 static int escape124 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Escape124 Context s avctx priv data Get Bit Context gb unsigned frame flags frame size unsigned i unsigned superblock index cb index 1 superblock col index 0 superblocks per row avctx width 8 skip 1 uint16 t old frame data new frame data unsigned old stride new stride AV Frame new frame 0 init get bits gb buf buf size 8 if can safely read gb 64 return 1 frame flags get bits long gb 32 frame size get bits long gb 32 if frame flags 0x114 frame flags 0x7800000 av log NULLAVLOGDEBUG Skipping frame n got frame 1 AV Frame data s frame return frame size for i 0 i 3 i if frame flags 1 17 i unsigned cb depth cb size if i 2 cb size get bits long gb 20 cb depth av log2 cb size 1 1 else cb depth get bits gb 4 if i 0 cb size 1 cb depth else cb size s num superblocks cb depth av free s codebooks i blocks s codebooks i unpack codebook gb cb depth cb size if s codebooks i blocks return 1 new frame reference 3 if ff get buffer avctx new frame av log avctx AVLOGERROR get buffer failed n return 1 new frame data uint16 t new frame data 0 new stride new frame linesize 0 2 old frame data uint16 t s frame data 0 old stride s frame linesize 0 2 for superblock index 0 superblock index s num superblocks superblock index Macro Block mb Super Block sb unsigned multi mask 0 if skip 1 skip decode skip count gb if skip copy superblock new frame data new stride old frame data old stride else copy superblock sb pixels 8 old frame data old stride while can safely read gb 1 get bits1 gb unsigned mask mb decode macroblock s gb cb index superblock index mask get bits gb 16 multi mask mask for i 0 i 16 i if mask mask matrix i insert mb into sb sb mb i if can safely read gb 1 get bits1 gb unsigned inv mask get bits gb 4 for i 0 i 4 i if inv mask 1 i multi mask 0x F i 4 else multi mask get bits gb 4 i 4 for i 0 i 16 i if multi mask mask matrix i if can safely read gb 1 break mb decode macroblock s gb cb index superblock index insert mb into sb sb mb i else if frame flags 1 16 while can safely read gb 1 get bits1 gb mb decode macroblock s gb cb index superblock index insert mb into sb sb mb get bits gb 4 copy superblock new frame data new stride sb pixels 8 superblock col index new frame data 8 if old frame data old frame data 8 if superblock col index superblocks per row new frame data new stride 8 superblocks per row 8 if old frame data old frame data old stride 8 superblocks per row 8 superblock col index 0 skip av log NULLAVLOGDEBUG Escape sizes i i i n frame size buf size get bits count gb 8 if s frame data 0 avctx release buffer avctx s frame AV Frame data s frame new frame got frame 1 return frame size static int g723 1 decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt G723 1 Context p avctx priv data AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int dec mode buf 0 3 PPF Param ppf SUBFRAMES int16 t cur lsp LPCORDER int16 t lpc SUBFRAMESLPCORDER int16 t acb vector SUBFRAMELEN int16 t out int bad frame 0 i j ret int16 t audio p audio if buf size frame size dec mode if buf size av log avctx AVLOGWARNING Expected d bytes got d skipping packet n frame size dec mode buf size got frame ptr 0 return buf size if unpack bitstream p buf buf size 0 bad frame 1 if p past frame type ACTIVEFRAME p cur frame type ACTIVEFRAME else p cur frame type UNTRANSMITTEDFRAME frame nb samples FRAMELEN if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret out int16 t frame data 0 if p cur frame type ACTIVEFRAME if bad frame p erased frames 0 else if p erased frames 3 p erased frames inverse quant cur lsp p prev lsp p lsp index bad frame lsp interpolate lpc cur lsp p prev lsp memcpy p prev lsp cur lsp LPCORDER sizeof p prev lsp memcpy p excitation p prev excitation PITCHMAX sizeof p excitation if p erased frames int16 t vector ptr p excitation PITCHMAX p interp gain fixed cb gain p subframe 2 amp index p subframe 3 amp index 1 for i 0 i SUBFRAMES i gen fcb excitation vector ptr p subframe i p cur rate p pitch lag i 1 i gen acb excitation acb vector p excitation SUBFRAMELEN i p pitch lag i 1 p subframe i p cur rate for j 0 j SUBFRAMELEN j int v av clip int16 vector ptr j 1 vector ptr j av clip int16 v acb vector j vector ptr SUBFRAMELEN vector ptr p excitation PITCHMAX p interp index comp interp index p p pitch lag 1 p sid gain p cur gain if p postfilter i PITCHMAX for j 0 j SUBFRAMES i SUBFRAMELEN j comp ppf coeff p i p pitch lag j 1 ppf j p cur rate for i 0 j 0 j SUBFRAMES i SUBFRAMELEN j ff acelp weighted vector sum p audio LPCORDER i vector ptr i vector ptr i ppf j index ppf j sc gain ppf j opt gain 1 14 15 SUBFRAMELEN else audio vector ptr LPCORDER memcpy p prev excitation p excitation FRAMELENPITCHMAX sizeof p excitation else p interp gain p interp gain 3 2 2 if p erased frames 3 memset p excitation 0 FRAMELENPITCHMAX sizeof p excitation memset p prev excitation 0 PITCHMAX sizeof p excitation memset frame data 0 0 FRAMELENLPCORDER sizeof int16 t else int16 t buf p audio LPCORDER residual interp p excitation buf p interp index p interp gain p random seed memcpy p prev excitation buf FRAMELENPITCHMAXPITCHMAX sizeof p excitation p cng random seed CNGRANDOMSEED else if p cur frame type SIDFRAME p sid gain sid gain to lsp index p subframe 0 amp index inverse quant p sid lsp p prev lsp p lsp index 0 else if p past frame type ACTIVEFRAME p sid gain estimate sid gain p if p past frame type ACTIVEFRAME p cur gain p sid gain else p cur gain p cur gain 7 p sid gain 3 generate noise p lsp interpolate lpc p sid lsp p prev lsp memcpy p prev lsp p sid lsp LPCORDER sizeof p prev lsp p past frame type p cur frame type memcpy p audio p synth mem LPCORDER sizeof p audio for i LPCORDER j 0 j SUBFRAMES i SUBFRAMELEN j ff celp lp synthesis filter p audio i lpc j LPCORDER audio i SUBFRAMELENLPCORDER 0 1 1 12 memcpy p synth mem p audio FRAMELENLPCORDER sizeof p audio if p postfilter formant postfilter p lpc p audio out else for i 0 i FRAMELEN i out i av clip int16 p audio LPCORDER i 1 got frame ptr 1 return frame size dec mode static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ansi Context s avctx priv data uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size int ret i count ret avctx reget buffer avctx s frame if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset s frame data 0 0 avctx height FFABS s frame linesize 0 memset s frame data 1 0 AVPALETTESIZE s frame pict type AVPICTURETYPEI s frame palette has changed 1 memcpy s frame data 1 ff cga palette 16 4 while buf buf end switch s state case STATENORMAL switch buf 0 case 0x00 case 0x07 case 0x1 A break case 0x08 s x FFMAX s x 1 0 break case 0x09 i s x FONTWIDTH count i 8 7 i for i 0 i count i draw char avctx break case 0x0 A hscroll avctx case 0x0 D s x 0 break case 0x0 C erase screen avctx break case 0x1 B s state STATEESCAPE break default draw char avctx buf 0 break case STATEESCAPE if buf 0 s state STATECODE s nb args 0 s args 0 0 else s state STATENORMAL draw char avctx 0x1 B continue break case STATECODE switch buf 0 case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 case 8 case 9 if s nb args MAXNBARGS s args s nb args s args s nb args 10 buf 0 0 break case s nb args if s nb args MAXNBARGS s args s nb args 0 break case M s state STATEMUSICPREAMBLE break case case break default if s nb args MAXNBARGS av log avctx AVLOGWARNING args overflow i n s nb args if s nb args MAXNBARGS s args s nb args s nb args if ret execute code avctx buf 0 0 return ret s state STATENORMAL break case STATEMUSICPREAMBLE if buf 0 0x0 E buf 0 0x1 B s state STATENORMAL break buf got frame 1 AV Frame data s frame return buf size static P Gconn connect Database const char dbname const char connection string const char pghost const char pgport const char pguser trivalue prompt password bool fail on error P Gconn conn bool new pass const char remoteversion str int my version static char password NULL const char keywords NULL const char values NULLP Qconninfo Option conn opts NULL if prompt password TRIYES password password simple prompt Password 100 false do int argcount 6 P Qconninfo Option conn opt char err msg NULL int i 0 if keywords free keywords if values free values if conn opts P Qconninfo Free conn opts if connection string conn opts P Qconninfo Parse connection string err msg if conn opts NULL fprintf stderr s s progname err msg exit nicely 1 for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 strcmp conn opt keyword dbname 0 argcount keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values for conn opt conn opts conn opt keyword NULL conn opt if conn opt val NULL conn opt val 0 0 strcmp conn opt keyword dbname 0 keywords i conn opt keyword values i conn opt val i else keywords pg malloc0 argcount 1 sizeof keywords values pg malloc0 argcount 1 sizeof values if pghost keywords i host values i pghost i if pgport keywords i port values i pgport i if pguser keywords i user values i pguser i if password keywords i password values i password i if dbname keywords i dbname values i dbname i keywords i fallback application name values i progname i new pass false conn P Qconnectdb Params keywords values true if conn fprintf stderr s could not connect to database s n progname dbname exit nicely 1 if P Qstatus conn CONNECTIONBADP Qconnection Needs Password conn password NULL prompt password TRINOP Qfinish conn password simple prompt Password 100 false new pass true while new pass if P Qstatus conn CONNECTIONBAD if fail on error fprintf stderr s could not connect to database s s n progname dbname P Qerror Message conn exit nicely 1 else P Qfinish conn free keywords free values P Qconninfo Free conn opts return NULL connstr construct Conn Str keywords values free keywords free values P Qconninfo Free conn opts remoteversion str P Qparameter Status conn server version if remoteversion str fprintf stderr s could not get server version n progname exit nicely 1 server version P Qserver Version conn if server version 0 fprintf stderr s could not parse server version s n progname remoteversion str exit nicely 1 my version PGVERSIONNUM if my version server version server version 70000 server version 100 my version 100 fprintf stderr server version s s version s n remoteversion str progname PGVERSION fprintf stderr aborting because of server version mismatch n exit nicely 1 if server version 70300 execute Command conn SET search path pg catalog return conn static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Camtasia Context const c avctx priv data const unsigned char encoded buf int zret int ret len buf size if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN c zstream next in encoded c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZFINISH if zret ZOK zret ZSTREAMEND zret ZDATAERROR av log avctx AVLOGERROR Inflate error d n zret return AVERRORUNKNOWN if zret ZDATAERROR bytestream2 init c gb c decomp buf c decomp size c zstream avail out ff msrle decode avctx AV Picture c pic c bpp c gb if c avctx pix fmt AVPIXFMTPA L8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static void await reference row Vp3 Decode Context s Vp3 Fragment fragment int motion y int y AV Frame ref frame int ref row int border motion y 1 if fragment coding method MODEUSINGGOLDEN fragment coding method MODEGOLDENMV ref frame s golden frame else ref frame s last frame ref row y motion y 1 ref row FFMAXFFABS ref row ref row 8 border ff thread await progress ref frame ref row 0 static void rv34 pred mv b R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mb pos s mb x s mb y s mb stride int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 0 C 2 0 int has A 0 has B 0 has C 0 int mx my int i j Picture cur pic s current picture ptr const int mask dir MBTYPE L1 MBTYPE L0 int type cur pic mb type mb pos if r avail cache 6 1 type mask A 0 cur pic motion val dir mv pos 1 0 A 1 cur pic motion val dir mv pos 1 1 has A 1 if r avail cache 6 4 type mask B 0 cur pic motion val dir mv pos s b8 stride 0 B 1 cur pic motion val dir mv pos s b8 stride 1 has B 1 if r avail cache 6 4 r avail cache 6 2 type mask C 0 cur pic motion val dir mv pos s b8 stride 2 0 C 1 cur pic motion val dir mv pos s b8 stride 2 1 has C 1 else if s mb x 1 s mb width r avail cache 6 5 type mask C 0 cur pic motion val dir mv pos s b8 stride 1 0 C 1 cur pic motion val dir mv pos s b8 stride 1 1 has C 1 rv34 pred b vector ABC has A has B has C mx my mx r dmv dir 0 my r dmv dir 1 for j 0 j 2 j for i 0 i 2 i cur pic motion val dir mv pos i j s b8 stride 0 mx cur pic motion val dir mv pos i j s b8 stride 1 my if block type R V34 MBBBACKWARD block type R V34 MBBFORWARDZER O8x2 cur pic motion val dir mv pos s b8 stride static void handle raw ping struct query q int dns fd int userid if check authenticated user and ip userid q 0 return if users userid authenticated raw return users userid last pkt time NULL memcpy users userid q q sizeof struct query if debug 1 fprintf stderr IN ping raw from user d n userid send raw dns fd NULL 0 userid RAWHDRCMDPING q static int test save copy const char origname return test copy to origname static void slurm rpc allocate resources slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESS slurm msg t response msg DEFTIMERS job desc msg t job desc msg job desc msg t msg data resource allocation response msg t alloc msg slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info int immediate job desc msg immediate bool do unlock false bool reject job false struct job record job ptr NULL uint16 t port slurm addr t resp addr char err msg NULL job submit user msg NULLSTARTTIMER if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if uid job desc msg user id validate slurm user uid error code ESLURMUSERIDMISSING error Security violation RESOURCEALLOCATE from uid d uid debug2 sched Processing RPCREQUESTRESOURCEALLOCATION from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTRESOURCEALLOCATE lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg error code ESLURMRESERVATIONBUSY error attempt to nest ALPS allocation on s d by uid d job desc msg alloc node job desc msg alloc sid uid static int isoent gen joliet identifier struct archive write a struct isoent isoent struct idr idr struct iso9660 iso9660 struct isoent np unsigned char p size t l int r size t ffmax parent len static const struct archive rb tree ops rb ops isoent cmp node joliet isoent cmp key joliet if isoent children cnt 0 return 0 iso9660 a format data if iso9660 opt joliet OPTJOLIETLONGNAME ffmax 206 else ffmax 128 r idr start a idr isoent children cnt int ffmax 6 2 rb ops if r 0 return r parent len 1 for np isoent np parent np np np parent parent len np mb len 1 for np isoent children first np NULL np np chnext unsigned char dot int ext off noff weight size t lt if l np file basename utf16 length ffmax l ffmax p malloc l 1 2 if p NULL archive set error a archive ENOMEM Can t allocate memory return ARCHIVEFATAL memcpy p np file basename utf16 s l p l 0 p l 1 0 np identifier char p lt l dot p l weight 0 while lt 0 if joliet allowed char p 0 p 1 archive be16enc p 0x005 F else if p 0 0 p 1 0x2 E dot p p 2 lt 2 ext off int dot unsigned char np identifier np ext off ext off np ext len int l ext off np id len int l if np file basename utf16 length ffmax if archive strncpy l iso9660 mbs const char np identifier l iso9660 sconv from utf16be 0 errno ENOMEM archive set error a archive errno No memory return ARCHIVEFATAL np mb len int iso9660 mbs length if np mb len int np file basename length weight np mb len else np mb len int np file basename length if parent len 240 np mb len 240 parent len np mb len 240 archive set error a archive ARCHIVEERRNOMISC The regulation of Joliet extensions A length of a full pathname of s is longer than 240 bytes p d b d archive entry pathname np file entry int parent len int np mb len return ARCHIVEFATAL if l ffmax noff ext off 6 else if l ffmax 2 noff ext off 4 else if l ffmax 4 noff ext off 2 else noff ext off idr register idr np weight noff idr resolve idr idr set num beutf16 return int uwsgi php request struct wsgi request wsgi req char real filename PATHMAX 1 char path info NULL size t real filename len 0 struct stat php stat char filename NULL int force empty script name 0 zend file handle file handle if uwsgi parse vars wsgi req return 1 char orig path info wsgi req path info uint16 t orig path info len wsgi req path info len if uphp docroot wsgi req document root uphp docroot else if wsgi req document root len wsgi req document root uwsgi cwd else char sanitized docroot ecalloc 1 PATHMAX 1 if uwsgi expand path wsgi req document root wsgi req document root len sanitized docroot efree sanitized docroot return 1 wsgi req document root sanitized docroot wsgi req document root len strlen wsgi req document root if uphp app while bypass if uwsgi regexp match bypass pattern bypass pattern extra wsgi req uri wsgi req uri len 0 goto oldstyle bypass bypass next if wsgi req path info len 1 wsgi req path info 0 goto appready if uphp app qs size t app qs len strlen uphp app qs size t qs len wsgi req path info len app qs len if wsgi req query string len 0 qs len 1 wsgi req query string len char qs ecalloc 1 qs len 1 memcpy qs uphp app qs app qs len memcpy qs app qs len wsgi req path info wsgi req path info len if wsgi req query string len 0 char ptr qs app qs len wsgi req path info len ptr memcpy ptr 1 wsgi req query string wsgi req query string len wsgi req query string qs wsgi req query string len qs len appready wsgi req path info wsgi req path info len 0 force empty script name 1 goto secure2 if uwsgi php walk wsgi req filename wsgi req document root wsgi req document root len path info free filename if uphp fallback uphp fallback2 if uphp fallback filename uwsgi str uphp fallback else filename uwsgi concat2n wsgi req document root strlen wsgi req document root uphp fallback2 strlen uphp fallback2 wsgi req script name uphp fallback2 wsgi req script name len strlen uphp fallback2 if uphp fallback qs size t fqs len strlen uphp fallback qs size t new qs len orig path info len fqs len 1 wsgi req query string len char new qs ecalloc 1 new qs len 1 memcpy new qs uphp fallback qs fqs len new qs fqs len memcpy new qs fqs len 1 orig path info orig path info len if wsgi req query string len new qs fqs len 1 orig path info len memcpy new qs fqs len 2 orig path info len wsgi req query string wsgi req query string len wsgi req query string new qs wsgi req query string len new qs len else uwsgi 404 wsgi req return 1 if path info wsgi req path info path info wsgi req path info len orig path info len path info orig path info else wsgi req path info wsgi req path info len 0 if realpath filename real filename free filename uwsgi 404 wsgi req return 1 free filename real filename len strlen real filename if uphp allowed docroot struct uwsgi string list usl uphp allowed docroot while usl if uwsgi starts with real filename real filename len usl value usl len goto secure usl usl next uwsgi 403 wsgi req uwsgi log PHP security error s is not under an allowed docroot n real filename return 1 else if uphp docroot if uwsgi starts with real filename real filename len uphp docroot uphp docroot len goto secure uwsgi 403 wsgi req uwsgi log PHP security error s is not under the default docroot n real filename return 1 secure if stat real filename php stat uwsgi 404 wsgi req return UWSGIOK if SISDIR php stat st mode if orig path info len 0 orig path info len 0 orig path info orig path info len 1 wsgi req path info orig path info wsgi req path info len orig path info len uwsgi redirect to slash wsgi req return UWSGIOK struct uwsgi string list upi uphp index real filename real filename len real filename len int found 0 while upi if real filename len upi len 1 PATHMAX memcpy real filename real filename len upi value upi len 1 if access real filename ROK found 1 break upi upi next if found uwsgi 404 wsgi req return UWSGIOK real filename len strlen real filename if uphp allowed ext struct uwsgi string list usl uphp allowed ext while usl if real filename len usl len if uwsgi strncmp real filename real filename len usl len usl len usl value usl len goto secure2 usl usl next uwsgi 403 wsgi req uwsgi log PHP security error s does not end with an allowed extension n real filename return 1 secure2 wsgi req file real filename wsgi req file len strlen wsgi req file if uphp allowed scripts struct uwsgi string list usl uphp allowed scripts while usl if uwsgi strncmp wsgi req file wsgi req file len usl value usl len goto secure3 usl usl next uwsgi 403 wsgi req uwsgi log PHP security error s is not an allowed script n real filename return 1 secure3 if force empty script name wsgi req script name wsgi req script name len 0 else if uphp fallback2 wsgi req script name orig path info if path info wsgi req script name len path info orig path info else wsgi req script name len orig path info len SG request info request method estrndup wsgi req method wsgi req method len SG request info proto num 1001 SG request info query string estrndup wsgi req query string wsgi req query string len SG request info content length wsgi req post cl SG request info content type estrndup wsgi req content type wsgi req content type len SG sapi headers http response code 200 SG request info path translated wsgi req file file handle type ZENDHANDLEFILENAME file handle filename real filename file handle free filename 0 file handle opened path NULL if php request startup TSRMLSCFAILURE uwsgi 500 wsgi req return 1 struct uwsgi string list usl NULL uwsgi foreach usl uphp exec before if zend eval string ex usl value NULL u WSGI php exec before 1 TSRMLSCCFAILURE goto end php execute script file handle TSRMLSCC uwsgi foreach usl uphp exec after if zend eval string ex usl value NULL u WSGI php exec after 1 TSRMLSCCFAILURE goto end end php request shutdown NULL return 0 static int escape124 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Escape124 Context s avctx priv data Get Bit Context gb unsigned frame flags frame size unsigned i unsigned superblock index cb index 1 superblock col index 0 superblocks per row avctx width 8 skip 1 uint16 t old frame data new frame data unsigned old stride new stride AV Frame new frame 0 init get bits gb buf buf size 8 if can safely read gb 64 return 1 frame flags get bits long gb 32 frame size get bits long gb 32 if frame flags 0x114 frame flags 0x7800000 av log NULLAVLOGDEBUG Skipping frame n got frame 1 AV Frame data s frame return frame size for i 0 i 3 i if frame flags 1 17 i unsigned cb depth cb size if i 2 cb size get bits long gb 20 cb depth av log2 cb size 1 1 else cb depth get bits gb 4 if i 0 cb size 1 cb depth else cb size s num superblocks cb depth av free s codebooks i blocks s codebooks i unpack codebook gb cb depth cb size if s codebooks i blocks return 1 new frame reference 3 if ff get buffer avctx new frame av log avctx AVLOGERROR get buffer failed n return 1 new frame data uint16 t new frame data 0 new stride new frame linesize 0 2 old frame data uint16 t s frame data 0 old stride s frame linesize 0 2 for superblock index 0 superblock index s num superblocks superblock index Macro Block mb Super Block sb unsigned multi mask 0 if skip 1 skip decode skip count gb if skip copy superblock new frame data new stride old frame data old stride else copy superblock sb pixels 8 old frame data old stride while can safely read gb 1 get bits1 gb unsigned mask mb decode macroblock s gb cb index superblock index mask get bits gb 16 multi mask mask for i 0 i 16 i if mask mask matrix i insert mb into sb sb mb i if can safely read gb 1 get bits1 gb unsigned inv mask get bits gb 4 for i 0 i 4 i if inv mask 1 i multi mask 0x F i 4 else multi mask get bits gb 4 i 4 for i 0 i 16 i if multi mask mask matrix i if can safely read gb 1 break mb decode macroblock s gb cb index superblock index insert mb into sb sb mb i else if frame flags 1 16 while can safely read gb 1 get bits1 gb mb decode macroblock s gb cb index superblock index insert mb into sb sb mb get bits gb 4 copy superblock new frame data new stride sb pixels 8 superblock col index new frame data 8 if old frame data old frame data 8 if superblock col index superblocks per row new frame data new stride 8 superblocks per row 8 if old frame data old frame data old stride 8 superblocks per row 8 superblock col index 0 skip av log NULLAVLOGDEBUG Escape sizes i i i n frame size buf size get bits count gb 8 if s frame data 0 avctx release buffer avctx s frame AV Frame data s frame new frame got frame 1 return frame size static int dtls1 retrieve buffered fragment SSL s int ok pitem item hm fragment frag int al ok 0 do item pqueue peek s d1 buffered messages if item NULL return 0 frag hm fragment item data if frag msg header seq s d1 handshake read seq pqueue pop s d1 buffered messages dtls1 hm fragment free frag pitem free item item NULL frag NULL while item NULL if frag reassembly NULL return 0 if s d1 handshake read seq frag msg header seq unsigned long frag len frag msg header frag len pqueue pop s d1 buffered messages al dtls1 preprocess fragment s frag msg header if al 0 unsigned char p unsigned char s init buf data DTL S1 HMHEADERLENGTH memcpy p frag msg header frag off frag fragment frag msg header frag len dtls1 hm fragment free frag pitem free item if al 0 ok 1 return frag len ssl3 send alert s SS L3 ALFATAL al s init num 0 ok 0 return 1 else return 0 static inline int svq3 mc dir SV Q3 Context s int size int mode int dir int avg int i j k mx my dx dy x y H264 Context h s h const int part width size 5 4 4 16 size 1 const int part height 16 unsigned size 1 3 const int extra width mode PREDICTMODE 16 6 0 const int h edge pos 6 s h edge pos part width extra width const int v edge pos 6 s v edge pos part height extra width for i 0 i 16 i part height for j 0 j 16 j part width const int b xy 4 h mb x j 2 4 h mb y i 2 h b stride int dxy x 16 h mb x j y 16 h mb y i k j 2 1 i 1 2 j 1 4 i 8 if mode PREDICTMODE pred motion h k part width 2 dir 1 mx my else mx s next pic motion val 0 b xy 0 1 my s next pic motion val 0 b xy 1 1 if dir 0 mx mx h frame num offset h prev frame num offset 1 1 my my h frame num offset h prev frame num offset 1 1 else mx mx h frame num offset h prev frame num offset h prev frame num offset 1 1 my my h frame num offset h prev frame num offset h prev frame num offset 1 1 mx av clip mx extra width 6 x h edge pos 6 x my av clip my extra width 6 y v edge pos 6 y if mode PREDICTMODE dx dy 0 else dy svq3 get se golomb h gb dx svq3 get se golomb h gb if dx INVALIDVLC dy INVALIDVLC av log h avctx AVLOGERROR invalid MV vlc n return 1 if mode THIRDPELMODE int fx fy mx mx 1 1 dx my my 1 1 dy fx unsigned mx 0x3000 3 0x1000 fy unsigned my 0x3000 3 0x1000 dxy mx 3 fx 4 my 3 fy svq3 mc dir part s x y part width part height fx fy dxy 1 dir avg mx mx my my else if mode HALFPELMODE mode PREDICTMODE mx unsigned mx 1 0x3000 3 dx 0x1000 my unsigned my 1 0x3000 3 dy 0x1000 dxy mx 1 2 my 1 svq3 mc dir part s x y part width part height mx 1 my 1 dxy 0 dir avg mx 3 my 3 else mx unsigned mx 3 0x6000 6 dx 0x1000 my unsigned my 3 0x6000 6 dy 0x1000 svq3 mc dir part s x y part width part height mx my 0 0 dir avg mx 6 my 6 if mode PREDICTMODE int32 t mv pack16to32 mx my if part height 8 i 8 AVW N32 A h mv cache dir scan8 k 1 8 mv if part width 8 j 8 AVW N32 A h mv cache dir scan8 k 1 1 8 mv if part width 8 j 8 AVW N32 A h mv cache dir scan8 k 1 mv if part width 4 part height 4 AVW N32 A h mv cache dir scan8 k mv fill rectangle h cur pic motion val dir b xy part width 2 part height 2 h b stride pack16to32 mx my 4 return 0 static int dissect spoolss keybuffer tvbuff t tvb int offset packet info pinfo proto tree tree dcerpc info di guint8 drep guint32 size int end offset if di conformant run return offset offset dissect ndr uint32 tvb offset pinfo tree di drep hf keybuffer size size end offset offset size 2 if end offset offset end offset tvb reported length remaining tvb offset 1 while offset 0 offset end offset offset dissect spoolss uint16uni tvb offset pinfo tree drep NULL hf keybuffer return offset static void handle raw data char packet int len struct query q int dns fd int tun fd int userid if check authenticated user and ip userid q 0 return if users userid authenticated raw return users userid last pkt time NULL memcpy users userid q q sizeof struct query users userid inpacket offset 0 memcpy users userid inpacket data packet len users userid inpacket len len if debug 1 fprintf stderr IN pkt raw total d from user d n users userid inpacket len userid handle full packet tun fd dns fd userid int ff h264 decode mb cabac H264 Context h int mb xy int mb type partition count cbp 0 int dct8x8 allowed h pps transform 8x8 mode int decode chroma h sps chroma format idc 1 h sps chroma format idc 2 const int pixel shift h pixel shift mb xy h mb xy h mb x h mb y h mb stride tprintf h avctx pic d mb d d n h frame num h mb x h mb y if h slice type nos AVPICTURETYPEI int skip if FRAMEMBAFF h mb y 1 1 h prev mb skipped skip h next mb skipped else skip decode cabac mb skip h h mb x h mb y if skip if FRAMEMBAFF h mb y 1 0 h cur pic mb type mb xy MBTYPESKIP h next mb skipped decode cabac mb skip h h mb x h mb y 1 if h next mb skipped h mb mbaff h mb field decoding flag decode cabac field decoding flag h decode mb skip h h cbp table mb xy 0 h chroma pred mode table mb xy 0 h last qscale diff 0 return 0 if FRAMEMBAFF if h mb y 1 0 h mb mbaff h mb field decoding flag decode cabac field decoding flag h h prev mb skipped 0 fill decode neighbors h MBFIELD if h slice type nos AVPICTURETYPEB int ctx 0 assert h slice type nos AVPICTURETYPEB if ISDIRECT h left type LTOP 1 ctx if ISDIRECT h top type 1 ctx if get cabac noinline h cabac h cabac state 27 ctx mb type 0 else if get cabac noinline h cabac h cabac state 27 3 mb type 1 get cabac noinline h cabac h cabac state 27 5 else int bits bits get cabac noinline h cabac h cabac state 27 4 3 bits get cabac noinline h cabac h cabac state 27 5 2 bits get cabac noinline h cabac h cabac state 27 5 1 bits get cabac noinline h cabac h cabac state 27 5 if bits 8 mb type bits 3 else if bits 13 mb type decode cabac intra mb type h 32 0 goto decode intra mb else if bits 14 mb type 11 else if bits 15 mb type 22 else bits bits 1 get cabac noinline h cabac h cabac state 27 5 mb type bits 4 partition count b mb type info mb type partition count mb type b mb type info mb type type else if h slice type nos AVPICTURETYPEP if get cabac noinline h cabac h cabac state 14 0 if get cabac noinline h cabac h cabac state 15 0 mb type 3 get cabac noinline h cabac h cabac state 16 else mb type 2 get cabac noinline h cabac h cabac state 17 partition count p mb type info mb type partition count mb type p mb type info mb type type else mb type decode cabac intra mb type h 17 0 goto decode intra mb else mb type decode cabac intra mb type h 3 1 if h slice type AVPICTURETYPESI mb type mb type assert h slice type nos AVPICTURETYPEI decode intra mb partition count 0 cbp i mb type info mb type cbp h intra16x16 pred mode i mb type info mb type pred mode mb type i mb type info mb type type if MBFIELD mb type MBTYPEINTERLACED h slice table mb xy h slice num if ISINTRAPCM mb type const int mb size ff h264 mb sizes h sps chroma format idc h sps bit depth luma 3 const uint8 t ptr ptr h cabac bytestream if h cabac low 0x1 ptr if CABACBITS 16 if h cabac low 0x1 FF ptr if int h cabac bytestream end ptr mb size return 1 h intra pcm ptr ptr ptr mb size ff init cabac decoder h cabac ptr h cabac bytestream end ptr h cbp table mb xy 0xf7ef h chroma pred mode table mb xy 0 h cur pic qscale table mb xy 0 memset h non zero count mb xy 16 48 h cur pic mb type mb xy mb type h last qscale diff 0 return 0 fill decode caches h mb type if ISINTRA mb type int i pred mode if ISINTR A4x4 mb type if dct8x8 allowed get cabac noinline h cabac h cabac state 399 h neighbor transform size mb type MBTYPE 8x8 DCT for i 0 i 16 i 4 int pred pred intra mode h i int mode decode cabac mb intra4x4 pred mode h pred fill rectangle h intra4x4 pred mode cache scan8 i 2 2 8 mode 1 else for i 0 i 16 i int pred pred intra mode h i h intra4x4 pred mode cache scan8 i decode cabac mb intra4x4 pred mode h pred av dlog h avctx i4x4 pred d mode d n pred h intra4x4 pred mode cache scan8 i write back intra pred mode h if ff h264 check intra4x4 pred mode h 0 return 1 else h intra16x16 pred mode ff h264 check intra pred mode h h intra16x16 pred mode 0 if h intra16x16 pred mode 0 return 1 if decode chroma h chroma pred mode table mb xy pred mode decode cabac mb chroma pre mode h pred mode ff h264 check intra pred mode h pred mode 1 if pred mode 0 return 1 h chroma pred mode pred mode else h chroma pred mode DC 128 PRE D8x8 else if partition count 4 int i j sub partition count 4 list ref 2 4 if h slice type nos AVPICTURETYPEB for i 0 i 4 i h sub mb type i decode cabac b mb sub type h sub partition count i b sub mb type info h sub mb type i partition count h sub mb type i b sub mb type info h sub mb type i type if ISDIRECT h sub mb type 0 h sub mb type 1 h sub mb type 2 h sub mb type 3 ff h264 pred direct motion h mb type h ref cache 0 scan8 4 h ref cache 1 scan8 4 h ref cache 0 scan8 12 h ref cache 1 scan8 12 PARTNOTAVAILABLE for i 0 i 4 i fill rectangle h direct cache scan8 4 i 2 2 8 h sub mb type i 1 0x FF 1 else for i 0 i 4 i h sub mb type i decode cabac p mb sub type h sub partition count i p sub mb type info h sub mb type i partition count h sub mb type i p sub mb type info h sub mb type i type for list 0 list h list count list for i 0 i 4 i if ISDIRECT h sub mb type i continue if ISDIR h sub mb type i 0 list int rc h ref count list MBMBAFF if rc 1 ref list i decode cabac mb ref h list 4 i if ref list i unsigned rc av log h avctx AVLOGERROR Reference d d n ref list i rc return 1 else ref list i 0 else ref list i 1 h ref cache list scan8 4 i 1 h ref cache list scan8 4 i 8 h ref cache list scan8 4 i 9 ref list i if dct8x8 allowed dct8x8 allowed get dct8x8 allowed h for list 0 list h list count list for i 0 i 4 i h ref cache list scan8 4 i h ref cache list scan8 4 i 1 if ISDIRECT h sub mb type i fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 continue if ISDIR h sub mb type i 0 list ISDIRECT h sub mb type i const int sub mb type h sub mb type i const int block width sub mb type MBTYPE 16x16 MBTYPE 16x8 2 1 for j 0 j sub partition count i j int mpx mpy int mx my const int index 4 i block width j int16 t mv cache 2 h mv cache list scan8 index uint8 t mvd cache 2 h mvd cache list scan8 index pred motion h index block width list h ref cache list scan8 index mx my DECODECABACMBMVD h list index tprintf h avctx final mv d d n mx my if ISSUB 8 X8 sub mb type mv cache 1 0 mv cache 8 0 mv cache 9 0 mx mv cache 1 1 mv cache 8 1 mv cache 9 1 my mvd cache 1 0 mvd cache 8 0 mvd cache 9 0 mpx mvd cache 1 1 mvd cache 8 1 mvd cache 9 1 mpy else if ISSUB 8 X4 sub mb type mv cache 1 0 mx mv cache 1 1 my mvd cache 1 0 mpx mvd cache 1 1 mpy else if ISSUB 4 X8 sub mb type mv cache 8 0 mx mv cache 8 1 my mvd cache 8 0 mpx mvd cache 8 1 mpy mv cache 0 0 mx mv cache 0 1 my mvd cache 0 0 mpx mvd cache 0 1 mpy else fill rectangle h mv cache list scan8 4 i 2 2 8 0 4 fill rectangle h mvd cache list scan8 4 i 2 2 8 0 2 else if ISDIRECT mb type ff h264 pred direct motion h mb type fill rectangle h mvd cache 0 scan8 0 4 4 8 0 2 fill rectangle h mvd cache 1 scan8 0 4 4 8 0 2 dct8x8 allowed h sps direct 8x8 inference flag else int list i if IS 16 X16 mb type for list 0 list h list count list if ISDIR mb type 0 list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 0 if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 4 4 8 ref 1 for list 0 list h list count list if ISDIR mb type 0 list int mx my mpx mpy pred motion h 0 4 list h ref cache list scan8 0 mx my DECODECABACMBMVD h list 0 tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 4 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 4 4 8 pack16to32 mx my 4 else if IS 16 X8 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 8 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 16 i 4 2 8 ref 1 else fill rectangle h ref cache list scan8 0 16 i 4 2 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 16x8 motion h 8 i list h ref cache list scan8 0 16 i mx my DECODECABACMBMVD h list 8 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 16 i 4 2 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 16 i 4 2 8 0 2 fill rectangle h mv cache list scan8 0 16 i 4 2 8 0 4 else assert IS 8 X16 mb type for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int ref rc h ref count list MBMBAFF if rc 1 ref decode cabac mb ref h list 4 i if ref unsigned rc av log h avctx AVLOGERROR Reference d d n ref rc return 1 else ref 0 fill rectangle h ref cache list scan8 0 2 i 2 4 8 ref 1 else fill rectangle h ref cache list scan8 0 2 i 2 4 8 LISTNOTUSED 0x FF 1 for list 0 list h list count list for i 0 i 2 i if ISDIR mb type i list int mx my mpx mpy pred 8x16 motion h i 4 list h ref cache list scan8 0 2 i mx my DECODECABACMBMVD h list 4 i tprintf h avctx final mv d d n mx my fill rectangle h mvd cache list scan8 0 2 i 2 4 8 pack8to16 mpx mpy 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 pack16to32 mx my 4 else fill rectangle h mvd cache list scan8 0 2 i 2 4 8 0 2 fill rectangle h mv cache list scan8 0 2 i 2 4 8 0 4 if ISINTER mb type h chroma pred mode table mb xy 0 write back motion h mb type if ISINTR A16x16 mb type cbp decode cabac mb cbp luma h if decode chroma cbp decode cabac mb cbp chroma h 4 h cbp table mb xy h cbp cbp if dct8x8 allowed cbp 15 ISINTRA mb type mb type MBTYPE 8x8 DCT get cabac noinline h cabac h cabac state 399 h neighbor transform size if CHROM A444 IS 8x8 DCT mb type int i uint8 t nnz cache h non zero count cache for i 0 i 2 i if h left type LEFT i IS 8x8 DCT h left type LEFT i nnz cache 3 8 1 2 8 i nnz cache 3 8 2 2 8 i nnz cache 3 8 6 2 8 i nnz cache 3 8 7 2 8 i nnz cache 3 8 11 2 8 i nnz cache 3 8 12 2 8 i ISINTRA mb type 64 0 if h top type IS 8x8 DCT h top type uint32 t top empty CABACISINTRA mb type 0 0x40404040 AVW N32 A nnz cache 4 8 0 top empty AVW N32 A nnz cache 4 8 5 top empty AVW N32 A nnz cache 4 8 10 top empty h cur pic mb type mb xy mb type if cbp ISINTR A16x16 mb type const uint8 t scan scan8x8 const uint32 t qmul if ISINTERLACED mb type scan8x8 h qscale h field scan8x8 h field scan8x8 q0 scan h qscale h field scan h field scan q0 else scan8x8 h qscale h zigzag scan8x8 h zigzag scan8x8 q0 scan h qscale h zigzag scan h zigzag scan q0 if get cabac noinline h cabac h cabac state 60 h last qscale diff 0 int val 1 int ctx 2 const int max qp 51 6 h sps bit depth luma 8 while get cabac noinline h cabac h cabac state 60 ctx ctx 3 val if val 2 max qp av log h avctx AVLOGERROR cabac decode of qscale diff failed at d d n h mb x h mb y return 1 if val 0x01 val val 1 1 else val val 1 1 h last qscale diff val h qscale val if unsigned h qscale max qp if h qscale 0 h qscale max qp 1 else h qscale max qp 1 h chroma qp 0 get chroma qp h 0 h qscale h chroma qp 1 get chroma qp h 1 h qscale else h last qscale diff 0 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 0 if CHROM A444 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 1 decode cabac luma residual h scan scan8x8 pixel shift mb type cbp 2 else if CHROM A422 if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc 422 h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma422 dc scan 8 if cbp 0x20 int c i i8x8 for c 0 c 2 c int16 t mb h mb 16 16 16 c pixel shift qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i8x8 0 i8x8 2 i8x8 for i 0 i 4 i const int index 16 16 c 8 i8x8 i decode cabac residual nondc h mb 4 index scan 1 qmul 15 mb 16 pixel shift else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else if cbp 0x30 int c for c 0 c 2 c decode cabac residual dc h h mb 256 16 16 c pixel shift 3 CHROMADCBLOCKINDEX c chroma dc scan 4 if cbp 0x20 int c i for c 0 c 2 c qmul h dequant4 coeff c 1 ISINTRA mb type 0 3 h chroma qp c for i 0 i 4 i const int index 16 16 c i decode cabac residual nondc h h mb 16 index pixel shift 4 index scan 1 qmul 15 else fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 else fill rectangle h non zero count cache scan8 0 4 4 8 0 1 fill rectangle h non zero count cache scan8 16 4 4 8 0 1 fill rectangle h non zero count cache scan8 32 4 4 8 0 1 h last qscale diff 0 h cur pic qscale table mb xy h qscale write back non zero count h return 0 void ff mpeg4 pred ac Mpeg Enc Context s int16 t block int n int dir int i int16 t ac val ac val1 int8 t const qscale table s current picture f qscale table ac val s ac val 0 0 s block index n 16 ac val1 ac val if s ac pred if dir 0 const int xy s mb x 1 s mb y s mb stride ac val 16 if s mb x 0 s qscale qscale table xy n 1 n 3 for i 1 i 8 i block s dsp idct permutation i 3 ac val i else for i 1 i 8 i block s dsp idct permutation i 3 ROUNDEDDIV ac val i qscale table xy s qscale else const int xy s mb x s mb y s mb stride s mb stride ac val 16 s block wrap n if s mb y 0 s qscale qscale table xy n 2 n 3 for i 1 i 8 i block s dsp idct permutation i ac val i 8 else for i 1 i 8 i block s dsp idct permutation i ROUNDEDDIV ac val i 8 qscale table xy s qscale for i 1 i 8 i ac val1 i block s dsp idct permutation i 3 for i 1 i 8 i ac val1 8 i block s dsp idct permutation i static int mpeg decode frame AV Codec Context avctx void data int got output AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Mpeg1 Context s avctx priv data AV Frame picture data Mpeg Enc Context s2 s mpeg enc ctx av dlog avctx fill buffer n if buf size 0 buf size 4 AVR B32 buf SEQENDCODE if s2 low delay 0 s2 next picture ptr int ret av frame ref picture s2 next picture ptr f if ret 0 return ret s2 next picture ptr NULL got output 1 return buf size if s2 flags CODECFLAGTRUNCATED int next ff mpeg1 find frame end s2 parse context buf buf size NULL if ff combine frame s2 parse context next const uint8 t buf buf size 0 return buf size if s mpeg enc ctx allocated 0 avctx codec tag AVR L32 VC R2 vcr2 init sequence avctx s slice count 0 if avctx extradata s extradata decoded int ret decode chunks avctx picture got output avctx extradata avctx extradata size s extradata decoded 1 if ret 0 avctx err recognition AVEFEXPLODE return ret return decode chunks avctx picture got output buf buf size static int decode frame Wmall Decode Ctx s Get Bit Context gb s gb int more frames 0 len 0 i ret s frame nb samples s samples per frame if ret ff get buffer s avctx s frame 0 0 av log s avctx AVLOGERROR not enough space for the output samples n s packet loss 1 return ret for i 0 i s num channels i s samples 16 i int16 t s frame extended data i s samples 32 i int32 t s frame extended data i if s len prefix len get bits gb s log2 frame size if decode tilehdr s s packet loss 1 return 0 if s dynamic range compression s drc gain get bits gb 8 if get bits1 gb int av unused skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx start skip i n skip if get bits1 gb skip get bits gb av log2 s samples per frame 2 av dlog s avctx end skip i n skip s parsed all subframes 0 for i 0 i s num channels i s channel i decoded samples 0 s channel i cur subframe 0 while s parsed all subframes if decode subframe s 0 s packet loss 1 return 0 av dlog s avctx Frame done n if s skip frame s skip frame 0 if s len prefix if len get bits count gb s frame offset 2 av log s avctx AVLOGERROR frame i would have to skip i bits n s frame num len get bits count gb s frame offset 1 s packet loss 1 return 0 skip bits long gb len get bits count gb s frame offset 1 more frames get bits1 gb s frame num return more frames static int jbig2 decode mmr line Jbig2 Mmr Ctx mmr const byte ref byte dst uint32 t a0 MINU S1 uint32 t a1 a2 b1 b2 int c 0 while 1 uint32 t word mmr word if a0 MINU S1 a0 mmr width break if word 32 3 1 int white run black run jbig2 decode mmr consume mmr 3 if a0 MINU S1 a0 0 if c 0 white run jbig2 decode get run mmr jbig2 mmr white decode 8 black run jbig2 decode get run mmr jbig2 mmr black decode 7 a1 a0 white run a2 a1 black run if a1 mmr width a1 mmr width if a2 mmr width a2 mmr width if a1 MINU S1 a2 a1 return 1 jbig2 set bits dst a1 a2 a0 a2 else black run jbig2 decode get run mmr jbig2 mmr black decode 7 white run jbig2 decode get run mmr jbig2 mmr white decode 8 a1 a0 black run a2 a1 white run if a1 mmr width a1 mmr width if a2 mmr width a2 mmr width if a0 MINU S1 a1 a0 return 1 jbig2 set bits dst a0 a1 a0 a2 else if word 32 4 1 jbig2 decode mmr consume mmr 4 b1 jbig2 find changing element of color ref a0 mmr width c b2 jbig2 find changing element ref b1 mmr width if c if a0 MINU S1 b2 a0 return 1 jbig2 set bits dst a0 b2 a0 b2 else if word 32 1 1 jbig2 decode mmr consume mmr 1 b1 jbig2 find changing element of color ref a0 mmr width c if c if a0 MINU S1 b1 a0 return 1 jbig2 set bits dst a0 b1 a0 b1 c c else if word 32 3 3 jbig2 decode mmr consume mmr 3 b1 jbig2 find changing element of color ref a0 mmr width c if b1 1 mmr width break if c if a0 MINU S1 b1 1 a0 return 1 jbig2 set bits dst a0 b1 1 a0 b1 1 c c else if word 32 6 3 jbig2 decode mmr consume mmr 6 b1 jbig2 find changing element of color ref a0 mmr width c if b1 2 mmr width break if c if a0 MINU S1 b1 2 a0 return 1 jbig2 set bits dst a0 b1 2 a0 b1 2 c c else if word 32 7 3 jbig2 decode mmr consume mmr 7 b1 jbig2 find changing element of color ref a0 mmr width c if b1 3 int mmr width break if c if a0 MINU S1 b1 3 a0 return 1 jbig2 set bits dst a0 b1 3 a0 b1 3 c c else if word 32 3 2 jbig2 decode mmr consume mmr 3 b1 jbig2 find changing element of color ref a0 mmr width c if b1 1 break if c if a0 MINU S1 b1 1 a0 return 1 jbig2 set bits dst a0 b1 1 a0 b1 1 c c else if word 32 6 2 jbig2 decode mmr consume mmr 6 b1 jbig2 find changing element of color ref a0 mmr width c if b1 2 break if c if b1 2 a0 a0 0 return 1 jbig2 set bits dst a0 b1 2 a0 b1 2 c c else if word 32 7 2 jbig2 decode mmr consume mmr 7 b1 jbig2 find changing element of color ref a0 mmr width c if b1 3 break if c if a0 MINU S1 b1 3 a0 return 1 jbig2 set bits dst a0 b1 3 a0 b1 3 c c else break return 0 int crypto authenticate and decrypt struct crypto instance instance unsigned char buf int buf len struct crypto config header cch struct crypto config header buf const char guessed str if buf len sizeof struct crypto config header log printf instance log level security Received message is too short ignoring return 1 if cch crypto cipher type CRYPTOCIPHERTYPE 2 3 guessed str NULL if cch crypto cipher type 0x C0 cch crypto hash type 0x70 cch crypto cipher type 0x70 cch crypto hash type 0x C0 guessed str Corosync 3 x else if cch crypto cipher type CRYPTOCIPHERTYPE 2 2 guessed str Corosync 2 2 else if cch crypto cipher type 0x01 guessed str unencrypted Kronosnet else if cch crypto cipher type 0 cch crypto cipher type 5 guessed str unencrypted Corosync 2 0 2 1 1 x Open AIS else guessed str encrypted Kronosnet Corosync 2 0 2 1 1 x Open AIS or unknown log printf instance log level security Unsupported incoming packet probably sent by s Rejecting guessed str return 1 if cch crypto hash type CRYPTOHASHTYPE 2 3 log printf instance log level security Incoming packet has different hash type Rejecting return 1 if authenticate nss 2 3 instance buf buf len 0 return 1 if cch pad0 0 cch pad1 0 log printf instance log level security Incoming packet appears to have features not supported by this version of corosync Rejecting return 1 if decrypt nss 2 3 instance buf buf len 0 return 1 cch NULL memmove buf buf sizeof struct crypto config header buf len return 0 static double eqjoinsel inner Oid operator Variable Stat Data vardata1 Variable Stat Data vardata2 double selec double nd1 double nd2 bool isdefault1 bool isdefault2 Oid opfuncoid Form pg statistic stats1 NULL Form pg statistic stats2 NULL bool have mcvs1 false Datum values1 NULL int nvalues1 0 float4 numbers1 NULL int nnumbers1 0 bool have mcvs2 false Datum values2 NULL int nvalues2 0 float4 numbers2 NULL int nnumbers2 0 nd1 get variable numdistinct vardata1 isdefault1 nd2 get variable numdistinct vardata2 isdefault2 opfuncoid get opcode operator if Heap Tuple Is Valid vardata1 stats Tuple stats1 Form pg statistic GETSTRUCT vardata1 stats Tuple if statistic proc security check vardata1 opfuncoid have mcvs1 get attstatsslot vardata1 stats Tuple vardata1 atttype vardata1 atttypmod STATISTICKINDMCV Invalid Oid NULL values1 nvalues1 numbers1 nnumbers1 if Heap Tuple Is Valid vardata2 stats Tuple stats2 Form pg statistic GETSTRUCT vardata2 stats Tuple if statistic proc security check vardata2 opfuncoid have mcvs2 get attstatsslot vardata2 stats Tuple vardata2 atttype vardata2 atttypmod STATISTICKINDMCV Invalid Oid NULL values2 nvalues2 numbers2 nnumbers2 if have mcvs1 have mcvs2 Fmgr Info eqproc bool hasmatch1 bool hasmatch2 double nullfrac1 stats1 stanullfrac double nullfrac2 stats2 stanullfrac double matchprodfreq matchfreq1 matchfreq2 unmatchfreq1 unmatchfreq2 otherfreq1 otherfreq2 totalsel1 totalsel2 int i nmatches fmgr info opfuncoid eqproc hasmatch1 bool palloc0 nvalues1 sizeof bool hasmatch2 bool palloc0 nvalues2 sizeof bool matchprodfreq 0 0 nmatches 0 for i 0 i nvalues1 i int j for j 0 j nvalues2 j if hasmatch2 j continue if Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values1 i values2 j hasmatch1 i hasmatch2 j true matchprodfreq numbers1 i numbers2 j nmatches break CLAMPPROBABILITY matchprodfreq matchfreq1 unmatchfreq1 0 0 for i 0 i nvalues1 i if hasmatch1 i matchfreq1 numbers1 i else unmatchfreq1 numbers1 i CLAMPPROBABILITY matchfreq1 CLAMPPROBABILITY unmatchfreq1 matchfreq2 unmatchfreq2 0 0 for i 0 i nvalues2 i if hasmatch2 i matchfreq2 numbers2 i else unmatchfreq2 numbers2 i CLAMPPROBABILITY matchfreq2 CLAMPPROBABILITY unmatchfreq2 pfree hasmatch1 pfree hasmatch2 otherfreq1 1 0 nullfrac1 matchfreq1 unmatchfreq1 otherfreq2 1 0 nullfrac2 matchfreq2 unmatchfreq2 CLAMPPROBABILITY otherfreq1 CLAMPPROBABILITY otherfreq2 totalsel1 matchprodfreq if nd2 nvalues2 totalsel1 unmatchfreq1 otherfreq2 nd2 nvalues2 if nd2 nmatches totalsel1 otherfreq1 otherfreq2 unmatchfreq2 nd2 nmatches totalsel2 matchprodfreq if nd1 nvalues1 totalsel2 unmatchfreq2 otherfreq1 nd1 nvalues1 if nd1 nmatches totalsel2 otherfreq2 otherfreq1 unmatchfreq1 nd1 nmatches selec totalsel1 totalsel2 totalsel1 totalsel2 else double nullfrac1 stats1 stats1 stanullfrac 0 0 double nullfrac2 stats2 stats2 stanullfrac 0 0 selec 1 0 nullfrac1 1 0 nullfrac2 if nd1 nd2 selec nd1 else selec nd2 if have mcvs1 free attstatsslot vardata1 atttype values1 nvalues1 numbers1 nnumbers1 if have mcvs2 free attstatsslot vardata2 atttype values2 nvalues2 numbers2 nnumbers2 return selec static int sdp parse fmtp config h264 AV Format Context s AV Stream stream Payload Context h264 data const char attr const char value AV Codec Parameters par stream codecpar if strcmp attr packetization mode av log s AVLOGDEBUGRTP Packetization Mode d n atoi value h264 data packetization mode atoi value if h264 data packetization mode 1 av log s AVLOGERROR Interleaved RTP mode is not supported yet n else if strcmp attr profile level id if strlen value 6 parse profile level id s h264 data value else if strcmp attr sprop parameter sets int ret if value strlen value 1 av log s AVLOGWARNING Missing PPS in sprop parameter sets ignoring n return 0 par extradata size 0 av freep par extradata ret ff h264 parse sprop parameter sets s par extradata par extradata size value av log s AVLOGDEBUG Extradata set to p size d n par extradata par extradata size return ret return 0 static int userauth hostbased struct ssh ssh Authctxt authctxt ssh authctxt struct sshbuf b struct sshkey key NULL char pkalg cuser chost u char pkblob sig size t alen blen slen int r pktype authenticated 0 if authctxt valid debug2 s disabled because of invalid user func return 0 if r sshpkt get cstring ssh pkalg alen 0 r sshpkt get string ssh pkblob blen 0 r sshpkt get cstring ssh chost NULL 0 r sshpkt get cstring ssh cuser NULL 0 r sshpkt get string ssh sig slen 0 fatal s packet parsing s func ssh err r debug s cuser s chost s pkalg s slen zu func cuser chost pkalg slen sshbuf dump data sig siglen stderr if pktype KEYUNSPEC logit s unsupported public key algorithm s func pkalg goto done if r sshkey from blob pkblob blen key 0 error s key from blob s func ssh err r goto done if key NULL error s cannot decode key s func pkalg goto done if key type pktype error s type mismatch for decoded key received d expected d func key type pktype goto done if sshkey type plain key type KEYRSA ssh compat SSHBUGRSASIGM D5 0 error Refusing RSA key because peer uses unsafe signature format goto done if match pattern list pkalg options hostbased key types 0 1 logit s key type s not in Hostbased Accepted Key Types func sshkey type key goto done if b sshbuf new NULL fatal s sshbuf new failed func if r sshbuf put string b session id2 session id2 len 0 r sshbuf put u8 b SS H2 MSGUSERAUTHREQUEST 0 r sshbuf put cstring b authctxt user 0 r sshbuf put cstring b authctxt service 0 r sshbuf put cstring b hostbased 0 r sshbuf put string b pkalg alen 0 r sshbuf put string b pkblob blen 0 r sshbuf put cstring b chost 0 r sshbuf put cstring b cuser 0 fatal s buffer error s func ssh err r authenticated 0 if PRIVSEP hostbased key allowed authctxt pw cuser chost key PRIVSEP sshkey verify key sig slen sshbuf ptr b sshbuf len b pkalg ssh compat 0 authenticated 1 auth2 record key authctxt authenticated key sshbuf free b done debug2 s authenticated d func authenticated sshkey free key free pkalg free pkblob free cuser free chost free sig return authenticated int zrestore i ctx t i ctx p os ptr op osp alloc save t asave bool last vm save t vmsave int code restore check operand op asave idmemory if code 0 return code if debug2m u imemory u vmrestore 0x lx id lu n ulong alloc save client data asave ulong op value saveid if IVALIDATEBEFORERESTORE ivalidate clean spaces i ctx p osp int code if code restore check stack i ctx p o stack asave false 0 code restore check stack i ctx p e stack asave true 0 code restore check stack i ctx p d stack asave false 0 osp return code restore fix stack i ctx p o stack asave false restore fix stack i ctx p e stack asave true restore fix stack i ctx p d stack asave false do vmsave alloc save client data alloc save current idmemory gs grestoreall for restore igs vmsave gsave vmsave gsave 0 code alloc restore step in idmemory asave if code 0 return code last code while last uint space icurrent space ialloc set space idmemory avm local ifree object vmsave zrestore ialloc set space idmemory space dict set top if IVALIDATEAFTERRESTORE ivalidate clean spaces i ctx p i ctx p Lock File Permissions false return 0 static void vacuum all databases vacuuming Options vacopts bool analyze in stages const char maintenance db const char host const char port const char username enum trivalue prompt password int concurrent Cons const char progname bool echo bool quiet P Gconn conn P Gresult result int stage int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn if analyze in stages for stage 0 stage ANALYZENUMSTAGES stage for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts stage NULL host port username prompt password concurrent Cons progname echo quiet else for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts ANALYZENOSTAGENULL host port username prompt password concurrent Cons progname echo quiet P Qclear result static void init bit trees init bit tree cat1 1 init bit tree cat2 2 init bit tree cat3 3 init bit tree cat4 4 init bit tree cat5 5 init bit tree cat6 14 init bit tree cat2 high10 2 init bit tree cat3 high10 3 init bit tree cat4 high10 4 init bit tree cat5 high10 5 init bit tree cat6 high10 16 init bit tree cat1 high12 1 init bit tree cat2 high12 2 init bit tree cat3 high12 3 init bit tree cat4 high12 4 init bit tree cat5 high12 5 init bit tree cat6 high12 18 int main int argc const char argv App Input app input 0 Vpx Video Writer writer NULL Vpx Video Info info 0 vpx codec ctx t codec vpx codec enc cfg t enc cfg Svc Context svc ctx uint32 t i uint32 t frame cnt 0 vpx image t raw vpx codec err t res int pts 0 int frame duration 1 FILE infile NULL int end of stream 0 int frames received 0 memset svc ctx 0 sizeof svc ctx svc ctx log print 1 exec name argv 0 parse command line argc argv app input svc ctx enc cfg if vpx img alloc raw VPXIMGFMT I420 enc cfg g w enc cfg g h 32 die Failed to allocate image dx d n enc cfg g w enc cfg g h if infile fopen app input input filename rb die Failed to open s for reading n app input input filename if vpx svc init svc ctx codec vpx codec vp9 cx enc cfg VPXCODECOK die Failed to initialize encoder n info codec fourcc V P9 FOURCC info time base numerator enc cfg g timebase num info time base denominator enc cfg g timebase den if app input passes 2 app input pass 1 writer vpx video writer open app input output filename k Container IVF info if writer die Failed to open s for writing n app input output filename for i 0 i app input frames to skip i vpx img read raw infile while end of stream vpx codec iter t iter NULL const vpx codec cx pkt t cx pkt if frame cnt app input frames to code vpx img read raw infile end of stream 1 res vpx svc encode svc ctx codec end of stream NULL raw pts frame duration VPXDLGOODQUALITY printf s vpx svc get message svc ctx if res VPXCODECOK die codec codec Failed to encode frame while cx pkt vpx codec get cx data codec iter NULL switch cx pkt kind case VPXCODECCXFRAMEPKT if cx pkt data frame sz 0 vpx video writer write frame writer cx pkt data frame buf cx pkt data frame sz cx pkt data frame pts printf SVC frame d kf d size d pts d n frames received cx pkt data frame flags VPXFRAMEISKEY int cx pkt data frame sz int cx pkt data frame pts frames received break case VPXCODECSTATSPKT stats write app input rc stats cx pkt data twopass stats buf cx pkt data twopass stats sz break default break if end of stream frame cnt pts frame duration printf Processed d frames n frame cnt fclose infile if vpx codec destroy codec die codec codec Failed to destroy codec if app input passes 2 stats close app input rc stats 1 if writer vpx video writer close writer vpx img free raw printf s vpx svc dump statistics svc ctx vpx svc release svc ctx return static int s302m decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int block size ret int frame size s302m parse frame header avctx buf buf size if frame size 0 return frame size buf size AE S3 HEADERLEN buf AE S3 HEADERLEN block size avctx bits per coded sample 4 4 frame nb samples 2 buf size block size avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf size frame nb samples avctx channels 2 block size if avctx bits per coded sample 24 uint32 t o uint32 t frame data 0 for buf size 6 buf size 7 o ff reverse buf 2 24 ff reverse buf 1 16 ff reverse buf 0 8 o ff reverse buf 6 0xf0 28 ff reverse buf 5 20 ff reverse buf 4 12 ff reverse buf 3 0x0f 4 buf 7 else if avctx bits per coded sample 20 uint32 t o uint32 t frame data 0 for buf size 5 buf size 6 o ff reverse buf 2 0xf0 28 ff reverse buf 1 20 ff reverse buf 0 12 o ff reverse buf 5 0xf0 28 ff reverse buf 4 20 ff reverse buf 3 12 buf 6 else uint16 t o uint16 t frame data 0 for buf size 4 buf size 5 o ff reverse buf 1 8 ff reverse buf 0 o ff reverse buf 4 0xf0 12 ff reverse buf 3 4 ff reverse buf 2 4 buf 5 got frame ptr 1 return avpkt size static int sunrast decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size AV Frame const p data unsigned int w h depth type maptype maplength stride x y len alen uint8 t ptr const uint8 t bufstart buf int ret if avpkt size 32 return AVERRORINVALIDDATA if AVR B32 buf RASMAGIC av log avctx AVLOGERROR this is not sunras encoded data n return AVERRORINVALIDDATA w AVR B32 buf 4 h AVR B32 buf 8 depth AVR B32 buf 12 type AVR B32 buf 20 maptype AVR B32 buf 24 maplength AVR B32 buf 28 buf 32 if type RTFORMATTIFF type RTFORMATIFF type RTEXPERIMENTAL av log ask for sample avctx unsupported compression type n return AVERRORPATCHWELCOME if type RTFORMATIFF av log avctx AVLOGERROR invalid compression type n return AVERRORINVALIDDATA if av image check size w h 0 avctx av log avctx AVLOGERROR invalid image size n return AVERRORINVALIDDATA if maptype RMTRAW av log ask for sample avctx unsupported colormap type n return AVERRORPATCHWELCOME if maptype RMTRAW av log avctx AVLOGERROR invalid colormap type n return AVERRORINVALIDDATA switch depth case 1 avctx pix fmt AVPIXFMTMONOWHITE break case 8 avctx pix fmt maplength AVPIXFMTPA L8 AVPIXFMTGRA Y8 break case 24 avctx pix fmt type RTFORMATRGBAVPIXFMTRG B24 AVPIXFMTBG R24 break default av log avctx AVLOGERROR invalid depth n return AVERRORINVALIDDATA if w avctx width h avctx height avcodec set dimensions avctx w h if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI if buf end buf maplength return AVERRORINVALIDDATA if depth 8 maplength av log avctx AVLOGWARNING useless colormap found or file is corrupted trying to recover n else if maplength unsigned int len maplength 3 if maplength 3 maplength 768 av log avctx AVLOGWARNING invalid colormap length n return AVERRORINVALIDDATA ptr p data 1 for x 0 x len x ptr 4 uint32 t ptr buf x 16 buf len x 8 buf len len x buf maplength ptr p data 0 stride p linesize 0 len depth w 7 3 alen len len 1 if type RTBYTEENCODED int value run uint8 t end ptr h stride x 0 while ptr end buf buf end run 1 if buf end buf 1 return AVERRORINVALIDDATA if value buf RLETRIGGER run buf 1 if run 1 value buf while run if x len ptr x value if x alen x 0 ptr stride if ptr end break else for y 0 y h y if buf end buf len break memcpy ptr buf len ptr stride buf alen got frame 1 return buf bufstart static void real proto register diameter void module t diameter module expert module t expert diameter guint i ett length hf register info hf base hf diameter version Version diameter version FTUIN T8 BASEHEXNULL 0x00 NULLHFILL hf diameter length Length diameter length FTUIN T24 BASEDECNULL 0x0 NULLHFILL hf diameter flags Flags diameter flags FTUIN T8 BASEHEXNULL 0x0 NULLHFILL hf diameter flags request Request diameter flags request FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSRNULLHFILL hf diameter flags proxyable Proxyable diameter flags proxyable FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSPNULLHFILL hf diameter flags error Error diameter flags error FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSENULLHFILL hf diameter flags TT Potentially re transmitted message diameter flags TFTBOOLEAN 8 TFS tfs set notset DIAMFLAGSTNULLHFILL hf diameter flags reserved4 Reserved diameter flags reserved4 FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSRESERVE D4 NULLHFILL hf diameter flags reserved5 Reserved diameter flags reserved5 FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSRESERVE D5 NULLHFILL hf diameter flags reserved6 Reserved diameter flags reserved6 FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSRESERVE D6 NULLHFILL hf diameter flags reserved7 Reserved diameter flags reserved7 FTBOOLEAN 8 TFS tfs set notset DIAMFLAGSRESERVE D7 NULLHFILL hf diameter vendor id Vendor Id diameter vendor Id FTUIN T32 BASEDECBASEEXTSTRING sminmpec values ext 0x0 NULLHFILL hf diameter application id Application Id diameter application Id FTUIN T32 BASEDECBASEEXTSTRINGVALSEXTPTR dictionary applications 0x0 NULLHFILL hf diameter hopbyhopid Hop by Hop Identifier diameter hopbyhopid FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf diameter endtoendid End to End Identifier diameter endtoendid FTUIN T32 BASEHEXNULL 0x0 NULLHFILL hf diameter avp AVP diameter avp FTBYTESBASENONENULL 0x0 NULLHFILL hf diameter avp len AVP Length diameter avp len FTUIN T24 BASEDECNULL 0x0 NULLHFILL hf diameter avp code AVP Code diameter avp code FTUIN T32 BASEDECNULL 0 NULLHFILL hf diameter avp flags AVP Flags diameter avp flags FTUIN T8 BASEHEXNULL 0x0 NULLHFILL hf diameter avp flags vendor specific Vendor Specific diameter flags vendorspecific FTBOOLEAN 8 TFS tfs set notset AVPFLAGSVNULLHFILL hf diameter avp flags mandatory Mandatory diameter flags mandatory FTBOOLEAN 8 TFS tfs set notset AVPFLAGSMNULLHFILL hf diameter avp flags protected Protected diameter avp flags protected FTBOOLEAN 8 TFS tfs set notset AVPFLAGSPNULLHFILL hf diameter avp flags reserved3 Reserved diameter avp flags reserved3 FTBOOLEAN 8 TFS tfs set notset AVPFLAGSRESERVE D3 NULLHFILL hf diameter avp flags reserved4 Reserved diameter avp flags reserved4 FTBOOLEAN 8 TFS tfs set notset AVPFLAGSRESERVE D4 NULLHFILL hf diameter avp flags reserved5 Reserved diameter avp flags reserved5 FTBOOLEAN 8 TFS tfs set notset AVPFLAGSRESERVE D5 NULLHFILL hf diameter avp flags reserved6 Reserved diameter avp flags reserved6 FTBOOLEAN 8 TFS tfs set notset AVPFLAGSRESERVE D6 NULLHFILL hf diameter avp flags reserved7 Reserved diameter avp flags reserved7 FTBOOLEAN 8 TFS tfs set notset AVPFLAGSRESERVE D7 NULLHFILL hf diameter avp vendor id AVP Vendor Id diameter avp vendor Id FTUIN T32 BASEDECBASEEXTSTRING sminmpec values ext 0x0 NULLHFILL unknown avp hf value Value diameter avp unknown FTBYTESBASENONENULL 0x0 NULLHFILL hf diameter avp data wrong length Data diameter avp invalid data FTBYTESBASENONENULL 0x0 NULLHFILL hf diameter avp pad Padding diameter avp pad FTBYTESBASENONENULL 0x0 NULLHFILL hf diameter code Command Code diameter cmd code FTUIN T32 BASEDECNULL 0 NULLHFILL hf diameter answer in Answer In diameter answer in FTFRAMENUMBASENONEFRAMENUMTYPEFTFRAMENUMRESPONSE 0x0 The answer to this diameter request is in this frame HFILL hf diameter answer to Request In diameter answer to FTFRAMENUMBASENONEFRAMENUMTYPEFTFRAMENUMREQUEST 0x0 This is an answer to the diameter request in this frame HFILL hf diameter answer time Response Time diameter resp time FTRELATIVETIMEBASENONENULL 0x0 The time between the request and the answer HFILL hf framed ipv6 prefix reserved Framed I Pv6 Prefix Reserved byte diameter framed ipv6 prefix reserved FTUIN T8 BASEHEXNULL 0 NULLHFILL hf framed ipv6 prefix length Framed I Pv6 Prefix length in bits diameter framed ipv6 prefix length FTUIN T8 BASEDECNULL 0 NULLHFILL hf framed ipv6 prefix bytes Framed I Pv6 Prefix as a bytestring diameter framed ipv6 prefix bytes FTBYTESBASENONENULL 0 NULLHFILL hf framed ipv6 prefix ipv6 Framed I Pv6 Prefix as an I Pv6 address diameter framed ipv6 prefix ipv6 FTI Pv6 BASENONENULL 0 This field is present only if the prefix length is 128 HFILL hf diameter 3gpp2 exp res Experimental Result Code diameter 3gpp2 exp res FTUIN T32 BASEDECVALS diameter 3gpp2 exp res vals 0x0 NULLHFILL hf diameter other vendor exp res Experimental Result Code diameter other vendor Experimental Result Code FTUIN T32 BASEDECNULL 0x0 NULLHFILL gint ett base ett diameter ett diameter flags ett diameter avp flags ett diameter avpinfo ett unknown ett err unknown avp ett static ei register info ei ei diameter reserved bit set diameter reserved bit set PIMALFORMEDPIWARN Reserved bit set EXPFILL ei diameter avp code diameter avp code unknown PIUNDECODEDPIWARN Unknown AVP if you know what this is you can add it to dictionary xml EXPFILL ei diameter avp vendor id diameter unknown vendor PIUNDECODEDPIWARN Unknown Vendor if you know whose this is you can add it to dictionary xml EXPFILL ei diameter avp no data diameter avp no data PIUNDECODEDPIWARN Data is empty EXPFILL ei diameter avp pad diameter avp pad non zero PIMALFORMEDPINOTE Padding is non zero EXPFILL ei diameter avp len diameter avp invalid len PIMALFORMEDPIWARN Wrong length EXPFILL ei diameter application id diameter application Id unknown PIUNDECODEDPIWARN Unknown Application Id if you know what this is you can add it to dictionary xml EXPFILL ei diameter version diameter version unknown PIUNDECODEDPIWARN Unknown Diameter Version decoding as RFC 3588 EXPFILL ei diameter code diameter cmd code unknown PIUNDECODEDPIWARN Unknown command if you know what this is you can add it to dictionary xml EXPFILL ei diameter invalid ipv6 prefix len diameter invalid ipv6 prefix len PIMALFORMEDPIERROR Invalid I Pv6 Prefix length EXPFILL wmem array append build dict hf hf base array length hf base ett length array length ett base for i 0 i ett length i g ptr array add build dict ett ett base i proto diameter proto register protocol Diameter Protocol DIAMETER diameter proto register field array proto diameter hf register info wmem array get raw build dict hf wmem array get count build dict hf proto register subtree array gint build dict ett pdata build dict ett len expert diameter expert register protocol proto diameter expert register field array expert diameter ei array length ei g ptr array free build dict ett TRUE new register dissector diameter dissect diameter proto diameter diameter dissector table register dissector table diameter base DIAMETERBASEAVPSFTUIN T32 BASEDECDISSECTORTABLEALLOWDUPLICATE diameter 3gpp avp dissector table register dissector table diameter 3gpp DIAMETER 3 GPPAVPSFTUIN T32 BASEDECDISSECTORTABLEALLOWDUPLICATE diameter ericsson avp dissector table register dissector table diameter ericsson DIAMETERERICSSONAVPSFTUIN T32 BASEDECDISSECTORTABLEALLOWDUPLICATE diameter expr result vnd table register dissector table diameter vnd exp res DIAMETER Experimental Result Code FTUIN T32 BASEDECDISSECTORTABLEALLOWDUPLICATE range convert str global diameter tcp port range DEFAULTDIAMETERPORTRANGEMAXUDPPORT range convert str global diameter sctp port range DEFAULTDIAMETERPORTRANGEMAXSCTPPORT range convert str global diameter udp port range MAXUDPPORT diameter module prefs register protocol proto diameter proto reg handoff diameter prefs register range preference diameter module tcp ports Diameter TCP ports TCP ports to be decoded as Diameter default DEFAULTDIAMETERPORTRANGE global diameter tcp port range MAXUDPPORT prefs register range preference diameter module sctp ports Diameter SCTP Ports SCTP ports to be decoded as Diameter default DEFAULTDIAMETERPORTRANGE global diameter sctp port range MAXSCTPPORT prefs register bool preference diameter module desegment Reassemble Diameter messages nspanning multiple TCP segments Whether the Diameter dissector should reassemble messages spanning multiple TCP segments To use this option you must also enable Allow subdissectors to reassemble TCP streams in the TCP protocol settings gbl diameter desegment prefs register range preference diameter module udp ports Diameter UDP ports UDP ports to be decoded as Diameter default 0 as Diameter over UDP is nonstandard global diameter udp port range MAXUDPPORT prefs register obsolete preference diameter module version prefs register obsolete preference diameter module tcp port prefs register obsolete preference diameter module sctp port prefs register obsolete preference diameter module command in header prefs register obsolete preference diameter module dictionary name prefs register obsolete preference diameter module dictionary use prefs register obsolete preference diameter module allow zero as app id prefs register obsolete preference diameter module suppress console output diameter tap register tap diameter register srt table proto diameter NULL 1 diameterstat packet diameterstat init static int xps parse gradient stops xps document doc char base uri fz xml node struct stop stops int maxcount fz colorspace colorspace float sample FZMAXCOLORS float rgb 3 int before after int count int i maxcount 2 count 0 while node count maxcount if strcmp fz xml tag node Gradient Stop char offset fz xml att node Offset char color fz xml att node Color if offset color stops count offset fz atof offset stops count index count xps parse color doc base uri color colorspace sample fz convert color doc ctx fz device rgb doc ctx rgb colorspace sample 1 stops count r rgb 0 stops count g rgb 1 stops count b rgb 2 stops count a sample 0 count node fz xml next node if count 0 fz warn doc ctx gradient brush has no gradient stops stops 0 offset 0 stops 0 r 0 stops 0 g 0 stops 0 b 0 stops 0 a 1 stops 1 offset 1 stops 1 r 1 stops 1 g 1 stops 1 b 1 stops 1 a 1 return 2 if count maxcount fz warn doc ctx gradient brush exceeded maximum number of gradient stops qsort stops count sizeof struct stop cmp stop before 1 after 1 for i 0 i count i if stops i offset 0 before i if stops i offset 1 after i break if before 0 memmove stops stops before count before sizeof struct stop count before if after 0 count after 1 if count 1 stops 1 stops 0 stops 0 offset 0 stops 1 offset 1 return 2 if stops 0 offset 0 float d stops 0 offset stops 1 offset stops 0 offset stops 0 offset 0 stops 0 r lerp stops 0 r stops 1 r d stops 0 g lerp stops 0 g stops 1 g d stops 0 b lerp stops 0 b stops 1 b d stops 0 a lerp stops 0 a stops 1 a d if stops count 1 offset 1 float d 1 stops count 2 offset stops count 1 offset stops count 2 offset stops count 1 offset 1 stops count 1 r lerp stops count 2 r stops count 1 r d stops count 1 g lerp stops count 2 g stops count 1 g d stops count 1 b lerp stops count 2 b stops count 1 b d stops count 1 a lerp stops count 2 a stops count 1 a d if stops 0 offset 0 memmove stops 1 stops count sizeof struct stop stops 0 stops 1 stops 0 offset 0 count if stops count 1 offset 1 stops count stops count 1 stops count offset 1 count return count static void vc1 mc 1mv V C1 Context v int dir Mpeg Enc Context s v s DSP Context dsp v s dsp H264 Chroma Context h264chroma v h264chroma uint8 t src Y src U src V int dxy mx my uvmx uvmy src x src y uvsrc x uvsrc y int off off uv int v edge pos s v edge pos v field mode if v field mode v ref field type dir 1 v cur field type 1 v s last picture f data 0 return mx s mv dir 0 0 my s mv dir 0 1 if s pict type AVPICTURETYPEP s current picture f motion val 1 s block index 0 v blocks off 0 mx s current picture f motion val 1 s block index 0 v blocks off 1 my uvmx mx mx 3 3 1 uvmy my my 3 3 1 v luma mv s mb x 0 uvmx v luma mv s mb x 1 uvmy if v field mode v cur field type v ref field type dir my my 2 4 v cur field type uvmy uvmy 2 4 v cur field type if v fastuvmc v fcm ILACEFRAME uvmx uvmx uvmx 0 uvmx 1 uvmx 1 uvmy uvmy uvmy 0 uvmy 1 uvmy 1 if v field mode if dir if v cur field type v ref field type dir v cur field type src Y s current picture f data 0 src U s current picture f data 1 src V s current picture f data 2 else src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 else if dir src Y s last picture f data 0 src U s last picture f data 1 src V s last picture f data 2 else src Y s next picture f data 0 src U s next picture f data 1 src V s next picture f data 2 src x s mb x 16 mx 2 src y s mb y 16 my 2 uvsrc x s mb x 8 uvmx 2 uvsrc y s mb y 8 uvmy 2 if v profile PROFILEADVANCED src x av clip src x 16 s mb width 16 src y av clip src y 16 s mb height 16 uvsrc x av clip uvsrc x 8 s mb width 8 uvsrc y av clip uvsrc y 8 s mb height 8 else src x av clip src x 17 s avctx coded width src y av clip src y 18 s avctx coded height 1 uvsrc x av clip uvsrc x 8 s avctx coded width 1 uvsrc y av clip uvsrc y 8 s avctx coded height 1 src Y src y s linesize src x src U uvsrc y s uvlinesize uvsrc x src V uvsrc y s uvlinesize uvsrc x if v field mode v ref field type dir src Y s current picture ptr f linesize 0 src U s current picture ptr f linesize 1 src V s current picture ptr f linesize 2 if s flags CODECFLAGGRAY src U s edge emu buffer 18 s linesize src V s edge emu buffer 18 s linesize if v rangeredfrm v mv mode MVPMODEINTENSITYCOMP s h edge pos 22 v edge pos 22 unsigned src x s mspel s h edge pos mx 3 16 s mspel 3 unsigned src y 1 v edge pos my 3 16 3 uint8 t uvbuf s edge emu buffer 19 s linesize src Y s mspel 1 s linesize s vdsp emulated edge mc s edge emu buffer src Y s linesize 17 s mspel 2 17 s mspel 2 src x s mspel src y s mspel s h edge pos v edge pos src Y s edge emu buffer s vdsp emulated edge mc uvbuf src U s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 s vdsp emulated edge mc uvbuf 16 src V s uvlinesize 8 1 8 1 uvsrc x uvsrc y s h edge pos 1 v edge pos 1 src U uvbuf src V uvbuf 16 if v rangeredfrm int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i src i 128 1 128 src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i src i 128 1 128 src2 i src2 i 128 1 128 src s uvlinesize src2 s uvlinesize if v mv mode MVPMODEINTENSITYCOMP int i j uint8 t src src2 src src Y for j 0 j 17 s mspel 2 j for i 0 i 17 s mspel 2 i src i v luty src i src s linesize src src U src2 src V for j 0 j 9 j for i 0 i 9 i src i v lutuv src i src2 i v lutuv src2 i src s uvlinesize src2 s uvlinesize src Y s mspel 1 s linesize if v field mode v cur field type off s current picture ptr f linesize 0 off uv s current picture ptr f linesize 1 else off 0 off uv 0 if s mspel dxy my 3 2 mx 3 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 src Y 8 s linesize v rnd src Y s linesize 8 v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize src Y s linesize v rnd v vc1dsp put vc1 mspel pixels tab dxy s dest 0 off 8 s linesize 8 src Y 8 s linesize v rnd else dxy my 2 mx 2 1 if v rnd dsp put pixels tab 0 dxy s dest 0 off src Y s linesize 16 else dsp put no rnd pixels tab 0 dxy s dest 0 off src Y s linesize 16 if s flags CODECFLAGGRAY return uvmx uvmx 3 1 uvmy uvmy 3 1 if v rnd h264chroma put h264 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy h264chroma put h264 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy else v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 1 off uv src U s uvlinesize 8 uvmx uvmy v vc1dsp put no rnd vc1 chroma pixels tab 0 s dest 2 off uv src V s uvlinesize 8 uvmx uvmy gcry error t gcry mpi print enum gcry mpi format format unsigned char buffer size t buflen size t nwritten struct gcry mpi a unsigned int nbits mpi get nbits a size t len size t dummy nwritten int negative if nwritten nwritten dummy nwritten if a sign gcry mpi cmp ui a 0 negative 1 else negative 0 len buflen nwritten 0 if format GCRYMPIFMTSTD unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if extra s 0 memcpy s tmp n extra gcry free tmp nwritten n return 0 else if format GCRYMPIFMTUSG unsigned int n nbits 7 8 if buffer n len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy buffer tmp n gcry free tmp nwritten n return 0 else if format GCRYMPIFMTPGP unsigned int n nbits 7 8 if negative return gcry error GPGERRINVARG if buffer n 2 len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp unsigned char s buffer s 0 nbits 8 s 1 nbits tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy s 2 tmp n gcry free tmp nwritten n 2 return 0 else if format GCRYMPIFMTSSH unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n 4 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer s n 24 s n 16 s n 8 s n if extra s 0 memcpy s tmp n extra gcry free tmp nwritten 4 n return 0 else if format GCRYMPIFMTHEX unsigned char tmp int i int extra 0 unsigned int n 0 tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 extra 2 if buffer 2 n extra negative 1 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if negative s if extra s 0 s 0 for i 0 i n i unsigned int c tmp i s c 4 10 0 c 4 A c 4 10 c 15 s c 10 0 c A c 10 s 0 nwritten s buffer else nwritten 2 n extra negative 1 gcry free tmp return 0 else return gcry error int evsignal set handler struct event base base int evsignal void handler int void p if evsignal sig sh old max int new max evsignal 1 event debug s evsignal d sh old max d resizing func evsignal sig sh old max p realloc sig sh old new max sizeof sig sh old if p NULL event warn realloc return 1 memset char p sig sh old max sizeof sig sh old 0 new max sig sh old max sizeof sig sh old sig sh old max new max sig sh old p sig sh old evsignal malloc sizeof sig sh old evsignal if sig sh old evsignal NULL event warn malloc return 1 sa sa handler handler sa sa flags SARESTART sigfillset sa sa mask if sigaction evsignal sa sig sh old evsignal 1 event warn sigaction free sig sh old evsignal sig sh old evsignal NULL return 1 event warn signal free sig sh old evsignal sig sh old evsignal NULL return 1 int encode function char string struct filter op fop char str strdup string int ret ENOTFOUND char name args int nargs 0 i char dec args NULL char tok memset fop 0 sizeof struct filter op name ec strtok string tok args name strlen name 1 dec args decode args args nargs fop opcode FOPFUNC if strcmp name search if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCSEARCH fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name regex if nargs 2 int err regex t regex char errbuf 100 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCREGEX fop op func string u char strdup dec args 1 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 err regcomp regex const char fop op func string REGEXTENDEDREGNOSUBREGICASE if err regerror err regex errbuf sizeof errbuf SCRIPTERROR s errbuf regfree regex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name pcre regex const char errbuf NULL int erroff if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func string strdup dec args 1 fop op func slen strlen fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else if nargs 3 fop opcode FOPFUNC fop op func op FFUNCPCRE fop op func level 5 fop op func string strdup dec args 1 fop op func slen strlen fop op func string fop op func replace strdup dec args 2 fop op func rlen strlen fop op func replace ret ESUCCESS pregex pcre compile fop op func string 0 errbuf erroff NULL if pregex NULLSCRIPTERROR s n errbuf pcre free pregex else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name replace if nargs 2 fop op func op FFUNCREPLACE fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string fop op func replace u char strdup dec args 1 fop op func rlen strescape char fop op func replace char fop op func replace ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name inject if nargs 1 fop op func op FFUNCINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name execinject if nargs 1 fop op func op FFUNCEXECINJECT fop op func level 5 fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name log if nargs 2 if encode offset dec args 0 fop ESUCCESS fop opcode FOPFUNC fop op func op FFUNCLOG fop op func string u char strdup dec args 1 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Unknown offset s dec args 0 else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name drop if nargs 0 fop op func op FFUNCDROP ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name kill if nargs 0 fop op func op FFUNCKILL ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name msg if nargs 1 fop op func op FFUNCMSG fop op func string u char strdup dec args 0 fop op func slen strescape char fop op func string char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exec if nargs 1 fop op func op FFUNCEXEC fop op func string u char strdup dec args 0 fop op func slen strlen const char fop op func string ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name else if strcmp name exit if nargs 0 fop opcode FOPEXIT ret ESUCCESS else SCRIPTERROR Wrong number of arguments for function s name for i 0 i nargs i SAFEFREE dec args i SAFEFREE dec args SAFEFREE str return ret void vp9 rd pick intra mode sb V P9 COMP cpi MACROBLOCK x int returnrate int64 t returndist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd struct macroblockd plane const pd xd plane int rate y 0 rate uv 0 rate y tokenonly 0 rate uv tokenonly 0 int y skip 0 uv skip 0 int64 t dist y 0 dist uv 0 tx cache TXMODES 0 TXSIZE max uv tx size x skip encode 0 ctx skip 0 xd mi 0 src mi mbmi ref frame 0 INTRAFRAME if bsize BLOCK 8 X8 if rd pick intra sby mode cpi x rate y rate y tokenonly dist y y skip bsize tx cache best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip bsize max uv tx size else y skip 0 if rd pick intra sub 8x8 y mode cpi x rate y rate y tokenonly dist y best rd best rd returnrate INTMAX return max uv tx size get uv tx size impl xd mi 0 src mi mbmi tx size bsize pd 1 subsampling x pd 1 subsampling y rd pick intra sbuv mode cpi x ctx rate uv rate uv tokenonly dist uv uv skip BLOCK 8 X8 max uv tx size if y skip uv skip returnrate rate y rate uv rate y tokenonly rate uv tokenonly vp9 cost bit vp9 get skip prob cm xd 1 returndist dist y dist uv vp9 zero ctx tx rd diff else int i returnrate rate y rate uv vp9 cost bit vp9 get skip prob cm xd 0 returndist dist y dist uv if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i if tx cache i IN T64 MAX tx cache cm tx mode IN T64 MAX ctx tx rd diff i tx cache i tx cache cm tx mode else ctx tx rd diff i 0 ctx mic xd mi 0 src mi static bfd boolean srec scan bfd abfd int c unsigned int lineno 1 bfd boolean error FALSE bfd byte buf NULL size t bufsize 0 asection sec NULL char symbuf NULL if bfd seek abfd file ptr 0 SEEKSET 0 goto error return while c srec get byte abfd error EOF if c S c r c n sec NULL switch c default srec bad byte abfd lineno c error goto error return case n lineno break case r break case while c srec get byte abfd error n c EOF if c EOF srec bad byte abfd lineno c error goto error return lineno break case do bfd size type alc char p symname bfd vma symval while c srec get byte abfd error EOF c c t if c n c r break if c EOF srec bad byte abfd lineno c error goto error return alc 10 symbuf char bfd malloc alc 1 if symbuf NULL goto error return p symbuf p c while c srec get byte abfd error EOFISSPACE c if bfd size type p symbuf alc char n alc 2 n char bfd realloc symbuf alc 1 if n NULL goto error return p n p symbuf symbuf n p c if c EOF srec bad byte abfd lineno c error goto error return p 0 symname char bfd alloc abfd bfd size type p symbuf if symname NULL goto error return strcpy symname symbuf free symbuf symbuf NULL while c srec get byte abfd error EOF c c t if c EOF srec bad byte abfd lineno c error goto error return if c c srec get byte abfd error if c EOF srec bad byte abfd lineno c error goto error return symval 0 while ISHEX c symval 4 symval NIBBLE c c srec get byte abfd error if c EOF srec bad byte abfd lineno c error goto error return if srec new symbol abfd symname symval goto error return while c c t if c n lineno else if c r srec bad byte abfd lineno c error goto error return break case S file ptr pos char hdr 3 unsigned int bytes min bytes bfd vma address bfd byte data unsigned char check sum pos bfd tell abfd 1 if bfd bread hdr bfd size type 3 abfd 3 goto error return if ISHEX hdr 1 ISHEX hdr 2 if ISHEX hdr 1 c hdr 1 else c hdr 2 srec bad byte abfd lineno c error goto error return check sum bytes HEX hdr 1 min bytes 3 if hdr 0 2 hdr 0 8 min bytes 4 else if hdr 0 3 hdr 0 7 min bytes 5 if bytes min bytes bfd error handler B d byte count d too small n abfd lineno bytes bfd set error bfd error bad value goto error return if bytes 2 bufsize if buf NULL free buf buf bfd byte bfd malloc bfd size type bytes 2 if buf NULL goto error return bufsize bytes 2 if bfd bread buf bfd size type bytes 2 abfd bytes 2 goto error return bytes address 0 data buf switch hdr 0 case 0 case 5 sec NULL break case 3 check sum HEX data address HEX data data 2 bytes case 2 check sum HEX data address address 8 HEX data data 2 bytes case 1 check sum HEX data address address 8 HEX data data 2 check sum HEX data address address 8 HEX data data 2 bytes 2 if sec NULL sec vma sec size address sec size bytes else char secbuf 20 char secname bfd size type amt flagword flags sprintf secbuf sec d bfd count sections abfd 1 amt strlen secbuf 1 secname char bfd alloc abfd amt strcpy secname secbuf flags SECHASCONTENTSSECLOADSECALLOC sec bfd make section with flags abfd secname flags if sec NULL goto error return sec vma address sec lma address sec size bytes sec filepos pos while bytes 0 check sum HEX data data 2 bytes check sum 255 check sum 0xff if check sum HEX data bfd error handler B d Bad checksum in S record file n abfd lineno bfd set error bfd error bad value goto error return break case 7 check sum HEX data address HEX data data 2 case 8 check sum HEX data address address 8 HEX data data 2 case 9 check sum HEX data address address 8 HEX data data 2 check sum HEX data address address 8 HEX data data 2 abfd start address address check sum 255 check sum 0xff if check sum HEX data bfd error handler B d Bad checksum in S record file n abfd lineno bfd set error bfd error bad value goto error return if buf NULL free buf return TRUE break if error goto error return if buf NULL free buf return TRUE error return if symbuf NULL free symbuf if buf NULL free buf return void ff MPV common defaults Mpeg Enc Context s s y dc scale table s c dc scale table ff mpeg1 dc scale table s chroma qscale table ff default chroma qscale table s progressive frame 1 s progressive sequence 1 s picture structure PICTFRAME s coded picture number 0 s picture number 0 s input picture number 0 s picture in gop number 0 s f code 1 s b code 1 s picture range start 0 s picture range end MAXPICTURECOUNT s slice context count 1 char cluster conn opts Cluster Info cluster static char conn opts MAXPGPATHNAMEDATALEN 100 if cluster sockdir snprintf conn opts sizeof conn opts host s port d username s cluster sockdir cluster port os info user else snprintf conn opts sizeof conn opts port d username s cluster port os info user return conn opts static void vacuum all databases vacuuming Options vacopts bool analyze in stages const char maintenance db const char host const char port const char username enum trivalue prompt password int concurrent Cons const char progname bool echo bool quiet P Gconn conn P Gresult result int stage int i conn connect Maintenance Database maintenance db host port username prompt password progname result execute Query conn SELECT datname FROM pg database WHERE datallowconn ORDERBY 1 progname echo P Qfinish conn if analyze in stages for stage 0 stage ANALYZENUMSTAGES stage for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts stage NULL host port username prompt password concurrent Cons progname echo quiet else for i 0 i P Qntuples result i const char dbname dbname P Qgetvalue result i 0 vacuum one database dbname vacopts ANALYZENOSTAGENULL host port username prompt password concurrent Cons progname echo quiet P Qclear result static int zsethalftone5 i ctx t i ctx p os ptr op osp uint count gs halftone component phtc 0 gs halftone component pc int code 0 int j bool have default gs halftone pht 0 gx device halftone pdht 0 ref sprocs GSCLIENTCOLORMAXCOMPONENTS 1 ref tprocs GSCLIENTCOLORMAXCOMPONENTS 1 gs memory t mem uint edepth ref stack count e stack int npop 2 int dict enum dict first op ref rvalue 2 int cname colorant number byte pname uint name size int halftonetype type 0 gs gstate pgs igs int space index r space index op 1 mem gs memory t idmemory spaces indexed space index check type op t dictionary check dict read op check type op 1 t dictionary check dict read op 1 code dict int param op 1 Halftone Type 1 100 0 type if code 0 return code halftonetype type 2 type 4 ht type multiple colorscreen ht type multiple have default false for count 0 if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue else if colorant number GXDEVICECOLORMAXCOMPONENTS if have default return error gs error rangecheck have default true count if count GSCLIENTCOLORMAXCOMPONENTS 1 code gs note error gs error rangecheck break if count 0 halftonetype ht type multiple have default code gs note error gs error rangecheck if code 0 check estack 5 refset null sprocs count refset null tprocs count rc alloc struct 0 pht gs halftone st halftone imemory pht 0 sethalftone5 phtc gs alloc struct array mem count gs halftone component st ht component element sethalftone5 rc alloc struct 0 pdht gx device halftone st device halftone imemory pdht 0 sethalftone5 if pht 0 phtc 0 pdht 0 j 0 code gs note error gs error V Merror if code 0 dict enum dict first op for j 0 pc phtc int type if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue pc cname cname pc comp number colorant number check dict read rvalue 1 if dict int param rvalue 1 Halftone Type 1 7 0 type 0 code gs note error gs error typecheck break switch type default code gs note error gs error rangecheck break case 1 code dict spot params rvalue 1 pc params spot sprocs j tprocs j mem pc params spot screen spot function spot1 dummy pc type ht type spot break case 3 code dict threshold params rvalue 1 pc params threshold tprocs j pc type ht type threshold break case 7 code dict threshold2 params rvalue 1 pc params threshold2 tprocs j imemory pc type ht type threshold2 break if code 0 break pc j if code 0 pht type halftonetype pht params multiple components phtc pht params multiple num comp j pht params multiple get colorname string gs get colorname string code gs sethalftone prepare igs pht pdht if code 0 dict enum dict first op for pc phtc if dict enum dict next op dict enum rvalue 1 break if r has type rvalue 0 t name continue if r has type rvalue 1 t dictionary continue cname name index mem rvalue 0 code gs get colorname string mem cname pname name size if code 0 break colorant number gs cname to colorant number pgs pname name size halftonetype if colorant number 0 continue if pc type ht type spot code dict spot results i ctx p rvalue 1 pc params spot if code 0 break pc if code 0 uint odepth ref stack count o stack ref odict odict5 odict op 1 odict5 op pop 2 op osp esp 5 make mark estack esp 4 es other sethalftone cleanup esp 3 odict make istruct esp 2 0 pht make istruct esp 1 0 pdht make op estack esp sethalftone finish for j 0 j count j gx ht order porder NULL if pdht components 0 porder pdht order else int k int comp number phtc j comp number for k 0 k count k if pdht components k comp number comp number porder pdht components k corder break switch phtc j type case ht type spot code zscreen enum init i ctx p porder phtc j params spot screen sprocs j 0 0 space index if code 0 break case ht type threshold if r has type tprocs j t invalid check ostack zcolor remap one ostack check estack zcolor remap one estack code zcolor remap one i ctx p tprocs j porder transfer igs zcolor remap one finish op osp break default if code 0 ref stack pop to o stack odepth ref stack pop to e stack edepth op osp op 1 odict op odict5 break npop 0 if code 0 gs free object mem pdht sethalftone5 gs free object mem phtc sethalftone5 gs free object mem pht sethalftone5 return code pop npop return ref stack count e stack edepth o push estack 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AS V1 Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p a picture int mb x mb y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 av fast padded malloc a bitstream buffer a bitstream buffer size buf size if a bitstream buffer return AVERRORENOMEM if avctx codec id AVCODECIDAS V1 a dsp bswap buf uint32 t a bitstream buffer const uint32 t buf buf size 4 else int i for i 0 i buf size i a bitstream buffer i ff reverse buf i init get bits a gb a bitstream buffer buf size 8 for mb y 0 mb y a mb height2 mb y for mb x 0 mb x a mb width2 mb x if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb width2 a mb width mb x a mb width2 for mb y 0 mb y a mb height2 mb y if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb height2 a mb height mb y a mb height2 for mb x 0 mb x a mb width mb x if ret decode mb a a block 0 return ret idct put a mb x mb y picture a picture got frame 1 emms c return get bits count a gb 31 32 4 static int tqi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size Tqi Context t avctx priv data Mpeg Enc Context s t s AV Frame frame data int ret s width AVR L16 buf 0 s height AVR L16 buf 2 tqi calculate qtable s buf 4 buf 8 if s avctx width s width s avctx height s height avcodec set dimensions s avctx s width s height if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret av fast padded malloc t bitstream buf t bitstream buf size buf end buf if t bitstream buf return AVERRORENOMEM s dsp bswap buf t bitstream buf const uint32 t buf buf end buf 4 init get bits s gb t bitstream buf 8 buf end buf s last dc 0 s last dc 1 s last dc 2 0 for s mb y 0 s mb y avctx height 15 16 s mb y for s mb x 0 s mb x avctx width 15 16 s mb x if tqi decode mb s t block 0 break tqi idct put t frame t block got frame 1 return buf size static int s302m decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int block size ret int frame size s302m parse frame header avctx buf buf size if frame size 0 return frame size buf size AE S3 HEADERLEN buf AE S3 HEADERLEN block size avctx bits per coded sample 4 4 frame nb samples 2 buf size block size avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf size frame nb samples avctx channels 2 block size if avctx bits per coded sample 24 uint32 t o uint32 t frame data 0 for buf size 6 buf size 7 o ff reverse buf 2 24 ff reverse buf 1 16 ff reverse buf 0 8 o ff reverse buf 6 0xf0 28 ff reverse buf 5 20 ff reverse buf 4 12 ff reverse buf 3 0x0f 4 buf 7 else if avctx bits per coded sample 20 uint32 t o uint32 t frame data 0 for buf size 5 buf size 6 o ff reverse buf 2 0xf0 28 ff reverse buf 1 20 ff reverse buf 0 12 o ff reverse buf 5 0xf0 28 ff reverse buf 4 20 ff reverse buf 3 12 buf 6 else uint16 t o uint16 t frame data 0 for buf size 4 buf size 5 o ff reverse buf 1 8 ff reverse buf 0 o ff reverse buf 4 0xf0 12 ff reverse buf 3 4 ff reverse buf 2 4 buf 5 got frame ptr 1 return avpkt size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Camtasia Context const c avctx priv data const unsigned char encoded buf int zret int ret len buf size if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN c zstream next in encoded c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZFINISH if zret ZOK zret ZSTREAMEND zret ZDATAERROR av log avctx AVLOGERROR Inflate error d n zret return AVERRORUNKNOWN if zret ZDATAERROR bytestream2 init c gb c decomp buf c decomp size c zstream avail out ff msrle decode avctx AV Picture c pic c bpp c gb if c avctx pix fmt AVPIXFMTPA L8 const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL if pal c pic palette has changed 1 memcpy c pal pal AVPALETTESIZE memcpy c pic data 1 c pal AVPALETTESIZE got frame 1 AV Frame data c pic return buf size static void slurm rpc submit batch job slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESSDEFTIMERS uint32 t job id 0 priority 0 struct job record job ptr NULL slurm msg t response msg submit response msg t submit msg job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info gid t gid g slurm auth get gid msg auth cred slurmctld config auth info char err msg NULL job submit user msg NULL bool reject job false STARTTIMER debug2 Processing RPCREQUESTSUBMITBATCHJOB from uid d uid if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if error code valid id REQUESTSUBMITBATCHJOB job desc msg uid gid reject job true goto send msg if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTSUBMITBATCHJOB lacks alloc node from uid d uid dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if error code reject job true goto send msg throttle start active rpc cnt lock slurmctld job write lock STARTTIMER if fed mgr fed rec if fed mgr job allocate msg job desc msg false uid msg protocol version job id error code err msg reject job true else job desc msg pack job offset NOVAL error code job allocate job desc msg job desc msg immediate false NULL 0 uid job ptr err msg msg protocol version if job ptr error code job ptr job state JOBFAILED reject job true else job id job ptr job id priority job ptr priority if job desc msg immediate error code SLURMSUCCESS error code ESLURMCANNOTSTARTIMMEDIATELY reject job true unlock slurmctld job write lock throttle fini active rpc cnt send msg ENDTIME R2 slurm rpc submit batch job if reject job info s s func slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else info s Job Id u Init Prio u s func job id priority TIMESTR submit msg job id job id submit msg step id SLURMBATCHSCRIPT submit msg error code error code submit msg job submit user msg job submit user msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg conn msg conn response msg msg type RESPONSESUBMITBATCHJOB response msg data submit msg slurm send node msg msg conn fd response msg schedule job save schedule node save queue job scheduler xfree err msg xfree job submit user msg static inline void vc1 pred mv V C1 Context v int n int dmv x int dmv y int mv1 int r x int r y uint8 t is intra int pred flag int dir Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int mixedmv pic num samefield 0 num oppfield 0 int opposite a f b f c f int16 t field pred A 2 int16 t field pred B 2 int16 t field pred C 2 int a valid b valid c valid int hybridmv thresh y bias 0 if v mv mode MVPMODEMIXEDMV v mv mode MVPMODEINTENSITYCOMP v mv mode2 MVPMODEMIXEDMV mixedmv pic 1 else mixedmv pic 0 dmv x 1 s quarter sample dmv y 1 s quarter sample wrap s b8 stride xy s block index n if s mb intra s mv 0 n 0 s current picture f motion val 0 xy v blocks off 0 0 s mv 0 n 1 s current picture f motion val 0 xy v blocks off 1 0 s current picture f motion val 1 xy v blocks off 0 0 s current picture f motion val 1 xy v blocks off 1 0 if mv1 s current picture f motion val 0 xy 1 v blocks off 0 0 s current picture f motion val 0 xy 1 v blocks off 1 0 s current picture f motion val 0 xy wrap v blocks off 0 0 s current picture f motion val 0 xy wrap v blocks off 1 0 s current picture f motion val 0 xy wrap 1 v blocks off 0 0 s current picture f motion val 0 xy wrap 1 v blocks off 1 0 v luma mv s mb x 0 v luma mv s mb x 1 0 s current picture f motion val 1 xy 1 v blocks off 0 0 s current picture f motion val 1 xy 1 v blocks off 1 0 s current picture f motion val 1 xy wrap 0 0 s current picture f motion val 1 xy wrap v blocks off 1 0 s current picture f motion val 1 xy wrap 1 v blocks off 0 0 s current picture f motion val 1 xy wrap 1 v blocks off 1 0 return C s current picture f motion val dir xy 1 v blocks off A s current picture f motion val dir xy wrap v blocks off if mv1 if v field mode mixedmv pic off s mb x s mb width 1 2 2 else off s mb x s mb width 1 1 2 else switch n case 0 off s mb x 0 1 1 break case 1 off s mb x s mb width 1 1 1 break case 2 off 1 break case 3 off 1 B s current picture f motion val dir xy wrap off v blocks off a valid s first slice line n 2 n 3 b valid a valid s mb width 1 c valid s mb x n 1 n 3 if v field mode a valid a valid is intra xy wrap b valid b valid is intra xy wrap off c valid c valid is intra xy 1 if a valid a f v mv f dir xy wrap v blocks off num oppfield a f num samefield 1 a f field pred A 0 A 0 field pred A 1 A 1 else field pred A 0 field pred A 1 0 a f 0 if b valid b f v mv f dir xy wrap off v blocks off num oppfield b f num samefield 1 b f field pred B 0 B 0 field pred B 1 B 1 else field pred B 0 field pred B 1 0 b f 0 if c valid c f v mv f dir xy 1 v blocks off num oppfield c f num samefield 1 c f field pred C 0 C 0 field pred C 1 C 1 else field pred C 0 field pred C 1 0 c f 0 if v field mode if v numref opposite 1 v reffield else if num samefield num oppfield opposite 1 pred flag else opposite pred flag else opposite 0 if opposite if a valid a f field pred A 0 scaleforopp v field pred A 0 0 dir field pred A 1 scaleforopp v field pred A 1 1 dir if b valid b f field pred B 0 scaleforopp v field pred B 0 0 dir field pred B 1 scaleforopp v field pred B 1 1 dir if c valid c f field pred C 0 scaleforopp v field pred C 0 0 dir field pred C 1 scaleforopp v field pred C 1 1 dir v mv f dir xy v blocks off 1 v ref field type dir v cur field type else if a valid a f field pred A 0 scaleforsame v n field pred A 0 0 dir field pred A 1 scaleforsame v n field pred A 1 1 dir if b valid b f field pred B 0 scaleforsame v n field pred B 0 0 dir field pred B 1 scaleforsame v n field pred B 1 1 dir if c valid c f field pred C 0 scaleforsame v n field pred C 0 0 dir field pred C 1 scaleforsame v n field pred C 1 1 dir v mv f dir xy v blocks off 0 v ref field type dir v cur field type if a valid px field pred A 0 py field pred A 1 else if c valid px field pred C 0 py field pred C 1 else if b valid px field pred B 0 py field pred B 1 else px 0 py 0 if num samefield num oppfield 1 px mid pred field pred A 0 field pred B 0 field pred C 0 py mid pred field pred A 1 field pred B 1 field pred C 1 if v field mode int qx qy XY qx s mb x 6 n 1 n 3 32 0 qy s mb y 6 n 2 n 3 32 0 X s mb width 6 4 Y s mb height 6 4 if mv1 if qx px 60 px 60 qx if qy py 60 py 60 qy else if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy if v field mode s pict type AVPICTURETYPEB hybridmv thresh 32 if a valid c valid if is intra xy wrap sum FFABS px FFABS py else sum FFABS px field pred A 0 FFABS py field pred A 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 else if is intra xy 1 sum FFABS px FFABS py else sum FFABS px field pred C 0 FFABS py field pred C 1 if sum hybridmv thresh if get bits1 s gb px field pred A 0 py field pred A 1 else px field pred C 0 py field pred C 1 if v field mode v numref r y 1 if v field mode v cur field type v ref field type dir 0 y bias 1 s mv dir n 0 s current picture f motion val dir xy v blocks off 0 px dmv x r x r x 1 1 r x s mv dir n 1 s current picture f motion val dir xy v blocks off 1 py dmv y r y y bias r y 1 1 r y y bias if mv1 s current picture f motion val dir xy 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap v blocks off 1 s current picture f motion val dir xy v blocks off 1 s current picture f motion val dir xy wrap 1 v blocks off 0 s current picture f motion val dir xy v blocks off 0 s current picture f motion val dir xy wrap 1 v blocks off 1 s current picture f motion val dir xy v blocks off 1 v mv f dir xy 1 v blocks off v mv f dir xy v blocks off v mv f dir xy wrap v blocks off v mv f dir xy wrap 1 v blocks off v mv f dir xy v blocks off static int dvvideo decode frame AV Codec Context avctx void data int got frame AV Packet avpkt uint8 t buf avpkt data int buf size avpkt size DV Video Context s avctx priv data const uint8 t vsc pack int apt is16 9 s sys avpriv dv frame profile s sys buf buf size if s sys buf size s sys frame size ff dv init dynamic tables s sys av log avctx AVLOGERROR could not find dv frame profile n return 1 s picture key frame 1 s picture pict type AVPICTURETYPEI avctx pix fmt s sys pix fmt avctx time base s sys time base avcodec set dimensions avctx s sys width s sys height if ff get buffer avctx s picture 0 0 av log avctx AVLOGERROR get buffer failed n return 1 s picture interlaced frame 1 s picture top field first 0 s buf buf avctx execute avctx dv decode video segment s sys work chunks NULL dv work pool size s sys sizeof D Vwork chunk emms c got frame 1 av frame move ref data s picture vsc pack buf 80 5 48 5 if vsc pack dv video control apt buf 4 0x07 is16 9 vsc pack vsc pack 2 0x07 0x02 apt vsc pack 2 0x07 0x07 avctx sample aspect ratio s sys sar is16 9 return s sys frame size static picture t vout new buffer decoder t p dec decoder owner sys t p owner p dec p owner if p owner p vout NULL p dec fmt out video i width p owner video i width p dec fmt out video i height p owner video i height p dec fmt out video i visible width p owner video i visible width p dec fmt out video i visible height p owner video i visible height p dec fmt out video i x offset p owner video i x offset p dec fmt out video i y offset p owner video i y offset p dec fmt out i codec p owner video i chroma int64 t p dec fmt out video i sar num p owner video i sar den int64 t p dec fmt out video i sar den p owner video i sar num p dec fmt out video orientation p owner video orientation vout thread t p vout if p dec fmt out video i width p dec fmt out video i height return NULL video format t fmt p dec fmt out video fmt i chroma p dec fmt out i codec p owner video fmt if vlc fourcc Is YUV fmt i chroma const vlc chroma description t dsc vlc fourcc Get Chroma Description fmt i chroma for unsigned int i 0 dsc i dsc plane count i while fmt i width dsc p i w den fmt i width while fmt i height dsc p i h den fmt i height if fmt i visible width fmt i visible height if p dec fmt in video i visible width p dec fmt in video i visible height fmt i visible width p dec fmt in video i visible width fmt i visible height p dec fmt in video i visible height fmt i x offset p dec fmt in video i x offset fmt i y offset p dec fmt in video i y offset else fmt i visible width fmt i width fmt i visible height fmt i height fmt i x offset 0 fmt i y offset 0 if fmt i visible height 1088 var Create Get Bool p dec hdtv fix fmt i visible height 1080 if fmt i sar num 136 fmt i sar num 135 fmt i sar den 136 msg Warn p dec Fixing broken HDTV stream display height 1088 if fmt i sar num fmt i sar den fmt i sar num 1 fmt i sar den 1 vlc ureduce fmt i sar num fmt i sar den fmt i sar num fmt i sar den 50000 vlc mutex lock p owner lock p vout p owner p vout p owner p vout NULL vlc mutex unlock p owner lock unsigned dpb size switch p dec fmt in i codec case VLCCODECHEVC case VLCCODEC H264 case VLCCODECDIRAC dpb size 18 break case VLCCODECV P5 case VLCCODECV P6 case VLCCODECV P6 F case VLCCODECV P8 dpb size 3 break default dpb size 2 break p vout input resource Request Vout p owner p resource p vout fmt dpb size p dec i extra picture buffers 1 true vlc mutex lock p owner lock p owner p vout p vout Decoder Update Format Locked p dec vlc mutex unlock p owner lock if p owner p input NULL input Send Event Vout p owner p input if p vout NULL msg Err p dec failed to create video output p dec b error true return NULL for if Decoder Is Exit Requested p dec p dec b error return NULL picture t p picture vout Get Picture p owner p vout if p picture return p picture if Decoder Is Flushing p dec return NULL Decoder Signal Wait p dec true vout Fix Leaks p owner p vout msleep static int slice end AV Codec Context avctx AV Frame pict Mpeg1 Context s1 avctx priv data Mpeg Enc Context s s1 mpeg enc ctx if s1 mpeg enc ctx allocated s current picture ptr return 0 if s avctx hwaccel if s avctx hwaccel end frame s avctx 0 av log avctx AVLOGERROR hardware accelerator failed to decode picture n if CONFIGMPEGXVMCDECODER s avctx xvmc acceleration ff xvmc field end s if s first field ff er frame end s er ff MPV frame end s if s pict type AVPICTURETYPEB s low delay int ret av frame ref pict s current picture ptr f if ret 0 return ret ff print debug info s s current picture ptr else if avctx active thread type FFTHREADFRAME s picture number if s last picture ptr NULL int ret av frame ref pict s last picture ptr f if ret 0 return ret ff print debug info s s last picture ptr return 1 else return 0 static void set block thresholds const V P9 COMMON cm RDOPT rd int i bsize segment id for segment id 0 segment id MAXSEGMENTS segment id const int qindex clamp vp9 get qindex cm seg segment id cm base qindex cm y dc delta q 0 MAXQ const int q compute rd thresh factor qindex for bsize 0 bsize BLOCKSIZES bsize const int t q rd thresh block size factor bsize const int thresh max INTMAX t if bsize BLOCK 8 X8 for i 0 i MAXMODES i rd threshes segment id bsize i rd thresh mult i thresh max rd thresh mult i t 4 INTMAX else for i 0 i MAXREFS i rd threshes segment id bsize i rd thresh mult sub8x8 i thresh max rd thresh mult sub8x8 i t 4 static Image Read CAPTION Image const Image Info image info Exception Info exception char caption geometry Max Text Extent property text const char gravity option Draw Info draw info Image image Magick Boolean Type split status register ssize t i size t height width Type Metric metrics assert image info const Image Info NULL assert image info signature Magick Signature if image info debug Magick False void Log Magick Event Trace Event Get Magick Module s image info filename assert exception Exception Info NULL assert exception signature Magick Signature image Acquire Image image info void Reset Image Page image 0x0 0 0 option Get Image Option image info filename if option const char NULL property Interpret Image Properties image info image image info filename else if Locale N Compare option caption 8 0 property Interpret Image Properties image info image option 8 else property Interpret Image Properties image info image option void Set Image Property image caption property property Destroy String property caption Constant String Get Image Property image caption draw info Clone Draw Info image info Draw Info NULL void Clone String draw info text caption gravity Get Image Option image info gravity if gravity char NULL draw info gravity Gravity Type Parse Command Option Magick Gravity Options Magick False gravity split Magick False status Magick True if image columns 0 text Acquire String caption i Format Magick Caption image draw info split metrics text void Clone String draw info text text text Destroy String text void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry status Get Multiline Type Metrics image draw info metrics width size t floor metrics width draw info stroke width 0 5 image columns width if image rows 0 split Magick True text Acquire String caption i Format Magick Caption image draw info split metrics text void Clone String draw info text text text Destroy String text void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry status Get Multiline Type Metrics image draw info metrics image rows size t i 1 metrics ascent metrics descent draw info interline spacing draw info stroke width 0 5 if status Magick False status Set Image Extent image image columns image rows if status Magick False draw info Destroy Draw Info draw info Inherit Exception exception image exception return Destroy Image List image if Set Image Background Color image Magick False draw info Destroy Draw Info draw info Inherit Exception exception image exception image Destroy Image List image return Image NULL if fabs image info pointsize Magick Epsilon strlen caption 0 double high low for draw info pointsize 2 0 text Acquire String caption i Format Magick Caption image draw info split metrics text void Clone String draw info text text text Destroy String text void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry status Get Multiline Type Metrics image draw info metrics void status width size t floor metrics width draw info stroke width 0 5 height size t floor metrics height draw info stroke width 0 5 if image columns 0 image rows 0 if width image columns height image rows break else if image columns 0 width image columns image rows 0 height image rows break high draw info pointsize for low 1 0 high low 0 5 draw info pointsize low high 2 0 text Acquire String caption i Format Magick Caption image draw info split metrics text void Clone String draw info text text text Destroy String text void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry void Get Multiline Type Metrics image draw info metrics width size t floor metrics width draw info stroke width 0 5 height size t floor metrics height draw info stroke width 0 5 if image columns 0 image rows 0 if width image columns height image rows low draw info pointsize 0 5 else high draw info pointsize 0 5 else if image columns 0 width image columns image rows 0 height image rows low draw info pointsize 0 5 else high draw info pointsize 0 5 draw info pointsize floor low high 2 0 0 5 i Format Magick Caption image draw info split metrics caption void Clone String draw info text caption void Format Locale String geometry Max Text Extent g g Magick Max draw info direction Right To Left Direction image columns metrics bounds x2 metrics bounds x1 0 0 draw info gravity Undefined Gravity metrics ascent 0 0 draw info geometry Acquire String geometry status Annotate Image image draw info if image info pointsize 0 0 char pointsize Max Text Extent void Format Locale String pointsize Max Text Extent 20g draw info pointsize void Set Image Property image caption pointsize pointsize draw info Destroy Draw Info draw info caption Destroy String caption if status Magick False image Destroy Image List image return Image NULL return Get First Image In List image static void set partition range V P9 COMMON cm MACROBLOCKD xd int mi row int mi col BLOCKSIZE bsize BLOCKSIZE min bs BLOCKSIZE max bs int mi width num 8x8 blocks wide lookup bsize int mi height num 8x8 blocks high lookup bsize int idx idy MODEINFO mi MODEINFO prev mi cm prev mi grid visible mi row cm mi stride mi col BLOCKSIZE bs min size max size min size BLOCK 64 X64 max size BLOCK 4 X4 if prev mi for idy 0 idy mi height idy for idx 0 idx mi width idx mi prev mi idy cm mi stride idx bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd left available for idy 0 idy mi height idy mi xd mi idy cm mi stride 1 bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if xd up available for idx 0 idx mi width idx mi xd mi idx cm mi stride bs mi mi mbmi sb type bsize min size MIN min size bs max size MAX max size bs if min size max size min size min partition size min size max size max partition size max size min bs min size max bs max size static void rd auto partition range V P9 COMP cpi const Tile Info const tile int mi row int mi col BLOCKSIZE min block size BLOCKSIZE max block size V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO mi xd mi 0 src mi const int left in image xd left available mi 1 src mi const int above in image xd up available mi xd mi stride src mi const int row8x8 remaining tile mi row end mi row const int col8x8 remaining tile mi col end mi col int bh bw BLOCKSIZE min size BLOCK 4 X4 BLOCKSIZE max size BLOCK 64 X64 int i 0 int bs hist BLOCKSIZES 0 if left in image above in image cm frame type KEYFRAME min size BLOCK 64 X64 max size BLOCK 4 X4 if cm frame type KEYFRAMEMODEINFO prev mi cm prev mip cm mi stride 1 mi row xd mi stride mi col get sb partition size range xd prev mi min size max size bs hist if left in image MODEINFO left sb64 mi mi MIBLOCKSIZE src mi get sb partition size range xd left sb64 mi min size max size bs hist if above in image MODEINFO above sb64 mi mi xd mi stride MIBLOCKSIZE src mi get sb partition size range xd above sb64 mi min size max size bs hist if cpi sf auto min max partition size RELAXEDNEIGHBORINGMINMAX min size min partition size min size max size max partition size max size else if cpi sf auto min max partition size CONSTRAINNEIGHBORINGMINMAX int sum 0 int first moment 0 int second moment 0 int var unnormalized 0 for i 0 i BLOCKSIZES i sum bs hist i first moment bs hist i i second moment bs hist i i i var unnormalized second moment first moment first moment sum if var unnormalized 4 sum int mean first moment sum min size min partition size mean max size max partition size mean else min size min partition size min size max size max partition size max size max size find partition size max size row8x8 remaining col8x8 remaining bh bw min size MIN min size max size if cpi sf use square partition only next square size max size min size min size next square size max size min block size min size max block size max size static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size Zmbv Context const c avctx priv data int zret ZOK int len buf size int hi ver lo ver ret uint8 t tmp if c pic data 0 avctx release buffer avctx c pic c pic reference 1 c pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx c pic 0 av log avctx AVLOGERROR get buffer failed n return ret c flags buf 0 buf len if c flags ZMBVKEYFRAME hi ver buf 0 lo ver buf 1 c comp buf 2 c fmt buf 3 c bw buf 4 c bh buf 5 c decode intra NULL c decode xor NULL buf 6 len 6 av log avctx AVLOGDEBUG Flags X ver i i comp i fmt i blk ix i n c flags hi ver lo ver c comp c fmt c bw c bh if hi ver 0 lo ver 1 av log ask for sample avctx Unsupported version i i n hi ver lo ver return AVERRORPATCHWELCOME if c bw 0 c bh 0 av log ask for sample avctx Unsupported block size ix i n c bw c bh return AVERRORPATCHWELCOME if c comp 0 c comp 1 av log ask for sample avctx Unsupported compression type i n c comp return AVERRORPATCHWELCOME switch c fmt case ZMBVFMT 8 BPP c bpp 8 c decode intra zmbv decode intra c decode xor zmbv decode xor 8 break case ZMBVFMT 15 BPP case ZMBVFMT 16 BPP c bpp 16 c decode intra zmbv decode intra c decode xor zmbv decode xor 16 break c decode intra zmbv decode intra c decode xor zmbv decode xor 24 break c decode intra zmbv decode intra c decode xor zmbv decode xor 32 break default c decode intra NULL c decode xor NULL av log ask for sample avctx Unsupported for now format i n c fmt return AVERRORPATCHWELCOME zret inflate Reset c zstream if zret ZOK av log avctx AVLOGERROR Inflate reset error d n zret return AVERRORUNKNOWN tmp av realloc c cur avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c cur tmp tmp av realloc c prev avctx width avctx height c bpp 8 if tmp return AVERRORENOMEM c prev tmp c bx c width c bw 1 c bw c by c height c bh 1 c bh if c decode intra NULL av log avctx AVLOGERROR Error Got no format or no keyframe n return AVERRORINVALIDDATA if c comp 0 memcpy c decomp buf buf len c decomp size 1 else c zstream total in c zstream total out 0 c zstream next in buf c zstream avail in len c zstream next out c decomp buf c zstream avail out c decomp size zret inflate c zstream ZSYNCFLUSH if zret ZOK zret ZSTREAMEND av log avctx AVLOGERROR inflate error d n zret return AVERRORINVALIDDATA c decomp len c zstream total out if c flags ZMBVKEYFRAME c pic key frame 1 c pic pict type AVPICTURETYPEI c decode intra c else c pic key frame 0 c pic pict type AVPICTURETYPEP if c decomp len c decode xor c uint8 t out src int i j out c pic data 0 src c cur switch c fmt case ZMBVFMT 8 BPP for j 0 j c height j for i 0 i c width i out i 3 0 c pal src 3 0 out i 3 1 c pal src 3 1 out i 3 2 c pal src 3 2 src out c pic linesize 0 break case ZMBVFMT 15 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x7 C00 7 out i 3 1 tmp 0x03 E0 2 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break case ZMBVFMT 16 BPP for j 0 j c height j for i 0 i c width i uint16 t tmp AVR L16 src src 2 out i 3 0 tmp 0x F800 8 out i 3 1 tmp 0x07 E0 3 out i 3 2 tmp 0x001 F 3 out c pic linesize 0 break j c height j memcpy out src c width 3 src c width 3 out c pic linesize 0 break j c height j for i 0 i c width i uint32 t tmp AVR L32 src src 4 AVW B24 out i 3 tmp out c pic linesize 0 break default av log avctx AVLOGERROR Cannot handle format i n c fmt FFSWAP uint8 t c cur c prev got frame 1 AV Frame data c pic return buf size static char rfc2047 decode word const char s size t len enum Content Encoding enc const char it s const char end s len if enc ENCQUOTEDPRINTABLE struct Buffer buf 0 for it end it if it mutt buffer addch buf else if it it 1 127 hexval it 1 1 it 2 127 hexval it 2 1 mutt buffer addch buf hexval it 1 4 hexval it 2 it 2 else mutt buffer addch buf it mutt buffer addch buf 0 return buf data else if enc ENCBAS E64 const int olen 3 len 4 1 char out mutt mem malloc olen int dlen mutt b64 decode out it olen if dlen 1 FREE out return NULL out dlen 0 return out assert 0 return static void vc1 decode i blocks V C1 Context v int k j Mpeg Enc Context s v s int cbp val uint8 t coded val int mb pos switch v y ac table index case 0 v codingset v pqindex 8 CSHIGHRATEINTRACSLOWMOTINTRA break case 1 v codingset CSHIGHMOTINTRA break case 2 v codingset CSMIDRATEINTRA break switch v c ac table index case 0 v codingset2 v pqindex 8 CSHIGHRATEINTERCSLOWMOTINTER break case 1 v codingset2 CSHIGHMOTINTER break case 2 v codingset2 CSMIDRATEINTER break s y dc scale s y dc scale table v pq s c dc scale s c dc scale table v pq s mb x s mb y 0 s mb intra 1 s first slice line 1 for s mb y 0 s mb y s end mb y s mb y s mb x 0 ff init block index s for s mb x v end mb x s mb x uint8 t dst 6 ff update block index s dst 0 s dest 0 dst 1 dst 0 8 dst 2 s dest 0 s linesize 8 dst 3 dst 2 8 dst 4 s dest 1 dst 5 s dest 2 s dsp clear blocks s block 0 mb pos s mb x s mb y s mb width s current picture f mb type mb pos MBTYPEINTRA s current picture f qscale table mb pos v pq s current picture f motion val 1 s block index 0 0 0 s current picture f motion val 1 s block index 0 1 0 cbp get vlc2 v s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 v s ac pred get bits1 v s gb for k 0 k 6 k val cbp 5 k 1 if k 4 int pred vc1 coded block pred v s k coded val val val pred coded val val cbp val 5 k vc1 decode i block v s block k k val k 4 v codingset v codingset2 if k 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block k if v pq 9 v overlap if v rangeredfrm for j 0 j 64 j s block k j 1 s dsp put signed pixels clamped s block k dst k k 4 s uvlinesize s linesize else if v rangeredfrm for j 0 j 64 j s block k j s block k j 64 1 s dsp put pixels clamped s block k dst k k 4 s uvlinesize s linesize if v pq 9 v overlap if s mb x v vc1dsp vc1 h overlap s dest 0 s linesize v vc1dsp vc1 h overlap s dest 0 8 s linesize s linesize if s flags CODECFLAGGRAY v vc1dsp vc1 h overlap s dest 1 s uvlinesize v vc1dsp vc1 h overlap s dest 2 s uvlinesize v vc1dsp vc1 h overlap s dest 0 8 s linesize v vc1dsp vc1 h overlap s dest 0 8 s linesize 8 s linesize if s first slice line v vc1dsp vc1 v overlap s dest 0 s linesize v vc1dsp vc1 v overlap s dest 0 8 s linesize if s flags CODECFLAGGRAY v vc1dsp vc1 v overlap s dest 1 s uvlinesize v vc1dsp vc1 v overlap s dest 2 s uvlinesize v vc1dsp vc1 v overlap s dest 0 8 s linesize s linesize v vc1dsp vc1 v overlap s dest 0 8 s linesize 8 s linesize if v s loop filter vc1 loop filter iblk v v pq if get bits count s gb v bits ff er add slice s er 0 0 s mb x s mb y ERMBERROR av log s avctx AVLOGERROR Bits overconsumption i i n get bits count s gb v bits return if v s loop filter ff mpeg draw horiz band s s mb y 16 16 else if s mb y ff mpeg draw horiz band s s mb y 1 16 16 s first slice line 0 if v s loop filter ff mpeg draw horiz band s s end mb y 1 16 16 ff er add slice s er 0 0 s mb width 1 s mb height 1 static int set and cost bmi mvs V P9 COMP cpi MACROBLOCKD xd int i PREDICTIONMODE mode int mv this mv 2 int mv frame mv MBMODECOUNTMAXREFFRAMES int mv seg mvs MAXREFFRAMES int mv best ref mv 2 const int mvjcost int mvcost 2 MODEINFO const mic xd mi 0 const MBMODEINFO const mbmi mic mbmi int thismvcost 0 int idx idy const int num 4x4 blocks wide num 4x4 blocks wide lookup mbmi sb type const int num 4x4 blocks high num 4x4 blocks high lookup mbmi sb type const int is compound has second ref mbmi switch mode case NEWMV this mv 0 as int seg mvs mbmi ref frame 0 as int thismvcost vp9 mv bit cost this mv 0 as mv best ref mv 0 as mv mvjcost mvcost MVCOSTWEIGHTSUB if is compound this mv 1 as int seg mvs mbmi ref frame 1 as int thismvcost vp9 mv bit cost this mv 1 as mv best ref mv 1 as mv mvjcost mvcost MVCOSTWEIGHTSUB break case NEARMV case NEARESTMV this mv 0 as int frame mv mode mbmi ref frame 0 as int if is compound this mv 1 as int frame mv mode mbmi ref frame 1 as int break case ZEROMV this mv 0 as int 0 if is compound this mv 1 as int 0 break default break mic bmi i as mv 0 as int this mv 0 as int if is compound mic bmi i as mv 1 as int this mv 1 as int mic bmi i as mode mode for idy 0 idy num 4x4 blocks high idy for idx 0 idx num 4x4 blocks wide idx vpx memcpy mic bmi i idy 2 idx mic bmi i sizeof mic bmi i return cost mv ref cpi mode mbmi mode context mbmi ref frame 0 thismvcost static int decode slice AV Codec Context avctx void tdata Prores Thread Data td tdata Prores Context ctx avctx priv data int mb x pos td x pos int mb y pos td y pos int pic num ctx pic num int slice num td slice num int mbs per slice td slice width const uint8 t buf uint8 t y data u data v data AV Frame pic avctx coded frame int i sf slice width factor int slice data size hdr size y data size u data size v data size int y linesize u linesize v linesize buf ctx slice data slice num index slice data size ctx slice data slice num 1 index buf slice width factor av log2 mbs per slice y data pic data 0 u data pic data 1 v data pic data 2 y linesize pic linesize 0 u linesize pic linesize 1 v linesize pic linesize 2 if pic interlaced frame if pic num pic top field first y data y linesize u data u linesize v data v linesize y linesize 1 u linesize 1 v linesize 1 if slice data size 6 av log avctx AVLOGERROR slice data too small n return AVERRORINVALIDDATA hdr size buf 0 3 y data size AVR B16 buf 2 u data size AVR B16 buf 4 v data size hdr size 7 AVR B16 buf 6 slice data size y data size u data size hdr size if hdr size y data size u data size v data size slice data size v data size 0 hdr size 6 av log avctx AVLOGERROR invalid data size n return AVERRORINVALIDDATA sf av clip buf 1 1 224 sf sf 128 sf 96 2 sf if ctx qmat changed sf td prev slice sf td prev slice sf sf for i 0 i 64 i td qmat luma scaled ctx dsp idct permutation i ctx qmat luma i sf td qmat chroma scaled ctx dsp idct permutation i ctx qmat chroma i sf decode slice plane ctx td buf hdr size y data size uint16 t y data mb y pos 4 y linesize mb x pos 5 y linesize mbs per slice 4 slice width factor 2 td qmat luma scaled 0 decode slice plane ctx td buf hdr size y data size u data size uint16 t u data mb y pos 4 u linesize mb x pos ctx mb chroma factor u linesize mbs per slice ctx num chroma blocks slice width factor ctx chroma factor 1 td qmat chroma scaled 1 decode slice plane ctx td buf hdr size y data size u data size v data size uint16 t v data mb y pos 4 v linesize mb x pos ctx mb chroma factor v linesize mbs per slice ctx num chroma blocks slice width factor ctx chroma factor 1 td qmat chroma scaled 1 return 0 void do exec struct st command command int error char buf 512 FILE res file char cmd command first argument DYNAMICSTRING ds cmd DYNAMICSTRING ds sorted ds result DBUGENTER do exec DBUGPRINT enter cmd s cmd while cmd my isspace charset info cmd cmd if cmd report or die Missing argument in exec return command last argument command end init dynamic string ds cmd 0 command query len 256 256 do eval ds cmd cmd command end is windows if builtin echo 0 strncmp cmd echo 4 0 replace ds cmd echo 4 builtin echo strlen builtin echo while replace ds cmd 3 4 3 0 DBUGPRINT info Executing s as s command first argument ds cmd str if res file my popen ds cmd r dynstr free ds cmd if command abort on error report or die popen s r failed command first argument return ds result ds res if display result sorted init dynamic string ds sorted 1024 1024 ds result ds sorted while fgets buf sizeof buf res file if disable result log buf strlen buf 1 0 DBUGPRINT exec result s buf else replace dynstr append ds result buf error pclose res file if display result sorted dynstr append sorted ds res ds sorted 0 dynstr free ds sorted if error 0 uint status WEXITSTATUS error int i if command abort on error report or die exec of s failed error d status d errno d n Output from before failure n s n ds cmd str error status errno ds res str dynstr free ds cmd return DBUGPRINT info error d status d error status i match expected error command status NULL if i 0 DBUGPRINT info command s failed with expected error d command first argument status else dynstr free ds cmd if command expected errors count 0 report or die command s failed with wrong error d command first argument status else if command expected errors err 0 type ERRERRNO command expected errors err 0 code errnum 0 log msg exec of s failed error d errno d ds cmd str error errno dynstr free ds cmd report or die command s succeeded should have failed with errno d command first argument command expected errors err 0 code errnum dynstr free ds cmd int main int argc char argv WSADATA wsa Data int err w Version Requested MAKEWORD 2 2 err WSA Startup w Version Requested wsa Data global base event init test registerfds test evutil strtoll test priorities 1 test priorities 2 test priorities 3 test evbuffer test evbuffer find test evbuffer readln test bufferevent test bufferevent watermarks test free active base test event base new http suite test simplewrite test multiple test persistent test combined test simpletimeout test multiplesignal test immediatesignal test loopbreak test loopexit multiple test multiple events for same fd test want only once evtag test test signal dealloc test signal pipeloss test signal switchbase test signal restore test signal assert test signal while processing static int userauth hostbased struct ssh ssh Authctxt authctxt ssh authctxt struct sshbuf b struct sshkey key NULL char pkalg cuser chost u char pkblob sig size t alen blen slen int r pktype authenticated 0 if authctxt valid debug2 s disabled because of invalid user func return 0 if r sshpkt get cstring ssh pkalg alen 0 r sshpkt get string ssh pkblob blen 0 r sshpkt get cstring ssh chost NULL 0 r sshpkt get cstring ssh cuser NULL 0 r sshpkt get string ssh sig slen 0 fatal s packet parsing s func ssh err r debug s cuser s chost s pkalg s slen zu func cuser chost pkalg slen sshbuf dump data sig siglen stderr if pktype KEYUNSPEC logit s unsupported public key algorithm s func pkalg goto done if r sshkey from blob pkblob blen key 0 error s key from blob s func ssh err r goto done if key NULL error s cannot decode key s func pkalg goto done if key type pktype error s type mismatch for decoded key received d expected d func key type pktype goto done if sshkey type plain key type KEYRSA ssh compat SSHBUGRSASIGM D5 0 error Refusing RSA key because peer uses unsafe signature format goto done if match pattern list pkalg options hostbased key types 0 1 logit s key type s not in Hostbased Accepted Key Types func sshkey type key goto done if b sshbuf new NULL fatal s sshbuf new failed func if r sshbuf put string b session id2 session id2 len 0 r sshbuf put u8 b SS H2 MSGUSERAUTHREQUEST 0 r sshbuf put cstring b authctxt user 0 r sshbuf put cstring b authctxt service 0 r sshbuf put cstring b hostbased 0 r sshbuf put string b pkalg alen 0 r sshbuf put string b pkblob blen 0 r sshbuf put cstring b chost 0 r sshbuf put cstring b cuser 0 fatal s buffer error s func ssh err r authenticated 0 if PRIVSEP hostbased key allowed authctxt pw cuser chost key PRIVSEP sshkey verify key sig slen sshbuf ptr b sshbuf len b pkalg ssh compat 0 authenticated 1 auth2 record key authctxt authenticated key sshbuf free b done debug2 s authenticated d func authenticated sshkey free key free pkalg free pkblob free cuser free chost free sig return authenticated static void slurm rpc allocate resources slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESS slurm msg t response msg DEFTIMERS job desc msg t job desc msg job desc msg t msg data resource allocation response msg t alloc msg slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info int immediate job desc msg immediate bool do unlock false bool reject job false struct job record job ptr NULL uint16 t port slurm addr t resp addr char err msg NULL job submit user msg NULLSTARTTIMER if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if uid job desc msg user id validate slurm user uid error code ESLURMUSERIDMISSING error Security violation RESOURCEALLOCATE from uid d uid debug2 sched Processing RPCREQUESTRESOURCEALLOCATION from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTRESOURCEALLOCATE lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg error code ESLURMRESERVATIONBUSY error attempt to nest ALPS allocation on s d by uid d job desc msg alloc node job desc msg alloc sid uid static int xan decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int ret buf size avpkt size Xan Context s avctx priv data Get Byte Context ctx int tag 0 bytestream2 init ctx buf buf size while bytestream2 get bytes left ctx 8 tag VGATAG unsigned tmpptr uint32 t new pal int size int i tag bytestream2 get le32 ctx size bytestream2 get be32 ctx size FFMIN size bytestream2 get bytes left ctx switch tag case PALTTAG if size PALETTESIZE return AVERRORINVALIDDATA if s palettes count PALETTESMAX return AVERRORINVALIDDATA tmpptr av realloc s palettes s palettes count 1 AVPALETTESIZE if tmpptr return AVERRORENOMEM s palettes tmpptr tmpptr s palettes count AVPALETTECOUNT for i 0 i PALETTECOUNT i int g gamma corr bytestream2 get byteu ctx int b gamma corr bytestream2 get byteu ctx int g gamma lookup bytestream2 get byteu ctx int b gamma lookup bytestream2 get byteu ctx s palettes count break case SHOTTAG if size 4 return AVERRORINVALIDDATA new pal bytestream2 get le32 ctx if new pal s palettes count s cur palette new pal else av log avctx AVLOGERROR Invalid palette selected n break case VGATAG break default bytestream2 skip ctx size break buf size bytestream2 get bytes left ctx if s palettes count 0 av log s avctx AVLOGERROR No palette found n return AVERRORINVALIDDATA if ret ff get buffer avctx frame AVGETBUFFERFLAGREF av log s avctx AVLOGERROR get buffer failed n return ret if s frame size s frame size frame linesize 0 s avctx height memcpy frame data 1 s palettes s cur palette AVPALETTECOUNTAVPALETTESIZE s buf ctx buffer s size buf size if xan wc3 decode frame s frame 0 return AVERRORINVALIDDATA av frame unref s last frame if ret av frame ref s last frame frame 0 return ret got frame 1 return buf size int64 t cpu get icount void int64 t icount CPU Arch State env cpu single env icount qemu icount if env if can do io env fprintf stderr Bad clock read n icount env icount decr u16 low env icount extra return qemu icount bias icount icount time shift int ff mpeg4 set direct mv Mpeg Enc Context s int mx int my const int mb index s mb x s mb y s mb stride const int colocated mb type s next picture mb type mb index uint16 t time pp uint16 t time pb int i if IS 8 X8 colocated mb type s mv type MVTYPE 8 X8 for i 0 i 4 i ff mpeg4 set one direct mv s mx my i return MBTYPEDIREC T2 MBTYPE 8x8 MBTYPE L0 L1 else if ISINTERLACED colocated mb type s mv type MVTYPEFIELD for i 0 i 2 i int field select s next picture ref index 0 4 mb index 2 i s field select 0 i field select s field select 1 i i if s top field first time pp s pp field time field select i time pb s pb field time field select i else time pp s pp field time field select i time pb s pb field time field select i s mv 0 i 0 s p field mv table i 0 mb index 0 time pb time pp mx s mv 0 i 1 s p field mv table i 0 mb index 1 time pb time pp my s mv 1 i 0 mx s mv 0 i 0 s p field mv table i 0 mb index 0 s p field mv table i 0 mb index 0 time pb time pp time pp s mv 1 i 1 my s mv 0 i 1 s p field mv table i 0 mb index 1 s p field mv table i 0 mb index 1 time pb time pp time pp return MBTYPEDIREC T2 MBTYPE 16x8 MBTYPE L0 L1 MBTYPEINTERLACED else ff mpeg4 set one direct mv s mx my 0 s mv 0 1 0 s mv 0 2 0 s mv 0 3 0 s mv 0 0 0 s mv 0 1 1 s mv 0 2 1 s mv 0 3 1 s mv 0 0 1 s mv 1 1 0 s mv 1 2 0 s mv 1 3 0 s mv 1 0 0 s mv 1 1 1 s mv 1 2 1 s mv 1 3 1 s mv 1 0 1 if s avctx workaround bugs FFBUGDIRECTBLOCKSIZE s quarter sample s mv type MVTYPE 16 X16 else s mv type MVTYPE 8 X8 return MBTYPEDIREC T2 MBTYPE 16x16 MBTYPE L0 L1 static void parse mb skip Wmv2 Context w int mb x mb y Mpeg Enc Context const s w s uint32 t const mb type s current picture ptr mb type w skip type get bits s gb 2 switch w skip type case SKIPTYPENONE for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEMPEG for mb y 0 mb y s mb height mb y for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPEROW for mb y 0 mb y s mb height mb y if get bits1 s gb for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb x 0 mb x s mb width mb x mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break case SKIPTYPECOL for mb x 0 mb x s mb width mb x if get bits1 s gb for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x MBTYPESKIPMBTYPE 16x16 MBTYPE L0 else for mb y 0 mb y s mb height mb y mb type mb y s mb stride mb x get bits1 s gb MBTYPESKIP 0 MBTYPE 16x16 MBTYPE L0 break static int matroska read seek AV Format Context s int stream index int64 t timestamp int flags Matroska Demux Context matroska s priv data Matroska Track tracks NULLAV Stream st s streams stream index int i index index sub index min if matroska cues parsing deferred matroska parse cues matroska matroska cues parsing deferred 0 if st nb index entries return 0 timestamp FFMAX timestamp st index entries 0 timestamp if index av index search timestamp st timestamp flags 0 avio seek s pb st index entries st nb index entries 1 pos SEEKSET matroska current id 0 while index av index search timestamp st timestamp flags 0 matroska clear queue matroska if matroska parse cluster matroska 0 break matroska clear queue matroska if index 0 return 0 index min index tracks matroska tracks elem for i 0 i matroska tracks nb elem i tracks i audio pkt cnt 0 tracks i audio sub packet cnt 0 tracks i audio buf timecode AVNOPTSVALUE tracks i end timecode 0 if tracks i type MATROSKATRACKTYPESUBTITLE tracks i stream discard AVDISCARDALL index sub av index search timestamp tracks i stream st index entries index timestamp AVSEEKFLAGBACKWARD if index sub 0 st index entries index sub pos st index entries index min pos st index entries index timestamp st index entries index sub timestamp 30000000000 matroska time scale index min index sub avio seek s pb st index entries index min pos SEEKSET matroska current id 0 matroska skip to keyframe flags AVSEEKFLAGANY matroska skip to timecode st index entries index timestamp matroska done 0 ff update cur dts s st st index entries index timestamp return 0 static int64 t rd pick intra sby mode V P9 COMP cpi MACROBLOCK x int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize int64 t tx cache TXMODES int64 t best rd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPREDMACROBLOCKD const xd x e mbd MODEINFO const mic xd mi 0 int this rate this rate tokenonly s int64 t this distortion this rd TXSIZE best tx TX 4 X4 int i int bmode costs cpi mbmode cost if cpi sf tx size search method USEFULLRD for i 0 i TXMODES i tx cache i IN T64 MAX for mode DCPRED mode TMPRED mode int64 t local tx cache TXMODESMODEINFO above mi xd mi xd mi stride MODEINFO left mi xd left available xd mi 1 NULL if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi 0 const PREDICTIONMODEL vp9 left block mode mic left mi 0 bmode costs cpi y mode costs AL mic mbmi mode mode super block yrd cpi x this rate tokenonly this distortion s NULL bsize local tx cache best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly bmode costs mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd best tx mic mbmi tx size rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if cpi sf tx size search method USEFULLRD this rd IN T64 MAX for i 0 i TXMODES local tx cache i IN T64 MAX i const int64 t adj rd this rd local tx cache i local tx cache cpi common tx mode if adj rd tx cache i tx cache i adj rd mic mbmi mode mode selected mic mbmi tx size best tx return best rd static void erase line AV Codec Context avctx int xoffset int xlength Ansi Context s avctx priv data int i for i 0 i s font height i memset s frame data 0 s y i s frame linesize 0 xoffset DEFAULTBGCOLOR xlength double mcv selectivity Variable Stat Data vardata Fmgr Info opproc Datum constval bool varonleft double sumcommonp double mcv selec sumcommon Datum values int nvalues float4 numbers int nnumbers int i mcv selec 0 0 sumcommon 0 0 if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opproc fn oid get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDMCV Invalid Oid NULL values nvalues numbers nnumbers for i 0 i nvalues i if varonleft Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID values i constval Datum Get Bool Function Call2 Coll opproc DEFAULTCOLLATIONOID constval values i mcv selec numbers i sumcommon numbers i free attstatsslot vardata atttype values nvalues numbers nnumbers sumcommonp sumcommon return mcv selec void vp9 set rd speed thresholds V P9 COMP cpi int i RDOPT const rd cpi rd SPEEDFEATURES const sf cpi sf for i 0 i MAXMODES i rd thresh mult i cpi oxcf mode BEST 500 0 rd thresh mult THRNEARESTMV 0 rd thresh mult THRNEARESTG 0 rd thresh mult THRNEARESTA 0 rd thresh mult THRDC 1000 rd thresh mult THRNEWMV 1000 rd thresh mult THRNEWA 1000 rd thresh mult THRNEWG 1000 rd thresh mult THRNEWMV sf elevate newmv thresh rd thresh mult THRNEARMV 1000 rd thresh mult THRNEARA 1000 rd thresh mult THRCOMPNEARESTLA 1000 rd thresh mult THRCOMPNEARESTGA 1000 rd thresh mult THRTM 1000 rd thresh mult THRCOMPNEARLA 1500 rd thresh mult THRCOMPNEWLA 2000 rd thresh mult THRNEARG 1000 rd thresh mult THRCOMPNEARGA 1500 rd thresh mult THRCOMPNEWGA 2000 rd thresh mult THRZEROMV 2000 rd thresh mult THRZEROG 2000 rd thresh mult THRZEROA 2000 rd thresh mult THRCOMPZEROLA 2500 rd thresh mult THRCOMPZEROGA 2500 rd thresh mult THRHPRED 2000 rd thresh mult THRVPRED 2000 rd thresh mult THR D45 PRED 2500 rd thresh mult THR D135 PRED 2500 rd thresh mult THR D117 PRED 2500 rd thresh mult THR D153 PRED 2500 rd thresh mult THR D207 PRED 2500 rd thresh mult THR D63 PRED 2500 if cpi ref frame flags V P9 LASTFLAG rd thresh mult THRNEWMVINTMAX rd thresh mult THRNEARESTMVINTMAX rd thresh mult THRZEROMVINTMAX rd thresh mult THRNEARMVINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult THRNEARESTGINTMAX rd thresh mult THRZEROGINTMAX rd thresh mult THRNEARGINTMAX rd thresh mult THRNEWGINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult THRNEARESTAINTMAX rd thresh mult THRZEROAINTMAX rd thresh mult THRNEARAINTMAX rd thresh mult THRNEWAINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROLAINTMAX rd thresh mult THRCOMPNEARESTLAINTMAX rd thresh mult THRCOMPNEARLAINTMAX rd thresh mult THRCOMPNEWLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROGAINTMAX rd thresh mult THRCOMPNEARESTGAINTMAX rd thresh mult THRCOMPNEARGAINTMAX rd thresh mult static int rv34 set deblock coef R V34 Dec Context r Mpeg Enc Context s r s int hmvmask 0 vmvmask 0 i j int midx s mb x 2 s mb y 2 s b8 stride int16 t motion val 2 s current picture ptr f motion val 0 midx for j 0 j 16 j 8 for i 0 i 2 i if is mv diff gt 3 motion val i 1 vmvmask 0x11 j i 2 if j s mb y is mv diff gt 3 motion val i s b8 stride hmvmask 0x03 j i 2 motion val s b8 stride if s first slice line hmvmask 0x000 F if s mb x vmvmask 0x1111 if r rv30 vmvmask vmvmask 0x4444 1 hmvmask hmvmask 0x0 F00 4 if s mb x r deblock coefs s mb x 1 s mb y s mb stride vmvmask 0x1111 3 if s first slice line r deblock coefs s mb x s mb y 1 s mb stride hmvmask 0x F 12 return hmvmask vmvmask static int lexescape struct vars v chr c static const chr alert CHR a CHR l CHR e CHR r CHR t static const chr esc CHRECHRSCHRC const chr save assert v cflags REGADVF assert ATEOS c v now if iscalnum c RETVPLAIN c NOTEREGUNONPOSIX switch c case CHR a RETVPLAIN chrnamed v alert ENDOF alert CHR 007 break case CHRARETVSBEGIN 0 break case CHR b RETVPLAINCHR b break case CHRBRETVPLAINCHR break case CHR c NOTEREGUUNPORT if ATEOSFAILWREGEESCAPERETVPLAIN chr v now 037 break case CHR d NOTEREGULOCALERETVCCLASS d break case CHRDNOTEREGULOCALERETVCCLASSD break case CHR e NOTEREGUUNPORTRETVPLAIN chrnamed v esc ENDOF esc CHR 033 break case CHR f RETVPLAINCHR f break case CHR m RET break case CHRMRET break case CHR n RETVPLAINCHR n break case CHR r RETVPLAINCHR r break case CHR s NOTEREGULOCALERETVCCLASS s break case CHRSNOTEREGULOCALERETVCCLASSS break case CHR t RETVPLAINCHR t break case CHR u c lexdigits v 16 4 4 if ISERRFAILWREGEESCAPERETVPLAIN c break case CHRU c lexdigits v 16 8 8 if ISERRFAILWREGEESCAPERETVPLAIN c break case CHR v RETVPLAINCHR v break case CHR w NOTEREGULOCALERETVCCLASS w break case CHRWNOTEREGULOCALERETVCCLASSW break case CHR x NOTEREGUUNPORT c lexdigits v 16 1 255 if ISERRFAILWREGEESCAPERETVPLAIN c break case CHR y NOTEREGULOCALERETVWBDRY 0 break case CHRYNOTEREGULOCALERETVNWBDRY 0 break case CHRZRETVSEND 0 break case CHR 1 case CHR 2 case CHR 3 case CHR 4 case CHR 5 case CHR 6 case CHR 7 case CHR 8 case CHR 9 save v now v now c lexdigits v 10 1 255 if ISERRFAILWREGEESCAPE if v now save int c 0 int c v nsubexp NOTEREGUBACKREFRETVBACKREF chr c v now save case CHR 0 NOTEREGUUNPORT v now c lexdigits v 8 1 3 if ISERRFAILWREGEESCAPE if c 0xff v now c 3 RETVPLAIN c break default assert iscalpha c FAILWREGEESCAPE break assert static void pk transaction authorize actions finished cb G Object source object G Async Result res struct Authorize Actions Data data const gchar action id NULL Pk Transaction Private priv data transaction priv g autoptr G Error error NULL g autoptr Polkit Authorization Result result NULL g assert data actions data actions len 0 action id g ptr array index data actions 0 result polkit authority check authorization finish priv authority res error if g cancellable is cancelled priv cancellable priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED The authentication was cancelled due to a timeout pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if result NULL g autofree gchar message NULL priv waiting for auth FALSE g warning failed to check for auth s error message pk transaction status changed emit data transaction PKSTATUSENUMFINISHED message g strdup printf Failed to check for authentication s error message pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED message pk transaction finished emit data transaction PKEXITENUMFAILED 0 goto out if polkit authorization result get is authorized result if g strcmp0 action id org freedesktop packagekit package install 0 pk bitfield contain priv cached transaction flags PKTRANSACTIONFLAGENUMALLOWREINSTALL g debug allowing just reinstallation pk bitfield add priv cached transaction flags PKTRANSACTIONFLAGENUMJUSTREINSTALL else priv waiting for auth FALSE pk transaction status changed emit data transaction PKSTATUSENUMFINISHED pk transaction error code emit data transaction PKERRORENUMNOTAUTHORIZED Failed to obtain authentication pk transaction finished emit data transaction PKEXITENUMFAILED 0 syslog LOGAUTHLOGNOTICE uid i failed to obtain auth priv uid goto out if data actions len 1 priv waiting for auth FALSE pk transaction set state data transaction PKTRANSACTIONSTATEREADY syslog LOGAUTHLOGINFO uid i obtained auth for s priv uid action id else g ptr array remove index data actions 0 pk transaction authorize actions data transaction data role data actions out g ptr array unref data actions g free data void vp9 rc update rate correction factors V P9 COMP cpi int damp var const V P9 COMMON const cm cpi common int correction factor 100 double rate correction factor get rate correction factor cpi double adjustment limit int projected size based on q 0 if cpi rc is src frame alt ref return vp9 clear system state projected size based on q estimate bits at q cm frame type cm base qindex cm M Bs rate correction factor cm bit depth if projected size based on q 0 correction factor 100 cpi rc projected frame size projected size based on q switch damp var case 0 adjustment limit 0 75 break case 1 adjustment limit 0 375 break case 2 default adjustment limit 0 25 break if correction factor 102 correction factor int 100 correction factor 100 adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MAXBPBFACTOR rate correction factor MAXBPBFACTOR else if correction factor 99 correction factor int 100 100 correction factor adjustment limit rate correction factor rate correction factor correction factor 100 if rate correction factor MINBPBFACTOR rate correction factor MINBPBFACTOR set rate correction factor cpi rate correction factor static int svq1 encode frame AV Codec Context avctx AV Packet pkt const AV Frame pict int got packet SV Q1 Context const s avctx priv data AV Frame const p s picture AV Frame temp int i ret if pkt data ret av new packet pkt s y block width s y block height MAXMBBYTES 3 FFMINBUFFERSIZE 0 av log avctx AVLOGERROR Error getting output packet n return ret if avctx pix fmt AVPIXFMTYU V410 P av log avctx AVLOGERROR unsupported pixel format n return 1 if s current picture data 0 ff get buffer avctx s current picture 0 ff get buffer avctx s last picture 0 s scratchbuf av malloc s current picture linesize 0 16 2 temp s current picture s current picture s last picture s last picture temp init put bits s pb pkt data pkt size p pict p pict type avctx gop size avctx frame number avctx gop size AVPICTURETYPEPAVPICTURETYPEI p key frame p pict type AVPICTURETYPEI svq1 write header s p pict type for i 0 i 3 i if svq1 encode plane s i s picture data i s last picture data i s current picture data i s frame width i 4 1 s frame height i 4 1 s picture linesize i s current picture linesize i 0 return 1 while put bits count s pb 31 put bits s pb 1 0 flush put bits s pb pkt size put bits count s pb 8 if p pict type AVPICTURETYPEI pkt flags AVPKTFLAGKEY got packet 1 return 0 uint8 t jbig2 decode gray scale image Jbig2 Ctx ctx Jbig2 Segment segment const byte data const size t size bool GSMMR uint32 t GSW uint32 t GSH uint32 t GSBPP bool GSUSESKIP Jbig2 Image GSKIP int GSTEMPLATE Jbig2 Arith Cx GB stats uint8 t GSVALSNULL size t consumed bytes 0 int i j code stride int x y Jbig2 Image GSPLANES Jbig2 Generic Region Params rparams Jbig2 Word Stream ws NULL Jbig2 Arith State as NULLGSPLANES jbig2 new ctx Jbig2 Image GSBPP if GSPLANESNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate d bytes for GSPLANESGSBPP return NULL for i 0 i GSBPP i GSPLANES i jbig2 image new ctx GSWGSH if GSPLANES i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate dx d image for GSPLANESGSWGSH for j i 1 j 0 j jbig2 image release ctx GSPLANES j jbig2 free ctx allocator GSPLANES return NULL rparams MMRGSMMR rparams GBTEMPLATEGSTEMPLATE rparams TPGDON 0 rparams USESKIPGSUSESKIP rparams gbat 0 GSTEMPLATE 1 3 2 rparams gbat 1 1 rparams gbat 2 3 rparams gbat 3 1 rparams gbat 4 2 rparams gbat 5 2 rparams gbat 6 2 rparams gbat 7 2 if GSMMR code jbig2 decode halftone mmr ctx rparams data size GSPLANESGSBPP 1 consumed bytes else ws jbig2 word stream buf new ctx data size if ws NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate ws in jbig2 decode gray scale image goto cleanup as jbig2 arith new ctx ws if as NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate as in jbig2 decode gray scale image goto cleanup code jbig2 decode generic region ctx segment rparams as GSPLANESGSBPP 1 GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup j GSBPP 2 while j 0 if GSMMR code jbig2 decode halftone mmr ctx rparams data consumed bytes size consumed bytes GSPLANES j consumed bytes else code jbig2 decode generic region ctx segment rparams as GSPLANES j GB stats if code 0 jbig2 error ctx JBI G2 SEVERITYFATAL segment number error decoding GSPLANES for halftone image goto cleanup stride GSPLANES 0 stride for i 0 i stride GSH i GSPLANES j data i GSPLANES j 1 data i j GSVALS jbig2 new ctx uint8 t GSW if GSVALSNULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSW goto cleanup for i 0 i GSW i GSVALS i jbig2 new ctx uint8 t GSH if GSVALS i NULL jbig2 error ctx JBI G2 SEVERITYFATAL segment number failed to allocate GSVALS d bytes GSHGSW for j i 1 j 0 j jbig2 free ctx allocator GSVALS j jbig2 free ctx allocator GSVALSGSVALSNULL goto cleanup for x 0 x GSW x for y 0 y GSH y GSVALS x y 0 for j 0 j GSBPP j GSVALS x y jbig2 image get pixel GSPLANES j x y j cleanup if GSMMR jbig2 free ctx allocator as jbig2 word stream buf free ctx ws for i 0 i GSBPP i jbig2 image release ctx GSPLANES i jbig2 free ctx allocator GSPLANES return static int search filter level const Y V12 BUFFERCONFIG sd V P9 COMP cpi int partial frame const V P9 COMMON const cm cpi common const struct loopfilter const lf cm lf const int min filter level 0 const int max filter level get max filter level cpi int filt direction 0 int best err filt best int filt mid clamp lf filter level min filter level max filter level int filter step filt mid 16 4 filt mid 4 int ss err MAXLOOPFILTER 1 vpx memset ss err 0x FF sizeof ss err vpx yv12 copy y cm frame to show cpi last frame uf best err try filter frame sd cpi filt mid partial frame filt best filt mid ss err filt mid best err while filter step 0 const int filt high MIN filt mid filter step max filter level const int filt low MAX filt mid filter step min filter level int filt err int bias best err 15 filt mid 8 filter step if cpi oxcf pass 2 cpi twopass section intra rating 20 bias bias cpi twopass section intra rating 20 if cm tx mode ONLY 4 X4 bias 1 if filt direction 0 filt low filt mid if ss err filt low 0 filt err try filter frame sd cpi filt low partial frame ss err filt low filt err else filt err ss err filt low if filt err bias best err if filt err best err best err filt err filt best filt low if filt direction 0 filt high filt mid if ss err filt high 0 filt err try filter frame sd cpi filt high partial frame ss err filt high filt err else filt err ss err filt high if filt err best err bias best err filt err filt best filt high if filt best filt mid filter step 2 filt direction 0 else filt direction filt best filt mid 1 1 filt mid filt best return filt best void ff MPV common defaults Mpeg Enc Context s s y dc scale table s c dc scale table ff mpeg1 dc scale table s chroma qscale table ff default chroma qscale table s progressive frame 1 s progressive sequence 1 s picture structure PICTFRAME s coded picture number 0 s picture number 0 s input picture number 0 s picture in gop number 0 s f code 1 s b code 1 s picture range start 0 s picture range end MAXPICTURECOUNT s slice context count 1 static int yop decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Yop Dec Context s avctx priv data AV Frame frame data int tag firstcolor is odd frame int ret i x y uint32 t palette if avpkt size 4 3 s num pal colors av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA ret ff get buffer avctx frame 0 if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset frame data 1 0 AVPALETTESIZE s dstbuf frame data 0 s dstptr frame data 0 s srcptr avpkt data 4 s src end avpkt data avpkt size s low nibble NULL is odd frame avpkt data 0 firstcolor s first color is odd frame palette uint32 t frame data 1 for i 0 i s num pal colors i s srcptr 3 palette i firstcolor s srcptr 0 18 s srcptr 1 10 s srcptr 2 2 frame palette has changed 1 for y 0 y avctx height y 2 for x 0 x avctx width x 2 if s srcptr avpkt data avpkt size av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA tag yop get next nibble s if tag 0xf ret yop paint block s frame linesize 0 tag if ret 0 return ret else tag yop get next nibble s ret yop copy previous block s frame linesize 0 tag if ret 0 return ret s dstptr 2 s dstptr 2 frame linesize 0 x got frame 1 return avpkt size static int do uncompress compress filter context t zfx z stream zs IOBUF a size t ret len int zrc int rc 0 int leave 0 size t n int nread count int refill zs avail in if DBGFILTER log debug begin inflate avail in u avail out u inbuf u n unsigned zs avail in unsigned zs avail out unsigned zfx inbufsize do if zs avail in zfx inbufsize refill n zs avail in if n ifndef riscos zs next in zfx inbuf nread iobuf read a zfx inbuf n count if nread 1 nread 0 n nread if nread count zfx algo 1 zfx algo1hack 4 zfx inbuf n 0x FF zfx algo1hack n leave 1 zs avail in n refill 1 if DBGFILTER log debug enter inflate avail in u avail out u n unsigned zs avail in unsigned zs avail out if zrc ZSTREAMEND rc 1 else if zrc ZOK zrc ZBUFERROR if zs msg log fatal zlib inflate problem s n zs msg else log fatal zlib inflate problem rc d n zrc while zs avail out zrc ZSTREAMEND zrc ZBUFERROR leave ret len zfx outbufsize zs avail out if DBGFILTER log debug do uncompress returning u bytes n unsigned ret len return rc static inline int gic get current cpu GIC State s if s num cpu 1 CPU State cpu ENVGETCPU cpu single env return cpu cpu index return 0 int test sqr BIO bp BNCTX ctx BIGNUM a c d e int i BN init a BN init c BN init d BN init e for i 0 i num0 i BN bntest rand a 40 i 10 0 0 a neg rand neg BN sqr c a ctx if bp NULL if results BN print bp a BIO puts bp BN print bp a BIO puts bp BN print bp c BIO puts bp n BN div d e c a ctx BN sub d d a if BN is zero d BN is zero e fprintf stderr Square test failed n return 0 BN free a BN free c BN free d BN free e return 1 static void dissect zcl pwr prof pwrprofstatersp tvbuff t tvb proto tree tree guint offset proto tree sub tree NULL guint i guint8 power profile count power profile count MIN tvb get guint8 tvb offset ZBEEZCLPWRPROFNUMPWRPROFETT proto tree add item tree hf zbee zcl pwr prof pwr prof count tvb offset 1 ENCNA offset 1 for i 0 i power profile count i sub tree proto tree add subtree format tree tvb offset 1 ett zbee zcl pwr prof pwrprofiles i NULL Power Profile u i dissect zcl power profile tvb sub tree offset static int64 t rd pick best sub8x8 mode V P9 COMP cpi MACROBLOCK x const Tile Info const tile int mv best ref mv int mv second best ref mv int64 t best rd int returntotrate int returnyrate int64 t returndistortion int skippable int64 t psse int mvthresh int mv seg mvs 4 MAXREFFRAMESBESTSEGINFO bsi buf int filter idx int mi row int mi col int i BESTSEGINFO bsi bsi buf filter idx MACROBLOCKD xd x e mbd MODEINFO mi xd mi 0 src mi MBMODEINFO mbmi mi mbmi int mode idx int k br 0 idx idy int64 t bd 0 block sse 0 PREDICTIONMODE this mode V P9 COMMON cm cpi common struct macroblock plane const p x plane 0 struct macroblockd plane const pd xd plane 0 const int label count 4 int64 t this segment rd 0 int label mv thresh int segmentyrate 0 const BLOCKSIZE bsize mbmi sb type const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize ENTROPYCONTEXT t above 2 t left 2 int subpelmv 1 have ref 0 const int has second rf has second ref mbmi const int inter mode mask cpi sf inter mode mask bsize vp9 zero bsi bsi segment rd best rd bsi ref mv 0 best ref mv bsi ref mv 1 second best ref mv bsi mvp as int best ref mv as int bsi mvthresh mvthresh for i 0 i 4 i bsi modes i ZEROMV vpx memcpy t above pd above context sizeof t above vpx memcpy t left pd left context sizeof t left label mv thresh 1 bsi mvthresh label count for idy 0 idy 2 idy num 4x4 blocks high for idx 0 idx 2 idx num 4x4 blocks wide int mv mode mv MBMODECOUNT 2 int mv frame mv MBMODECOUNTMAXREFFRAMESPREDICTIONMODE mode selected ZEROMV int64 t best rd IN T64 MAX const int i idy 2 idx int ref for ref 0 ref 1 has second rf ref const MVREFERENCEFRAME frame mbmi ref frame ref frame mv ZEROMV frame as int 0 vp9 append sub8x8 mvs for idx cm xd tile i ref mi row mi col frame mv NEARESTMV frame frame mv NEARMV frame for this mode NEARESTMV this mode NEWMV this mode const struct buf 2d orig src x plane 0 src struct buf 2d orig pre 2 mode idx INTEROFFSET this mode bsi rdstat i mode idx brdcost IN T64 MAX if inter mode mask 1 this mode continue if check best zero mv cpi mbmi mode context frame mv this mode mbmi ref frame continue vpx memcpy orig pre pd pre sizeof orig pre vpx memcpy bsi rdstat i mode idx ta t above sizeof bsi rdstat i mode idx ta vpx memcpy bsi rdstat i mode idx tl t left sizeof bsi rdstat i mode idx tl if has second rf this mode NEWMV seg mvs i mbmi ref frame 0 as int INVALIDMVMV const new mv mode mv NEWMV 0 as mv int step param 0 int thissme bestsme INTMAX int sadpb x sadperbit4 MV mvp full int max mv int sad list 5 if best rd label mv thresh break if cpi oxcf mode BEST if i 0 bsi mvp as int mi bmi i 1 as mv 0 as int if i 2 bsi mvp as int mi bmi i 2 as mv 0 as int if i 0 max mv x max mv context mbmi ref frame 0 else max mv MAX abs bsi mvp as mv row abs bsi mvp as mv col 3 if cpi sf mv auto mv step size cm show frame step param vp9 init search range max mv cpi mv step param 2 else step param cpi mv step param mvp full row bsi mvp as mv row 3 mvp full col bsi mvp as mv col 3 if cpi sf adaptive motion search mvp full row x pred mv mbmi ref frame 0 row 3 mvp full col x pred mv mbmi ref frame 0 col 3 step param MAX step param 8 mi buf shift x i vp9 set mv search range x bsi ref mv 0 as mv bestsme vp9 full pixel search cpi x bsize mvp full step param sadpb cpi sf mv subpel search method SUBPELTREE sad list NULL bsi ref mv 0 as mv new mv INTMAX 1 if cpi oxcf mode BEST int mv const best mv mi bmi i as mv 0 clamp mv mvp full x mv col min x mv col max x mv row min x mv row max thissme cpi full search sad x mvp full sadpb 16 cpi fn ptr bsize bsi ref mv 0 as mv best mv as mv sad list 1 sad list 2 sad list 3 sad list 4 INTMAX if thissme bestsme bestsme thissme new mv best mv as mv else best mv as mv new mv if bestsme INTMAX int distortion cpi find fractional mv step x new mv bsi ref mv 0 as mv cm allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost distortion x pred sse mbmi ref frame 0 NULL 0 0 seg mvs i mbmi ref frame 0 as mv new mv if cpi sf adaptive motion search x pred mv mbmi ref frame 0 new mv mi buf restore x orig src orig pre if has second rf if seg mvs i mbmi ref frame 1 as int INVALIDMV seg mvs i mbmi ref frame 0 as int INVALIDMV continue if has second rf this mode NEWMV mbmi interp filter EIGHTTAP mi buf shift x i if cpi sf comp inter joint search thresh bsize int rate mv joint motion search cpi x bsize frame mv this mode mi row mi col seg mvs i rate mv seg mvs i mbmi ref frame 0 as int frame mv this mode mbmi ref frame 0 as int seg mvs i mbmi ref frame 1 as int frame mv this mode mbmi ref frame 1 as int mi buf restore x orig src orig pre bsi rdstat i mode idx brate set and cost bmi mvs cpi xd i this mode mode mv this mode frame mv seg mvs i bsi ref mv x nmvjointcost x mvcost for ref 0 ref 1 has second rf ref bsi rdstat i mode idx mvs ref as int mode mv this mode ref as int if num 4x4 blocks wide 1 bsi rdstat i 1 mode idx mvs ref as int mode mv this mode ref as int if num 4x4 blocks high 1 bsi rdstat i 2 mode idx mvs ref as int mode mv this mode ref as int if mv check bounds x mode mv this mode 0 as mv has second rf mv check bounds x mode mv this mode 1 as mv continue if filter idx 0 BESTSEGINFO ref bsi bsi buf subpelmv 0 have ref 1 for ref 0 ref 1 has second rf ref subpelmv mv has subpel mode mv this mode ref as mv have ref mode mv this mode ref as int ref bsi rdstat i mode idx mvs ref as int if filter idx 1 subpelmv have ref ref bsi bsi buf 1 have ref 1 for ref 0 ref 1 has second rf ref have ref mode mv this mode ref as int ref bsi rdstat i mode idx mvs ref as int if subpelmv have ref ref bsi rdstat i mode idx brdcost IN T64 MAX vpx memcpy bsi rdstat i mode idx ref bsi rdstat i mode idx sizeof SEGRDSTAT if num 4x4 blocks wide 1 bsi rdstat i 1 mode idx eobs ref bsi rdstat i 1 mode idx eobs if num 4x4 blocks high 1 bsi rdstat i 2 mode idx eobs ref bsi rdstat i 2 mode idx eobs if bsi rdstat i mode idx brdcost best rd mode selected this mode best rd bsi rdstat i mode idx brdcost continue bsi rdstat i mode idx brdcost encode inter mb segment cpi x bsi segment rd this segment rd i bsi rdstat i mode idx byrate bsi rdstat i mode idx bdist bsi rdstat i mode idx bsse bsi rdstat i mode idx ta bsi rdstat i mode idx tl mi row mi col if bsi rdstat i mode idx brdcost IN T64 MAX bsi rdstat i mode idx brdcost RDCOST x rdmult x rddiv bsi rdstat i mode idx brate 0 bsi rdstat i mode idx brate bsi rdstat i mode idx byrate bsi rdstat i mode idx eobs p eobs i if num 4x4 blocks wide 1 bsi rdstat i 1 mode idx eobs p eobs i 1 if num 4x4 blocks high 1 bsi rdstat i 2 mode idx eobs p eobs i 2 if bsi rdstat i mode idx brdcost best rd mode selected this mode best rd bsi rdstat i mode idx brdcost if best rd IN T64 MAX int iy midx for iy i 1 iy 4 iy for midx 0 midx INTERMODES midx bsi rdstat iy midx brdcost IN T64 MAX bsi segment rd IN T64 MAX return IN T64 MAX mode idx INTEROFFSET mode selected vpx memcpy t above bsi rdstat i mode idx ta sizeof t above vpx memcpy t left bsi rdstat i mode idx tl sizeof t left set and cost bmi mvs cpi xd i mode selected mode mv mode selected frame mv seg mvs i bsi ref mv x nmvjointcost x mvcost br bsi rdstat i mode idx brate bd bsi rdstat i mode idx bdist block sse bsi rdstat i mode idx bsse segmentyrate bsi rdstat i mode idx byrate this segment rd bsi rdstat i mode idx brdcost if this segment rd bsi segment rd int iy midx for iy i 1 iy 4 iy for midx 0 midx INTERMODES midx bsi rdstat iy midx brdcost IN T64 MAX bsi segment rd IN T64 MAX return IN T64 MAX bsi r br bsi d bd bsi segment yrate segmentyrate bsi segment rd this segment rd bsi sse block sse for k 0 k 4 k bsi modes k mi bmi k as mode if bsi segment rd best rd return IN T64 MAX for i 0 i 4 i mode idx INTEROFFSET bsi modes i mi bmi i as mv 0 as int bsi rdstat i mode idx mvs 0 as int if has second ref mbmi mi bmi i as mv 1 as int bsi rdstat i mode idx mvs 1 as int x plane 0 eobs i bsi rdstat i mode idx eobs mi bmi i as mode bsi modes i returntotrate bsi r returndistortion bsi d returnyrate bsi segment yrate skippable vp9 is skippable in plane x BLOCK 8 X8 0 psse bsi sse mbmi mode bsi modes 3 return bsi segment rd void xps begin opacity xps document doc const fz matrix ctm const fz rect area char base uri xps resource dict char opacity att fz xml opacity mask tag float opacity if opacity att opacity mask tag return opacity 1 if opacity att opacity fz atof opacity att if opacity mask tag strcmp fz xml tag opacity mask tag Solid Color Brush char scb opacity att fz xml att opacity mask tag Opacity char scb color att fz xml att opacity mask tag Color if scb opacity att opacity opacity fz atof scb opacity att if scb color att fz colorspace colorspace float samples FZMAXCOLORS xps parse color doc base uri scb color att colorspace samples opacity opacity samples 0 opacity mask tag NULL if doc opacity top 1 nelem doc opacity doc opacity doc opacity top 1 doc opacity doc opacity top opacity doc opacity top if opacity mask tag fz begin mask doc dev area 0 NULLNULL xps parse brush doc ctm area base uri dict opacity mask tag fz end mask doc dev extern int as mysql node down mysql conn t mysql conn struct node record node ptr time t event time char reason uint32 t reason uid int rc SLURMSUCCESS char query NULL char my reason MYSQLRES result NULLMYSQLROW row if check connection mysql conn SLURMSUCCESS return ESLURMDBCONNECTION if mysql conn cluster name error s d no cluster name THISFILELINE return SLURMERROR if node ptr error No node ptr given return SLURMERROR if node ptr tres str error node ptr has no tres list return SLURMERROR query xstrdup printf select state reason from s s where time end 0 and node name s mysql conn cluster name event table node ptr name result mysql db query ret mysql conn query 0 xfree query if result return SLURMERROR if reason my reason reason else my reason node ptr reason row mysql fetch row result if row node ptr node state slurm atoul row 0 my reason row 1 xstrcasecmp my reason row 1 debug as mysql node down no change needed u s and s s node ptr node state row 0 my reason row 1 mysql free result result return SLURMSUCCESS mysql free result result debug2 inserting s s with tres of s node ptr name mysql conn cluster name node ptr tres str query xstrdup printf update s s set time end ld where time end 0 and node name s mysql conn cluster name event table event time node ptr name xstrfmtcat query insert into s s node name state tres time start reason reason uid values s u s ld s u on duplicate key update time end 0 mysql conn cluster name event table node ptr name node ptr node state node ptr tres str event time my reason reason uid debug2 d s d query n s mysql conn conn THISFILELINE query rc mysql db query mysql conn query xfree query return rc static int build def list Picture def Picture in int len int is long int sel int i 2 0 int index 0 while i 0 len i 1 len while i 0 len in i 0 in i 0 reference sel i 0 while i 1 len in i 1 in i 1 reference sel 3 i 1 if i 0 len in i 0 pic id is long i 0 in i 0 frame num split field copy def index in i 0 sel 1 if i 1 len in i 1 pic id is long i 1 in i 1 frame num split field copy def index in i 1 sel 3 0 return index static char construct command line struct manager ctx manager struct server server static char cmd BUFSIZE char method manager method int i build config working dir server if server method method server method memset cmd 0 BUFSIZE snprintf cmd BUFSIZE s m s manager address s f s shadowsocks s pid c s shadowsocks s conf executable method manager manager address working dir server port working dir server port if manager acl NULL int len strlen cmd snprintf cmd len BUFSIZE len acl s manager acl if manager timeout NULL int len strlen cmd snprintf cmd len BUFSIZE len t s manager timeout int len strlen cmd snprintf cmd len BUFSIZE len n d manager nofile static void loop filter rows mt const Y V12 BUFFERCONFIG const frame buffer V P9 COMMON const cm struct macroblockd plane planes MAXMBPLANE int start int stop int y only V P9 Lf Sync const lf sync int num lf workers const int num planes y only 1 MAXMBPLANE int r c const int sb cols mi cols aligned to sb cm mi cols MIBLOCKSIZELO G2 for r start r stop r num lf workers const int mi row r MIBLOCKSIZELO G2 MODEINFO const mi cm mi grid visible mi row cm mi stride for c 0 c sb cols c const int mi col c MIBLOCKSIZELO G2 LOOPFILTERMASK lfm int plane sync read lf sync r c vp9 setup dst planes planes frame buffer mi row mi col vp9 setup mask cm mi row mi col mi mi col cm mi stride lfm for plane 0 plane num planes plane vp9 filter block plane cm planes plane mi row lfm sync write lf sync r c sb cols static void apply frame size V P9 COMMON cm int width int height if width cm width height cm height if vp9 resize frame buffers cm width height vpx internal error cm error VPXCODECMEMERROR Failed to allocate frame buffers cm width width cm height height vp9 update frame size cm int event base priority init struct event base base int npriorities int i if base event count active return 1 if base nactivequeues npriorities base nactivequeues for i 0 i base nactivequeues i free base activequeues i free base activequeues base nactivequeues npriorities base activequeues struct event list calloc base nactivequeues sizeof struct event list if base activequeues NULL event err 1 s calloc func for i 0 i base nactivequeues i base activequeues i malloc sizeof struct event list if base activequeues i NULL event err 1 s malloc func TAILQINIT base activequeues i return 0 static inline void ff mpeg4 set one direct mv Mpeg Enc Context s int mx int my int i int xy s block index i uint16 t time pp s pp time uint16 t time pb s pb time int p mx p my p mx s next picture f motion val 0 xy 0 if unsigned p mx tab bias tab size s mv 0 i 0 s direct scale mv 0 p mx tab bias mx s mv 1 i 0 mx s mv 0 i 0 p mx s direct scale mv 1 p mx tab bias else s mv 0 i 0 p mx time pb time pp mx s mv 1 i 0 mx s mv 0 i 0 p mx p mx time pb time pp time pp p my s next picture f motion val 0 xy 1 if unsigned p my tab bias tab size s mv 0 i 1 s direct scale mv 0 p my tab bias my s mv 1 i 1 my s mv 0 i 1 p my s direct scale mv 1 p my tab bias else s mv 0 i 1 p my time pb time pp my s mv 1 i 1 my s mv 0 i 1 p my p my time pb time pp time pp void create script for cluster analyze char analyze script file name FILE script NULL char user specification prep status Creating script to analyze new cluster if os info user specified user specification psprintf U s os info user analyze script file name psprintf sanalyze new cluster s SCRIPTPREFIXSCRIPTEXT if script fopen priv analyze script file name w NULL pg fatal Could not open file s s n analyze script file name get Error Text fprintf script echo sso your system is usable and then gather statistics twice more s n ECHOQUOTEECHOQUOTE fprintf script echo swith increasing accuracy When it is done your system will s n ECHOQUOTEECHOQUOTE fprintf script echo shave the default level of optimizer statistics s n ECHOQUOTEECHOQUOTE fprintf script echo s n n ECHOBLANK fprintf script echo s If you have used ALTERTABLE to modify the statistics target for s n ECHOQUOTEECHOQUOTE fprintf script echo sany tables you might want to remove them and restore them after s n ECHOQUOTEECHOQUOTE fprintf script echo srunning this script because they will delay fast statistics generation s n ECHOQUOTEECHOQUOTE fprintf script echo s n n ECHOBLANK fprintf script echo s If you would like default statistics as quickly as possible cancel s n ECHOQUOTEECHOQUOTE fprintf script echo sthis script and run s n ECHOQUOTEECHOQUOTE fprintf script echo s s vacuumdb s all s s n ECHOQUOTE new cluster bindir user specification GETMAJORVERSION old cluster major version 804 analyze only analyze ECHOQUOTE fprintf script echo s n n ECHOBLANK fprintf script s vacuumdb s all analyze in stages n new cluster bindir user specification if GETMAJORVERSION old cluster major version 804 fprintf script s vacuumdb s all n new cluster bindir user specification fprintf script echo s n n ECHOBLANK fprintf script echo s Done s n ECHOQUOTEECHOQUOTE fclose script check ok gcry error t gcry mpi print enum gcry mpi format format unsigned char buffer size t buflen size t nwritten struct gcry mpi a unsigned int nbits mpi get nbits a size t len size t dummy nwritten int negative if nwritten nwritten dummy nwritten if a sign gcry mpi cmp ui a 0 negative 1 else negative 0 len buflen nwritten 0 if format GCRYMPIFMTSTD unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if extra s 0 memcpy s tmp n extra gcry free tmp nwritten n return 0 else if format GCRYMPIFMTUSG unsigned int n nbits 7 8 if buffer n len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy buffer tmp n gcry free tmp nwritten n return 0 else if format GCRYMPIFMTPGP unsigned int n nbits 7 8 if negative return gcry error GPGERRINVARG if buffer n 2 len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp unsigned char s buffer s 0 nbits 8 s 1 nbits tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy s 2 tmp n gcry free tmp nwritten n 2 return 0 else if format GCRYMPIFMTSSH unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n 4 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer s n 24 s n 16 s n 8 s n if extra s 0 memcpy s tmp n extra gcry free tmp nwritten 4 n return 0 else if format GCRYMPIFMTHEX unsigned char tmp int i int extra 0 unsigned int n 0 tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 extra 2 if buffer 2 n extra negative 1 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if negative s if extra s 0 s 0 for i 0 i n i unsigned int c tmp i s c 4 10 0 c 4 A c 4 10 c 15 s c 10 0 c A c 10 s 0 nwritten s buffer else nwritten 2 n extra negative 1 gcry free tmp return 0 else return gcry error static double var eq const Variable Stat Data vardata Oid operator Datum constval bool constisnull bool varonleft double selec bool isdefault Oid opfuncoid if constisnull return 0 0 if vardata isunique vardata rel vardata rel tuples 1 0 return 1 0 vardata rel tuples if Heap Tuple Is Valid vardata stats Tuple statistic proc security check vardata opfuncoid get opcode operator Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers bool match false int i stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple vardata atttype vardata atttypmod STATISTICKINDMCV Invalid Oid NULL values nvalues numbers nnumbers Fmgr Info eqproc fmgr info opfuncoid eqproc for i 0 i nvalues i if varonleft match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID values i constval else match Datum Get Bool Function Call2 Coll eqproc DEFAULTCOLLATIONOID constval values i if match break else values NULL numbers NULL i nvalues nnumbers 0 if match selec numbers i else double sumcommon 0 0 double otherdistinct for i 0 i nnumbers i sumcommon numbers i selec 1 0 sumcommon stats stanullfrac CLAMPPROBABILITY selec otherdistinct get variable numdistinct vardata isdefault nnumbers if otherdistinct 1 selec otherdistinct if nnumbers 0 selec numbers nnumbers 1 selec numbers nnumbers 1 free attstatsslot vardata atttype values nvalues numbers nnumbers else selec 1 0 get variable numdistinct vardata isdefault CLAMPPROBABILITY selec return selec static int libschroedinger decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size int64 t pts avpkt pts Schro Tag tag Schro Decoder Params p schro params avctx priv data Schro Decoder decoder p schro params decoder Schro Buffer enc buf Schro Frame frame int state int go 1 int outer 1 Schro Parse Unit Context parse ctx Lib Schro Frame Context framewithpts NULL got frame 0 parse context init parse ctx buf buf size if buf size if p schro params eos signalled state schro decoder push end of stream decoder p schro params eos signalled 1 do if enc buf find next parse unit parse ctx enc buf tag schro tag new av malloc sizeof int64 t av free if enc buf tag value av log avctx AVLOGERROR Unable to allocate Schro Tag n return AVERRORENOMEMAVWN 64 enc buf tag value pts if SCHROPARSECODEISPICTURE enc buf data 4 SCHROPARSECODENUMREFS enc buf data 4 0 avctx has b frames 1 state schro decoder push decoder enc buf if state SCHRODECODERFIRSTACCESSUNIT libschroedinger handle first access unit avctx go 1 else outer 0 while go state schro decoder wait decoder switch state case SCHRODECODERFIRSTACCESSUNIT libschroedinger handle first access unit avctx break case SCHRODECODERNEEDBITS go 0 break case SCHRODECODERNEEDFRAME frame ff create schro frame avctx p schro params frame format schro decoder add output picture decoder frame break case SCHRODECODEROK tag schro decoder get picture tag decoder frame schro decoder pull decoder if frame framewithpts av malloc sizeof Lib Schro Frame Context if framewithpts av log avctx AVLOGERROR Unable to allocate Frame With Pts n return AVERRORENOMEM framewithpts frame frame framewithpts pts AVR N64 tag value ff schro queue push back p schro params dec frame queue framewithpts break case SCHRODECODEREOS go 0 p schro params eos pulled 1 schro decoder reset decoder outer 0 break case SCHRODECODERERROR return 1 break while outer framewithpts ff schro queue pop p schro params dec frame queue if framewithpts framewithpts frame if p schro params dec frame data 0 avctx release buffer avctx p schro params dec frame if ff get buffer avctx p schro params dec frame 0 av log avctx AVLOGERROR Unable to allocate buffer n return AVERRORENOMEM memcpy p schro params dec frame data 0 framewithpts frame components 0 data framewithpts frame components 0 length memcpy p schro params dec frame data 1 framewithpts frame components 1 data framewithpts frame components 1 length memcpy p schro params dec frame data 2 framewithpts frame components 2 data framewithpts frame components 2 length p schro params dec frame format 1 p schro params dec frame width framewithpts frame width p schro params dec frame height framewithpts frame height p schro params dec frame pkt pts framewithpts pts p schro params dec frame linesize 0 framewithpts frame components 0 stride p schro params dec frame linesize 1 framewithpts frame components 1 stride p schro params dec frame linesize 2 framewithpts frame components 2 stride AV Frame data p schro params dec frame got frame 1 libschroedinger decode frame free framewithpts frame av free framewithpts else data NULL got frame 0 return buf size static vpx codec err t encoder encode vpx codec alg priv t ctx const vpx image t img vpx codec pts t pts unsigned long duration vpx enc frame flags t flags unsigned long deadline vpx codec err t res VPXCODECOKV P9 COMP const cpi ctx cpi const vpx rational t const timebase ctx cfg g timebase if img NULL res validate img ctx img if res VPXCODECOK cpi NULL ctx cx data NULL ctx cx data sz ctx cfg g w ctx cfg g h get image bps img 8 cpi multi arf allowed 8 2 if ctx cx data sz 4096 ctx cx data sz 4096 ctx cx data unsigned char malloc ctx cx data sz if ctx cx data NULL return VPXCODECMEMERROR pick quickcompress mode ctx duration deadline vpx codec pkt list init ctx pkt list if flags V P8 EFLAGNOUPDGF flags V P8 EFLAGFORCEGF flags V P8 EFLAGNOUPDARF flags V P8 EFLAGFORCEARF ctx base err detail Conflicting flags return VPXCODECINVALIDPARAM vp9 apply encoding flags cpi flags if ctx cfg kf mode VPXKFAUTO ctx cfg kf min dist ctx cfg kf max dist if ctx fixed kf cntr ctx cfg kf min dist flags VPXEFLAGFORCEKF ctx fixed kf cntr 1 if res VPXCODECOK cpi NULL unsigned int lib flags 0 Y V12 BUFFERCONFIG sd int64 t dst time stamp timebase units to ticks timebase pts int64 t dst end time stamp timebase units to ticks timebase pts duration size t size cx data sz unsigned char cx data if ctx base init flags VPXCODECUSEPSNR cpi b calculate psnr 1 if img NULL res image2yuvconfig img sd if vp9 receive raw frame cpi flags sd dst time stamp dst end time stamp res update error state ctx cpi common error cx data ctx cx data cx data sz ctx cx data sz if ctx pending cx data memmove cx data ctx pending cx data ctx pending cx data sz ctx pending cx data cx data cx data ctx pending cx data sz cx data sz ctx pending cx data sz if cx data sz ctx cx data sz 2 ctx base err detail Compressed data buffer too small return VPXCODECERROR while cx data sz ctx cx data sz 2 1 vp9 get compressed data cpi lib flags size cx data dst time stamp dst end time stamp img if size vpx codec cx pkt t pkt if ctx pending cx data 0 ctx pending cx data cx data ctx pending cx data sz size ctx pending frame sizes ctx pending frame count size ctx pending frame magnitude size cx data size cx data sz size continue pkt kind VPXCODECCXFRAMEPKT pkt data frame pts ticks to timebase units timebase dst time stamp pkt data frame duration unsigned long ticks to timebase units timebase dst end time stamp dst time stamp pkt data frame flags get frame pkt flags cpi lib flags if ctx pending cx data ctx pending frame sizes ctx pending frame count size ctx pending frame magnitude size ctx pending cx data sz size size write superframe index ctx pkt data frame buf ctx pending cx data pkt data frame sz ctx pending cx data sz ctx pending cx data NULL ctx pending cx data sz 0 ctx pending frame count 0 ctx pending frame magnitude 0 else pkt data frame buf cx data pkt data frame sz size pkt data frame partition id 1 vpx codec pkt list add ctx pkt list head pkt cx data size cx data sz size vpx codec cx pkt t pkt sizes pkt psnr int i vp9 zero pkt sizes vp9 zero pkt psnr pkt sizes kind VPXCODECSPATIALSVCLAYERSIZES pkt psnr kind VPXCODECSPATIALSVCLAYERPSNR for i 0 i cpi svc number spatial layers i LAYERCONTEXT lc cpi svc layer context i pkt sizes data layer sizes i lc layer size pkt psnr data layer psnr i lc psnr pkt lc layer size 0 vpx codec pkt list add ctx pkt list head pkt sizes vpx codec pkt list add ctx pkt list head pkt psnr static void write modes b V P9 COMP cpi const Tile Info const tile vp9 writer w TOKENEXTRA tok const TOKENEXTRA const tok end int mi row int mi col const V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd MODEINFO m xd mi cm mi mi row cm mi stride mi col m xd mi set mi row col xd tile mi row num 8x8 blocks high lookup m mbmi sb type mi col num 8x8 blocks wide lookup m mbmi sb type cm mi rows cm mi cols if frame is intra only cm write mb modes kf cm xd xd mi w else pack inter mode mvs cpi m w assert tok tok end pack mb tokens w tok tok end static int ptx decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end avpkt data avpkt size AV Frame const p data unsigned int offset w h y stride bytes per pixel int ret uint8 t ptr if buf end buf 14 return AVERRORINVALIDDATA offset AVR L16 buf w AVR L16 buf 8 h AVR L16 buf 10 bytes per pixel AVR L16 buf 12 3 if bytes per pixel 2 av log ask for sample avctx Image format is not RG B15 n return AVERRORPATCHWELCOME avctx pix fmt AVPIXFMTRG B555 if buf end buf offset return AVERRORINVALIDDATA if offset 0x2c av log ask for sample avctx offset 0x2c n buf offset if ret av image check size w h 0 avctx 0 return ret if w avctx width h avctx height avcodec set dimensions avctx w h if ret ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI ptr p data 0 stride p linesize 0 for y 0 y h buf end buf w bytes per pixel y for x 0 x w bytes per pixel x bytes per pixel AVW N16 ptr x AVR L16 buf x buf w bytes per pixel got frame 1 if y h av log avctx AVLOGWARNING incomplete packet n return avpkt size return offset w h bytes per pixel static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end buf avpkt size Kgv Context const c avctx priv data int offsets 8 uint16 t out prev int outcnt 0 maxcnt int w h i res if avpkt size 2 return AVERRORINVALIDDATA w buf 0 1 8 h buf 1 1 8 buf 2 if res av image check size w h 0 avctx 0 return res if w avctx width h avctx height if c prev data 0 avctx release buffer avctx c prev avcodec set dimensions avctx w h maxcnt w h c cur reference 3 if res ff get buffer avctx c cur 0 return res out uint16 t c cur data 0 if c prev data 0 prev uint16 t c prev data 0 else prev NULL for i 0 i 8 i offsets i 1 while outcnt maxcnt buf end 2 buf int code AVR L16 buf buf 2 if code 0x8000 out outcnt code else int count int inp off uint16 t inp if code 0x6000 0x6000 int oidx code 10 7 int start count code 0x3 FF 3 if offsets oidx 0 if buf end 3 buf break offsets oidx AVR L24 buf buf 3 start outcnt offsets oidx maxcnt if maxcnt start count break if prev av log avctx AVLOGERROR Frame reference does not exist n break inp prev inp off start else int offset code 0x1 FFF 1 if code 0x6000 count 2 else if code 0x6000 0x2000 count 3 else if buf end 1 buf break count 4 buf if outcnt offset break inp out inp off outcnt offset if maxcnt outcnt count break for i inp off i count inp off i out outcnt inp i if outcnt maxcnt av log avctx AVLOGDEBUG frame finished with d diff n outcnt maxcnt got frame 1 AV Frame data c cur if c prev data 0 avctx release buffer avctx c prev FFSWAPAV Frame c cur c prev return avpkt size static void prc destroy jpc enc prc t prc jpc enc cblk t cblk uint fast32 t cblkno if prc cblks for cblkno 0 cblk prc cblks cblkno prc numcblks cblkno cblk cblk destroy cblk jas free prc cblks prc cblks NULL if prc incltree jpc tagtree destroy prc incltree prc incltree NULL if prc nlibtree jpc tagtree destroy prc nlibtree prc nlibtree NULL if prc savincltree jpc tagtree destroy prc savincltree prc savincltree NULL if prc savnlibtree jpc tagtree destroy prc savnlibtree prc savnlibtree void ff h264 direct ref list init H264 Context const h Picture const ref1 h ref list 1 0 Picture const cur h cur pic ptr int list j field int sidx h picture structure 1 1 int ref1sidx ref1 reference 1 1 for list 0 list 2 list cur ref count sidx list h ref count list for j 0 j h ref count list j cur ref poc sidx list j 4 h ref list list j frame num h ref list list j reference 3 if h picture structure PICTFRAME memcpy cur ref count 1 cur ref count 0 sizeof cur ref count 0 memcpy cur ref poc 1 cur ref poc 0 sizeof cur ref poc 0 cur mbaff FRAMEMBAFF h col fieldoff 0 if h picture structure PICTFRAME int cur poc h cur pic ptr poc int col poc h ref list 1 field poc h col parity FFABS col poc 0 cur poc FFABS col poc 1 cur poc ref1sidx sidx h col parity else if h picture structure h ref list 1 0 reference h ref list 1 0 mbaff h col fieldoff 2 h ref list 1 0 reference 3 if h slice type nos AVPICTURETYPEB h direct spatial mv pred return for list 0 list 2 list fill colmap h h map col to list0 list sidx ref1sidx 0 if FRAMEMBAFF for field 0 field 2 field fill colmap h h map col to list0 field field list field field 1 int ff alloc picture Mpeg Enc Context s Picture pic int shared const int big mb num s mb stride s mb height 1 1 const int mb array size s mb stride s mb height const int b8 array size s b8 stride s mb height 2 const int b4 array size s b4 stride s mb height 4 int i int r 1 if shared assert pic f data 0 assert pic f type 0 pic f type FFBUFFERTYPESHARED pic f type FFBUFFERTYPESHARED else assert pic f data 0 if alloc frame buffer s pic 0 return 1 s linesize pic f linesize 0 s uvlinesize pic f linesize 1 if pic f qscale table NULL if s encoding FFALLOCZORGOTO s avctx pic mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mc mb var mb array size sizeof int16 t fail FFALLOCZORGOTO s avctx pic mb mean mb array size sizeof int8 t fail FFALLOCZORGOTO s avctx pic f mbskip table mb array size sizeof uint8 t 2 fail FFALLOCZORGOTO s avctx pic qscale table base big mb num s mb stride sizeof uint8 t fail FFALLOCZORGOTO s avctx pic mb type base big mb num s mb stride sizeof uint32 t fail pic f mb type pic mb type base 2 s mb stride 1 pic f qscale table pic qscale table base 2 s mb stride 1 if s out format FMT H264 for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b4 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 2 else if s out format FMT H263 s encoding s avctx debug FFDEBUGMV s avctx debug mv for i 0 i 2 i FFALLOCZORGOTO s avctx pic motion val base i 2 b8 array size 4 sizeof int16 t fail pic f motion val i pic motion val base i 4 FFALLOCZORGOTO s avctx pic f ref index i 4 mb array size sizeof uint8 t fail pic f motion subsample log2 3 if s avctx debug FFDEBUGDCTCOEFFFFALLOCZORGOTO s avctx pic f dct coeff 64 mb array size sizeof int16 t 6 fail pic f qstride s mb stride FFALLOCZORGOTO s avctx pic f pan scan 1 sizeof AV Pan Scan fail pic owner2 s return 0 fail if r 0 free frame buffer s pic return 1 void vp9 set rd speed thresholds V P9 COMP cpi int i RDOPT const rd cpi rd SPEEDFEATURES const sf cpi sf for i 0 i MAXMODES i rd thresh mult i cpi oxcf mode BEST 500 0 rd thresh mult THRNEARESTMV 0 rd thresh mult THRNEARESTG 0 rd thresh mult THRNEARESTA 0 rd thresh mult THRDC 1000 rd thresh mult THRNEWMV 1000 rd thresh mult THRNEWA 1000 rd thresh mult THRNEWG 1000 rd thresh mult THRNEWMV sf elevate newmv thresh rd thresh mult THRNEARMV 1000 rd thresh mult THRNEARA 1000 rd thresh mult THRCOMPNEARESTLA 1000 rd thresh mult THRCOMPNEARESTGA 1000 rd thresh mult THRTM 1000 rd thresh mult THRCOMPNEARLA 1500 rd thresh mult THRCOMPNEWLA 2000 rd thresh mult THRNEARG 1000 rd thresh mult THRCOMPNEARGA 1500 rd thresh mult THRCOMPNEWGA 2000 rd thresh mult THRZEROMV 2000 rd thresh mult THRZEROG 2000 rd thresh mult THRZEROA 2000 rd thresh mult THRCOMPZEROLA 2500 rd thresh mult THRCOMPZEROGA 2500 rd thresh mult THRHPRED 2000 rd thresh mult THRVPRED 2000 rd thresh mult THR D45 PRED 2500 rd thresh mult THR D135 PRED 2500 rd thresh mult THR D117 PRED 2500 rd thresh mult THR D153 PRED 2500 rd thresh mult THR D207 PRED 2500 rd thresh mult THR D63 PRED 2500 if cpi ref frame flags V P9 LASTFLAG rd thresh mult THRNEWMVINTMAX rd thresh mult THRNEARESTMVINTMAX rd thresh mult THRZEROMVINTMAX rd thresh mult THRNEARMVINTMAX if cpi ref frame flags V P9 GOLDFLAG rd thresh mult THRNEARESTGINTMAX rd thresh mult THRZEROGINTMAX rd thresh mult THRNEARGINTMAX rd thresh mult THRNEWGINTMAX if cpi ref frame flags V P9 ALTFLAG rd thresh mult THRNEARESTAINTMAX rd thresh mult THRZEROAINTMAX rd thresh mult THRNEARAINTMAX rd thresh mult THRNEWAINTMAX if cpi ref frame flags V P9 LASTFLAGV P9 ALTFLAGV P9 LASTFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROLAINTMAX rd thresh mult THRCOMPNEARESTLAINTMAX rd thresh mult THRCOMPNEARLAINTMAX rd thresh mult THRCOMPNEWLAINTMAX if cpi ref frame flags V P9 GOLDFLAGV P9 ALTFLAGV P9 GOLDFLAGV P9 ALTFLAG rd thresh mult THRCOMPZEROGAINTMAX rd thresh mult THRCOMPNEARESTGAINTMAX rd thresh mult THRCOMPNEARGAINTMAX rd thresh mult static int mxpeg decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size M Xpeg Decode Context s avctx priv data M Jpeg Decode Context jpg s jpg const uint8 t buf end buf ptr const uint8 t unescaped buf ptr int unescaped buf size int start code int ret buf ptr buf buf end buf buf size jpg got picture 0 s got mxm bitmask 0 while buf ptr buf end start code ff mjpeg find marker jpg buf ptr buf end unescaped buf ptr unescaped buf size if start code 0 goto the end init get bits jpg gb unescaped buf ptr unescaped buf size 8 if start code AP P0 start code AP P15 mxpeg decode app s unescaped buf ptr unescaped buf size switch start code case SOI if jpg got picture goto the end break case EOI goto the end case DQT ret ff mjpeg decode dqt jpg if ret 0 av log avctx AVLOGERROR quantization table decode error n return ret break case DHT ret ff mjpeg decode dht jpg if ret 0 av log avctx AVLOGERROR huffman table decode error n return ret break case COM ret mxpeg decode com s unescaped buf ptr unescaped buf size if ret 0 return ret break case SO F0 s got sof data 0 ret ff mjpeg decode sof jpg if ret 0 av log avctx AVLOGERRORSOF data decode error n return ret if jpg interlaced av log avctx AVLOGERROR Interlaced mode not supported in Mx PEG n return AVERROREINVAL s got sof data 1 break case SOS if s got sof data av log avctx AVLOGWARNING Can not process SOS without SOF data skipping n break if jpg got picture if jpg first picture av log avctx AVLOGWARNING First picture has no SOF skipping n break if s got mxm bitmask av log avctx AVLOGWARNING Non key frame has no MXM skipping n break av frame unref jpg picture ptr if ff get buffer avctx jpg picture ptr AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return AVERRORENOMEM jpg picture ptr pict type AVPICTURETYPEP jpg picture ptr key frame 0 jpg got picture 1 else jpg picture ptr pict type AVPICTURETYPEI jpg picture ptr key frame 1 if s got mxm bitmask AV Frame reference ptr s picture s picture index 1 if mxpeg check dimensions s jpg reference ptr 0 break if reference ptr data 0 ff get buffer avctx reference ptr AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return AVERRORENOMEM ret ff mjpeg decode sos jpg s mxm bitmask reference ptr if ret 0 avctx err recognition AVEFEXPLODE return ret else ret ff mjpeg decode sos jpg NULLNULL if ret 0 avctx err recognition AVEFEXPLODE return ret break buf ptr get bits count jpg gb 7 3 the end if jpg got picture int ret av frame ref data jpg picture ptr if ret 0 return ret got frame 1 s picture index 1 jpg picture ptr s picture s picture index if s has complete frame if s got mxm bitmask s has complete frame 1 else got frame 0 return buf ptr buf static void update state V P9 COMP cpi PICKMODECONTEXT ctx int mi row int mi col BLOCKSIZE bsize int output enabled int i x idx y V P9 COMMON const cm cpi common RDOPT const rd opt cpi rd MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd struct macroblock plane const p x plane struct macroblockd plane const pd xd plane MODEINFO mi ctx mic MBMODEINFO const mbmi xd mi 0 src mi mbmi MODEINFO mi addr xd mi 0 const struct segmentation const seg cm seg const int mis cm mi stride const int mi width num 8x8 blocks wide lookup bsize const int mi height num 8x8 blocks high lookup bsize int max plane assert mi mbmi sb type bsize mi addr mi mi addr src mi mi addr if seg enabled output enabled if cpi oxcf aq mode COMPLEXITYAQ const uint8 t const map seg update map cpi segmentation map cm last frame seg map mi addr mbmi segment id vp9 get segment id cm map bsize mi row mi col if cpi oxcf aq mode CYCLICREFRESHAQ vp9 cyclic refresh update segment cpi xd mi 0 src mi mbmi mi row mi col bsize 1 max plane is inter block mbmi MAXMBPLANE 1 for i 0 i max plane i p i coeff ctx coeff pbuf i 1 p i qcoeff ctx qcoeff pbuf i 1 pd i dqcoeff ctx dqcoeff pbuf i 1 p i eobs ctx eobs pbuf i 1 for i max plane i MAXMBPLANE i p i coeff ctx coeff pbuf i 2 p i qcoeff ctx qcoeff pbuf i 2 pd i dqcoeff ctx dqcoeff pbuf i 2 p i eobs ctx eobs pbuf i 2 for y 0 y mi height y for x idx 0 x idx mi width x idx if xd mb to right edge 3 MISIZELO G2 mi width x idx xd mb to bottom edge 3 MISIZELO G2 mi height y xd mi x idx y mis src mi mi addr if cpi oxcf aq mode vp9 init plane quantizers cpi x if bsize BLOCK 32 X32 if bsize BLOCK 16 X16 ctx tx rd diff ALLOW 16 X16 ctx tx rd diff ALLOW 8 X8 ctx tx rd diff ALLOW 32 X32 ctx tx rd diff ALLOW 16 X16 if is inter block mbmi mbmi sb type BLOCK 8 X8 mbmi mv 0 as int mi bmi 3 as mv 0 as int mbmi mv 1 as int mi bmi 3 as mv 1 as int x skip ctx skip vpx memcpy x zcoeff blk mbmi tx size ctx zcoeff blk sizeof uint8 t ctx num 4x4 blk if output enabled return if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP for i 0 i TXMODES i rd opt tx select diff i ctx tx rd diff i static const int kf mode index THRDCTHRVPREDTHRHPREDTHR D45 PREDTHR D135 PREDTHR D117 PREDTHR D153 PREDTHR D207 PREDTHR D63 PREDTHRTM cpi mode chosen counts kf mode index mbmi mode static int vp8 decode AV Codec Context avctx void data int got frame AV Packet avpkt V P8 Context ctx avctx priv data AV Frame picture data const void iter NULL struct vpx image img int ret if vpx codec decode ctx decoder avpkt data avpkt size NULL 0 VPXCODECOK const char error vpx codec error ctx decoder const char detail vpx codec error detail ctx decoder av log avctx AVLOGERROR Failed to decode frame s n error if detail av log avctx AVLOGERROR Additional information s n detail return AVERRORINVALIDDATA if img vpx codec get frame ctx decoder iter if img fmt VPXIMGFMT I420 av log avctx AVLOGERROR Unsupported output colorspace d n img fmt return AVERRORINVALIDDATA if int img d w avctx width int img d h avctx height av log avctx AVLOGINFO dimension change dx d dx d n avctx width avctx height img d w img d h if av image check size img d w img d h 0 avctx return AVERRORINVALIDDATA avcodec set dimensions avctx img d w img d h if ret ff get buffer avctx picture 0 0 return ret av image copy picture data picture linesize img planes img stride avctx pix fmt img d w img d h got frame 1 return avpkt size static void vc1 decode i blocks adv V C1 Context v int k Mpeg Enc Context s v s int cbp val uint8 t coded val int mb pos int mquant v pq int mqdiff Get Bit Context gb s gb switch v y ac table index case 0 v codingset v pqindex 8 CSHIGHRATEINTRACSLOWMOTINTRA break case 1 v codingset CSHIGHMOTINTRA break case 2 v codingset CSMIDRATEINTRA break switch v c ac table index case 0 v codingset2 v pqindex 8 CSHIGHRATEINTERCSLOWMOTINTER break case 1 v codingset2 CSHIGHMOTINTER break case 2 v codingset2 CSMIDRATEINTER break s mb x s mb y 0 s mb intra 1 s first slice line 1 s mb y s start mb y if s start mb y s mb x 0 ff init block index s memset s coded block s block index 0 s b8 stride 0 1 s b8 stride sizeof s coded block for s mb y s end mb y s mb y s mb x 0 ff init block index s for s mb x s mb width s mb x int16 t block 64 v block v cur blk idx ff update block index s s dsp clear blocks block 0 mb pos s mb x s mb y s mb stride s current picture mb type mb pos v mb off MBTYPEINTRA s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 if v fieldtx is raw v fieldtx plane mb pos get bits1 v s gb cbp get vlc2 v s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if v acpred is raw v s ac pred get bits1 v s gb else v s ac pred v acpred plane mb pos if v condover CONDOVERSELECT v overflg is raw v over flags plane mb pos get bits1 v s gb GETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant for k 0 k 6 k val cbp 5 k 1 if k 4 int pred vc1 coded block pred v s k coded val val val pred coded val val cbp val 5 k v a avail s first slice line k 2 k 3 v c avail s mb x k 1 k 3 vc1 decode i block adv v block k k val k 4 v codingset v codingset2 mquant if k 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 block k vc1 smooth overlap filter iblk v vc1 put signed blocks clamped v if v s loop filter vc1 loop filter iblk delayed v v pq if get bits count s gb v bits ff er add slice s er 0 s start mb y s mb x s mb y ERMBERROR av log s avctx AVLOGERROR Bits overconsumption i i n get bits count s gb v bits return if v s loop filter ff mpeg draw horiz band s s mb y 16 16 else if s mb y ff mpeg draw horiz band s s mb y 1 16 16 s first slice line 0 s mb x 0 ff init block index s for s mb x s mb width s mb x ff update block index s vc1 put signed blocks clamped v if v s loop filter vc1 loop filter iblk delayed v v pq if v s loop filter ff mpeg draw horiz band s s end mb y 1 16 16 ff er add slice s er 0 s start mb y v field mode s mb width 1 s end mb y v field mode 1 static void encode block intra int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct encode b args const args arg MACROBLOCK const x args x MACROBLOCKD const xd x e mbd MBMODEINFO mbmi xd mi 0 mbmi struct macroblock plane const p x plane plane struct macroblockd plane const pd xd plane plane int16 t coeff BLOCKOFFSET p coeff block int16 t qcoeff BLOCKOFFSET p qcoeff block int16 t dqcoeff BLOCKOFFSET pd dqcoeff block const scan order scan order TXTYPE tx type PREDICTIONMODE mode const int bwl b width log2 plane bsize const int diff stride 4 1 bwl uint8 t src dst int16 t src diff uint16 t eob p eobs block const int src stride p src stride const int dst stride pd dst stride int i j txfrm block to raster xy plane bsize tx size block i j dst pd dst buf 4 j dst stride i src p src buf 4 j src stride i src diff p src diff 4 j diff stride i switch tx size case TX 32 X32 scan order vp9 default scan orders TX 32 X32 mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 6 bwl TX 32 X32 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 32 32 src diff diff stride src src stride dst dst stride fdct32x32 x use lp32x32fdct src diff coeff diff stride vp9 quantize b 32x32 coeff 1024 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 idct32x32 add dqcoeff dst dst stride eob break case TX 16 X16 tx type get tx type pd plane type xd scan order vp9 scan orders TX 16 X16 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 4 bwl TX 16 X16 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 16 16 src diff diff stride src src stride dst dst stride vp9 fht16x16 src diff coeff diff stride tx type vp9 quantize b coeff 256 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht16x16 add tx type dqcoeff dst dst stride eob break case TX 8 X8 tx type get tx type pd plane type xd scan order vp9 scan orders TX 8 X8 tx type mode plane 0 mbmi mode mbmi uv mode vp9 predict intra block xd block 2 bwl TX 8 X8 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 8 8 src diff diff stride src src stride dst dst stride vp9 fht8x8 src diff coeff diff stride tx type vp9 quantize b coeff 64 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob vp9 iht8x8 add tx type dqcoeff dst dst stride eob break case TX 4 X4 tx type get tx type 4x4 pd plane type xd block scan order vp9 scan orders TX 4 X4 tx type mode plane 0 get y mode xd mi 0 block mbmi uv mode vp9 predict intra block xd block bwl TX 4 X4 mode x skip encode src dst x skip encode src stride dst stride dst dst stride i j plane if x skip recode vp9 subtract block 4 4 src diff diff stride src src stride dst dst stride if tx type DCTDCT vp9 fht4x4 src diff coeff diff stride tx type else x fwd txm4x4 src diff coeff diff stride vp9 quantize b coeff 16 x skip block p zbin p round p quant p quant shift qcoeff dqcoeff pd dequant p zbin extra eob scan order scan scan order iscan if x skip encode eob if tx type DCTDCT x itxm add dqcoeff dst dst stride eob else vp9 iht4x4 16 add dqcoeff dst dst stride tx type break default assert 0 break if eob args skip 0 static void encode nonrd sb row V P9 COMP cpi const Tile Info const tile int mi row TOKENEXTRA tp SPEEDFEATURES const sf cpi sf V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd int mi col vpx memset xd left context 0 sizeof xd left context vpx memset xd left seg context 0 sizeof xd left seg context for mi col tile mi col start mi col tile mi col end mi col MIBLOCKSIZE int dummy rate 0 int64 t dummy dist 0 const int idx str cm mi stride mi row mi col MODEINFO mi cm mi idx str MODEINFO prev mi cm prev mip cm mi stride 1 idx str src mi BLOCKSIZE bsize x in static area 0 x source variance UINTMAX vp9 zero x pred mv switch sf partition search type case VARBASEDPARTITION choose partitioning cpi tile mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case SOURCEVARBASEDPARTITION set source var based partition cpi tile mi mi row mi col nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case VARBASEDFIXEDPARTITION case FIXEDPARTITION bsize sf partition search type FIXEDPARTITION sf always this block size get nonrd var based fixed partition cpi mi row mi col set fixed partitioning cpi tile mi mi row mi col bsize nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break case REFERENCEPARTITION if sf partition check x in static area is background cpi tile mi row mi col set modeinfo offsets cm xd mi row mi col auto partition range cpi tile mi row mi col sf min partition size sf max partition size nonrd pick partition cpi tile tp mi row mi col BLOCK 64 X64 dummy rate dummy dist 1 IN T64 MAX cpi pc root else copy partitioning cm mi prev mi nonrd use partition cpi tile mi tp mi row mi col BLOCK 64 X64 1 dummy rate dummy dist cpi pc root break default assert 0 break void vp9 rc init const V P9 Encoder Config oxcf int pass RATECONTROL rc int i if pass 0 oxcf rc mode VPXCBR rc avg frame qindex KEYFRAME oxcf worst allowed q rc avg frame qindex INTERFRAME oxcf worst allowed q else rc avg frame qindex KEYFRAME oxcf worst allowed q oxcf best allowed q 2 rc avg frame qindex INTERFRAME oxcf worst allowed q oxcf best allowed q 2 rc last q KEYFRAME oxcf best allowed q rc last q INTERFRAME oxcf best allowed q rc buffer level rc starting buffer level rc bits off target rc starting buffer level rc rolling target bits rc avg frame bandwidth rc rolling actual bits rc avg frame bandwidth rc long rolling target bits rc avg frame bandwidth rc long rolling actual bits rc avg frame bandwidth rc total actual bits 0 rc total target bits 0 rc total target vs actual 0 rc baseline gf interval DEFAULTGFINTERVAL rc frames since key 8 rc this key frame forced 0 rc next key frame forced 0 rc source alt ref pending 0 rc source alt ref active 0 rc frames till gf update due 0 rc ni av qi oxcf worst allowed q rc ni tot qi 0 rc ni frames 0 rc tot q 0 0 rc avg q vp9 convert qindex to q oxcf worst allowed q for i 0 i RATEFACTORLEVELS i rc rate correction factors i 1 0 struct login settings login settings read pool t pool const struct ip addr local ip const struct ip addr remote ip const char local name const struct master service ssl settings ssl set r void other settings r struct master service settings input input const char error const struct setting parser context parser void const cache sets void sets unsigned int i count i zero input input roots login set roots input module login binary process name input service login binary protocol input local name local name if local ip NULL input local ip local ip if remote ip NULL input remote ip remote ip if set cache NULL set cache master service settings cache init master service input module input service if master service get service count master service 1 master service settings cache init filter set cache if master service settings cache read set cache input NULL parser error 0 i fatal Error reading configuration s error cache sets master service settings parser get others master service parser for count 0 input roots count NULL count i assert cache sets count NULL sets p new pool void count 1 for i 0 i count i sets i login setting dup pool input roots i cache sets i settings var expand login setting parser info sets 0 pool login set var expand table input ssl set r login setting dup pool master service ssl setting parser info settings parser get list parser 1 other settings r sets 1 return sets 0 static Asn1 Generic Decode Asn1 Der Octet String const unsigned char buffer uint32 t max size uint8 t depth uint32 t errcode const unsigned char d ptr buffer uint32 t length numbytes Asn1 Generic a unsigned char c d ptr c d ptr 0 if c 1 7 7 0 length c d ptr else numbytes c 0x7f d ptr if Decode Asn1 Build Value d ptr length numbytes errcode 1 return NULL if length UIN T32 MAX length max size if errcode errcode ERRDERELEMENTSIZETOOBIG return NULL a Asn1 Generic New if a NULL return NULL a type AS N1 OCTETSTRING a strlen length a str SC Malloc length 1 if a str NULLSC Free a return NULL memcpy a str const char d ptr length a str length 0 d ptr length a length d ptr buffer return a static Image Read LABEL Image const Image Info image info Exception Info exception char geometry Max Text Extent property const char label Draw Info draw info Image image Magick Boolean Type status Type Metric metrics size t height width assert image info const Image Info NULL assert image info signature Magick Signature if image info debug Magick False void Log Magick Event Trace Event Get Magick Module s image info filename assert exception Exception Info NULL assert exception signature Magick Signature image Acquire Image image info void Reset Image Page image 0x0 0 0 property Interpret Image Properties image info image image info filename void Set Image Property image label property property Destroy String property label Get Image Property image label draw info Clone Draw Info image info Draw Info NULL draw info text Constant String label metrics width 0 metrics ascent 0 0 status Get Multiline Type Metrics image draw info metrics if image columns 0 image rows 0 image columns size t floor metrics width draw info stroke width 0 5 image rows size t floor metrics height draw info stroke width 0 5 else if strlen label 0 image columns 0 image rows 0 fabs image info pointsize Magick Epsilon double high low for draw info pointsize 2 0 void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry void Get Multiline Type Metrics image draw info metrics width size t floor metrics width draw info stroke width 0 5 height size t floor metrics height draw info stroke width 0 5 if image columns 0 image rows 0 if width image columns height image rows break else if image columns 0 width image columns image rows 0 height image rows break high draw info pointsize for low 1 0 high low 0 5 draw info pointsize low high 2 0 void Format Locale String geometry Max Text Extent g g metrics bounds x1 metrics ascent if draw info gravity Undefined Gravity void Clone String draw info geometry geometry void Get Multiline Type Metrics image draw info metrics width size t floor metrics width draw info stroke width 0 5 height size t floor metrics height draw info stroke width 0 5 if image columns 0 image rows 0 if width image columns height image rows low draw info pointsize 0 5 else high draw info pointsize 0 5 else if image columns 0 width image columns image rows 0 height image rows low draw info pointsize 0 5 else high draw info pointsize 0 5 draw info pointsize low high 2 0 0 5 status Get Multiline Type Metrics image draw info metrics if status Magick False draw info Destroy Draw Info draw info Inherit Exception exception image exception image Destroy Image List image return Image NULL if image columns 0 image columns size t floor metrics width draw info stroke width 0 5 if image columns 0 image columns size t floor draw info pointsize draw info stroke width 0 5 if image rows 0 image rows size t floor metrics ascent metrics descent draw info stroke width 0 5 if image rows 0 image rows size t floor draw info pointsize draw info stroke width 0 5 status Set Image Extent image image columns image rows if status Magick False draw info Destroy Draw Info draw info Inherit Exception exception image exception return Destroy Image List image if Set Image Background Color image Magick False draw info Destroy Draw Info draw info Inherit Exception exception image exception image Destroy Image List image return Image NULL void Format Locale String geometry Max Text Extent g g draw info direction Right To Left Direction image columns metrics bounds x2 0 0 draw info gravity Undefined Gravity metrics ascent 0 0 void Clone String draw info geometry geometry status Annotate Image image draw info if image info pointsize 0 0 char pointsize Max Text Extent void Format Locale String pointsize Max Text Extent 20g draw info pointsize void Set Image Property image label pointsize pointsize draw info Destroy Draw Info draw info if status Magick False image Destroy Image List image return Image NULL return Get First Image In List image static void write modes sb V P9 COMP cpi const Tile Info const tile vp9 writer w TOKENEXTRA tok const TOKENEXTRA const tok end int mi row int mi col BLOCKSIZE bsize const V P9 COMMON const cm cpi common MACROBLOCKD const xd cpi mb e mbd const int bsl b width log2 bsize const int bs 1 bsl 4 PARTITIONTYPE partition BLOCKSIZE subsize const MODEINFO m NULL if mi row cm mi rows mi col cm mi cols return m cm mi mi row cm mi stride mi col src mi partition partition lookup bsl m mbmi sb type write partition cm xd bs mi row mi col partition bsize w subsize get subsize bsize partition if subsize BLOCK 8 X8 write modes b cpi tile w tok tok end mi row mi col else switch partition case PARTITIONNONE write modes b cpi tile w tok tok end mi row mi col break case PARTITIONHORZ write modes b cpi tile w tok tok end mi row mi col if mi row bs cm mi rows write modes b cpi tile w tok tok end mi row bs mi col break case PARTITIONVERT write modes b cpi tile w tok tok end mi row mi col if mi col bs cm mi cols write modes b cpi tile w tok tok end mi row mi col bs break case PARTITIONSPLIT write modes sb cpi tile w tok tok end mi row mi col subsize write modes sb cpi tile w tok tok end mi row mi col bs subsize write modes sb cpi tile w tok tok end mi row bs mi col subsize write modes sb cpi tile w tok tok end mi row bs mi col bs subsize break default assert 0 if bsize BLOCK 8 X8 bsize BLOCK 8 X8 partition PARTITIONSPLIT update partition context xd mi row mi col subsize bsize static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt AS V1 Context const a avctx priv data const uint8 t buf avpkt data int buf size avpkt size AV Frame picture data AV Frame const p a picture int mb x mb y ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 av fast padded malloc a bitstream buffer a bitstream buffer size buf size if a bitstream buffer return AVERRORENOMEM if avctx codec id AVCODECIDAS V1 a dsp bswap buf uint32 t a bitstream buffer const uint32 t buf buf size 4 else int i for i 0 i buf size i a bitstream buffer i ff reverse buf i init get bits a gb a bitstream buffer buf size 8 for mb y 0 mb y a mb height2 mb y for mb x 0 mb x a mb width2 mb x if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb width2 a mb width mb x a mb width2 for mb y 0 mb y a mb height2 mb y if ret decode mb a a block 0 return ret idct put a mb x mb y if a mb height2 a mb height mb y a mb height2 for mb x 0 mb x a mb width mb x if ret decode mb a a block 0 return ret idct put a mb x mb y picture a picture got frame 1 emms c return get bits count a gb 31 32 4 static gcry err code t sexp to key gcry sexp t sexp int want private int use const char override elems gcry mpi t retarray gcry module t retalgo int r is ecc gcry err code t err 0 gcry sexp t list l2 char name const char elems gcry mpi t array gcry module t module gcry pk spec t pubkey pk extra spec t extraspec int is ecc list gcry sexp find token sexp want private private key public key 0 if list want private list gcry sexp find token sexp private key 0 if list return GPGERRINVOBJ l2 gcry sexp cadr list gcry sexp release list list l2 name gcry sexp nth string list 0 if name gcry sexp release list return GPGERRINVOBJ if strcmp name ecc is ecc 2 else if strcmp name ecdsa strcmp name ecdh is ecc 1 else is ecc 0 ath mutex lock pubkeys registered lock if is ecc 2 use GCRYPKUSAGESIGN module gcry pk lookup name ecdsa else if is ecc 2 use GCRYPKUSAGEENCR module gcry pk lookup name ecdh else module gcry pk lookup name name ath mutex unlock pubkeys registered lock gcry free name if module gcry sexp release list return GPGERRPUBKEYALGO else pubkey gcry pk spec t module spec extraspec module extraspec if override elems elems override elems else if want private elems pubkey elements skey else elems pubkey elements pkey array gcry calloc strlen elems 1 sizeof array if array err gpg err code from syserror if err if is ecc err sexp elements extract ecc list elems array extraspec want private else err sexp elements extract list elems array pubkey name gcry sexp release list if err gcry free array ath mutex lock pubkeys registered lock gcry module release module ath mutex unlock pubkeys registered lock else retarray array retalgo module if r is ecc r is ecc is ecc return err static int remote Stream Handle Finish struct qemud client client struct qemud client stream stream struct qemud client message msg remote error rerr int ret VIRDEBUG stream p proc d serial d stream msg hdr proc msg hdr serial memset rerr 0 sizeof rerr stream closed 1 vir Stream Event Remove Callback stream st ret vir Stream Finish stream st if ret 0 remote Dispatch Conn Error rerr client conn return remote Serialize Reply Error client rerr msg hdr else if remote Send Stream Data client stream NULL 0 0 return 1 return 0 static int ec G F2m montgomery point multiply const ECGROUP group ECPOINT r const BIGNUM scalar const ECPOINT point BNCTX ctx BIGNUM x1 x2 z1 z2 int ret 0 i BNULONG mask word if r point E Cerr ECFECG F2 MMONTGOMERYPOINTMULTIPLYECRINVALIDARGUMENT return 0 if scalar NULLBN is zero scalar point NULLECPOINT is at infinity group point return ECPOINT set to infinity group r if point Z is one return 0 BNCTX start ctx x1 BNCTX get ctx z1 BNCTX get ctx if z1 NULL goto err x2 r X z2 r Y bn wexpand x1 group field top bn wexpand z1 group field top bn wexpand x2 group field top bn wexpand z2 group field top if BNG F2m mod arr x1 point X group poly goto err if BN one z1 goto err if group meth field sqr group z2 x1 ctx goto err if group meth field sqr group x2 z2 ctx goto err if BNG F2m add x2 x2 group b goto err i scalar top 1 mask BNTBIT word scalar d i while word mask mask 1 mask 1 if mask i mask BNTBIT for i 0 i word scalar d i while mask BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top if gf2m Madd group point X x2 z2 x1 z1 ctx goto err if gf2m Mdouble group x1 z1 ctx goto err BN consttime swap word mask x1 x2 group field top BN consttime swap word mask z1 z2 group field top mask 1 mask BNTBIT i gf2m Mxy group point X point Y x1 z1 x2 z2 ctx if i 0 goto err else if i 1 if ECPOINT set to infinity group r goto err else if BN one r Z goto err r Z is one 1 BN set negative r X 0 BN set negative r Y 0 ret 1 err BNCTX end ctx return ret static int pnm decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size PNM Context const s avctx priv data AV Frame picture data AV Frame const p s picture int i j n linesize h upgrade 0 unsigned char ptr int components sample len ret s bytestream start s bytestream buf s bytestream end buf buf size if ret ff pnm decode header avctx s 0 return ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 switch avctx pix fmt default return AVERROREINVAL case AVPIXFMTRG B48 BE n avctx width 6 components 3 sample len 16 goto do read case AVPIXFMTRG B24 n avctx width 3 components 3 sample len 8 goto do read case AVPIXFMTGRA Y8 n avctx width components 1 sample len 8 if s maxval 255 upgrade 1 goto do read case AVPIXFMTGRA Y16 BE case AVPIXFMTGRA Y16 LE n avctx width 2 components 1 sample len 16 if s maxval 65535 upgrade 2 goto do read case AVPIXFMTMONOWHITE case AVPIXFMTMONOBLACK n avctx width 7 3 components 1 sample len 1 do read ptr p data 0 linesize p linesize 0 if s bytestream n avctx height s bytestream end return AVERRORINVALIDDATA if s type 4 for i 0 i avctx height i Put Bit Context pb init put bits pb ptr linesize for j 0 j avctx width components j unsigned int c 0 int v 0 while s bytestream s bytestream end s bytestream 0 s bytestream 9 s bytestream if s bytestream s bytestream end return AVERRORINVALIDDATA do v 10 v c c s bytestream 0 while c 9 put bits pb sample len 1 sample len 1 v s maxval 1 s maxval flush put bits pb ptr linesize else for i 0 i avctx height i if upgrade memcpy ptr s bytestream n else if upgrade 1 unsigned int j f 255 128 s maxval 2 s maxval for j 0 j n j ptr j s bytestream j f 64 7 else if upgrade 2 unsigned int j v f 65535 32768 s maxval 2 s maxval for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize break case AVPIXFMTYU V420 P case AVPIXFMTYU V420 P9 BE case AVPIXFMTYU V420 P10 BE unsigned char ptr1 ptr2 n avctx width ptr p data 0 linesize p linesize 0 if s maxval 256 n 2 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i memcpy ptr s bytestream n s bytestream n ptr linesize ptr1 p data 1 ptr2 p data 2 n 1 h avctx height 1 for i 0 i h i memcpy ptr1 s bytestream n s bytestream n memcpy ptr2 s bytestream n s bytestream n ptr1 p linesize 1 ptr2 p linesize 2 break case AVPIXFMTYU V420 P16 uint16 t ptr1 ptr2 const int f 65535 32768 s maxval 2 s maxval unsigned int j v n avctx width 2 ptr p data 0 linesize p linesize 0 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize ptr1 uint16 t p data 1 ptr2 uint16 t p data 2 n 1 h avctx height 1 for i 0 i h i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr1 j v f 16384 15 s bytestream n for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr2 j v f 16384 15 s bytestream n ptr1 p linesize 1 2 ptr2 p linesize 2 2 break case AVPIXFMTRG B32 ptr p data 0 linesize p linesize 0 if s bytestream avctx width avctx height 4 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i int j r g b a for j 0 j avctx width j r s bytestream g s bytestream b s bytestream a s bytestream uint32 t ptr j a 24 r 16 g 8 b ptr linesize break picture s picture got frame 1 return s bytestream s bytestream start mbfl string mbfl strcut mbfl string string mbfl string result int from int length const mbfl encoding encoding mbfl memory device device if string NULL string val NULL result NULL return NULL if from 0 length 0 return NULL if from string len from string len encoding mbfl no2encoding string no encoding if encoding NULL return NULL mbfl string init result result no language string no language result no encoding string no encoding if encoding flag MBFLENCTYPESBCSMBFLENCTYPEWC S2 BEMBFLENCTYPEWC S2 LEMBFLENCTYPEWC S4 BEMBFLENCTYPEWC S4 LE encoding mblen table NULL const unsigned char start NULL const unsigned char end NULL unsigned char w unsigned int sz if encoding flag MBFLENCTYPEWC S2 BEMBFLENCTYPEWC S2 LE from 2 if length string len from length string len from start string val from end start length 2 else if encoding flag MBFLENCTYPEWC S4 BEMBFLENCTYPEWC S4 LE from 4 if length string len from length string len from start string val from end start length 4 else if encoding flag MBFLENCTYPESBCS if length string len from length string len from start string val from end start length else if encoding mblen table NULL const unsigned char mbtab encoding mblen table const unsigned char p q int m for m 0 p string val q p from p q p m mbtab p if p q p m start p if length int string len start string val end string val string len else for q p length p q p m mbtab p if p q p m end p else return NULL sz end start if w unsigned char mbfl calloc sz 8 sizeof unsigned char NULL return NULL memcpy w start sz w sz 0 w sz 1 0 w sz 2 0 w sz 3 0 result val w result len sz else mbfl convert filter encoder NULL mbfl convert filter decoder NULL const unsigned char p q r struct mbfl convert filter encoder mbfl convert filter decoder const unsigned char p int pos bk bk if decoder mbfl convert filter new mbfl no encoding wchar string no encoding mbfl memory device output 0 device return NULL if encoder mbfl convert filter new string no encoding mbfl no encoding wchar mbfl filter output null NULLNULL mbfl convert filter delete decoder return NULL mbfl memory device init device length 8 0 p string val for q string val from p q p encoder filter function p encoder encoder output function int int void decoder filter function encoder flush function int void decoder filter flush encoder data decoder q string val string len mbfl convert filter copy decoder bk decoder mbfl convert filter copy encoder bk encoder bk p p bk pos device pos if length q p length q p if length 20 for r p length 20 p r p encoder filter function p encoder if device pos length p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder bk bk else mbfl convert filter copy decoder bk decoder mbfl convert filter copy encoder bk encoder bk p p bk pos device pos encoder filter flush encoder if device pos length bk decoder filter dtor bk decoder bk encoder filter dtor bk encoder p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder bk bk else bk decoder filter dtor bk decoder bk encoder filter dtor bk encoder p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder else bk bk while p q encoder filter function p encoder if device pos length p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder break p mbfl convert filter copy decoder bk decoder mbfl convert filter copy encoder bk encoder bk pos device pos bk p p encoder filter flush encoder if device pos length bk decoder filter dtor bk decoder bk encoder filter dtor bk encoder p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder break bk decoder filter dtor bk decoder bk encoder filter dtor bk encoder p bk p device pos bk pos decoder filter dtor decoder encoder filter dtor encoder mbfl convert filter copy bk decoder decoder mbfl convert filter copy bk encoder encoder bk bk encoder filter flush encoder bk decoder filter dtor bk decoder bk encoder filter dtor bk encoder result mbfl memory device result device result mbfl convert filter delete encoder mbfl convert filter delete decoder return result void ff draw horiz band AV Codec Context avctx DSP Context dsp Picture cur Picture last int y int h int picture structure int first field int draw edges int low delay int v edge pos int h edge pos const AV Pix Fmt Descriptor desc av pix fmt desc get avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h const int field pic picture structure PICTFRAME if field pic h 1 y 1 if avctx hwaccel avctx codec capabilities CODECCAPHWACCELVDPAU draw edges cur f reference avctx flags CODECFLAGEMUEDGE int linesize cur f linesize int sides 0 edge h if y 0 sides EDGETOP if y h v edge pos sides EDGEBOTTOM edge h FFMIN h v edge pos y dsp draw edges cur f data 0 y linesize 0 linesize 0 h edge pos edge h EDGEWIDTHEDGEWIDTH sides dsp draw edges cur f data 1 y vshift linesize 1 linesize 1 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides dsp draw edges cur f data 2 y vshift linesize 2 linesize 2 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides h FFMIN h avctx height y if field pic first field avctx slice flags SLICEFLAGALLOWFIELD return if avctx draw horiz band AV Frame src int offset AVNUMDATAPOINTERS int i if cur f pict type AVPICTURETYPEB low delay avctx slice flags SLICEFLAGCODEDORDER src cur f else if last src last f else return if cur f pict type AVPICTURETYPEB picture structure PICTFRAME avctx codec id AVCODECID H264 avctx codec id AVCODECIDSV Q3 for i 0 i AVNUMDATAPOINTERS i offset i 0 else offset 0 y src linesize 0 offset 1 offset 2 y vshift src linesize 1 for i 3 i AVNUMDATAPOINTERS i offset i 0 emms c avctx draw horiz band avctx src offset y picture structure h void create directory config apr pool t mp char path directory config dcfg directory config apr pcalloc mp sizeof directory config if dcfg NULL return NULL dcfg is enabled NOTSET dcfg reqbody access NOTSET dcfg reqintercept oe NOTSET dcfg reqbody buffering NOTSET dcfg reqbody inmemory limit NOTSET dcfg reqbody limit NOTSET dcfg reqbody no files limit NOTSET dcfg resbody access NOTSET dcfg debuglog name NOTSETP dcfg debuglog level NOTSET dcfg debuglog fd NOTSETP dcfg of limit NOTSET dcfg if limit action NOTSET dcfg of limit action NOTSET dcfg of mime types NOTSETP dcfg of mime types cleared NOTSET dcfg cookie format NOTSET dcfg argument separator NOTSET dcfg cookiev0 separator NOTSETP dcfg rule inheritance NOTSET dcfg rule exceptions apr array make mp 16 sizeof rule exception dcfg hash method apr array make mp 16 sizeof hash method dcfg auditlog flag NOTSET dcfg auditlog type NOTSET dcfg max rule time NOTSET dcfg auditlog dirperms NOTSET dcfg auditlog fileperms NOTSET dcfg auditlog name NOTSETP dcfg auditlog2 name NOTSETP dcfg auditlog fd NOTSETP dcfg auditlog2 fd NOTSETP dcfg auditlog storage dir NOTSETP dcfg auditlog parts NOTSETP dcfg auditlog relevant regex NOTSETP dcfg ruleset NULL dcfg tmp dir NOTSETP dcfg upload dir NOTSETP dcfg upload keep files NOTSET dcfg upload validates files NOTSET dcfg upload filemode NOTSET dcfg upload file limit NOTSET dcfg tmp chain starter NULL dcfg tmp default actionset NULL dcfg tmp rule placeholders NULL dcfg data dir NOTSETP dcfg webappid NOTSETP dcfg sensor id NOTSETP dcfg http Blkey NOTSETP dcfg content injection enabled NOTSET dcfg stream inbody inspection NOTSET dcfg stream outbody inspection NOTSET dcfg geo NOTSETP dcfg gsb NOTSETP dcfg u map NOTSETP dcfg cache trans NOTSET dcfg cache trans incremental NOTSET dcfg cache trans min NOTSET dcfg cache trans max NOTSET dcfg cache trans maxitems NOTSET dcfg rule id htab apr hash make mp dcfg component signatures apr array make mp 16 sizeof char dcfg request encoding NOTSETP dcfg disable backend compression NOTSET dcfg col timeout NOTSET dcfg crypto key NOTSETP dcfg crypto key len NOTSET dcfg crypto key add NOTSET dcfg crypto param name NOTSETP dcfg hash is enabled NOTSET dcfg hash enforcement NOTSET dcfg crypto hash href rx NOTSET dcfg crypto hash faction rx NOTSET dcfg crypto hash location rx NOTSET dcfg crypto hash iframesrc rx NOTSET dcfg crypto hash framesrc rx NOTSET dcfg crypto hash href pm NOTSET dcfg crypto hash faction pm NOTSET dcfg crypto hash location pm NOTSET dcfg crypto hash iframesrc pm NOTSET dcfg crypto hash framesrc pm NOTSET dcfg xml external entity NOTSET return dcfg static int aes ccm ctrl EVPCIPHERCTX c int type int arg void ptr EVPAESCCMCTX cctx EVPCDATAEVPAESCCMCTX c switch type case EVPCTRLINIT cctx key set 0 cctx iv set 0 cctx L 8 cctx M 12 cctx tag set 0 cctx len set 0 cctx tls aad len 1 return 1 case EVPCTRLAEADTL S1 AAD if arg EVPAEADTL S1 AADLEN return 0 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx tls aad len arg uint16 t len EVPCIPHERCTX buf noconst c arg 2 8 EVPCIPHERCTX buf noconst c arg 1 if len EVPCCMTLSEXPLICITIVLEN return 0 len EVPCCMTLSEXPLICITIVLEN if EVPCIPHERCTX encrypting c if len cctx M return 0 len cctx MEVPCIPHERCTX buf noconst c arg 2 len 8 EVPCIPHERCTX buf noconst c arg 1 len 0xff return cctx M case EVPCTRLCCMSETIVFIXED if arg EVPCCMTLSFIXEDIVLEN return 0 memcpy EVPCIPHERCTX iv noconst c ptr arg return 1 case EVPCTRLAEADSETIVLEN arg 15 arg case EVPCTRLCCMSETL if arg 2 arg 8 return 0 cctx L arg return 1 case EVPCTRLAEADSETTAG if arg 1 arg 4 arg 16 return 0 if EVPCIPHERCTX encrypting c ptr return 0 if ptr cctx tag set 1 memcpy EVPCIPHERCTX buf noconst c ptr arg cctx M arg return 1 case EVPCTRLAEADGETTAG if EVPCIPHERCTX encrypting c cctx tag set return 0 if CRYPTO ccm128 tag cctx ccm ptr size t arg return 0 cctx tag set 0 cctx iv set 0 cctx len set 0 return 1 case EVPCTRLCOPYEVPCIPHERCTX out ptr EVPAESCCMCTX cctx out EVPCDATAEVPAESCCMCTX out if cctx ccm key if cctx ccm key cctx ks return 0 cctx out ccm key cctx out ks return 1 default return 1 static void MCFUNC hl motion H264 Context h uint8 t dest y uint8 t dest cb uint8 t dest cr qpel mc func qpix put 16 h264 chroma mc func chroma put qpel mc func qpix avg 16 h264 chroma mc func chroma avg h264 weight func weight op h264 biweight func weight avg const int mb xy h mb xy const int mb type h cur pic mb type mb xy assert ISINTER mb type if HAVETHREADS h avctx active thread type FFTHREADFRAME await references h prefetch motion h 0 PIXELSHIFTCHROMAIDC if IS 16 X16 mb type mc part h 0 1 16 0 dest y dest cb dest cr 0 0 qpix put 0 chroma put 0 qpix avg 0 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 else if IS 16 X8 mb type mc part h 0 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 0 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 8 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 4 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 1 0 ISDIR mb type 1 1 else if IS 8 X16 mb type mc part h 0 0 16 8 h mb linesize dest y dest cb dest cr 0 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 4 0 16 8 h mb linesize dest y dest cb dest cr 4 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 1 0 ISDIR mb type 1 1 else int i assert IS 8 X8 mb type for i 0 i 4 i const int sub mb type h sub mb type i const int n 4 i int x offset i 1 2 int y offset i 2 1 if ISSUB 8 X8 sub mb type mc part h n 1 8 0 dest y dest cb dest cr x offset y offset qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 8 X4 sub mb type mc part h n 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 2 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset 2 qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 4 X8 sub mb type mc part h n 0 8 4 h mb linesize dest y dest cb dest cr x offset y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 1 0 8 4 h mb linesize dest y dest cb dest cr x offset 2 y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else int j assert ISSUB 4 X4 sub mb type for j 0 j 4 j int sub x offset x offset 2 j 1 int sub y offset y offset j 2 mc part h n j 1 4 0 dest y dest cb dest cr sub x offset sub y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 prefetch motion h 1 static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Sgi State s avctx priv data AV Frame p data unsigned int dimension rle int ret 0 uint8 t out buf out end bytestream2 init s g avpkt data avpkt size if bytestream2 get bytes left s g SGIHEADERSIZE av log avctx AVLOGERROR buf size too small d n avpkt size return AVERRORINVALIDDATA if bytestream2 get be16 s g SGIMAGIC av log avctx AVLOGERROR bad magic number n return AVERRORINVALIDDATA rle bytestream2 get byte s g s bytes per channel bytestream2 get byte s g dimension bytestream2 get be16 s g s width bytestream2 get be16 s g s height bytestream2 get be16 s g s depth bytestream2 get be16 s g if s bytes per channel 1 s bytes per channel 2 rle av log avctx AVLOGERROR wrong channel number n return 1 if dimension 2 dimension 3 av log avctx AVLOGERROR wrong dimension number n return 1 if s depth SGIGRAYSCALE avctx pix fmt s bytes per channel 2 AVPIXFMTGRA Y16 BEAVPIXFMTGRA Y8 else if s depth SGIRGB avctx pix fmt s bytes per channel 2 AVPIXFMTRG B48 BEAVPIXFMTRG B24 else if s depth SGIRGBA s bytes per channel 1 avctx pix fmt AVPIXFMTRGBA else av log avctx AVLOGERROR wrong picture format n return 1 if av image check size s width s height 0 avctx return 1 avcodec set dimensions avctx s width s height if ff get buffer avctx p 0 0 av log avctx AVLOGERROR get buffer failed n return 1 p pict type AVPICTURETYPEI p key frame 1 out buf p data 0 out end out buf p linesize 0 s height s linesize p linesize 0 bytestream2 seek s g SGIHEADERSIZESEEKSET if rle ret read rle sgi out end s else ret read uncompressed sgi out buf out end s if ret 0 got frame 1 return avpkt size else return ret static void fill colmap H264 Context h int map 2 16 32 int list int field int colfield int mbafi Picture const ref1 h ref list 1 0 int j old ref rfield int start mbafi 16 0 int end mbafi 16 2 h ref count 0 h ref count 0 int interl mbafi h picture structure PICTFRAME memset map list 0 sizeof map list for rfield 0 rfield 2 rfield for old ref 0 old ref ref1 ref count colfield list old ref int poc ref1 ref poc colfield list old ref if interl poc 3 else if interl poc 3 3 poc poc 3 rfield 1 for j start j end j if 4 h ref list 0 j frame num h ref list 0 j reference 3 poc int cur ref mbafi j 16 field j if ref1 mbaff map list 2 old ref rfield field 16 cur ref if rfield field interl map list old ref cur ref break static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data const uint8 t buf end buf avpkt size Kgv Context const c avctx priv data int offsets 8 uint16 t out prev int outcnt 0 maxcnt int w h i res if avpkt size 2 return AVERRORINVALIDDATA w buf 0 1 8 h buf 1 1 8 buf 2 if res av image check size w h 0 avctx 0 return res if w avctx width h avctx height if c prev data 0 avctx release buffer avctx c prev avcodec set dimensions avctx w h maxcnt w h c cur reference 3 if res ff get buffer avctx c cur 0 return res out uint16 t c cur data 0 if c prev data 0 prev uint16 t c prev data 0 else prev NULL for i 0 i 8 i offsets i 1 while outcnt maxcnt buf end 2 buf int code AVR L16 buf buf 2 if code 0x8000 out outcnt code else int count int inp off uint16 t inp if code 0x6000 0x6000 int oidx code 10 7 int start count code 0x3 FF 3 if offsets oidx 0 if buf end 3 buf break offsets oidx AVR L24 buf buf 3 start outcnt offsets oidx maxcnt if maxcnt start count break if prev av log avctx AVLOGERROR Frame reference does not exist n break inp prev inp off start else int offset code 0x1 FFF 1 if code 0x6000 count 2 else if code 0x6000 0x2000 count 3 else if buf end 1 buf break count 4 buf if outcnt offset break inp out inp off outcnt offset if maxcnt outcnt count break for i inp off i count inp off i out outcnt inp i if outcnt maxcnt av log avctx AVLOGDEBUG frame finished with d diff n outcnt maxcnt got frame 1 AV Frame data c cur if c prev data 0 avctx release buffer avctx c prev FFSWAPAV Frame c cur c prev return avpkt size void ff estimate b frame motion Mpeg Enc Context s int mb x int mb y Motion Est Context const c s me const int penalty factor c mb penalty factor int fmin bmin dmin fbmin bimin fimin int type 0 const int xy mb y s mb stride mb x init ref c s new picture f data s last picture f data s next picture f data 16 mb x 16 mb y 2 get limits s 16 mb x 16 mb y c skip 0 if s codec id AVCODECIDMPE G4 s next picture f mbskip table xy int score direct search s mb x mb y score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score s mb type mb y s mb stride mb x CANDIDATEMBTYPEDIREC T0 return if s codec id AVCODECIDMPE G4 dmin direct search s mb x mb y else dmin INTMAX c skip 0 fmin ff estimate motion b s mb x mb y s b forw mv table 0 s f code 3 penalty factor c skip 0 bmin ff estimate motion b s mb x mb y s b back mv table 2 s b code 2 penalty factor av dlog s d d s b forw mv table xy 0 s b forw mv table xy 1 c skip 0 fbmin bidir refine s mb x mb y penalty factor av dlog s d d d d n dmin fmin bmin fbmin if s flags CODECFLAGINTERLACEDME c skip 0 c current mv penalty c mv penalty s f code MAXMV fimin interlaced search s 0 s b field mv table 0 s b field select table 0 s b forw mv table xy 0 s b forw mv table xy 1 0 c current mv penalty c mv penalty s b code MAXMV bimin interlaced search s 2 s b field mv table 1 s b field select table 1 s b back mv table xy 0 s b back mv table xy 1 0 else fimin bimin INTMAX int score fmin type CANDIDATEMBTYPEFORWARD if dmin score score dmin type CANDIDATEMBTYPEDIRECT if bmin score score bmin type CANDIDATEMBTYPEBACKWARD if fbmin score score fbmin type CANDIDATEMBTYPEBIDIR if fimin score score fimin type CANDIDATEMBTYPEFORWARDI if bimin score score bimin type CANDIDATEMBTYPEBACKWARDI score unsigned score score 128 256 16 c mc mb var sum temp score s current picture mc mb var mb y s mb stride mb x score if c avctx mb decision FFMBDECISIONSIMPLE type CANDIDATEMBTYPEFORWARDCANDIDATEMBTYPEBACKWARDCANDIDATEMBTYPEBIDIRCANDIDATEMBTYPEDIRECT if fimin INTMAX type CANDIDATEMBTYPEFORWARDI if bimin INTMAX type CANDIDATEMBTYPEBACKWARDI if fimin INTMAX bimin INTMAX type CANDIDATEMBTYPEBIDIRI if dmin 256 256 16 type CANDIDATEMBTYPEDIRECT if s codec id AVCODECIDMPE G4 type CANDIDATEMBTYPEDIRECT s flags CODECFLAGM V0 uint32 t s b direct mv table xy type CANDIDATEMBTYPEDIREC T0 s mb type mb y s mb stride mb x type static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint32 t src const uint32 t avpkt data AV Frame pic avctx coded frame int width avctx width int y 0 uint16 t ydst udst vdst yend int ret if pic data 0 avctx release buffer avctx pic if avpkt size avctx width avctx height 8 3 av log avctx AVLOGERROR Packet too small n return AVERRORINVALIDDATA if avpkt size avctx width avctx height 8 3 av log ask for sample avctx Probably padded data n pic reference 0 if ret ff get buffer avctx pic 0 return ret ydst uint16 t pic data 0 udst uint16 t pic data 1 vdst uint16 t pic data 2 yend ydst width pic pict type AVPICTURETYPEI pic key frame 1 for uint32 t v av be2ne32 src udst v 16 0x FF C0 ydst v 6 0x FF C0 vdst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 6 0x FF C0 ydst v 4 0x FF C0 v av be2ne32 src vdst v 16 0x FF C0 ydst v 6 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break udst v 4 0x FF C0 v av be2ne32 src ydst v 16 0x FF C0 vdst v 6 0x FF C0 ydst v 4 0x FF C0 if ydst yend ydst pic linesize 0 2 width udst pic linesize 1 2 width 2 vdst pic linesize 2 2 width 2 yend ydst width if y avctx height break got frame 1 AV Frame data avctx coded frame return avpkt size void ff draw horiz band AV Codec Context avctx DSP Context dsp Picture cur Picture last int y int h int picture structure int first field int draw edges int low delay int v edge pos int h edge pos const AV Pix Fmt Descriptor desc av pix fmt desc get avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h const int field pic picture structure PICTFRAME if field pic h 1 y 1 if avctx hwaccel avctx codec capabilities CODECCAPHWACCELVDPAU draw edges cur f reference avctx flags CODECFLAGEMUEDGE int linesize cur f linesize int sides 0 edge h if y 0 sides EDGETOP if y h v edge pos sides EDGEBOTTOM edge h FFMIN h v edge pos y dsp draw edges cur f data 0 y linesize 0 linesize 0 h edge pos edge h EDGEWIDTHEDGEWIDTH sides dsp draw edges cur f data 1 y vshift linesize 1 linesize 1 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides dsp draw edges cur f data 2 y vshift linesize 2 linesize 2 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides h FFMIN h avctx height y if field pic first field avctx slice flags SLICEFLAGALLOWFIELD return if avctx draw horiz band AV Frame src int offset AVNUMDATAPOINTERS int i if cur f pict type AVPICTURETYPEB low delay avctx slice flags SLICEFLAGCODEDORDER src cur f else if last src last f else return if cur f pict type AVPICTURETYPEB picture structure PICTFRAME avctx codec id AVCODECID H264 avctx codec id AVCODECIDSV Q3 for i 0 i AVNUMDATAPOINTERS i offset i 0 else offset 0 y src linesize 0 offset 1 offset 2 y vshift src linesize 1 for i 3 i AVNUMDATAPOINTERS i offset i 0 emms c avctx draw horiz band avctx src offset y picture structure h static gint detect version wtap wth int err gchar err info gint bytes read guint16 payload length guint16 try header size guint8 buffer gint64 file offset guint32 log length guint32 tag length guint16 tmp file offset file tell wth fh bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 payload length pletoh16 tmp bytes read file read tmp 2 wth fh if bytes read 2 err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD return 1 try header size pletoh16 tmp buffer guint8 g malloc 5 4 payload length bytes read file read buffer 5 4 payload length wth fh if bytes read 5 4 payload length if bytes read 4 4 payload length err file error wth fh err info if err 0 bytes read 0 err WTAPERRSHORTREAD g free buffer return 1 if try header size 24 tag length guint32 strlen buffer 5 4 1 1 log length guint32 strlen buffer 5 4 1 tag length 1 if payload length 1 tag length log length g free buffer return 2 tag length guint32 strlen buffer 4 4 1 1 log length guint32 strlen buffer 4 4 1 tag length 1 if payload length 1 tag length log length if file seek wth fh file offset 4 4 1 tag length log length SEEKSET err 1 g free buffer return 1 g free buffer return 1 g free buffer return 0 static P Gconn connect DB Archive Handle AH const char reqdb const char requser PQ Exp Buffer Data connstr P Gconn new Conn const char newdb const char newuser char password bool new pass if reqdb newdb P Qdb AH connection else newdb reqdb if requser strlen requser 0 newuser P Quser AH connection else newuser requser ahlog AH 1 connecting to database s as user s n newdb newuser password AH saved Password pg strdup AH saved Password NULL if AH prompt Password TRIYES password NULL password simple prompt Password 100 false if password NULL exit horribly modulename out of memory n init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr newdb do const char keywords 7 const char values 7 keywords 0 host values 0 P Qhost AH connection keywords 1 port values 1 P Qport AH connection keywords 2 user values 2 newuser keywords 3 password values 3 password keywords 4 dbname values 4 connstr data keywords 5 fallback application name values 5 progname keywords 6 NULL values 6 NULL new pass false new Conn P Qconnectdb Params keywords values true if new Conn exit horribly modulename failed to reconnect to database n if P Qstatus new Conn CONNECTIONBAD if P Qconnection Needs Password new Conn exit horribly modulename could not reconnect to database s P Qerror Message new Conn P Qfinish new Conn if password fprintf stderr Password incorrect n fprintf stderr Connecting to s as s n newdb newuser if password free password if AH prompt Password TRINO password simple prompt Password 100 false else exit horribly modulename connection needs password n if password NULL exit horribly modulename out of memory n new pass true while new pass if P Qconnection Used Password new Conn if AH saved Password free AH saved Password AH saved Password pg strdup P Qpass new Conn if password free password term PQ Exp Buffer connstr check database version AHP Qset Notice Processor new Conn notice processor NULL return new Conn static void slurm rpc submit batch job slurm msg t msg static int active rpc cnt 0 int error code SLURMSUCCESSDEFTIMERS uint32 t job id 0 priority 0 struct job record job ptr NULL slurm msg t response msg submit response msg t submit msg job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info gid t gid g slurm auth get gid msg auth cred slurmctld config auth info char err msg NULL job submit user msg NULL bool reject job false STARTTIMER debug2 Processing RPCREQUESTSUBMITBATCHJOB from uid d uid if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED reject job true goto send msg if error code valid id REQUESTSUBMITBATCHJOB job desc msg uid gid reject job true goto send msg if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTSUBMITBATCHJOB lacks alloc node from uid d uid dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if error code reject job true goto send msg throttle start active rpc cnt lock slurmctld job write lock STARTTIMER if fed mgr fed rec if fed mgr job allocate msg job desc msg false uid msg protocol version job id error code err msg reject job true else job desc msg pack job offset NOVAL error code job allocate job desc msg job desc msg immediate false NULL 0 uid job ptr err msg msg protocol version if job ptr error code job ptr job state JOBFAILED reject job true else job id job ptr job id priority job ptr priority if job desc msg immediate error code SLURMSUCCESS error code ESLURMCANNOTSTARTIMMEDIATELY reject job true unlock slurmctld job write lock throttle fini active rpc cnt send msg ENDTIME R2 slurm rpc submit batch job if reject job info s s func slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else info s Job Id u Init Prio u s func job id priority TIMESTR submit msg job id job id submit msg step id SLURMBATCHSCRIPT submit msg error code error code submit msg job submit user msg job submit user msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg conn msg conn response msg msg type RESPONSESUBMITBATCHJOB response msg data submit msg slurm send node msg msg conn fd response msg schedule job save schedule node save queue job scheduler xfree err msg xfree job submit user msg int main int argc char argv struct event evfifo socket Create File A test txt GENERICREAD 0 NULLOPENEXISTINGFILEATTRIBUTENORMALNULL if socket INVALIDHANDLEVALUE return 1 const char fifo event fifo int socket if lstat fifo st 0 if st st mode SIFMTSIFREG errno EEXIST perror lstat exit 1 unlink fifo if mkfifo fifo 0600 1 perror mkfifo exit 1 perror open exit 1 static void write header FILE sql file char db name if opt xml fputs xml version 1 0 n sql file fputs mysqldump sql file fputs xmlns xsi http fputs n sql file check io sql file else if opt compact print comment sql file 0 My SQL dump s Distrib s for s s n n DUMPVERSIONMYSQLSERVERVERSIONSYSTEMTYPEMACHINETYPE print comment sql file 0 Host s Database s n current host current host localhost db name db name print comment sql file 0 n print comment sql file 0 Server version t s n mysql get server info mysql connection if opt set charset fprintf sql file n n n n n default charset if opt tz utc fprintf sql file n fprintf sql file n if path if opt no create info fprintf md result file n fprintf md result file n fprintf sql file n n path NOAUTOVALUEONZERO compatible mode normal str 0 0 compatible mode normal str check io sql file int petite inflate2x 1to9 char buf uint32 t minrva uint32 t bufsz struct cli exe section sections unsigned int sectcount uint32 t Imagebase uint32 t pep int desc int version uint32 t Res Rva uint32 t Res Size char adjbuf buf minrva char packed NULL uint32 t thisrva 0 bottom 0 enc ep 0 irva 0 workdone 0 grown 0x355 skew 0x35 int j 0 oob mangled 0 check4resources 0 struct cli exe section usects NULL void tmpsct NULL if version 2 packed adjbuf sections sectcount 1 rva 0x1b8 if version 1 packed adjbuf sections sectcount 1 rva 0x178 grown 0x323 skew 0x34 while 1 char ssrc ddst uint32 t size srva int backbytes oldback backsize addsize if CLIISCONTAINED buf bufsz packed 4 if usects free usects return 1 srva cli readint32 packed if srva int t upd 1 if j 0 return 1 while upd upd 0 for t 0 t j 1 t uint32 t trva trsz tvsz if usects t rva usects t 1 rva continue trva usects t rva trsz usects t rsz tvsz usects t vsz usects t rva usects t 1 rva usects t rsz usects t 1 rsz usects t vsz usects t 1 vsz usects t 1 rva trva usects t 1 rsz trsz usects t 1 vsz tvsz upd 1 for t 0 t j 1 t if usects t vsz usects t 1 rva usects t rva usects t vsz usects t 1 rva usects t rva if enc ep uint32 t virtaddr pep 5 Imagebase tmpep int rndm 0 dummy 1 char thunk adjbuf irva char imports if version 2 while dummy CLIISCONTAINED buf bufsz thunk 4 uint32 t api if cli readint32 thunk workdone 1 break imports adjbuf cli readint32 thunk thunk 4 dummy 0 while CLIISCONTAINED buf bufsz imports 4 dummy 0 imports 4 if api cli readint32 imports 4 dummy 1 break if api api 0x80000000 mangled rndm 0 api virtaddr virtaddr 5 rndm virtaddr 7 else api 0xbff01337 if sections sectcount 1 rva Imagebase api enc ep if api virtaddr enc ep tmpep enc ep 0xfffffff8 3 0x1fffffff enc ep enc ep 7 29 tmpep else workdone 1 enc ep pep 5 enc ep if workdone 1 cli dbgmsg Petite Old EP x n enc ep else enc ep usects 0 rva cli dbgmsg Petite In troubles while attempting to decrypt old EP using bogus x n enc ep for t 0 t j t usects t raw t 0 usects t 1 raw usects t 1 rsz 0 if usects t rsz 0 if CLIISCONTAINED buf bufsz buf usects t raw usects t rsz memmove buf usects t raw adjbuf usects t rva usects t rsz else cli dbgmsg Petite Skipping section d Raw x R Size x n t usects t raw usects t rsz usects t raw t 0 usects t 1 raw 0 usects t rsz 0 cli dbgmsg Petite Sections dump n for t 0 t j t cli dbgmsg Petite SECT d RVA x V Size x R Offset x R Size x n t usects t rva usects t vsz usects t raw usects t rsz if cli rebuildpe buf usects j Imagebase enc ep Res Rva Res Size desc cli dbgmsg Petite Rebuilding failed n free usects return 1 free usects return 0 size srva 0x7fffffff if srva size check4resources 0 if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 bottom cli readint32 packed 8 4 ssrc adjbuf cli readint32 packed 4 size 1 4 ddst adjbuf cli readint32 packed 8 size 1 4 if CLIISCONTAINED buf bufsz ssrc size 4 CLIISCONTAINED buf bufsz ddst size 4 if usects free usects return 1 memmove ddst ssrc size 4 packed 0x0c else uint32 t check1 check2 uint8 t mydl 0 uint8 t goback unsigned int q if CLIISCONTAINED buf bufsz packed 4 8 if usects free usects return 1 size cli readint32 packed 4 thisrva cli readint32 packed 8 packed 0x10 if j 96 cli dbgmsg Petite maximum number of sections exceeded giving up n free usects return 1 if tmpsct cli realloc usects sizeof struct cli exe section j 1 if usects free usects return 1 usects struct cli exe section tmpsct usects j rva thisrva usects j rsz size if int bottom thisrva 0 usects j vsz bottom thisrva else usects j vsz size usects j raw 0 if size j continue ssrc adjbuf srva ddst adjbuf thisrva for q 0 q sectcount q if CLIISCONTAINED sections q rva sections q vsz usects j rva usects j vsz continue if check4resources usects j rva sections q rva usects j rsz thisrva sections q rva size break if q sectcount free usects return 1 j if size 0x10000 check1 0x0 FFFF C060 check2 0x0 FFFFF C60 goback 5 else if size 0x40000 check1 0x0 FFF F8180 check2 0x0 FFFF F980 goback 7 else check1 0x0 FFF F8300 check2 0x0 FFFFF B00 goback 8 if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 size ddst ssrc backbytes 0 oldback 0 while size 0 oob doubledl ssrc mydl buf bufsz if oob 1 free usects return 1 if oob if CLIISCONTAINED buf bufsz ssrc 1 CLIISCONTAINED buf bufsz ddst 1 free usects return 1 ddst char ssrc size 0xff size else addsize 0 backbytes while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backbytes 3 if backbytes 0 backsize goback do if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backbytes backbytes 2 oob backsize while backsize backbytes 0xffffffff addsize 1 backbytes int check2 backbytes int check1 oldback backbytes else backsize backbytes 1 backbytes oldback if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if backsize backsize while 1 if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 backsize backsize 2 oob if oob doubledl ssrc mydl buf bufsz 1 free usects return 1 if oob break backsize 2 backsize addsize size backsize if CLIISCONTAINED buf bufsz ddst backsize CLIISCONTAINED buf bufsz ddst backbytes backsize free usects return 1 while backsize ddst ddst backbytes ddst backbytes 0 backsize 0 if j int strippetite 0 uint32 t reloc if usects j 1 rsz grown CLIISCONTAINED buf bufsz ddst grown 5 0x4f 8 cli readint32 ddst grown 5 0x4f 0x645ec033 cli readint32 ddst grown 5 0x4f 4 0x1b8b188b reloc 0 strippetite 1 if strippetite usects j 1 rsz grown skew CLIISCONTAINED buf bufsz ddst grown 5 0x4f skew 8 cli readint32 ddst grown 5 0x4f skew 0x645ec033 cli readint32 ddst grown 5 0x4f 4 skew 0x1b8b188b reloc skew strippetite 1 if strippetite CLIISCONTAINED buf bufsz ddst grown 0x0f 8 reloc 8 uint32 t test1 test2 test1 cli readint32 ddst grown 0x0f 8 reloc 0x9d6661aa test2 cli readint32 ddst grown 0x0f 4 reloc 0xe908c483 cli dbgmsg Petite Found petite code in sect d x Let s strip it n j 1 usects j 1 rva if test1 test2 CLIISCONTAINED buf bufsz ddst grown 0x0f reloc 0x1c0 0x0f 4 irva cli readint32 ddst grown 0x121 reloc enc ep cli readint32 ddst grown 0x0f reloc test1 mangled uint32 t cli readint32 ddst grown 0x1c0 reloc 0x90909090 cli dbgmsg Petite Encrypted EP x Array of imports x n enc ep irva usects j 1 rsz grown reloc check4resources static int bfi decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Get Byte Context g int buf size avpkt size BFI Context bfi avctx priv data uint8 t dst bfi dst uint8 t src dst offset colour1 colour2 uint8 t frame end bfi dst avctx width avctx height uint32 t pal int i j ret height avctx height if bfi frame data 0 avctx release buffer avctx bfi frame bfi frame reference 1 if ret ff get buffer avctx bfi frame 0 av log avctx AVLOGERROR get buffer failed n return ret bytestream2 init g avpkt data buf size if avctx frame number bfi frame pict type AVPICTURETYPEI bfi frame key frame 1 if avctx extradata size 768 av log NULLAVLOGERROR Palette is too large n return AVERRORINVALIDDATA pal uint32 t bfi frame data 1 for i 0 i avctx extradata size 3 i int shift 16 pal 0 for j 0 j 3 j shift 8 pal avctx extradata i 3 j 2 avctx extradata i 3 j 4 shift pal bfi frame palette has changed 1 else bfi frame pict type AVPICTURETYPEP bfi frame key frame 0 bytestream2 skip g 4 while dst frame end static const uint8 t lentab 4 0 2 0 1 unsigned int byte bytestream2 get byte g av uninit offset unsigned int code byte 6 unsigned int length byte 0x C0 if bytestream2 get bytes left g av log avctx AVLOGERROR Input resolution larger than actual frame n return AVERRORINVALIDDATA if length 0 if code 1 length bytestream2 get byte g offset bytestream2 get le16 g else length bytestream2 get le16 g if code 2 length 0 break else if code 1 offset bytestream2 get byte g if dst length lentab code frame end break switch code case 0 if length bytestream2 get bytes left g av log avctx AVLOGERROR Frame larger than buffer n return AVERRORINVALIDDATA bytestream2 get buffer g dst length dst length break case 1 dst offset dst offset length 4 if dst offset bfi dst break while length dst dst offset break case 2 dst length break case 3 colour1 bytestream2 get byte g colour2 bytestream2 get byte g while length dst colour1 dst colour2 break src bfi dst dst bfi frame data 0 while height memcpy dst src avctx width src avctx width dst bfi frame linesize 0 got frame 1 AV Frame data bfi frame return buf size static inline void vc1 pred b mv V C1 Context v int dmv x 2 int dmv y 2 int direct int mvtype Mpeg Enc Context s v s int xy wrap off 0 int16 t ABC int px py int sum int r x r y const uint8 t is intra v mb type 0 r x v range x r y v range y dmv x 0 1 s quarter sample dmv y 0 1 s quarter sample dmv x 1 1 s quarter sample dmv y 1 1 s quarter sample wrap s b8 stride xy s block index 0 if s mb intra s current picture f motion val 0 xy v blocks off 0 s current picture f motion val 0 xy v blocks off 1 s current picture f motion val 1 xy v blocks off 0 s current picture f motion val 1 xy v blocks off 1 0 return if v field mode s mv 0 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 0 s quarter sample s mv 0 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 0 s quarter sample s mv 1 0 0 scale mv s next picture f motion val 1 xy 0 v bfraction 1 s quarter sample s mv 1 0 1 scale mv s next picture f motion val 1 xy 1 v bfraction 1 s quarter sample s mv 0 0 0 av clip s mv 0 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 0 0 1 av clip s mv 0 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 s mv 1 0 0 av clip s mv 1 0 0 60 s mb x 6 s mb width 6 4 s mb x 6 s mv 1 0 1 av clip s mv 1 0 1 60 s mb y 6 s mb height 6 4 s mb y 6 if direct s current picture f motion val 0 xy v blocks off 0 s mv 0 0 0 s current picture f motion val 0 xy v blocks off 1 s mv 0 0 1 s current picture f motion val 1 xy v blocks off 0 s mv 1 0 0 s current picture f motion val 1 xy v blocks off 1 s mv 1 0 1 return if mvtype BMVTYPEFORWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 0 xy 2 A s current picture f motion val 0 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 0 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 0 0 0 px dmv x 0 r x r x 1 1 r x s mv 0 0 1 py dmv y 0 r y r y 1 1 r y if mvtype BMVTYPEBACKWARD mvtype BMVTYPEINTERPOLATEDC s current picture f motion val 1 xy 2 A s current picture f motion val 1 xy wrap 2 off s mb x s mb width 1 2 2 B s current picture f motion val 1 xy wrap 2 off if s mb x C 0 C 1 0 if s first slice line if s mb width 1 px A 0 py A 1 else px mid pred A 0 B 0 C 0 py mid pred A 1 B 1 C 1 else if s mb x px C 0 py C 1 else px py 0 int qx qy XY if v profile PROFILEADVANCED qx s mb x 5 qy s mb y 5 X s mb width 5 4 Y s mb height 5 4 if qx px 28 px 28 qx if qy py 28 py 28 qy if qx px X px X qx if qy py Y py Y qy else qx s mb x 6 qy s mb y 6 X s mb width 6 4 Y s mb height 6 4 if qx px 60 px 60 qx if qy py 60 py 60 qy if qx px X px X qx if qy py Y py Y qy if 0 s first slice line s mb x if is intra xy wrap sum FFABS px FFABS py else sum FFABS px A 0 FFABS py A 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 else if is intra xy 2 sum FFABS px FFABS py else sum FFABS px C 0 FFABS py C 1 if sum 32 if get bits1 s gb px A 0 py A 1 else px C 0 py C 1 s mv 1 0 0 px dmv x 1 r x r x 1 1 r x s mv 1 0 1 py dmv y 1 r y r y 1 1 r y s current picture f motion val 0 xy 0 s mv 0 0 0 s current picture f motion val 0 xy 1 s mv 0 0 1 s current picture f motion val 1 xy 0 s mv 1 0 0 s current picture f motion val 1 xy 1 s mv 1 0 1 static void fill mode info sb V P9 COMMON cm MACROBLOCK x int mi row int mi col BLOCKSIZE bsize BLOCKSIZE subsize PCTREE pc tree MACROBLOCKD xd x e mbd int bsl b width log2 bsize hbs 1 bsl 4 PARTITIONTYPE partition pc tree partitioning assert bsize BLOCK 8 X8 if mi row cm mi rows mi col cm mi cols return switch partition case PARTITIONNONE set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree none mic duplicate mode info in sb cm xd mi row mi col bsize break case PARTITIONVERT set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree vertical 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi col hbs cm mi cols set modeinfo offsets cm xd mi row mi col hbs xd mi 0 src mi pc tree vertical 1 mic duplicate mode info in sb cm xd mi row mi col hbs bsize break case PARTITIONHORZ set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree horizontal 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi row hbs cm mi rows set modeinfo offsets cm xd mi row hbs mi col xd mi 0 src mi pc tree horizontal 1 mic duplicate mode info in sb cm xd mi row hbs mi col bsize break case PARTITIONSPLITBLOCKSIZE subsubsize get subsize subsize PARTITIONSPLIT fill mode info sb cm x mi row mi col subsize subsubsize pc tree split 0 fill mode info sb cm x mi row mi col hbs subsize subsubsize pc tree split 1 fill mode info sb cm x mi row hbs mi col subsize subsubsize pc tree split 2 fill mode info sb cm x mi row hbs mi col hbs subsize subsubsize pc tree split 3 break default break static void find mv refs idx const V P9 COMMON cm const MACROBLOCKD xd const Tile Info const tile MODEINFO mi MVREFERENCEFRAME ref frame int mv mv ref list int block int mi row int mi col const int ref sign bias cm ref frame sign bias int i refmv count 0 const MODEINFO prev mi cm error resilient mode cm prev mi cm prev mi grid visible mi row xd mi stride mi col NULL const MBMODEINFO const prev mbmi prev mi prev mi mbmi NULL const POSITION const mv ref search mv ref blocks mi mbmi sb type int different ref found 0 int context counter 0 vpx memset mv ref list 0 sizeof mv ref list MAXMVREFCANDIDATES for i 0 i 2 i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MODEINFO const candidate mi xd mi mv ref col mv ref row xd mi stride const MBMODEINFO const candidate candidate mi mbmi context counter mode 2 counter candidate mode different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST get sub block mv candidate mi 0 mv ref col block else if candidate ref frame 1 ref frame ADDMVREFLIST get sub block mv candidate mi 1 mv ref col block for i MVREFNEIGHBOURS i const POSITION const mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi different ref found 1 if candidate ref frame 0 ref frame ADDMVREFLIST candidate mv 0 else if candidate ref frame 1 ref frame ADDMVREFLIST candidate mv 1 if prev mbmi if prev mbmi ref frame 0 ref frame ADDMVREFLIST prev mbmi mv 0 else if prev mbmi ref frame 1 ref frame ADDMVREFLIST prev mbmi mv 1 if different ref found for i 0 i MVREFNEIGHBOURS i const POSITION mv ref mv ref search i if is inside tile mi col mi row cm mi rows mv ref const MBMODEINFO const candidate xd mi mv ref col mv ref row xd mi stride mbmi IFDIFFREFFRAMEADDMV candidate if prev mbmi IFDIFFREFFRAMEADDMV prev mbmi Done mi mbmi mode context ref frame counter to context context counter for i 0 i MAXMVREFCANDIDATES i clamp mv ref mv ref list i as mv xd static bool qemu in vcpu thread void return cpu single env qemu cpu is self ENVGETCPU cpu single env int ff wmv2 decode mb Mpeg Enc Context s int16 t block 6 64 Wmv2 Context const w Wmv2 Context s int cbp code i uint8 t coded val if w j type return 0 if s pict type AVPICTURETYPEP if ISSKIP s current picture mb type s mb y s mb stride s mb x s mb intra 0 for i 0 i 6 i s block last index i 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 0 s mv 0 0 1 0 s mb skipped 1 w hshift 0 return 0 code get vlc2 s gb ff mb non intra vlc w cbp table index table MBNONINTRAVLCBITS 3 if code 0 return 1 s mb intra code 0x40 6 cbp code 0x3f else s mb intra 1 code get vlc2 s gb ff msmp4 mb i vlc table MBINTRAVLCBITS 2 if code 0 av log s avctx AVLOGERRORII cbp illegal at d d n s mb x s mb y return 1 cbp 0 for i 0 i 6 i int val code 5 i 1 if i 4 int pred ff msmpeg4 coded block pred s i coded val val val pred coded val val cbp val 5 i if s mb intra int mx my wmv2 pred motion w mx my if cbp s dsp clear blocks s block 0 if s per mb rl table s rl table index decode012 s gb s rl chroma table index s rl table index if w abt flag w per mb abt w per block abt get bits1 s gb if w per block abt w abt type decode012 s gb else w per block abt 0 if wmv2 decode motion w mx my 0 return 1 s mv dir MVDIRFORWARD s mv type MVTYPE 16 X16 s mv 0 0 0 mx s mv 0 0 1 my for i 0 i 6 i if wmv2 decode inter block w block i i cbp 5 i 1 0 av log s avctx AVLOGERROR nerror while decoding inter block d x d d n s mb x s mb y i return 1 else if s pict type AVPICTURETYPEP av dlog s avctx d d s inter intra pred cbp av dlog s avctx I at d d d 06 X n s mb x s mb y cbp 3 1 0 cbp 0x3 C 2 0 show bits s gb 24 s ac pred get bits1 s gb if s inter intra pred s h263 aic dir get vlc2 s gb ff inter intra vlc table INTERINTRAVLCBITS 1 av dlog s avctx d d d d s ac pred s h263 aic dir s mb x s mb y if s per mb rl table cbp s rl table index decode012 s gb s rl chroma table index s rl table index s dsp clear blocks s block 0 for i 0 i 6 i if ff msmpeg4 decode block s block i i cbp 5 i 1 NULL 0 av log s avctx AVLOGERROR nerror while decoding intra block d x d d n s mb x s mb y i return 1 return 0 static int svq1 encode frame AV Codec Context avctx AV Packet pkt const AV Frame pict int got packet SV Q1 Context const s avctx priv data AV Frame const p s picture AV Frame temp int i ret if pkt data ret av new packet pkt s y block width s y block height MAXMBBYTES 3 FFMINBUFFERSIZE 0 av log avctx AVLOGERROR Error getting output packet n return ret if avctx pix fmt AVPIXFMTYU V410 P av log avctx AVLOGERROR unsupported pixel format n return 1 if s current picture data 0 ff get buffer avctx s current picture 0 ff get buffer avctx s last picture 0 s scratchbuf av malloc s current picture linesize 0 16 2 temp s current picture s current picture s last picture s last picture temp init put bits s pb pkt data pkt size p pict p pict type avctx gop size avctx frame number avctx gop size AVPICTURETYPEPAVPICTURETYPEI p key frame p pict type AVPICTURETYPEI svq1 write header s p pict type for i 0 i 3 i if svq1 encode plane s i s picture data i s last picture data i s current picture data i s frame width i 4 1 s frame height i 4 1 s picture linesize i s current picture linesize i 0 return 1 while put bits count s pb 31 put bits s pb 1 0 flush put bits s pb pkt size put bits count s pb 8 if p pict type AVPICTURETYPEI pkt flags AVPKTFLAGKEY got packet 1 return 0 void jpc qmfb split col jpc fix t a int numrows int stride int parity int bufsize JPCCEILDIVPO W2 numrows 1 jpc fix t splitbuf QMFBSPLITBUFSIZE jpc fix t buf splitbuf register jpc fix t srcptr register jpc fix t dstptr register int n register int m int hstartcol if bufsize QMFBSPLITBUFSIZE if buf jas alloc2 bufsize sizeof jpc fix t abort if numrows 2 hstartcol numrows 1 parity 1 m numrows hstartcol n m dstptr buf srcptr a 1 parity stride while n 0 dstptr srcptr dstptr srcptr stride 1 dstptr a 1 parity stride srcptr a 2 parity stride n numrows m parity while n 0 dstptr srcptr dstptr stride srcptr stride 1 dstptr a hstartcol stride srcptr buf n m while n 0 dstptr srcptr dstptr stride srcptr if buf splitbuf jas free buf static void kq init struct event base base int i kq struct kqop kqueueop if evutil getenv EVENTNOKQUEUE return NULL if kqueueop calloc 1 sizeof struct kqop return NULL if kq kqueue 1 event warn kqueue free kqueueop return NULL kqueueop kq kq kqueueop pid getpid kqueueop changes malloc NEVENT sizeof struct kevent if kqueueop changes NULL free kqueueop return NULL kqueueop events malloc NEVENT sizeof struct kevent if kqueueop events NULL free kqueueop changes free kqueueop return NULL kqueueop nevents NEVENT for i 0 i NSIG i TAILQINIT kqueueop evsigevents i memset kqueueop changes 0 0 sizeof kqueueop changes 0 kqueueop changes 0 ident 1 kqueueop changes 0 filter EVFILTREAD kqueueop changes 0 flags EVADD if kevent kq kqueueop changes 1 kqueueop events NEVENTNULL 1 kqueueop events 0 ident 1 kqueueop events 0 flags EVERROR event warn s detected broken kqueue not using func free kqueueop changes free kqueueop events free kqueueop close kq return NULL return kqueueop gcry error t gcry mpi print enum gcry mpi format format unsigned char buffer size t buflen size t nwritten struct gcry mpi a unsigned int nbits mpi get nbits a size t len size t dummy nwritten int negative if nwritten nwritten dummy nwritten if a sign gcry mpi cmp ui a 0 negative 1 else negative 0 len buflen nwritten 0 if format GCRYMPIFMTSTD unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if extra s 0 memcpy s tmp n extra gcry free tmp nwritten n return 0 else if format GCRYMPIFMTUSG unsigned int n nbits 7 8 if buffer n len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy buffer tmp n gcry free tmp nwritten n return 0 else if format GCRYMPIFMTPGP unsigned int n nbits 7 8 if negative return gcry error GPGERRINVARG if buffer n 2 len return gcry error GPGERRTOOSHORT if buffer unsigned char tmp unsigned char s buffer s 0 nbits 8 s 1 nbits tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror memcpy s 2 tmp n gcry free tmp nwritten n 2 return 0 else if format GCRYMPIFMTSSH unsigned char tmp int extra 0 unsigned int n if negative return gcry error GPGERRINTERNAL tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 n extra 1 if buffer n 4 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer s n 24 s n 16 s n 8 s n if extra s 0 memcpy s tmp n extra gcry free tmp nwritten 4 n return 0 else if format GCRYMPIFMTHEX unsigned char tmp int i int extra 0 unsigned int n 0 tmp gcry mpi get buffer a 0 n NULL if tmp return gpg error from syserror if n tmp 0x80 extra 2 if buffer 2 n extra negative 1 len gcry free tmp return gcry error GPGERRTOOSHORT if buffer unsigned char s buffer if negative s if extra s 0 s 0 for i 0 i n i unsigned int c tmp i s c 4 10 0 c 4 A c 4 10 c 15 s c 10 0 c A c 10 s 0 nwritten s buffer else nwritten 2 n extra negative 1 gcry free tmp return 0 else return gcry error static krb5 error code process chpw request krb5 context context void server handle char realm krb5 keytab keytab const krb5 fulladdr local faddr const krb5 fulladdr remote faddr krb5 data req krb5 data rep krb5 error code ret char ptr unsigned int plen vno krb5 data ap req ap rep empty data krb5 data cipher empty data clear empty data krb5 auth context auth context NULL krb5 principal changepw NULL krb5 principal client target NULL krb5 ticket ticket NULL krb5 replay data replay krb5 error krberror int numresult char strresult 1024 char clientstr NULL targetstr NULL const char errmsg NULL size t clen char cdots struct sockaddr storage ss socklen t salen char addrbuf 100 krb5 address addr remote faddr address rep empty data if req length 4 ret KR B5 KRBAPERRMODIFIED numresult KR B5 KPASSWDMALFORMED strlcpy strresult Request was truncated sizeof strresult goto chpwfail ptr req data plen ptr 0xff plen plen 8 ptr 0xff if plen req length ret KR B5 KRBAPERRMODIFIED numresult KR B5 KPASSWDMALFORMED strlcpy strresult Request length was inconsistent sizeof strresult goto chpwfail vno ptr 0xff vno vno 8 ptr 0xff if vno 1 vno RF C3244 VERSION ret KR B5 KDCERRBADPVNO numresult KR B5 KPASSWDBADVERSION snprintf strresult sizeof strresult Request contained unknown protocol version number d vno goto chpwfail ap req length ptr 0xff ap req length ap req length 8 ptr 0xff if ptr ap req length req data req length ret KR B5 KRBAPERRMODIFIED numresult KR B5 KPASSWDMALFORMED strlcpy strresult Request was truncated in APREQ sizeof strresult goto chpwfail ap req data ptr ptr ap req length ret krb5 auth con init context auth context if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed initializing auth context sizeof strresult goto chpwfail ret krb5 auth con setflags context auth context KR B5 AUTHCONTEXTDOSEQUENCE if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed initializing auth context sizeof strresult goto chpwfail ret krb5 build principal context changepw strlen realm realm kadmin changepw NULL if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed building kadmin changepw principal sizeof strresult goto chpwfail ret krb5 rd req context auth context ap req changepw keytab NULL ticket if ret numresult KR B5 KPASSWDAUTHERROR strlcpy strresult Failed reading application request sizeof strresult goto chpwfail ret krb5 mk rep context auth context ap rep if ret numresult KR B5 KPASSWDAUTHERROR strlcpy strresult Failed replying to application request sizeof strresult goto chpwfail cipher length req data req length ptr cipher data ptr ret krb5 rd priv context auth context cipher clear replay if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed decrypting request sizeof strresult goto chpwfail client ticket enc part2 client if vno RF C3244 VERSION krb5 data clear data ret decode krb5 setpw req clear clear data target if ret 0 numresult KR B5 KPASSWDMALFORMED strlcpy strresult Failed decoding Change Passwd Data sizeof strresult goto chpwfail zapfree clear data clear length clear clear data free clear data if target NULL ret krb5 unparse name context target targetstr if ret 0 numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed unparsing target name for log sizeof strresult goto chpwfail ret krb5 unparse name context client clientstr if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed unparsing client name for log sizeof strresult goto chpwfail if vno 1 ticket enc part2 flags TKTFLGINITIAL 0 numresult KR B5 KPASSWDINITIALFLAGNEEDED strlcpy strresult Ticket must be derived from a password sizeof strresult goto chpwfail ptr k5memdup0 clear data clear length ret ret schpw util wrapper server handle client target ticket enc part2 flags TKTFLGINITIAL 0 ptr NULL strresult sizeof strresult if ret errmsg krb5 get error message context ret zapfree clear data clear length zapfree ptr clear length clear empty data clen strlen clientstr trunc name clen cdots switch addr addrtype case ADDRTYPEINET struct sockaddr in sin ss2sin ss sin sin family AFINET memcpy sin sin addr addr contents addr length sin sin port htons remote faddr port salen sizeof sin break case ADDRTYPEINE T6 struct sockaddr in6 sin6 ss2sin6 ss sin6 sin6 family AFINE T6 memcpy sin6 sin6 addr addr contents addr length sin6 sin6 port htons remote faddr port salen sizeof sin6 break default struct sockaddr sa ss2sa ss sa sa family AFUNSPEC salen sizeof sa break if getnameinfo ss2sa ss salen addrbuf sizeof addrbuf NULL 0 NINUMERICHOSTNINUMERICSERV 0 strlcpy addrbuf unprintable sizeof addrbuf if vno RF C3244 VERSION size t tlen char tdots const char targetp if target NULL tlen clen tdots cdots targetp targetstr else tlen strlen targetstr trunc name tlen tdots targetp clientstr krb5 klog syslog LOGNOTICE setpw request from s by s s for s s s addrbuf int clen clientstr cdots int tlen targetp tdots errmsg errmsg success else krb5 klog syslog LOGNOTICE chpw request from s for s s s addrbuf int clen clientstr cdots errmsg errmsg success switch ret case KAD M5 AUTHCHANGEPW numresult KR B5 KPASSWDACCESSDENIED break case KAD M5 PASSQTOOSHORT case KAD M5 PASSREUSE case KAD M5 PASSQCLASS case KAD M5 PASSQDICT case KAD M5 PASSQGENERIC case KAD M5 PASSTOOSOON numresult KR B5 KPASSWDSOFTERROR break case 0 numresult KR B5 KPASSWDSUCCESS strlcpy strresult sizeof strresult break default numresult KR B5 KPASSWDHARDERROR break chpwfail clear length 2 strlen strresult clear data char malloc clear length ptr clear data ptr numresult 8 0xff ptr numresult 0xff memcpy ptr strresult strlen strresult cipher empty data if ap rep length ret krb5 auth con setaddrs context auth context local faddr address NULL if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed storing client and server internet addresses sizeof strresult else ret krb5 mk priv context auth context clear cipher replay if ret numresult KR B5 KPASSWDHARDERROR strlcpy strresult Failed encrypting reply sizeof strresult if cipher length 0 if ap rep length free ap rep data ap rep empty data krberror ctime 0 krberror cusec 0 krberror susec 0 ret krb5 timeofday context krberror stime if ret goto bailout krberror error ret krberror error ERRORTABLEBASE krb5 if krberror error 0 krberror error 128 krberror error KRBERRGENERIC krberror client NULL ret krb5 build principal context krberror server strlen realm realm kadmin changepw NULL if ret goto bailout krberror text length 0 krberror e data clear ret krb5 mk error context krberror cipher krb5 free principal context krberror server if ret goto bailout ret alloc data rep 6 ap rep length cipher length if ret goto bailout ptr rep data ptr rep length 8 0xff ptr rep length 0xff ptr 0 ptr 1 ptr ap rep length 8 0xff ptr ap rep length 0xff if ap rep length memcpy ptr ap rep data ap rep length ptr ap rep length memcpy ptr cipher data cipher length bailout krb5 auth con free context auth context krb5 free principal context changepw krb5 free ticket context ticket free ap rep data free clear data free cipher data krb5 free principal context target krb5 free unparsed name context targetstr krb5 free unparsed name context clientstr krb5 free error message context errmsg return ret void xps parse path xps document doc const fz matrix ctm char base uri xps resource dict fz xml root fz xml node char fill uri char stroke uri char opacity mask uri char transform att char clip att char data att char fill att char stroke att char opacity att char opacity mask att fz xml transform tag NULL fz xml clip tag NULL fz xml data tag NULL fz xml fill tag NULL fz xml stroke tag NULL fz xml opacity mask tag NULL char fill opacity att NULL char stroke opacity att NULL char stroke dash array att char stroke dash cap att char stroke dash offset att char stroke end line cap att char stroke start line cap att char stroke line join att char stroke miter limit att char stroke thickness att char navigate uri att fz stroke state stroke NULL fz matrix transform float samples 32 fz colorspace colorspace fz path path NULL fz path stroke path NULL fz rect area int fill rule int dash len 0 fz matrix local ctm transform att fz xml att root Render Transform clip att fz xml att root Clip data att fz xml att root Data fill att fz xml att root Fill stroke att fz xml att root Stroke opacity att fz xml att root Opacity opacity mask att fz xml att root Opacity Mask stroke dash array att fz xml att root Stroke Dash Array stroke dash cap att fz xml att root Stroke Dash Cap stroke dash offset att fz xml att root Stroke Dash Offset stroke end line cap att fz xml att root Stroke End Line Cap stroke start line cap att fz xml att root Stroke Start Line Cap stroke line join att fz xml att root Stroke Line Join stroke miter limit att fz xml att root Stroke Miter Limit stroke thickness att fz xml att root Stroke Thickness navigate uri att fz xml att root Fixed Page Navigate Uri for node fz xml down root node node fz xml next node if strcmp fz xml tag node Path Render Transform transform tag fz xml down node if strcmp fz xml tag node Path Opacity Mask opacity mask tag fz xml down node if strcmp fz xml tag node Path Clip clip tag fz xml down node if strcmp fz xml tag node Path Fill fill tag fz xml down node if strcmp fz xml tag node Path Stroke stroke tag fz xml down node if strcmp fz xml tag node Path Data data tag fz xml down node fill uri base uri stroke uri base uri opacity mask uri base uri xps resolve resource reference doc dict data att data tag NULL xps resolve resource reference doc dict clip att clip tag NULL xps resolve resource reference doc dict transform att transform tag NULL xps resolve resource reference doc dict fill att fill tag fill uri xps resolve resource reference doc dict stroke att stroke tag stroke uri xps resolve resource reference doc dict opacity mask att opacity mask tag opacity mask uri if data att data tag return if fill tag strcmp fz xml tag fill tag Solid Color Brush fill opacity att fz xml att fill tag Opacity fill att fz xml att fill tag Color fill tag NULL if stroke tag strcmp fz xml tag stroke tag Solid Color Brush stroke opacity att fz xml att stroke tag Opacity stroke att fz xml att stroke tag Color stroke tag NULL if stroke att stroke tag if stroke dash array att char s stroke dash array att while s while s s if s dash len while s s s stroke fz new stroke state with dash len doc ctx dash len stroke start cap xps parse line cap stroke start line cap att stroke dash cap xps parse line cap stroke dash cap att stroke end cap xps parse line cap stroke end line cap att stroke linejoin FZLINEJOINMITERXPS if stroke line join att if strcmp stroke line join att Miter stroke linejoin FZLINEJOINMITERXPS if strcmp stroke line join att Round stroke linejoin FZLINEJOINROUND if strcmp stroke line join att Bevel stroke linejoin FZLINEJOINBEVEL stroke miterlimit 10 if stroke miter limit att stroke miterlimit fz atof stroke miter limit att stroke linewidth 1 if stroke thickness att stroke linewidth fz atof stroke thickness att stroke dash phase 0 stroke dash len 0 if stroke dash array att char s stroke dash array att if stroke dash offset att stroke dash phase fz atof stroke dash offset att stroke linewidth while s while s s if s stroke dash list stroke dash len fz atof s stroke linewidth while s s s stroke dash len dash len transform fz identity if transform att xps parse render transform doc transform att transform if transform tag xps parse matrix transform doc transform tag transform fz concat local ctm transform ctm if clip att clip tag xps clip doc local ctm dict clip att clip tag fill rule 0 if data att path xps parse abbreviated geometry doc data att fill rule else if data tag path xps parse path geometry doc dict data tag 0 fill rule if stroke att stroke tag stroke path xps parse path geometry doc dict data tag 1 fill rule if stroke path stroke path path if stroke att stroke tag fz bound path doc ctx stroke path stroke local ctm area if stroke path path fill att fill tag fz rect bounds fz bound path doc ctx path NULL local ctm bounds fz union rect area bounds else fz bound path doc ctx path NULL local ctm area if navigate uri att xps add link doc area base uri navigate uri att xps begin opacity doc local ctm area opacity mask uri dict opacity att opacity mask tag if fill att xps parse color doc base uri fill att colorspace samples if fill opacity att samples 0 fz atof fill opacity att xps set color doc colorspace samples fz fill path doc dev path fill rule 0 local ctm doc colorspace doc color doc alpha if fill tag fz clip path doc dev path area fill rule 0 local ctm xps parse brush doc local ctm area fill uri dict fill tag fz pop clip doc dev if stroke att xps parse color doc base uri stroke att colorspace samples if stroke opacity att samples 0 fz atof stroke opacity att xps set color doc colorspace samples fz stroke path doc dev stroke path stroke local ctm doc colorspace doc color doc alpha if stroke tag fz clip stroke path doc dev stroke path area stroke local ctm xps parse brush doc local ctm area stroke uri dict stroke tag fz pop clip doc dev xps end opacity doc opacity mask uri dict opacity att opacity mask tag if stroke path path fz free path doc ctx stroke path fz free path doc ctx path path NULL fz drop stroke state doc ctx stroke if clip att clip tag fz pop clip doc dev gcry error t gcry pk verify gcry sexp t s sig gcry sexp t s hash gcry sexp t s pkey gcry module t module key NULL module sig NULL gcry mpi t pkey NULL hash NULL sig NULL struct pk encoding ctx ctx gcry err code t rc REGISTERDEFAULTPUBKEYS rc sexp to key s pkey 0 GCRYPKUSAGESIGNNULL pkey module key NULL if rc goto leave rc sexp to sig s sig sig module sig if rc goto leave if module key mod id module sig mod id rc GPGERRCONFLICT goto leave init encoding ctx ctx PUBKEYOPVERIFY gcry pk get nbits s pkey rc sexp data to mpi s hash hash ctx if rc goto leave rc pubkey verify module key mod id hash sig pkey ctx leave if pkey release mpi array pkey gcry free pkey if sig release mpi array sig gcry free sig if hash mpi free hash if module key module sig ath mutex lock pubkeys registered lock if module key gcry module release module key if module sig gcry module release module sig ath mutex unlock pubkeys registered lock return gcry error rc static void ps2 common post load P S2 State s P S2 Queue q s queue int size int i int tmp data P S2 QUEUESIZE size q count P S2 QUEUESIZE 0 q count if size 0 for i 0 i size i tmp data i q data q rptr if q rptr 256 q rptr 0 memcpy q data tmp data size q rptr 0 q wptr size q count size s update irq s update arg q count 0 static int decode frame AV Codec Context avctx void data int got frame AV Packet pkt Bink Context const c avctx priv data AV Frame frame data Get Bit Context gb int plane plane idx ret int bits count pkt size 3 if c version b if ret ff get buffer avctx frame AVGETBUFFERFLAGREF 0 av log avctx AVLOGERROR get buffer failed n return ret else if ret ff reget buffer avctx c last 0 av log avctx AVLOGERROR reget buffer failed n return ret if ret av frame ref frame c last 0 return ret init get bits gb pkt data bits count if c has alpha if c version i skip bits long gb 32 if ret bink decode plane c frame gb 3 0 0 return ret if c version i skip bits long gb 32 for plane 0 plane 3 plane plane idx plane c swap planes plane plane 3 if c version b if ret bink decode plane c frame gb plane idx plane 0 return ret else if ret binkb decode plane c frame gb plane idx avctx frame number plane 0 return ret if get bits count gb bits count break emms c if c version b av frame unref c last if ret av frame ref c last frame 0 return ret got frame 1 return pkt size void vp8 mbpost proc across ip c unsigned char src int pitch int rows int cols int flimit int r c i unsigned char s src unsigned char d 16 for r 0 r rows r int sumsq 0 int sum 0 for i 8 i 0 i s i s 0 for i cols i cols 17 i s i s cols 1 for i 8 i 6 i sumsq s i s i sum s i d i 8 0 for c 0 c cols 8 c int x s c 7 s c 8 int y s c 7 s c 8 sum x sumsq x y d c 15 s c if sumsq 15 sum sum flimit d c 15 8 sum s c 4 s c 8 d c 8 15 s pitch int dtls1 get record SSL s int ssl major ssl minor int i n SS L3 RECORD rr unsigned char p NULL unsigned short version DTL S1 BITMAP bitmap unsigned int is next epoch rr RECORDLAYER get rrec s rlayer again if dtls1 process buffered records s 0 return 1 if dtls1 get processed record s return 1 if RECORDLAYER get rstate s rlayer SSLSTREADBODYRECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH n ssl3 read n s DTL S1 RTHEADERLENGTHSS L3 BUFFER get len s rlayer rbuf 0 1 if n 0 return n if RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTHRECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADBODY p RECORDLAYER get packet s rlayer if s msg callback s msg callback 0 0 SS L3 RTHEADER p DTL S1 RTHEADERLENGTH s s msg callback arg rr type p ssl major p ssl minor p version ssl major 8 ssl minor n2s p rr epoch memcpy RECORDLAYER get read sequence s rlayer 2 p 6 p 6 n2s p rr length if s first packet if version s version rr length 0 RECORDLAYER reset packet length s rlayer goto again if version 0xff00 s version 0xff00 rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length SS L3 RTMAXENCRYPTEDLENGTH rr length 0 RECORDLAYER reset packet length s rlayer goto again if rr length RECORDLAYER get packet length s rlayer DTL S1 RTHEADERLENGTH i rr length n ssl3 read n s i i 1 1 if n i rr length 0 RECORDLAYER reset packet length s rlayer goto again RECORDLAYER set rstate s rlayer SSLSTREADHEADER bitmap dtls1 get bitmap s rr is next epoch if bitmap NULL rr length 0 RECORDLAYER reset packet length s rlayer goto again rr length 0 RECORDLAYER reset packet length s rlayer goto again static void tokenize b int plane int block BLOCKSIZE plane bsize TXSIZE tx size void arg struct tokenize b args const args arg V P9 COMP cpi args cpi MACROBLOCKD xd args xd TOKENEXTRA tp args tp uint8 t token cache 32 32 struct macroblock plane p cpi mb plane plane struct macroblockd plane pd xd plane plane MBMODEINFO mbmi xd mi 0 mbmi int pt int c TOKENEXTRA t tp int eob p eobs block const PLANETYPE type pd plane type const int16 t qcoeff BLOCKOFFSET p qcoeff block const int segment id mbmi segment id const int16 t scan nb const scan order so const int ref is inter block mbmi unsigned int const counts COEFFCONTEXTSENTROPYTOKENS cpi coef counts tx size type ref vp9 prob const coef probs COEFFCONTEXTSUNCONSTRAINEDNODES cpi common fc coef probs tx size type ref unsigned int const eob branch COEFFCONTEXTS cpi common counts eob branch tx size type ref const uint8 t const band get band translate tx size const int seg eob get tx eob cpi common seg segment id tx size int aoff loff txfrm block to raster xy plane bsize tx size block aoff loff pt get entropy context tx size pd above context aoff pd left context loff so get scan xd tx size type block scan so scan nb so neighbors c 0 while c eob int v 0 int skip eob 0 v qcoeff scan c while v add token no extra t coef probs band c pt ZEROTOKEN skip eob counts band c pt eob branch band c pt skip eob skip eob 1 token cache scan c 0 c pt get coef context nb token cache c v qcoeff scan c add token t coef probs band c pt vp9 dct value tokens ptr v extra uint8 t vp9 dct value tokens ptr v token uint8 t skip eob counts band c pt eob branch band c pt skip eob token cache scan c vp9 pt energy class vp9 dct value tokens ptr v token c pt get coef context nb token cache c if c seg eob add token no extra t coef probs band c pt EOBTOKEN 0 counts band c pt eob branch band c pt tp t vp9 set contexts xd pd plane bsize tx size c 0 aoff loff static int pnm decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size PNM Context const s avctx priv data AV Frame picture data AV Frame const p s picture int i j n linesize h upgrade 0 unsigned char ptr int components sample len ret s bytestream start s bytestream buf s bytestream end buf buf size if ret ff pnm decode header avctx s 0 return ret if p data 0 avctx release buffer avctx p p reference 0 if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret p pict type AVPICTURETYPEI p key frame 1 switch avctx pix fmt default return AVERROREINVAL case AVPIXFMTRG B48 BE n avctx width 6 components 3 sample len 16 goto do read case AVPIXFMTRG B24 n avctx width 3 components 3 sample len 8 goto do read case AVPIXFMTGRA Y8 n avctx width components 1 sample len 8 if s maxval 255 upgrade 1 goto do read case AVPIXFMTGRA Y16 BE case AVPIXFMTGRA Y16 LE n avctx width 2 components 1 sample len 16 if s maxval 65535 upgrade 2 goto do read case AVPIXFMTMONOWHITE case AVPIXFMTMONOBLACK n avctx width 7 3 components 1 sample len 1 do read ptr p data 0 linesize p linesize 0 if s bytestream n avctx height s bytestream end return AVERRORINVALIDDATA if s type 4 for i 0 i avctx height i Put Bit Context pb init put bits pb ptr linesize for j 0 j avctx width components j unsigned int c 0 int v 0 while s bytestream s bytestream end s bytestream 0 s bytestream 9 s bytestream if s bytestream s bytestream end return AVERRORINVALIDDATA do v 10 v c c s bytestream 0 while c 9 put bits pb sample len 1 sample len 1 v s maxval 1 s maxval flush put bits pb ptr linesize else for i 0 i avctx height i if upgrade memcpy ptr s bytestream n else if upgrade 1 unsigned int j f 255 128 s maxval 2 s maxval for j 0 j n j ptr j s bytestream j f 64 7 else if upgrade 2 unsigned int j v f 65535 32768 s maxval 2 s maxval for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize break case AVPIXFMTYU V420 P case AVPIXFMTYU V420 P9 BE case AVPIXFMTYU V420 P10 BE unsigned char ptr1 ptr2 n avctx width ptr p data 0 linesize p linesize 0 if s maxval 256 n 2 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i memcpy ptr s bytestream n s bytestream n ptr linesize ptr1 p data 1 ptr2 p data 2 n 1 h avctx height 1 for i 0 i h i memcpy ptr1 s bytestream n s bytestream n memcpy ptr2 s bytestream n s bytestream n ptr1 p linesize 1 ptr2 p linesize 2 break case AVPIXFMTYU V420 P16 uint16 t ptr1 ptr2 const int f 65535 32768 s maxval 2 s maxval unsigned int j v n avctx width 2 ptr p data 0 linesize p linesize 0 if s bytestream n avctx height 3 2 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j uint16 t ptr j v f 16384 15 s bytestream n ptr linesize ptr1 uint16 t p data 1 ptr2 uint16 t p data 2 n 1 h avctx height 1 for i 0 i h i for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr1 j v f 16384 15 s bytestream n for j 0 j n 2 j v av be2ne16 uint16 t s bytestream j ptr2 j v f 16384 15 s bytestream n ptr1 p linesize 1 2 ptr2 p linesize 2 2 break case AVPIXFMTRG B32 ptr p data 0 linesize p linesize 0 if s bytestream avctx width avctx height 4 s bytestream end return AVERRORINVALIDDATA for i 0 i avctx height i int j r g b a for j 0 j avctx width j r s bytestream g s bytestream b s bytestream a s bytestream uint32 t ptr j a 24 r 16 g 8 b ptr linesize break picture s picture got frame 1 return s bytestream s bytestream start static int64 t rd pick intra sub 8x8 y mode V P9 COMP cpi MACROBLOCK mb int rate int rate y int64 t distortion int64 t best rd int i j const MACROBLOCKD const xd mb e mbd MODEINFO const mic xd mi 0 const MODEINFO above mi xd mi xd mi stride const MODEINFO left mi xd left available xd mi 1 NULL const BLOCKSIZE bsize xd mi 0 mbmi sb type const int num 4x4 blocks wide num 4x4 blocks wide lookup bsize const int num 4x4 blocks high num 4x4 blocks high lookup bsize int idx idy int cost 0 int64 t total distortion 0 int tot rate y 0 int64 t total rd 0 ENTROPYCONTEXT t above 4 t left 4 const int bmode costs cpi mbmode cost vpx memcpy t above xd plane 0 above context sizeof t above vpx memcpy t left xd plane 0 left context sizeof t left for idy 0 idy 2 idy num 4x4 blocks high for idx 0 idx 2 idx num 4x4 blocks wide PREDICTIONMODE best mode DCPRED int r INTMAX ry INTMAX int64 t d IN T64 MAX this rd IN T64 MAX i idy 2 idx if cpi common frame type KEYFRAME const PREDICTIONMODEA vp9 above block mode mic above mi i const PREDICTIONMODEL vp9 left block mode mic left mi i bmode costs cpi y mode costs AL this rd rd pick intra4x4block cpi mb i best mode bmode costs t above idx t left idy r ry d bsize best rd total rd if this rd best rd total rd return IN T64 MAX total rd this rd cost r total distortion d tot rate y ry mic bmi i as mode best mode for j 1 j num 4x4 blocks high j mic bmi i j 2 as mode best mode for j 1 j num 4x4 blocks wide j mic bmi i j as mode best mode if total rd best rd return IN T64 MAX rate cost rate y tot rate y distortion total distortion mic mbmi mode mic bmi 3 as mode return RDCOST mb rdmult mb rddiv cost total distortion static int vc1 decode p mb intfi V C1 Context v Mpeg Enc Context s v s Get Bit Context gb s gb int i int mb pos s mb x s mb y s mb stride int cbp 0 int mqdiff mquant int ttmb v ttfrm int mb has coeffs 1 int dmv x dmv y int val int first block 1 int dst idx off int pred flag int block cbp 0 pat block tt 0 int idx mbmode 0 mquant v pq idx mbmode get vlc2 gb v mbmode vlc table V C1 IFMBMODEVLCBITS 2 if idx mbmode 1 s mb intra v is intra s mb x 1 s current picture motion val 1 s block index 0 v blocks off 0 0 s current picture motion val 1 s block index 0 v blocks off 1 0 s current picture mb type mb pos v mb off MBTYPEINTRAGETMQUANT s current picture qscale table mb pos mquant s y dc scale s y dc scale table mquant s c dc scale s c dc scale table mquant v s ac pred v acpred plane mb pos get bits1 gb mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 ICBPCYVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 v mb type 0 s block index i 1 dst idx i 2 val cbp 5 i 1 v a avail v c avail 0 if i 2 i 3 s first slice line v a avail v mb type 0 s block index i s block wrap i if i 1 i 3 s mb x v c avail v mb type 0 s block index i 1 vc1 decode intra block v s block i i val mquant i 4 v codingset2 v codingset if i 3 s flags CODECFLAGGRAY continue v vc1dsp vc1 inv trans 8x8 s block i off i 4 0 i 1 8 i 2 4 s linesize off v cur field type i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 0 s dsp put signed pixels clamped s block i s dest dst idx off i 4 s uvlinesize s linesize else s mb intra v is intra s mb x 0 s current picture mb type mb pos v mb off MBTYPE 16x16 for i 0 i 6 i v mb type 0 s block index i 0 if idx mbmode 5 dmv x dmv y pred flag 0 if idx mbmode 1 get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v 0 dmv x dmv y 1 v range x v range y v mb type 0 pred flag 0 vc1 mc 1mv v 0 mb has coeffs idx mbmode 2 else v fourmvbp get vlc2 gb v fourmvbp vlc table V C1 4 MVBLOCKPATTERNVLCBITS 1 for i 0 i 6 i if i 4 dmv x dmv y pred flag 0 val v fourmvbp 3 i 1 if val get mvdata interlaced v dmv x dmv y pred flag vc1 pred mv v i dmv x dmv y 0 v range x v range y v mb type 0 pred flag 0 vc1 mc 4mv luma v i 0 else if i 4 vc1 mc 4mv chroma v 0 mb has coeffs idx mbmode 1 if mb has coeffs cbp 1 get vlc2 v s gb v cbpcy vlc table V C1 CBPCYPVLCBITS 2 if cbp GETMQUANT s current picture qscale table mb pos mquant if v ttmbf cbp ttmb get vlc2 gb ff vc1 ttmb vlc v tt index table V C1 TTMBVLCBITS 2 dst idx 0 for i 0 i 6 i s dc val 0 s block index i 0 dst idx i 2 val cbp 5 i 1 off i 4 0 i 1 8 i 2 4 s linesize if v cur field type off i 4 s current picture ptr f linesize 1 s current picture ptr f linesize 0 if val pat vc1 decode p block v s block i i mquant ttmb first block s dest dst idx off i 4 s uvlinesize s linesize i 4 s flags CODECFLAGGRAY block tt block cbp pat i 2 if v ttmbf ttmb 8 ttmb 1 first block 0 if s mb x s mb width 1 memmove v is intra base v is intra sizeof v is intra base 0 s mb stride return 0 static inline void ff mpeg4 set one direct mv Mpeg Enc Context s int mx int my int i int xy s block index i uint16 t time pp s pp time uint16 t time pb s pb time int p mx p my p mx s next picture f motion val 0 xy 0 if unsigned p mx tab bias tab size s mv 0 i 0 s direct scale mv 0 p mx tab bias mx s mv 1 i 0 mx s mv 0 i 0 p mx s direct scale mv 1 p mx tab bias else s mv 0 i 0 p mx time pb time pp mx s mv 1 i 0 mx s mv 0 i 0 p mx p mx time pb time pp time pp p my s next picture f motion val 0 xy 1 if unsigned p my tab bias tab size s mv 0 i 1 s direct scale mv 0 p my tab bias my s mv 1 i 1 my s mv 0 i 1 p my s direct scale mv 1 p my tab bias else s mv 0 i 1 p my time pb time pp my s mv 1 i 1 my s mv 0 i 1 p my p my time pb time pp time pp static void basic ec math simplified void gpg error t err gcry ctx t ctx gcry mpi point t GQ gcry mpi t d gcry mpi t x y z gcry sexp t sexp wherestr basic ec math simplified show checking basic math functions for EC variant n d hex2mpi D4 E F27 E32 F8 A D8 E2 A1 C6 DDEB B1 D235 A69 E3 CE F9 BC E90273 DQ gcry mpi point new 0 err gcry mpi ec new ctx NULLNISTP 192 if err die gcry mpi ec new failed s n gpg strerror err G gcry mpi ec get point g ctx 1 if G die gcry mpi ec get point G failed n gcry mpi ec mul Q d G ctx x gcry mpi new 0 y gcry mpi new 0 z gcry mpi new 0 gcry mpi point get x y z Q if cmp mpihex x 222 D9 E C717 C89 D047 E0898 C9185 B033 C D11 C0 A981 E E6 D C66 cmp mpihex y 605 D E0 A82 D70 D3 E0 F84 A127 D0739 E D33 D657 D F0 D054 BFD E8 cmp mpihex z 00 B06 B519071 B C536999 A C8 F2 D3934 B3 C1 F C9 EACC D0 A31 F88 F fail computed public key does not match n if debug print mpi Q x x print mpi Q y y print mpi Q z z if gcry mpi ec get affine x y Q ctx fail failed to get affine coordinates n if cmp mpihex x 008532093 B A023 F4 D55 C0424 F A3 A F9367 E05 F309 D C34 CD C3 FE cmp mpihex y 00 C13 C A9 E617 C6 C8487 BF F6 A726 E3 C4 F277913 D97117939966 fail computed affine coordinates of public key do not match n if debug print mpi q x x print mpi q y y gcry mpi release z gcry mpi release y gcry mpi release x err gcry mpi ec set point g G ctx if err die gcry mpi ec set point G failed n err gcry mpi ec set mpi d d ctx if err die gcry mpi ec set mpi d failed n err gcry pubkey get sexp sexp 0 ctx if err fail gcry pubkey get sexp 0 failed s n gpg strerror err else if verbose print sexp Result of gcry pubkey get sexp 0 n sexp gcry sexp release sexp err gcry pubkey get sexp sexp GCRYPKGETPUBKEY ctx if err fail gcry pubkey get sexp GETPUBKEY failed s n gpg strerror err else if verbose print sexp Result of gcry pubkey get sexp GETPUBKEY n sexp gcry sexp release sexp err gcry mpi ec set mpi d NULL ctx if err die gcry mpi ec set mpi d NULL failed n err gcry pubkey get sexp sexp 0 ctx if err fail gcry pubkey get sexp 0 w o d failed s n gpg strerror err else if verbose print sexp Result of gcry pubkey get sexp 0 w o d n sexp gcry sexp release sexp err gcry pubkey get sexp sexp GCRYPKGETSECKEY ctx if gpg err code err GPGERRNOSECKEY fail gcry pubkey get sexp GETSECKEY returned wrong error s n gpg strerror err gcry sexp release sexp err gcry mpi ec set point q NULL ctx if err die gcry mpi ec set point q NULL failed n err gcry pubkey get sexp sexp 0 ctx if gpg err code err GPGERRBADCRYPTCTX fail gcry pubkey get sexp 0 w o Q d returned wrong error s n gpg strerror err gcry sexp release sexp gcry mpi point release Q gcry mpi release d gcry mpi point release G gcry ctx release ctx static void fill mode info sb V P9 COMMON cm MACROBLOCK x int mi row int mi col BLOCKSIZE bsize BLOCKSIZE subsize PCTREE pc tree MACROBLOCKD xd x e mbd int bsl b width log2 bsize hbs 1 bsl 4 PARTITIONTYPE partition pc tree partitioning assert bsize BLOCK 8 X8 if mi row cm mi rows mi col cm mi cols return switch partition case PARTITIONNONE set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree none mic duplicate mode info in sb cm xd mi row mi col bsize break case PARTITIONVERT set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree vertical 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi col hbs cm mi cols set modeinfo offsets cm xd mi row mi col hbs xd mi 0 src mi pc tree vertical 1 mic duplicate mode info in sb cm xd mi row mi col hbs bsize break case PARTITIONHORZ set modeinfo offsets cm xd mi row mi col xd mi 0 src mi pc tree horizontal 0 mic duplicate mode info in sb cm xd mi row mi col bsize if mi row hbs cm mi rows set modeinfo offsets cm xd mi row hbs mi col xd mi 0 src mi pc tree horizontal 1 mic duplicate mode info in sb cm xd mi row hbs mi col bsize break case PARTITIONSPLITBLOCKSIZE subsubsize get subsize subsize PARTITIONSPLIT fill mode info sb cm x mi row mi col subsize subsubsize pc tree split 0 fill mode info sb cm x mi row mi col hbs subsize subsubsize pc tree split 1 fill mode info sb cm x mi row hbs mi col subsize subsubsize pc tree split 2 fill mode info sb cm x mi row hbs mi col hbs subsize subsubsize pc tree split 3 break default break static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Kmvc Context const ctx avctx priv data uint8 t out src int i ret int header int blocksize const uint8 t pal av packet get side data avpkt AVPKTDATAPALETTENULL bytestream2 init ctx g avpkt data avpkt size if ctx pic data 0 avctx release buffer avctx ctx pic ctx pic reference 1 ctx pic buffer hints FFBUFFERHINTSVALID if ret ff get buffer avctx ctx pic 0 av log avctx AVLOGERROR get buffer failed n return ret header bytestream2 get byte ctx g if bytestream2 peek byte ctx g 127 bytestream2 skip ctx g 3 for i 0 i 127 i ctx pal i header 0x81 bytestream2 get be24 ctx g bytestream2 skip ctx g 1 bytestream2 seek ctx g 127 4 3 SEEKCUR if header KMVCKEYFRAME ctx pic key frame 1 ctx pic pict type AVPICTURETYPEI else ctx pic key frame 0 ctx pic pict type AVPICTURETYPEP if header KMVCPALETTE ctx pic palette has changed 1 for i 1 i ctx palsize i ctx pal i bytestream2 get be24 ctx g if pal ctx pic palette has changed 1 memcpy ctx pal pal AVPALETTESIZE if ctx setpal ctx setpal 0 ctx pic palette has changed 1 memcpy ctx pic data 1 ctx pal 1024 blocksize bytestream2 get byte ctx g if blocksize 8 blocksize 127 av log avctx AVLOGERROR Block size i n blocksize return AVERRORINVALIDDATA memset ctx cur 0 320 200 switch header KMVCMETHOD case 0 case 1 memcpy ctx cur ctx prev 320 200 break case 3 kmvc decode intra 8x8 ctx avctx width avctx height break case 4 kmvc decode inter 8x8 ctx avctx width avctx height break default av log avctx AVLOGERROR Unknown compression method i n header KMVCMETHOD return AVERRORINVALIDDATA out ctx pic data 0 src ctx cur for i 0 i avctx height i memcpy out src avctx width src 320 out ctx pic linesize 0 if ctx cur ctx frm0 ctx cur ctx frm1 ctx prev ctx frm0 else ctx cur ctx frm0 ctx prev ctx frm1 got frame 1 AV Frame data ctx pic return avpkt size void ff mpeg4 pred ac Mpeg Enc Context s int16 t block int n int dir int i int16 t ac val ac val1 int8 t const qscale table s current picture f qscale table ac val s ac val 0 0 s block index n 16 ac val1 ac val if s ac pred if dir 0 const int xy s mb x 1 s mb y s mb stride ac val 16 if s mb x 0 s qscale qscale table xy n 1 n 3 for i 1 i 8 i block s dsp idct permutation i 3 ac val i else for i 1 i 8 i block s dsp idct permutation i 3 ROUNDEDDIV ac val i qscale table xy s qscale else const int xy s mb x s mb y s mb stride s mb stride ac val 16 s block wrap n if s mb y 0 s qscale qscale table xy n 2 n 3 for i 1 i 8 i block s dsp idct permutation i ac val i 8 else for i 1 i 8 i block s dsp idct permutation i ROUNDEDDIV ac val i 8 qscale table xy s qscale for i 1 i 8 i ac val1 i block s dsp idct permutation i 3 for i 1 i 8 i ac val1 8 i block s dsp idct permutation i static void rd pick sb modes V P9 COMP cpi const Tile Info const tile int mi row int mi col int totalrate int64 t totaldist BLOCKSIZE bsize PICKMODECONTEXT ctx int64 t best rd int block V P9 COMMON const cm cpi common MACROBLOCK const x cpi mb MACROBLOCKD const xd x e mbd MBMODEINFO mbmi struct macroblock plane const p x plane struct macroblockd plane const pd xd plane const AQMODE aq mode cpi oxcf aq mode int i orig rdmult double rdmult ratio vp9 clear system state rdmult ratio 1 0 x use lp32x32fdct 1 if bsize BLOCK 8 X8 if block 0 totalrate 0 totaldist 0 return set offsets cpi tile mi row mi col bsize mbmi xd mi 0 src mi mbmi mbmi sb type bsize for i 0 i MAXMBPLANE i p i coeff ctx coeff pbuf i 0 p i qcoeff ctx qcoeff pbuf i 0 pd i dqcoeff ctx dqcoeff pbuf i 0 p i eobs ctx eobs pbuf i 0 ctx is coded 0 ctx skippable 0 x skip recode 0 mbmi skip 0 x source variance get sby perpixel variance cpi x plane 0 src bsize orig rdmult x rdmult if aq mode VARIANCEAQ const int energy bsize BLOCK 16 X16 x mb energy vp9 block energy cpi x bsize if cm frame type KEYFRAME cpi refresh alt ref frame cpi refresh golden frame cpi rc is src frame alt ref mbmi segment id vp9 vaq segment id energy else const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map mbmi segment id vp9 get segment id cm map bsize mi row mi col rdmult ratio vp9 vaq rdmult ratio energy vp9 init plane quantizers cpi x vp9 clear system state x rdmult int round x rdmult rdmult ratio else if aq mode COMPLEXITYAQ const int mi offset mi row cm mi cols mi col unsigned char complexity cpi complexity map mi offset const int is edge mi row 1 mi row cm mi rows 2 mi col 1 mi col cm mi cols 2 if is edge complexity 128 x rdmult x rdmult complexity 128 256 else if aq mode CYCLICREFRESHAQ const uint8 t const map cm seg update map cpi segmentation map cm last frame seg map if vp9 get segment id cm map bsize mi row mi col x rdmult vp9 cyclic refresh get rdmult cpi cyclic refresh if frame is intra only cm vp9 rd pick intra mode sb cpi x totalrate totaldist bsize ctx best rd else if bsize BLOCK 8 X8 if vp9 segfeature active cm seg mbmi segment id SEGLVLSKIP vp9 rd pick inter mode sb seg skip cpi x totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sb cpi x tile mi row mi col totalrate totaldist bsize ctx best rd else vp9 rd pick inter mode sub8x8 cpi x tile mi row mi col totalrate totaldist bsize ctx best rd x rdmult orig rdmult if aq mode VARIANCEAQ totalrate INTMAX vp9 clear system state totalrate int round totalrate rdmult ratio int vp9 get frame buffer void cb priv size t min size vpx codec frame buffer t fb int i Internal Frame Buffer List const int fb list Internal Frame Buffer List cb priv if int fb list NULL return 1 for i 0 i int fb list num internal frame buffers i if int fb list int fb i in use break if i int fb list num internal frame buffers return 1 if int fb list int fb i size min size int fb list int fb i data uint8 t vpx realloc int fb list int fb i data min size if int fb list int fb i data return 1 vpx memset int fb list int fb i data 0 min size int fb list int fb i size min size fb data int fb list int fb i data fb size int fb list int fb i size int fb list int fb i in use 1 fb priv int fb list int fb i return 0 int test sqr BIO bp BNCTX ctx BIGNUM a c d e int i BN init a BN init c BN init d BN init e for i 0 i num0 i BN bntest rand a 40 i 10 0 0 a neg rand neg BN sqr c a ctx if bp NULL if results BN print bp a BIO puts bp BN print bp a BIO puts bp BN print bp c BIO puts bp n BN div d e c a ctx BN sub d d a if BN is zero d BN is zero e fprintf stderr Square test failed n return 0 BN free a BN free c BN free d BN free e return 1 static void rv34 pred mv rv3 R V34 Dec Context r int block type int dir Mpeg Enc Context s r s int mv pos s mb x 2 s mb y 2 s b8 stride int A 2 0 B 2 C 2 int i j k int mx my int avail r avail cache avail indexes 0 if avail 1 A 0 s current picture ptr f motion val 0 mv pos 1 0 A 1 s current picture ptr f motion val 0 mv pos 1 1 if avail 4 B 0 s current picture ptr f motion val 0 mv pos s b8 stride 0 B 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 else B 0 A 0 B 1 A 1 if avail 4 2 if avail 4 avail 1 C 0 s current picture ptr f motion val 0 mv pos s b8 stride 1 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 1 1 else C 0 A 0 C 1 A 1 else C 0 s current picture ptr f motion val 0 mv pos s b8 stride 2 0 C 1 s current picture ptr f motion val 0 mv pos s b8 stride 2 1 mx mid pred A 0 B 0 C 0 my mid pred A 1 B 1 C 1 mx r dmv 0 0 my r dmv 0 1 for j 0 j 2 j for i 0 i 2 i for k 0 k 2 k s current picture ptr f motion val k mv pos i j s b8 stride 0 mx s current picture ptr f motion val k mv pos i j s b8 stride 1 my int dissect ber Generalized Time gboolean implicit tag asn1 ctx t actx proto tree tree tvbuff t tvb int offset gint hf id char str 35 int tmp int const guint8 tmpstr char strptr char first delim 2 int first digits char second delim 2 int second digits int ret gint8 ber class gboolean pc gint32 tag guint32 len int end offset int hoffset proto item cause if implicit tag hoffset offset offset dissect ber identifier actx pinfo tree tvb offset ber class pc tag offset dissect ber length actx pinfo tree tvb offset len NULL end offset offset len if ber class BERCLASSUNI tag BERUNITAG Generalized Time tvb ensure bytes exist tvb hoffset 2 cause proto tree add string format value tree hf ber error tvb offset len generalized time expected Generalized Time expected but class s d s tag d was unexpected val to str const ber class ber class codes Unknown ber class pc ber pc codes short true string ber pc codes short false string tag expert add info actx pinfo cause ei ber expected generalized time if decode unexpected proto tree unknown tree proto item add subtree cause ett ber unknown dissect unknown ber actx pinfo tvb hoffset unknown tree return end offset else len tvb reported length remaining tvb offset end offset offset len if len 14 len 23 cause proto tree add string format value tree hf ber error tvb offset len illegal length Generalized Time invalid length u len expert add info format actx pinfo cause ei ber error length BER Error Generalized Time invalid length if decode unexpected proto tree unknown tree proto item add subtree cause ett ber unknown dissect unknown ber actx pinfo tvb offset unknown tree return end offset tmpstr tvb get string enc wmem packet scope tvb offset len ENCASCII strptr str strptr g snprintf str 20 4s 2s 2s 2s 2s 2s tmpstr tmpstr 4 tmpstr 6 tmpstr 8 tmpstr 10 tmpstr 12 first delim 0 0 second delim 0 0 ret sscanf tmpstr 14d 1 Z 4d 1 Z 4d tmp int first delim first digits second delim second digits if ret 1 goto invalid if ret 2 switch first delim 0 case case if ret 2 goto invalid strptr g snprintf strptr 5 c 3d first delim 0 first digits if ret 4 switch second delim 0 case case if ret 4 goto invalid g snprintf strptr 12 UTC c 4d second delim 0 second digits break case Z g snprintf strptr 7 UTC break default break break case case if ret 2 goto invalid g snprintf strptr 12 UTC c 4d first delim 0 first digits break case Z g snprintf strptr 7 UTC break default break if hf id 0 proto tree add string tree hf id tvb offset len str offset len return offset invalid cause proto tree add string format value tree hf ber error tvb offset len invalid generalized time Generalized Time invalid format s tmpstr expert add info actx pinfo cause ei ber invalid format generalized time if decode unexpected proto tree unknown tree proto item add subtree cause ett ber unknown dissect unknown ber actx pinfo tvb offset unknown tree return end offset static int s302m decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt AV Frame frame data const uint8 t buf avpkt data int buf size avpkt size int block size ret int frame size s302m parse frame header avctx buf buf size if frame size 0 return frame size buf size AE S3 HEADERLEN buf AE S3 HEADERLEN block size avctx bits per coded sample 4 4 frame nb samples 2 buf size block size avctx channels if ret ff get buffer avctx frame 0 0 av log avctx AVLOGERROR get buffer failed n return ret buf size frame nb samples avctx channels 2 block size if avctx bits per coded sample 24 uint32 t o uint32 t frame data 0 for buf size 6 buf size 7 o ff reverse buf 2 24 ff reverse buf 1 16 ff reverse buf 0 8 o ff reverse buf 6 0xf0 28 ff reverse buf 5 20 ff reverse buf 4 12 ff reverse buf 3 0x0f 4 buf 7 else if avctx bits per coded sample 20 uint32 t o uint32 t frame data 0 for buf size 5 buf size 6 o ff reverse buf 2 0xf0 28 ff reverse buf 1 20 ff reverse buf 0 12 o ff reverse buf 5 0xf0 28 ff reverse buf 4 20 ff reverse buf 3 12 buf 6 else uint16 t o uint16 t frame data 0 for buf size 4 buf size 5 o ff reverse buf 1 8 ff reverse buf 0 o ff reverse buf 4 0xf0 12 ff reverse buf 3 4 ff reverse buf 2 4 buf 5 got frame ptr 1 return avpkt size static int m authenticate struct Client client p struct Client source p int parc const char parv struct Client agent p NULL struct Client saslserv p NULL if Is Capable source p CLICAPSASL return 0 if strlen client p id 3 exit client client p client p client p Mixing client and server protocol return 0 if parv 1 strchr parv 1 exit client client p client p client p Malformed AUTHENTICATE return 0 saslserv p find named client Config File Entry sasl service if saslserv p NULL Is Service saslserv p sendto one source p form str ERRSASLABORTED me name Empty String source p name source p name return 0 if source p local Client sasl complete source p local Client sasl agent 0 source p local Client sasl complete 0 if strlen parv 1 400 sendto one source p form str ERRSASLTOOLONG me name Empty String source p name source p name return 0 if source p id strcpy source p id generate uid add to id hash source p id source p if source p local Client sasl agent agent p find id source p local Client sasl agent if agent p NULL sendto one saslserv p s ENCAP s SASL s s H s s me id saslserv p servptr name source p id saslserv p id source p host source p sockhost if strcmp parv 1 EXTERNAL source p certfp NULL sendto one saslserv p s ENCAP s SASL s s S s s me id saslserv p servptr name source p id saslserv p id parv 1 source p certfp else sendto one saslserv p s ENCAP s SASL s s S s me id saslserv p servptr name source p id saslserv p id parv 1 rb strlcpy source p local Client sasl agent saslserv p id IDLEN else sendto one agent p s ENCAP s SASL s s C s me id agent p servptr name source p id agent p id parv 1 source p local Client sasl out return 0 int jbig2 decode halftone region Jbig2 Ctx ctx Jbig2 Segment segment Jbig2 Halftone Region Params params const byte data const size t size Jbig2 Image image Jbig2 Arith Cx GB stats uint32 t HBPP uint32 t HNUMPATS uint8 t GI Jbig2 Image HSKIPNULL Jbig2 Pattern Dict HPATS int i uint32 t mg ng int32 t x y uint8 t gray val memset image data params HDEFPIXEL image stride image height if params HENABLESKIP 1 jbig2 error ctx JBI G2 SEVERITYWARNING segment number unhandled option HENABLESKIPHPATS jbig2 decode ht region get hpats ctx segment if HPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number no pattern dictionary found skipping halftone image return 1 HNUMPATSHPATS n patterns HBPP 0 while HNUMPATS 1 HBPPGI jbig2 decode gray scale image ctx segment data size params HMMR params HGW params HGHHBPP params HENABLESKIPHSKIP params HTEMPLATEGB stats if GI jbig2 error ctx JBI G2 SEVERITYWARNING segment number unable to acquire gray scale image skipping halftone image return 1 for mg 0 mg params HGH mg for ng 0 ng params HGW ng x params HGX mg params HRY ng params HRX 8 y params HGY mg params HRX ng params HRY 8 gray val GI ng mg if gray val HNUMPATS jbig2 error ctx JBI G2 SEVERITYWARNING segment number gray scale image uses value d which larger than pattern dictionary gray val gray val HNUMPATS 1 jbig2 image compose ctx image HPATS patterns gray val x y params op for i 0 i params HGW i jbig2 free ctx allocator GI i jbig2 free ctx allocator GI return 0 static P Gconn connect DB Archive Handle AH const char reqdb const char requser PQ Exp Buffer Data connstr P Gconn new Conn const char newdb const char newuser char password bool new pass if reqdb newdb P Qdb AH connection else newdb reqdb if requser strlen requser 0 newuser P Quser AH connection else newuser requser ahlog AH 1 connecting to database s as user s n newdb newuser password AH saved Password pg strdup AH saved Password NULL if AH prompt Password TRIYES password NULL password simple prompt Password 100 false if password NULL exit horribly modulename out of memory n init PQ Exp Buffer connstr append PQ Exp Buffer connstr dbname append Conn Str Val connstr newdb do const char keywords 7 const char values 7 keywords 0 host values 0 P Qhost AH connection keywords 1 port values 1 P Qport AH connection keywords 2 user values 2 newuser keywords 3 password values 3 password keywords 4 dbname values 4 connstr data keywords 5 fallback application name values 5 progname keywords 6 NULL values 6 NULL new pass false new Conn P Qconnectdb Params keywords values true if new Conn exit horribly modulename failed to reconnect to database n if P Qstatus new Conn CONNECTIONBAD if P Qconnection Needs Password new Conn exit horribly modulename could not reconnect to database s P Qerror Message new Conn P Qfinish new Conn if password fprintf stderr Password incorrect n fprintf stderr Connecting to s as s n newdb newuser if password free password if AH prompt Password TRINO password simple prompt Password 100 false else exit horribly modulename connection needs password n if password NULL exit horribly modulename out of memory n new pass true while new pass if P Qconnection Used Password new Conn if AH saved Password free AH saved Password AH saved Password pg strdup P Qpass new Conn if password free password term PQ Exp Buffer connstr check database version AHP Qset Notice Processor new Conn notice processor NULL return new Conn static void MCFUNC hl motion H264 Context h uint8 t dest y uint8 t dest cb uint8 t dest cr qpel mc func qpix put 16 h264 chroma mc func chroma put qpel mc func qpix avg 16 h264 chroma mc func chroma avg h264 weight func weight op h264 biweight func weight avg const int mb xy h mb xy const int mb type h cur pic mb type mb xy assert ISINTER mb type if HAVETHREADS h avctx active thread type FFTHREADFRAME await references h prefetch motion h 0 PIXELSHIFTCHROMAIDC if IS 16 X16 mb type mc part h 0 1 16 0 dest y dest cb dest cr 0 0 qpix put 0 chroma put 0 qpix avg 0 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 else if IS 16 X8 mb type mc part h 0 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 0 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 8 0 8 8 PIXELSHIFT dest y dest cb dest cr 0 4 qpix put 1 chroma put 0 qpix avg 1 chroma avg 0 weight op weight avg ISDIR mb type 1 0 ISDIR mb type 1 1 else if IS 8 X16 mb type mc part h 0 0 16 8 h mb linesize dest y dest cb dest cr 0 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 0 0 ISDIR mb type 0 1 mc part h 4 0 16 8 h mb linesize dest y dest cb dest cr 4 0 qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR mb type 1 0 ISDIR mb type 1 1 else int i assert IS 8 X8 mb type for i 0 i 4 i const int sub mb type h sub mb type i const int n 4 i int x offset i 1 2 int y offset i 2 1 if ISSUB 8 X8 sub mb type mc part h n 1 8 0 dest y dest cb dest cr x offset y offset qpix put 1 chroma put 1 qpix avg 1 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 8 X4 sub mb type mc part h n 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 2 0 4 4 PIXELSHIFT dest y dest cb dest cr x offset y offset 2 qpix put 2 chroma put 1 qpix avg 2 chroma avg 1 weight op 1 weight avg 1 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else if ISSUB 4 X8 sub mb type mc part h n 0 8 4 h mb linesize dest y dest cb dest cr x offset y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 mc part h n 1 0 8 4 h mb linesize dest y dest cb dest cr x offset 2 y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 else int j assert ISSUB 4 X4 sub mb type for j 0 j 4 j int sub x offset x offset 2 j 1 int sub y offset y offset j 2 mc part h n j 1 4 0 dest y dest cb dest cr sub x offset sub y offset qpix put 2 chroma put 2 qpix avg 2 chroma avg 2 weight op 2 weight avg 2 ISDIR sub mb type 0 0 ISDIR sub mb type 0 1 prefetch motion h 1 Parse Result mime parser parse MIME Parser parser Hdr Heap heap MIME Hdr Impl mh const char real s const char real e bool must copy strings bool eof Parse Result err bool line is real const char colon const char line c const char line s nullptr const char line e nullptr const char field name first const char field name last const char field value first const char field value last const char field line first const char field line last int field name length field value length MIME Scanner scanner parser m scanner while true err mime scanner get scanner real s real e line s line e line is real eof MIMESCANNERTYPEFIELD if err PARSERESULTOK return err line c line s if line e line c 2 line c 0 Parse Rules CHARCR line c 1 Parse Rules CHARLF return PARSERESULTDONE if line e line c 1 line c 0 Parse Rules CHARLF return PARSERESULTDONE field line first line c field line last line e 1 field name first line c if Parse Rules is token field name first field name first continue colon char memchr line c line e line c if colon continue field name last colon 1 if field name last field name first is ws field name last return PARSERESULTERROR field value first colon 1 while field value first line e is ws field value first field value first field value last line e 1 while field value last field value first Parse Rules is wslfcr field value last field value last field name length int field name last field name first 1 field value length int field value last field value first 1 if field name length UIN T16 MAX field value length UIN T16 MAX return PARSERESULTERROR int total line length int field line last field line first 1 if must copy strings line is real int length total line length char dup heap duplicate str field name first length intptr t delta dup field name first field name first delta field value first delta int field name wks idx hdrtoken tokenize field name first field name length MIME Field field mime field create heap mh mime field name value set heap mh field field name wks idx field name first field name length field value first field value length true total line length false mime hdr field attach mh field 1 nullptr static void temporal filter iterate c V P9 COMP cpi Y V12 BUFFERCONFIG frames int frame count int alt ref index int strength struct scale factors scale int byte int frame int mb col mb row unsigned int filter weight int mb cols cpi common mb cols int mb rows cpi common mb rows int mb y offset 0 int mb uv offset 0 DECLAREALIGNEDARRAY 16 unsigned int accumulator 16 16 3 DECLAREALIGNEDARRAY 16 uint16 t count 16 16 3 MACROBLOCKD mbd cpi mb e mbd Y V12 BUFFERCONFIG f frames alt ref index uint8 t dst1 dst2 DECLAREALIGNEDARRAY 16 uint8 t predictor 16 16 3 const int mb uv height 16 mbd plane 1 subsampling y const int mb uv width 16 mbd plane 1 subsampling x uint8 t input buffer MAXMBPLANE int i for i 0 i MAXMBPLANE i input buffer i mbd plane i pre 0 buf for mb row 0 mb row mb rows mb row cpi mb mv row min mb row 16 17 2 V P9 INTERPEXTEND cpi mb mv row max cpi common mb rows 1 mb row 16 17 2 V P9 INTERPEXTEND for mb col 0 mb col mb cols mb col int i j k int stride vpx memset accumulator 0 16 16 3 sizeof accumulator 0 vpx memset count 0 16 16 3 sizeof count 0 cpi mb mv col min mb col 16 17 2 V P9 INTERPEXTEND cpi mb mv col max cpi common mb cols 1 mb col 16 17 2 V P9 INTERPEXTEND for frame 0 frame frame count frame const int thresh low 10000 const int thresh high 20000 if frames frame NULL continue mbd mi 0 bmi 0 as mv 0 as mv row 0 mbd mi 0 bmi 0 as mv 0 as mv col 0 if frame alt ref index filter weight 2 else int err temporal filter find matching mb c cpi frames alt ref index y buffer mb y offset frames frame y buffer mb y offset frames frame y stride filter weight err thresh low 2 err thresh high 1 0 if filter weight 0 temporal filter predictors mb c mbd frames frame y buffer mb y offset frames frame u buffer mb uv offset frames frame v buffer mb uv offset frames frame y stride mb uv width mb uv height mbd mi 0 bmi 0 as mv 0 as mv row mbd mi 0 bmi 0 as mv 0 as mv col predictor scale mb col 16 mb row 16 vp9 temporal filter apply f y buffer mb y offset f y stride predictor 16 16 strength filter weight accumulator count vp9 temporal filter apply f u buffer mb uv offset f uv stride predictor 256 mb uv width mb uv height strength filter weight accumulator 256 count 256 vp9 temporal filter apply f v buffer mb uv offset f uv stride predictor 512 mb uv width mb uv height strength filter weight accumulator 512 count 512 dst1 cpi alt ref buffer y buffer stride cpi alt ref buffer y stride byte mb y offset for i 0 k 0 i 16 i for j 0 j 16 j k unsigned int pval accumulator k count k 1 pval fixed divide count k pval 19 dst1 byte uint8 t pval byte byte stride 16 dst1 cpi alt ref buffer u buffer dst2 cpi alt ref buffer v buffer stride cpi alt ref buffer uv stride byte mb uv offset for i 0 k 256 i mb uv height i for j 0 j mb uv width j k int m k 256 unsigned int pval accumulator k count k 1 pval fixed divide count k pval 19 dst1 byte uint8 t pval pval accumulator m count m 1 pval fixed divide count m pval 19 dst2 byte uint8 t pval byte byte stride mb uv width mb y offset 16 mb uv offset mb uv width mb y offset 16 f y stride mb cols mb uv offset mb uv height f uv stride mb uv width mb cols for i 0 i MAXMBPLANE i mbd plane i pre 0 buf input buffer i static int combined motion search V P9 COMP cpi MACROBLOCK x BLOCKSIZE bsize int mi row int mi col int mv tmp mv int rate mv int64 t best rd sofar MACROBLOCKD xd x e mbd MBMODEINFO mbmi xd mi 0 src mi mbmi struct buf 2d backup yv12 MAXMBPLANE 0 0 const int step param cpi sf mv fullpel search step param const int sadpb x sadperbit16 MV mvp full const int ref mbmi ref frame 0 const MV ref mv mbmi ref mvs ref 0 as mv int dis int rate mode const int tmp col min x mv col min const int tmp col max x mv col max const int tmp row min x mv row min const int tmp row max x mv row max int rv 0 int sad list 5 const Y V12 BUFFERCONFIG scaled ref frame vp9 get scaled ref frame cpi ref if cpi common show frame x pred mv sad ref 3 x pred mv sad LASTFRAME return rv if scaled ref frame int i for i 0 i MAXMBPLANE i backup yv12 i xd plane i pre 0 vp9 setup pre planes xd 0 scaled ref frame mi row mi col NULL vp9 set mv search range x ref mv assert x mv best ref index ref 2 if x mv best ref index ref 2 mvp full mbmi ref mvs ref x mv best ref index ref as mv else mvp full x pred mv ref mvp full col 3 mvp full row 3 vp9 full pixel search cpi x bsize mvp full step param sadpb cond sad list cpi sad list ref mv tmp mv as mv INTMAX 0 x mv col min tmp col min x mv col max tmp col max x mv row min tmp row min x mv row max tmp row max mvp full row tmp mv as mv row 8 mvp full col tmp mv as mv col 8 rate mv vp9 mv bit cost mvp full ref mv x nmvjointcost x mvcost MVCOSTWEIGHT rate mode cpi inter mode cost mbmi mode context ref INTEROFFSETNEWMV rv RDCOST x rdmult x rddiv rate mv rate mode 0 best rd sofar if rv cpi find fractional mv step x tmp mv as mv ref mv cpi common allow high precision mv x errorperbit cpi fn ptr bsize cpi sf mv subpel force stop cpi sf mv subpel iters per step cond sad list cpi sad list x nmvjointcost x mvcost dis x pred sse ref NULL 0 0 x pred mv ref tmp mv as mv if scaled ref frame int i for i 0 i MAXMBPLANE i xd plane i pre 0 backup yv12 i return rv static Selectivity calc arraycontsel Variable Stat Data vardata Datum constval Oid elemtype Oid operator Selectivity selec Type Cache Entry typentry Fmgr Info cmpfunc Array Type array typentry lookup type cache elemtype TYPECACHECMPPROCFINFO if Oid Is Valid typentry cmp proc finfo fn oid return DEFAULTSEL operator cmpfunc typentry cmp proc finfo array Datum Get Array Type P constval if Heap Tuple Is Valid vardata stats Tuple Form pg statistic stats Datum values int nvalues float4 numbers int nnumbers float4 hist int nhist stats Form pg statistic GETSTRUCT vardata stats Tuple if get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDMCELEM Invalid Oid NULL values nvalues numbers nnumbers if operator OIDARRAYCONTAINEDOP get attstatsslot vardata stats Tuple elemtype vardata atttypmod STATISTICKINDDECHIST Invalid Oid NULLNULLNULL hist nhist hist NULL nhist 0 selec mcelem array selec array typentry values nvalues numbers nnumbers hist nhist operator cmpfunc if hist free attstatsslot elemtype NULL 0 hist nhist free attstatsslot elemtype values nvalues numbers nnumbers else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc selec 1 0 stats stanullfrac else selec mcelem array selec array typentry NULL 0 NULL 0 NULL 0 operator cmpfunc if Pointer Get Datum array constval pfree array return selec static int h261 decode frame AV Codec Context avctx void data int got frame AV Packet avpkt const uint8 t buf avpkt data int buf size avpkt size H261 Context h avctx priv data Mpeg Enc Context s h s int ret AV Frame pict data av dlog avctx frame d size d n avctx frame number buf size av dlog avctx bytes x x x x n buf 0 buf 1 buf 2 buf 3 s flags avctx flags s flags2 avctx flags2 h gob start code skipped 0 retry init get bits s gb buf buf size 8 if s context initialized if ff MPV common init s 0 return 1 if s current picture ptr NULL s current picture ptr f data 0 int i ff find unused picture s 0 if i 0 return i s current picture ptr s picture i ret h261 decode picture header h if ret 0 av log s avctx AVLOGERROR header damaged n return 1 if s width avctx coded width s height avctx coded height Parse Context pc s parse context s parse context buffer 0 ff MPV common end s s parse context pc if s context initialized avcodec set dimensions avctx s width s height goto retry s current picture f pict type s pict type s current picture f key frame s pict type AVPICTURETYPEI if avctx skip frame AVDISCARDNONREF s pict type AVPICTURETYPEB avctx skip frame AVDISCARDNONKEY s pict type AVPICTURETYPEI avctx skip frame AVDISCARDALL return get consumed bytes s buf size if ff MPV frame start s avctx 0 return 1 ff mpeg er frame start s s mb x 0 s mb y 0 while h gob number s mb height 18 12 5 if ff h261 resync h 0 break h261 decode gob h ff MPV frame end s assert s current picture f pict type s current picture ptr f pict type assert s current picture f pict type s pict type pict s current picture ptr f ff print debug info s pict got frame 1 return get consumed bytes s buf size static void set ref V P9 COMMON const cm MACROBLOCKD const xd int idx int mi row int mi col MBMODEINFO const mbmi xd mi 0 mbmi Ref Buffer ref buffer cm frame refs mbmi ref frame idx LASTFRAME xd block refs idx ref buffer if vp9 is valid scale ref buffer sf vpx internal error cm error VPXCODECUNSUPBITSTREAM Invalid scale factors if ref buffer buf corrupted vpx internal error cm error VPXCODECCORRUPTFRAME Block reference is corrupt vp9 setup pre planes xd idx ref buffer buf mi row mi col ref buffer sf xd corrupted ref buffer buf corrupted static void loop filter rows mt const Y V12 BUFFERCONFIG const frame buffer V P9 COMMON const cm struct macroblockd plane planes MAXMBPLANE int start int stop int y only V P9 Lf Sync const lf sync int num lf workers const int num planes y only 1 MAXMBPLANE int r c const int sb cols mi cols aligned to sb cm mi cols MIBLOCKSIZELO G2 for r start r stop r num lf workers const int mi row r MIBLOCKSIZELO G2 MODEINFO const mi cm mi grid visible mi row cm mi stride for c 0 c sb cols c const int mi col c MIBLOCKSIZELO G2 LOOPFILTERMASK lfm int plane sync read lf sync r c vp9 setup dst planes planes frame buffer mi row mi col vp9 setup mask cm mi row mi col mi mi col cm mi stride lfm for plane 0 plane num planes plane vp9 filter block plane cm planes plane mi row lfm sync write lf sync r c sb cols static inline int unreference pic H264 Context h Picture pic int refmask int i if pic f reference refmask return 0 else for i 0 h delayed pic i i if pic h delayed pic i pic f reference DELAYEDPICREF break return 1 static int get delta struct rev info revs struct remote lock lock int i struct commit commit struct object list p objects int count 0 while commit get revision revs NULL p process tree commit tree p commit object flags LOCAL if commit object flags UNINTERESTING count add send request commit object lock for i 0 i revs pending nr i struct object array entry entry revs pending objects i struct object obj entry item const char name entry name if obj flags UNINTERESTINGSEEN continue if obj type OBJTAG obj flags SEEN p add one object obj p continue if obj type OBJTREE p process tree struct tree obj p continue if obj type OBJBLOB p process blob struct blob obj p continue die unknown pending object s s oid to hex obj oid name while objects if objects item flags UNINTERESTING count add send request objects item lock objects objects next return count static int decode frame AV Codec Context avctx void data int got frame ptr AV Packet avpkt Bink Audio Context s avctx priv data AV Frame frame data Get Bit Context gb s gb int ret consumed 0 if get bits left gb uint8 t buf if avpkt size got frame ptr 0 return 0 if avpkt size 4 av log avctx AVLOGERROR Packet is too small n return AVERRORINVALIDDATA buf av realloc s packet buffer avpkt size FFINPUTBUFFERPADDINGSIZE if buf return AVERRORENOMEM s packet buffer buf memcpy s packet buffer avpkt data avpkt size init get bits gb s packet buffer avpkt size 8 consumed avpkt size skip bits long gb 32 frame nb samples s frame len if ret ff get buffer avctx frame 0 av log avctx AVLOGERROR get buffer failed n return ret if decode block s float frame extended data avctx codec id AVCODECIDBINKAUDIODCT av log avctx AVLOGERROR Incomplete packet n return AVERRORINVALIDDATA get bits align32 gb frame nb samples s block size avctx channels got frame ptr 1 return consumed static void build inter predictors for planes MACROBLOCKD xd BLOCKSIZE bsize int mi row int mi col int plane from int plane to int plane const int mi x mi col MISIZE const int mi y mi row MISIZE for plane plane from plane plane to plane const BLOCKSIZE plane bsize get plane block size bsize xd plane plane const int num 4x4 w num 4x4 blocks wide lookup plane bsize const int num 4x4 h num 4x4 blocks high lookup plane bsize const int bw 4 num 4x4 w const int bh 4 num 4x4 h if xd mi 0 src mi mbmi sb type BLOCK 8 X8 int i 0 x y assert bsize BLOCK 8 X8 for y 0 y num 4x4 h y for x 0 x num 4x4 w x build inter predictors xd plane i bw bh x 4 y 4 4 mi x mi y else build inter predictors xd plane 0 bw bh 0 0 bw bh mi x mi y static void super block uvrd const V P9 COMP cpi MACROBLOCK x int rate int64 t distortion int skippable int64 t sse BLOCKSIZE bsize int64 t ref best rd MACROBLOCKD const xd x e mbd MBMODEINFO const mbmi xd mi 0 src mi mbmi const TXSIZE uv tx size get uv tx size mbmi xd plane 1 int plane int pnrate 0 pnskip 1 int64 t pndist 0 pnsse 0 if ref best rd 0 goto term if is inter block mbmi int plane for plane 1 plane MAXMBPLANE plane vp9 subtract plane x bsize plane rate 0 distortion 0 sse 0 skippable 1 for plane 1 plane MAXMBPLANE plane txfm rd in plane x pnrate pndist pnskip pnsse ref best rd plane bsize uv tx size cpi sf use fast coef costing if pnrate INTMAX goto term rate pnrate distortion pndist sse pnsse skippable pnskip return term rate INTMAX distortion IN T64 MAX sse IN T64 MAX skippable 0 return void kadmin addprinc int argc char argv kadm5 principal ent rec princ kadm5 policy ent rec defpol long mask krb5 boolean randkey FALSE old style randkey FALSE int n ks tuple krb5 key salt tuple ks tuple NULL char pass canon NULL krb5 error code retval char newpw 1024 dummybuf 256 static char prompt1 1024 prompt2 1024 memset princ 0 sizeof princ princ attributes 0 if kadmin parse princ args argc argv princ mask pass randkey ks tuple n ks tuple add principal kadmin addprinc usage goto cleanup retval krb5 unparse name context princ principal canon if retval com err add principal retval while canonicalizing principal goto cleanup if mask KAD M5 POLICY mask KAD M5 POLICYCLR if kadm5 get policy handle default defpol fprintf stderr NOTICE no policy specified for s assigning default n canon princ policy default mask KAD M5 POLICY kadm5 free policy ent handle defpol else fprintf stderr WARNING no policy specified for s defaulting to no policy n canon mask KAD M5 POLICYCLR if randkey pass NULL else if pass NULL unsigned int sz sizeof newpw 1 snprintf prompt1 sizeof prompt1 Enter password for principal s canon snprintf prompt2 sizeof prompt2 Re enter password for principal s canon retval krb5 read password context prompt1 prompt2 newpw sz if retval com err add principal retval while reading password for s canon goto cleanup pass newpw mask KAD M5 PRINCIPAL retval create princ princ mask n ks tuple ks tuple pass if retval EINVAL randkey prepare dummy password dummybuf sizeof dummybuf princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES pass dummybuf retval create princ princ mask n ks tuple ks tuple pass old style randkey 1 if retval com err add principal retval while creating s canon goto cleanup if old style randkey retval randkey princ princ principal FALSE n ks tuple ks tuple if retval com err add principal retval while randomizing key for s canon goto cleanup princ attributes KR B5 KDBDISALLOWALLTIX mask KAD M5 ATTRIBUTES retval kadm5 modify principal handle princ mask if retval com err add principal retval while clearing DISALLOWALLTIX for s canon goto cleanup printf Principal s created n canon cleanup krb5 free principal context princ principal free ks tuple free canon kadmin free tl data princ n tl data princ tl data void ff draw horiz band AV Codec Context avctx DSP Context dsp Picture cur Picture last int y int h int picture structure int first field int draw edges int low delay int v edge pos int h edge pos const AV Pix Fmt Descriptor desc av pix fmt desc get avctx pix fmt int hshift desc log2 chroma w int vshift desc log2 chroma h const int field pic picture structure PICTFRAME if field pic h 1 y 1 if avctx hwaccel avctx codec capabilities CODECCAPHWACCELVDPAU draw edges cur f reference avctx flags CODECFLAGEMUEDGE int linesize cur f linesize int sides 0 edge h if y 0 sides EDGETOP if y h v edge pos sides EDGEBOTTOM edge h FFMIN h v edge pos y dsp draw edges cur f data 0 y linesize 0 linesize 0 h edge pos edge h EDGEWIDTHEDGEWIDTH sides dsp draw edges cur f data 1 y vshift linesize 1 linesize 1 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides dsp draw edges cur f data 2 y vshift linesize 2 linesize 2 h edge pos hshift edge h vshift EDGEWIDTH hshift EDGEWIDTH vshift sides h FFMIN h avctx height y if field pic first field avctx slice flags SLICEFLAGALLOWFIELD return if avctx draw horiz band AV Frame src int offset AVNUMDATAPOINTERS int i if cur f pict type AVPICTURETYPEB low delay avctx slice flags SLICEFLAGCODEDORDER src cur f else if last src last f else return if cur f pict type AVPICTURETYPEB picture structure PICTFRAME avctx codec id AVCODECID H264 avctx codec id AVCODECIDSV Q3 for i 0 i AVNUMDATAPOINTERS i offset i 0 else offset 0 y src linesize 0 offset 1 offset 2 y vshift src linesize 1 for i 3 i AVNUMDATAPOINTERS i offset i 0 emms c avctx draw horiz band avctx src offset y picture structure h static VALUE ossl cipher initialize VALUE self VALUE str EVPCIPHERCTX ctx const EVPCIPHER cipher char name unsigned char dummy key EVPMAXKEYLENGTH 0 name String Value C Str str Get Cipher Init self ctx if ctx ossl raise rb e Runtime Error Cipher already inititalized Alloc Cipher self ctx if cipher EVP get cipherbyname name ossl raise rb e Runtime Error unsupported cipher algorithm PR Is VALUE str if EVP Cipher Init ex ctx cipher NULL dummy key NULL 1 1 ossl raise e Cipher Error NULL return self static int32 t append Keywords To Language Tag const char locale ID char append At int32 t capacity U Bool strict U Bool had Posix U Error Code status char buf ULOCKEYWORDANDVALUESCAPACITY char attr Buf ULOCKEYWORDANDVALUESCAPACITY 0 int32 t attr Buf Length 0 U Enumeration keyword Enum NULL int32 t reslen 0 keyword Enum uloc open Keywords locale ID status if UFAILURE status had Posix uenum close keyword Enum return 0 if keyword Enum NULL had Posix int32 t len const char key Extension List Entry first Ext NULL Extension List Entry ext Attribute List Entry first Attr NULL Attribute List Entry attr char attr Value char ext Buf ULOCKEYWORDANDVALUESCAPACITY char p Ext Buf ext Buf int32 t ext Buf Capacity sizeof ext Buf const char bcp Key nullptr bcp Value nullptr U Error Code tmp Status UZEROERROR int32 t keylen U Bool is Bcp U Ext while TRUE key uenum next keyword Enum NULL status if key NULL break len uloc get Keyword Value locale ID key buf sizeof buf tmp Status if UFAILURE tmp Status tmp Status USTRINGNOTTERMINATEDWARNING if strict status UILLEGALARGUMENTERROR break tmp Status UZEROERROR continue keylen int32 t uprv strlen key is Bcp U Ext keylen 1 if uprv strcmp key LOCALEATTRIBUTEKEY 0 if len 0 int32 t i 0 while TRUE attr Buf Length 0 for i len i if buf i attr Buf attr Buf Length buf i else i break if attr Buf Length 0 attr Buf attr Buf Length 0 else if i len break attr Attribute List Entry uprv malloc sizeof Attribute List Entry if attr NULL status UMEMORYALLOCATIONERROR break attr Value char uprv malloc attr Buf Length 1 if attr Value NULL status UMEMORYALLOCATIONERROR break uprv strcpy attr Value attr Buf attr attribute attr Value if add Attribute To List first Attr attr uprv free attr uprv free attr Value if strict status UILLEGALARGUMENTERROR break bcp Key LOCALEATTRIBUTEKEY bcp Value NULL else if is Bcp U Ext bcp Key uloc to Unicode Locale Key key if bcp Key NULL if strict status UILLEGALARGUMENTERROR break continue bcp Value uloc to Unicode Locale Type key buf if bcp Value NULL if strict status UILLEGALARGUMENTERROR break continue if bcp Value buf int32 t bcp Value Len uprv strlen bcp Value if bcp Value Len ext Buf Capacity uprv strcpy p Ext Buf bcp Value TC String to Lower Case p Ext Buf bcp Value p Ext Buf p Ext Buf bcp Value Len 1 ext Buf Capacity bcp Value Len 1 else if strict status UILLEGALARGUMENTERROR break continue else if key PRIVATEUSE if is Privateuse Value Subtags buf len if strict status UILLEGALARGUMENTERROR break continue else if is Extension Singleton key keylen is Extension Subtags buf len if strict status UILLEGALARGUMENTERROR break continue bcp Key key if len 1 ext Buf Capacity uprv memcpy p Ext Buf buf len bcp Value p Ext Buf p Ext Buf len p Ext Buf 0 p Ext Buf ext Buf Capacity len 1 else status UILLEGALARGUMENTERROR break ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR break ext key bcp Key ext value bcp Value if add Extension To List first Ext ext TRUE uprv free ext if strict status UILLEGALARGUMENTERROR break if had Posix ext Extension List Entry uprv malloc sizeof Extension List Entry if ext NULL status UMEMORYALLOCATIONERROR goto cleanup ext key POSIXKEY ext value POSIXVALUE if add Extension To List first Ext ext TRUE uprv free ext if USUCCESS status first Ext NULL first Attr NULLU Bool start LDML Extension FALSE for ext first Ext ext ext ext next if start LDML Extension uprv strlen ext key 1 if reslen capacity append At reslen SEP reslen if reslen capacity append At reslen LDMLEXT reslen start LDML Extension TRUE if uprv strcmp ext key LOCALEATTRIBUTEKEY 0 for attr first Attr attr attr attr next if reslen capacity append At reslen SEP reslen len int32 t uprv strlen attr attribute if reslen capacity uprv memcpy append At reslen attr attribute uprv min len capacity reslen reslen len else if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext key if reslen capacity uprv memcpy append At reslen ext key uprv min len capacity reslen reslen len if reslen capacity append At reslen SEP reslen len int32 t uprv strlen ext value if reslen capacity uprv memcpy append At reslen ext value uprv min len capacity reslen reslen len cleanup ext first Ext while ext NULL Extension List Entry tmp Ext ext next uprv free ext ext tmp Ext attr first Attr while attr NULL Attribute List Entry tmp Attr attr next char p Value char attr attribute uprv free p Value uprv free attr attr tmp Attr uenum close keyword Enum if UFAILURE status return 0 return u terminate Chars append At capacity reslen status void ff xvmc decode mb Mpeg Enc Context s Xv MC Macro Block mv block struct xvmc pix fmt render int i cbp blocks per mb const int mb xy s mb y s mb stride s mb x if s encoding av log s avctx AVLOGERRORXVMC doesn t support encoding n return if s mb intra s last dc 0 s last dc 1 s last dc 2 128 s intra dc precision s mb skipped 0 s current picture qscale table mb xy s qscale render struct xvmc pix fmt s current picture f data 2 assert render assert render xvmc id AVXVMCID assert render mv blocks mv block render mv blocks render start mv blocks num render filled mv blocks num mv block x s mb x mv block y s mb y mv block dct type s interlaced dct if s mb intra mv block macroblock type XVMCMBTYPEINTRA else mv block macroblock type XVMCMBTYPEPATTERN if s mv dir MVDIRFORWARD mv block macroblock type XVMCMBTYPEMOTIONFORWARD mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 mv block PMV 1 0 0 s mv 0 1 0 mv block PMV 1 0 1 s mv 0 1 1 if s mv dir MVDIRBACKWARD mv block macroblock type XVMCMBTYPEMOTIONBACKWARD mv block PMV 0 1 0 s mv 1 0 0 mv block PMV 0 1 1 s mv 1 0 1 mv block PMV 1 1 0 s mv 1 1 0 mv block PMV 1 1 1 s mv 1 1 1 switch s mv type case MVTYPE 16 X16 mv block motion type XVMCPREDICTIONFRAME break case MVTYPE 16 X8 mv block motion type XVMCPREDICTION 16x8 break case MVTYPEFIELD mv block motion type XVMCPREDICTIONFIELD if s picture structure PICTFRAME mv block PMV 0 0 1 1 mv block PMV 1 0 1 1 mv block PMV 0 1 1 1 mv block PMV 1 1 1 1 break case MVTYPEDMV mv block motion type XVMCPREDICTIONDUALPRIME if s picture structure PICTFRAME mv block PMV 0 0 0 s mv 0 0 0 mv block PMV 0 0 1 s mv 0 0 1 1 mv block PMV 0 1 0 s mv 0 0 0 mv block PMV 0 1 1 s mv 0 0 1 1 mv block PMV 1 0 0 s mv 0 2 0 mv block PMV 1 0 1 s mv 0 2 1 1 mv block PMV 1 1 0 s mv 0 3 0 mv block PMV 1 1 1 s mv 0 3 1 1 else mv block PMV 0 1 0 s mv 0 2 0 mv block PMV 0 1 1 s mv 0 2 1 break default assert 0 mv block motion vertical field select 0 if s mv type MVTYPEFIELD s mv type MVTYPE 16 X8 mv block motion vertical field select s field select 0 0 mv block motion vertical field select s field select 1 0 1 mv block motion vertical field select s field select 0 1 2 mv block motion vertical field select s field select 1 1 3 mv block index render next free data block num blocks per mb 6 if s chroma format 2 blocks per mb 4 1 s chroma format cbp 0 for i 0 i blocks per mb i cbp cbp if s block last index i 0 cbp if s flags CODECFLAGGRAY if s mb intra for i 4 i blocks per mb i memset s pblocks i 0 sizeof s pblocks i if render unsigned intra s pblocks i 0 1 10 else cbp 0xf blocks per mb 4 blocks per mb 4 mv block coded block pattern cbp if cbp 0 mv block macroblock type XVMCMBTYPEPATTERN for i 0 i blocks per mb i if s block last index i 0 if s mb intra render idct render unsigned intra s pblocks i 0 1 10 if render idct s dsp idct s pblocks i if s avctx xvmc acceleration 1 memcpy render data blocks render next free data block num 64 s pblocks i sizeof s pblocks i render next free data block num render filled mv blocks num assert render filled mv blocks num render allocated mv blocks assert render next free data block num render allocated data blocks if render filled mv blocks num render allocated mv blocks ff mpeg draw horiz band s 0 0 static void encode frame internal V P9 COMP cpi SPEEDFEATURES const sf cpi sf RDOPT const rd opt cpi rd MACROBLOCK const x cpi mb V P9 COMMON const cm cpi common MACROBLOCKD const xd x e mbd xd mi cm mi grid visible xd mi 0 cm mi vp9 zero cm counts vp9 zero cpi coef counts vp9 zero rd opt comp pred diff vp9 zero rd opt filter diff vp9 zero rd opt tx select diff vp9 zero rd opt tx select threshes xd lossless cm base qindex 0 cm y dc delta q 0 cm uv dc delta q 0 cm uv ac delta q 0 cm tx mode select tx mode cpi x fwd txm4x4 xd lossless vp9 fwht4x4 vp9 fdct4x4 x itxm add xd lossless vp9 iwht4x4 add vp9 idct4x4 add if xd lossless x optimize 0 cm lf filter level 0 cpi zbin mode boost enabled 0 vp9 frame init quantizer cpi vp9 initialize rd consts cpi vp9 initialize me consts cpi cm base qindex init encode frame mb context cpi set prev mi cm x quant fp cpi sf use quant fp vp9 zero x skip txfm if sf use nonrd pick mode int i struct macroblock plane const p x plane struct macroblockd plane const pd xd plane PICKMODECONTEXT ctx cpi pc root none for i 0 i MAXMBPLANE i p i coeff ctx coeff pbuf i 0 p i qcoeff ctx qcoeff pbuf i 0 pd i dqcoeff ctx dqcoeff pbuf i 0 p i eobs ctx eobs pbuf i 0 vp9 zero x zcoeff blk if sf partition search type SOURCEVARBASEDPARTITION source var based partition search method cpi struct vpx usec timer emr timer vpx usec timer start emr timer input fpmb stats cpi twopass firstpass mb stats cm cpi twopass this frame mb stats vpx usec timer mark emr timer cpi time encode sb row vpx usec timer elapsed emr timer static int get buffer AV Codec Context avctx Picture pic SV Q3 Context s avctx priv data H264 Context h s h const int big mb num h mb stride h mb height 1 1 const int mb array size h mb stride h mb height const int b4 stride h mb width 4 1 const int b4 array size b4 stride h mb height 4 int ret if pic motion val buf 0 int i pic mb type buf av buffer allocz big mb num h mb stride sizeof uint32 t if pic mb type buf return AVERRORENOMEM pic mb type uint32 t pic mb type buf data 2 h mb stride 1 for i 0 i 2 i pic motion val buf i av buffer allocz 2 b4 array size 4 sizeof int16 t pic ref index buf i av buffer allocz 4 mb array size if pic motion val buf i pic ref index buf i ret AVERRORENOMEM goto fail pic motion val i int16 t 2 pic motion val buf i data 4 pic ref index i pic ref index buf i data pic f motion subsample log2 2 pic reference h pict type AVPICTURETYPEB ret ff get buffer avctx pic f pic reference AVGETBUFFERFLAGREF 0 if ret 0 goto fail if h edge emu buffer h edge emu buffer av mallocz pic f linesize 0 17 if h edge emu buffer return AVERRORENOMEM h linesize pic f linesize 0 h uvlinesize pic f linesize 1 return 0 fail free picture avctx pic return ret static int get current cpu void if current cpu return 1 return current cpu cpu index static void slurm rpc job will run slurm msg t msg DEFTIMERS int error code SLURMSUCCESS struct job record job ptr NULL job desc msg t job desc msg job desc msg t msg data slurmctld lock t job read lock READLOCKREADLOCKREADLOCKREADLOCKREADLOCK slurmctld lock t job write lock READLOCKWRITELOCKWRITELOCKREADLOCKREADLOCK uid t uid g slurm auth get uid msg auth cred slurmctld config auth info uint16 t port slurm addr t resp addr will run response msg t resp NULL char err msg NULL job submit user msg NULL if slurmctld config submissions disabled info Submissions disabled on system error code ESLURMSUBMISSIONSDISABLED goto send reply STARTTIMER debug2 Processing RPCREQUESTJOBWILLRUN from uid d uid if is valid will run user job desc msg uid error code ESLURMUSERIDMISSING error Security violation JOBWILLRUNRPC from uid d uid if job desc msg alloc node NULL job desc msg alloc node 0 0 error code ESLURMINVALIDNODENAME error REQUESTJOBWILLRUN lacks alloc node from uid d uid if error code SLURMSUCCESS lock slurmctld job read lock job desc msg pack job offset NOVAL error code validate job create req job desc msg uid err msg unlock slurmctld job read lock if err msg job submit user msg xstrdup err msg if slurm get peer addr msg conn fd resp addr job desc msg resp host xmalloc 16 slurm get ip str resp addr port job desc msg resp host 16 dump job desc job desc msg if error code SLURMSUCCESS lock slurmctld job write lock if job desc msg job id NOVAL job desc msg pack job offset NOVAL error code job allocate job desc msg false true resp true uid job ptr err msg msg protocol version else error code job start data job desc msg resp unlock slurmctld job write lock ENDTIME R2 slurm rpc job will run else if errno error code errno else error code SLURMERROR send reply if error code debug2 slurm rpc job will run s slurm strerror error code if err msg slurm send rc err msg msg error code err msg else slurm send rc msg msg error code else if resp slurm msg t response msg slurm msg t init response msg response msg flags msg flags response msg protocol version msg protocol version response msg address msg address response msg conn msg conn response msg msg type RESPONSEJOBWILLRUN response msg data resp resp job submit user msg job submit user msg job submit user msg NULL slurm send node msg msg conn fd response msg slurm free will run response msg resp debug2 slurm rpc job will run success s TIMESTR else debug2 slurm rpc job will run success s TIMESTR if job desc msg job id NOVAL slurm send rc msg msg SLURMSUCCESS xfree err msg xfree job submit user msg static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Targa Context const s avctx priv data AV Frame picture data AV Frame const p s picture uint8 t dst int stride int idlen compr y w h bpp flags ret int first clr colors csize bytestream2 init s gb avpkt data avpkt size idlen bytestream2 get byte s gb bytestream2 skip s gb 1 compr bytestream2 get byte s gb first clr bytestream2 get le16 s gb colors bytestream2 get le16 s gb csize bytestream2 get byte s gb bytestream2 skip s gb 4 w bytestream2 get le16 s gb h bytestream2 get le16 s gb bpp bytestream2 get byte s gb flags bytestream2 get byte s gb bytestream2 skip s gb idlen switch bpp case 8 avctx pix fmt compr TGARLETGABWAVPIXFMTGRA Y8 AVPIXFMTPA L8 break case 15 avctx pix fmt AVPIXFMTRG B555 LE break case 16 avctx pix fmt AVPIXFMTRG B555 LE break case 24 avctx pix fmt AVPIXFMTBG R24 break case 32 avctx pix fmt AVPIXFMTBGRA break default av log avctx AVLOGERROR Bit depth i is not supported n bpp return AVERRORINVALIDDATA if s picture data 0 avctx release buffer avctx s picture if ret av image check size w h 0 avctx 0 return ret if w avctx width h avctx height avcodec set dimensions avctx w h if ret ff get buffer avctx p 0 av log avctx AVLOGERROR get buffer failed n return ret if flags 0x20 dst p data 0 stride p linesize 0 else dst p data 0 p linesize 0 h 1 stride p linesize 0 if colors int pal size pal sample size if colors first clr 256 av log avctx AVLOGERROR Incorrect palette i colors with offset i n colors first clr return AVERRORINVALIDDATA switch csize case 24 pal sample size 3 break case 16 case 15 pal sample size 2 break default av log avctx AVLOGERROR Palette entry size i bits is not supported n csize return AVERRORINVALIDDATA pal size colors pal sample size if avctx pix fmt AVPIXFMTPA L8 bytestream2 skip s gb pal size else int t uint32 t pal uint32 t p data 1 first clr if bytestream2 get bytes left s gb pal size av log avctx AVLOGERROR Not enough data to read palette n return AVERRORINVALIDDATA switch pal sample size case 3 for t 0 t colors t pal bytestream2 get le24u s gb break case 2 for t 0 t colors t uint32 t v bytestream2 get le16u s gb v v 0x7 C00 9 v 0x03 E0 6 v 0x001 F 3 v v 0x E0 E0 E0 U 5 pal v break p palette has changed 1 if compr TGARLETGANODATA memset p data 0 0 p linesize 0 h else if compr TGARLE int res targa decode rle avctx s dst w h stride bpp if res 0 return res else size t img size w bpp 1 3 if bytestream2 get bytes left s gb img size h av log avctx AVLOGERROR Not enough data available for image n return AVERRORINVALIDDATA for y 0 y h y bytestream2 get bufferu s gb dst img size dst stride picture s picture got frame 1 return avpkt size static uint32 t vmport cmd get version void opaque uint32 t addr X86 CPU cpu X86 CPU current cpu cpu env regs REBXVMPORTMAGIC return 6 static void LMBCS Open Worker U Converter this U Converter Load Args p Args U Error Code err ulmbcs byte t Opt Group U Converter Data LMBCS extra Info this extra Info U Converter Data LMBCS uprv malloc sizeof U Converter Data LMBCS if extra Info NULLU Converter Name Pieces stack Pieces U Converter Load Args stack Args int32 t sizeof U Converter Load Args ulmbcs byte t i uprv memset extra Info 0 sizeof U Converter Data LMBCS stack Args only Test Is Loadable p Args only Test Is Loadable for i 0 i ULMBCSGRPLASTUSUCCESS err i if Opt Group Byte To CP Name i NULL extra Info Opt Grp Converter i ucnv load Shared Data Opt Group Byte To CP Name i stack Pieces stack Args err if UFAILURE err p Args only Test Is Loadable LMBCS Close this return extra Info Opt Group Opt Group extra Info locale Converter Index Find LMBCS Locale p Args locale else err static int64 t rd pick intra sbuv mode V P9 COMP cpi MACROBLOCK x PICKMODECONTEXT ctx int rate int rate tokenonly int64 t distortion int skippable BLOCKSIZE bsize TXSIZE max tx size MACROBLOCKD xd x e mbd PREDICTIONMODE mode PREDICTIONMODE mode selected DCPRED int64 t best rd IN T64 MAX this rd int this rate tokenonly this rate s int64 t this distortion this sse for mode DCPRED mode TMPRED mode if cpi sf intra uv mode mask max tx size 1 mode continue xd mi 0 mbmi uv mode mode super block uvrd cpi x this rate tokenonly this distortion s this sse bsize best rd if this rate tokenonly INTMAX continue this rate this rate tokenonly cpi intra uv mode cost cpi common frame type mode this rd RDCOST x rdmult x rddiv this rate this distortion if this rd best rd mode selected mode best rd this rd rate this rate rate tokenonly this rate tokenonly distortion this distortion skippable s if x select tx size swap block ptr x ctx 2 0 1 MAXMBPLANE xd mi 0 mbmi uv mode mode selected return best rd static int rc pick q and bounds one pass cbr const V P9 COMP cpi int bottom index int top index const V P9 COMMON const cm cpi common const RATECONTROL const rc cpi rc int active best quality int active worst quality calc active worst quality one pass cbr cpi int q int rtc minq ASSIGNMINQTABLE cm bit depth rtc minq if frame is intra only cm active best quality rc best quality if rc this key frame forced int qindex rc last boosted qindex double last boosted q vp9 convert qindex to q qindex cm bit depth int delta qindex vp9 compute qdelta rc last boosted q last boosted q 0 75 cm bit depth active best quality MAX qindex delta qindex rc best quality else if cm current video frame 0 double q adj factor 1 0 double q val active best quality get kf active quality rc rc avg frame qindex KEYFRAME cm bit depth if cm width cm height 352 288 q adj factor 0 25 q val vp9 convert qindex to q active best quality cm bit depth active best quality vp9 compute qdelta rc q val q val q adj factor cm bit depth else if rc is src frame alt ref cpi use svc cpi refresh golden frame cpi refresh alt ref frame if rc frames since key 1 rc avg frame qindex INTERFRAME active worst quality q rc avg frame qindex INTERFRAME else q active worst quality active best quality get gf active quality rc q cm bit depth else if cm current video frame 1 if rc avg frame qindex INTERFRAME active worst quality active best quality rtc minq rc avg frame qindex INTERFRAME else active best quality rtc minq active worst quality else if rc avg frame qindex KEYFRAME active worst quality active best quality rtc minq rc avg frame qindex KEYFRAME else active best quality rtc minq active worst quality active best quality clamp active best quality rc best quality rc worst quality active worst quality clamp active worst quality active best quality rc worst quality top index active worst quality bottom index active best quality int qdelta 0 vp9 clear system state qdelta vp9 compute qdelta by rate cpi rc cm frame type active worst quality 2 0 cm bit depth top index active worst quality qdelta top index top index bottom index top index bottom index static int decode frame AV Codec Context avctx void data int got frame AV Packet avpkt Ansi Context s avctx priv data uint8 t buf avpkt data int buf size avpkt size const uint8 t buf end buf buf size int ret i count ret avctx reget buffer avctx s frame if ret 0 av log avctx AVLOGERROR get buffer failed n return ret if avctx frame number memset s frame data 0 0 avctx height FFABS s frame linesize 0 memset s frame data 1 0 AVPALETTESIZE s frame pict type AVPICTURETYPEI s frame palette has changed 1 memcpy s frame data 1 ff cga palette 16 4 while buf buf end switch s state case STATENORMAL switch buf 0 case 0x00 case 0x07 case 0x1 A break case 0x08 s x FFMAX s x 1 0 break case 0x09 i s x FONTWIDTH count i 8 7 i for i 0 i count i draw char avctx break case 0x0 A hscroll avctx case 0x0 D s x 0 break case 0x0 C erase screen avctx break case 0x1 B s state STATEESCAPE break default draw char avctx buf 0 break case STATEESCAPE if buf 0 s state STATECODE s nb args 0 s args 0 0 else s state STATENORMAL draw char avctx 0x1 B continue break case STATECODE switch buf 0 case 0 case 1 case 2 case 3 case 4 case 5 case 6 case 7 case 8 case 9 if s nb args MAXNBARGS s args s nb args s args s nb args 10 buf 0 0 break case s nb args if s nb args MAXNBARGS s args s nb args 0 break case M s state STATEMUSICPREAMBLE break case case break default if s nb args MAXNBARGS av log avctx AVLOGWARNING args overflow i n s nb args if s nb args MAXNBARGS s args s nb args s nb args if ret execute code avctx buf 0 0 return ret s state STATENORMAL break case STATEMUSICPREAMBLE if buf 0 0x0 E buf 0 0x1 B s state STATENORMAL break buf got frame 1 AV Frame data s frame return buf size 